<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>3784</fr:anchor>
    <fr:addr type="user">inference-of-reversible-languages</fr:addr>
    <fr:route>inference-of-reversible-languages.xml</fr:route>
    <fr:title text="Inference of Reversible Languages">Inference of Reversible Languages</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:date>
      <fr:year>1982</fr:year>
      <fr:month>7</fr:month>
    </fr:date>
    <fr:authors>
      <fr:author>Dana Angluin</fr:author>
    </fr:authors>
    <fr:meta name="doi">10.1145/322326.322334</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>We consider inductive inference of certain classes of languages, namely the <fr:tex display="inline"><![CDATA[k]]></fr:tex>-reversible languages for some fixed <fr:tex display="inline"><![CDATA[k \ge  0]]></fr:tex>, from positive, possibly infinite samples. More precisely, given any rational language <fr:tex display="inline"><![CDATA[S]]></fr:tex>, the sample, we prove that there exists a smallest, with respect to inclusion, <fr:tex display="inline"><![CDATA[k]]></fr:tex>-reversible language containing it, which is then also rational. After an algebraic proof, we describe a polynomial algorithm performing the inference.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Backlinks">Backlinks</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>3786</fr:anchor>
            <fr:addr type="user">misc-000N</fr:addr>
            <fr:route>misc-000N.xml</fr:route>
            <fr:title text="Characterization of reversible languages">Characterization of reversible languages</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>Given a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, it is a <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible regular language</fr:link> if and only if it is regular, and if <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}]]></fr:tex> for some strings <fr:tex display="inline"><![CDATA[x, y, z]]></fr:tex>, then for all strings <fr:tex display="inline"><![CDATA[w]]></fr:tex> we have <fr:tex display="inline"><![CDATA[xw \in  \mathcal {L} \iff  yw \in  \mathcal {L}]]></fr:tex>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>580</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>See Theorem 7 in <fr:link type="local" href="inference-of-reversible-languages.xml" addr="inference-of-reversible-languages" title="Inference of Reversible Languages">Inference of Reversible Languages</fr:link>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>3788</fr:anchor>
            <fr:addr type="user">misc-000O</fr:addr>
            <fr:route>misc-000O.xml</fr:route>
            <fr:title text="Induction of reversible languages">Induction of reversible languages</fr:title>
            <fr:taxon>Algorithm</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>This algorithm is described in <fr:link type="local" href="inference-of-reversible-languages.xml" addr="inference-of-reversible-languages" title="Inference of Reversible Languages">Inference of Reversible Languages</fr:link>. It inputs a set of example strings in a <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible regular language</fr:link>, and outputs a finite <fr:link type="local" href="misc-000L.xml" addr="misc-000L" title="Bideterministic automaton">bideterministic automaton</fr:link>. The soundness proof is given as Theorem 26, and if the input enumerates all the strings in the language, then the output is guaranteed to converge to the correct minimal DFA at a finite stage by Theorem 27. Note that obviously we cannot algorithmically determine whether it has converged or not, without further information.</fr:p>
            <fr:p>The algorithm proceeds as follows. Start with a trivial automata with a start and accept state, but no transitions. When we read a new example string, add a new chain of states and transitions from the start to the accept state, solely accepting this new string. Then we perform a merging process. Whenever a state has two transitions on the same letter, we merge the destination states, and vice versa for transitions to that state. This process obviously terminates and produces a bideterministic automata. And we can read the next example string.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
