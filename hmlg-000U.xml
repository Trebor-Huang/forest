<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2267</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>308</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>485</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>487</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>489</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>492</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2265</fr:anchor><fr:addr>hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>465</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y \subseteq X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0 \to C_\bullet(Y) \hookrightarrow C_\bullet(X) \to C_\bullet(X, Y) \to 0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>463</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>494</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>308</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>485</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>487</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>489</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>492</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>496</fr:anchor><fr:addr>hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title>Exactness of <fr:tex>\hom</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>\hom(P, -)</fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition"></fr:ref> it is left exact. Similarly <fr:tex>\hom(-, I)</fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex>\hom(P, -)</fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex>\hom(P, -)</fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>420</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P \to B</fr:tex> can be lifted through an epimorphism <fr:tex>A \twoheadrightarrow B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P \to A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>421</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P \to B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Dually, we have the definition of injective objects, which make <fr:tex>\hom(-, I)</fr:tex> exact.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>428</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title>Abelian groups are injective iff divisible</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An abelian group <fr:tex>G</fr:tex> is <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex>g \in G</fr:tex> and positive integer <fr:tex>n</fr:tex>, there exists a (non-unique) solution of <fr:tex>nx = g</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>412</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2259</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2261</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title>Freyd–Mitchell embedding theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex>R</fr:tex>-modules for some ring <fr:tex>R</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1235</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  (TODO)
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2263</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y \subseteq X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0 \to C_\bullet(Y) \hookrightarrow C_\bullet(X) \to C_\bullet(X, Y) \to 0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>463</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>