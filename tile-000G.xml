<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>537</fr:anchor>
    <fr:addr type="user">tile-000G</fr:addr>
    <fr:route>tile-000G.xml</fr:route>
    <fr:title text="The augmented language of neighborhood relation is reversible">The augmented language of neighborhood relation is reversible</fr:title>
    <fr:taxon>Theorem</fr:taxon>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>2</fr:month>
      <fr:day>22</fr:day>
    </fr:date>
    <fr:authors>
      <fr:author>
        <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
      </fr:author>
    </fr:authors>
  </fr:frontmatter>
  <fr:mainmatter><fr:p>Given any <fr:link type="local" href="tile-0004.xml" addr="tile-0004" title="Substitution system">substitution system</fr:link>, the augmented <fr:link type="local" href="tile-000E.xml" addr="tile-000E" title="Language of neighborhood relation">language of neighborhood relation</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> is <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible</fr:link>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>363</fr:anchor><fr:addr type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>We use the <fr:link type="local" href="misc-000N.xml" addr="misc-000N" title="Characterization of reversible languages">characterization of reversible languages</fr:link>. Any substring (ignoring the special starting and ending symbols) in this case describes a fixed geometric transformation between a tile and some supertile that it is contained in. So suppose <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}^+]]></fr:tex>, then inverting the transformation given by <fr:tex display="inline"><![CDATA[z]]></fr:tex>, we know that <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> describe equivalent geometric configurations of a tile in some supertile. Therefore they must actually be <fr:link type="local" href="misc-000J.xml" addr="misc-000J" title="Nerode congruence">Nerode congruent</fr:link>.</fr:p>

  <fr:p>Since we have not rigorously defined the geometric aspects of tile systems, we will not attempt to articulate a completely formal proof. But it should be noted how geometry plays a crucial role here, meaning that substitution systems that are “non-rigid” may fail this property.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>539</fr:anchor>
            <fr:addr type="user">tile-000H</fr:addr>
            <fr:route>tile-000H.xml</fr:route>
            <fr:title text="The transductive algorithm">The transductive algorithm</fr:title>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>The discussion in <fr:ref addr="tile-000C" href="tile-000C.xml" /> suggests that we can take the following approach to generate neighbor Conway signatures:</fr:p>
            <fr:ul><fr:li>Construct a finite automaton that recognizes <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, the <fr:link type="local" href="tile-000E.xml" addr="tile-000E" title="Language of neighborhood relation">language of neighborhood relation</fr:link>.</fr:li>
  <fr:li>Convert a recognizer for the binary relation into a <fr:em>transducer</fr:em>, i.e. a finite state machine with input and output.</fr:li>
  <fr:li>Simulate the transducer efficiently.</fr:li></fr:ul>
            <fr:p>The second step is very easy. Suppose we are working over the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex>, and we have a finite state automata where the transition edges are labelled with pairs <fr:tex display="inline"><![CDATA[(x, y) \in  \Delta  \times  \Delta ]]></fr:tex>. So we can just relabel it by <fr:tex display="inline"><![CDATA[x/y]]></fr:tex>, i.e. a transition that consumes the symbol <fr:tex display="inline"><![CDATA[x]]></fr:tex> and outputs the symbol <fr:tex display="inline"><![CDATA[y]]></fr:tex>. Of course, this results in a non-deterministic transducer. But there is a lot of previous work on executing non-deterministic transducers, which we can use verbatim.</fr:p>
            <fr:p>So, we have reduced our problem to the first step. But unless we can resolve <fr:ref addr="tile-000F" href="tile-000F.xml" taxon="Conjecture" /> constructively, how are we going to produce such an automaton? This is due to a special property that <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> enjoys, as promised.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>425</fr:anchor>
                <fr:addr type="user">misc-000L</fr:addr>
                <fr:route>misc-000L.xml</fr:route>
                <fr:title text="Bideterministic automaton">Bideterministic automaton</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>A deterministic automaton is <fr:strong>bideterministic</fr:strong> if it has only one accepting state, and if reversing all transitions and swapping the starting and accepting state produces another deterministic automaton.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>427</fr:anchor>
                <fr:addr type="user">misc-000M</fr:addr>
                <fr:route>misc-000M.xml</fr:route>
                <fr:title text="Reversible regular language">Reversible regular language</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>A regular language is <fr:strong>reversible</fr:strong> if it can be recognized by a <fr:link type="local" href="misc-000L.xml" addr="misc-000L" title="Bideterministic automaton">bideterministic</fr:link> DFA, which is equivalent to requiring the <fr:link type="local" href="misc-000K.xml" addr="misc-000K" title="Myhill–Nerode automaton">Myhill–Nerode automaton</fr:link> to be bideterministic.</fr:p>
                <fr:p>Note that there are stronger and weaker notions of reversible regular languages in the literature, with inconsistent names.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>429</fr:anchor>
                <fr:addr type="user">misc-000N</fr:addr>
                <fr:route>misc-000N.xml</fr:route>
                <fr:title text="Characterization of reversible languages">Characterization of reversible languages</fr:title>
                <fr:taxon>Theorem</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Given a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, it is a <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible regular language</fr:link> if and only if it is regular, and if <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}]]></fr:tex> for some strings <fr:tex display="inline"><![CDATA[x, y, z]]></fr:tex>, then for all strings <fr:tex display="inline"><![CDATA[w]]></fr:tex> we have <fr:tex display="inline"><![CDATA[xw \in  \mathcal {L} \iff  yw \in  \mathcal {L}]]></fr:tex>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>369</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>See Theorem 7 in <fr:link type="local" href="inference-of-reversible-languages.xml" addr="inference-of-reversible-languages" title="Inference of Reversible Languages">Inference of Reversible Languages</fr:link>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>By the way, this suggests a definition for reversible languages in general, without restricting to regular languages. And indeed, Tatham had the <fr:link type="external" href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/aperiodic-followup/#adjrec-dsf">important realization</fr:link> that <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> is reversible, although the result there is stated in terms of <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>. This is essentially the same, because in the automaton for <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, there are many accepting states, each corresponding to a tile type. And the automaton for <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> simply adds a “true” accepting state, and connects each of the original accepting states to it by a transition that expects an input character of the correct tile type. Since we know what the tile type is at all times, there is no fundamental difference between the two languages. But for <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex>, the start and end is completely symmetric, so it allows for a cleaner treatment.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>431</fr:anchor>
                <fr:addr type="user">tile-000G</fr:addr>
                <fr:route>tile-000G.xml</fr:route>
                <fr:title text="The augmented language of neighborhood relation is reversible">The augmented language of neighborhood relation is reversible</fr:title>
                <fr:taxon>Theorem</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Given any <fr:link type="local" href="tile-0004.xml" addr="tile-0004" title="Substitution system">substitution system</fr:link>, the augmented <fr:link type="local" href="tile-000E.xml" addr="tile-000E" title="Language of neighborhood relation">language of neighborhood relation</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> is <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible</fr:link>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>363</fr:anchor><fr:addr type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>We use the <fr:link type="local" href="misc-000N.xml" addr="misc-000N" title="Characterization of reversible languages">characterization of reversible languages</fr:link>. Any substring (ignoring the special starting and ending symbols) in this case describes a fixed geometric transformation between a tile and some supertile that it is contained in. So suppose <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}^+]]></fr:tex>, then inverting the transformation given by <fr:tex display="inline"><![CDATA[z]]></fr:tex>, we know that <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> describe equivalent geometric configurations of a tile in some supertile. Therefore they must actually be <fr:link type="local" href="misc-000J.xml" addr="misc-000J" title="Nerode congruence">Nerode congruent</fr:link>.</fr:p>

  <fr:p>Since we have not rigorously defined the geometric aspects of tile systems, we will not attempt to articulate a completely formal proof. But it should be noted how geometry plays a crucial role here, meaning that substitution systems that are “non-rigid” may fail this property.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>We are finally ready to discuss the benefits of a reversible language: they admit a very efficient algorithm that learns the language from a series of examples. This problem, called <fr:em>language induction</fr:em>, is very difficult for general languages.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>433</fr:anchor>
                <fr:addr type="user">misc-000O</fr:addr>
                <fr:route>misc-000O.xml</fr:route>
                <fr:title text="Induction of reversible languages">Induction of reversible languages</fr:title>
                <fr:taxon>Algorithm</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This algorithm is described in <fr:link type="local" href="inference-of-reversible-languages.xml" addr="inference-of-reversible-languages" title="Inference of Reversible Languages">Inference of Reversible Languages</fr:link>. It inputs a set of example strings in a <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible regular language</fr:link>, and outputs a finite <fr:link type="local" href="misc-000L.xml" addr="misc-000L" title="Bideterministic automaton">bideterministic automaton</fr:link>. The soundness proof is given as Theorem 26, and if the input enumerates all the strings in the language, then the output is guaranteed to converge to the correct minimal DFA at a finite stage by Theorem 27. Note that obviously we cannot algorithmically determine whether it has converged or not, without further information.</fr:p>
                <fr:p>The algorithm proceeds as follows. Start with a trivial automata with a start and accept state, but no transitions. When we read a new example string, add a new chain of states and transitions from the start to the accept state, solely accepting this new string. Then we perform a merging process. Whenever a state has two transitions on the same letter, we merge the destination states, and vice versa for transitions to that state. This process obviously terminates and produces a bideterministic automata. And we can read the next example string.</fr:p>
              </fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>It is easy to generate example strings in our use case: simply feed in valid finite Conway signatures in <fr:ref addr="tile-0007" href="tile-0007.xml" taxon="Algorithm" />. Now all we need is a way to know when to stop. A possible criterion is when the resulting transducer never rejects a valid Conway signature. To do this, erase the outputs to get an automaton, and determinize it to get a DFA <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Now consider another automaton <fr:tex display="inline"><![CDATA[B]]></fr:tex> that recognizes valid Conway signatures (paired with an edge label at the beginning and a terminating tile label). Take the product of these two automata, remove unreachable states, and check whether there are states where <fr:tex display="inline"><![CDATA[B]]></fr:tex> has a valid transition but <fr:tex display="inline"><![CDATA[A]]></fr:tex> doesn’t. This is essentially a special case of the standard algorithm deciding regular language containment.</fr:p>
            <fr:p>Since the learned language only grows larger with each example, this condition is obviously sufficient because the original language came from a recursive function. Furthermore, we will prove that under some conditions, this can always be achieved in finite time, so the language inference algorithm terminates. Recall that for the transducer, we modified it so that every state is accepting, so this claim is reduced to the following theorem.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>435</fr:anchor>
                <fr:addr type="user">tile-000J</fr:addr>
                <fr:route>tile-000J.xml</fr:route>
                <fr:title text="Totality of the neighborhood relation">Totality of the neighborhood relation</fr:title>
                <fr:taxon>Theorem</fr:taxon>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>
                    <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Suppose we have a <fr:link type="local" href="tile-0004.xml" addr="tile-0004" title="Substitution system">substitution system</fr:link> that doesn’t involve a prototile that never appears in its <fr:link type="local" href="tile-000A.xml" addr="tile-000A" title="Hull of set of tilings">hull</fr:link>, then for every finite <fr:link type="local" href="tile-0006.xml" addr="tile-0006" title="Conway signature">Conway signature</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> with a valid edge label <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>, it is always possible to extend <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> so that the <fr:link type="local" href="tile-0007.xml" addr="tile-0007" title="Recursive neighborhood algorithm">recursive neighborhood algorithm</fr:link> accepts it.</fr:p><fr:p>There are contrived substitution systems that violate the condition of this theorem. For example, consider a one-dimensional system with two kinds of tiles <fr:tex display="inline"><![CDATA[a, b]]></fr:tex>. Let the substitution rules be <fr:tex display="inline"><![CDATA[a \mapsto  aa]]></fr:tex>, <fr:tex display="inline"><![CDATA[b \mapsto  ba]]></fr:tex>. Iterated deflations produce the patches <fr:tex display="inline"><![CDATA[baa\dots  a]]></fr:tex>, and taking the hull results in the periodic tiling <fr:tex display="inline"><![CDATA[\dots  aaa \dots ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[b]]></fr:tex> doesn’t occur. These are probably<fr:tex display="inline"><![CDATA[^?]]></fr:tex> never interesting.</fr:p><fr:p>Another caveat is when the substitution system contains a final stage of deflation. This technically makes most of the results invalid since deflation rules are no longer unique. But it should be apparent that this can be fixed by suitably changing our definitions and proofs.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>357</fr:anchor><fr:addr type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>If a prototile <fr:tex display="inline"><![CDATA[t]]></fr:tex> can appear in the hull of <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex>, this means for any radius, there is a patch of tiling in <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex> covering that radius, with this tile in the center. In this case, <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex> consists of iterated deflations of a single tile. So there exists <fr:tex display="inline"><![CDATA[t']]></fr:tex> such that its <fr:tex display="inline"><![CDATA[n]]></fr:tex>-th deflation contains <fr:tex display="inline"><![CDATA[t]]></fr:tex>, such that all the edges of <fr:tex display="inline"><![CDATA[t]]></fr:tex> have neighbors in the deflation. So <fr:tex display="inline"><![CDATA[t]]></fr:tex> has a Conway signature <fr:tex display="inline"><![CDATA[\Sigma ' = t \rightarrow  \cdots  \rightarrow  t']]></fr:tex>. Now take <fr:tex display="inline"><![CDATA[t]]></fr:tex> to be the last prototile label in <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, and let the extension be the concatenation <fr:tex display="inline"><![CDATA[\Sigma  \frown  \Sigma ']]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
              <fr:backmatter />
            </fr:tree>
            <fr:p>We finish with some discussion on methods to execute the resulting non-deterministic transducer efficiently. One obvious way is to attempt to determinize the transducer. This is not always possible, since the transducer also has a “potential output” state, which means the powerset construction may produce infinitely many states. However, this frequently works, and produces a deterministic finite state transducer.</fr:p>
            <fr:p>Another, more convenient method is via programs like <fr:link type="external" href="https://kleenexlang.org/">Kleenex</fr:link> to compile the transducers. We can either directly extract the resulting deterministic streaming transducer and simulate it, or compile it into a binary and use FFI.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>541</fr:anchor>
            <fr:addr type="user">misc-000J</fr:addr>
            <fr:route>misc-000J.xml</fr:route>
            <fr:title text="Nerode congruence">Nerode congruence</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, two words <fr:tex display="inline"><![CDATA[x, y \in  \Sigma ^*]]></fr:tex> are <fr:strong>Nerode congruent</fr:strong> if for any word <fr:tex display="inline"><![CDATA[z]]></fr:tex>, <fr:tex display="inline"><![CDATA[xz \in  \mathcal {L}]]></fr:tex> iff <fr:tex display="inline"><![CDATA[yz \in  \mathcal {L}]]></fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>543</fr:anchor>
            <fr:addr type="user">misc-000N</fr:addr>
            <fr:route>misc-000N.xml</fr:route>
            <fr:title text="Characterization of reversible languages">Characterization of reversible languages</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>Given a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, it is a <fr:link type="local" href="misc-000M.xml" addr="misc-000M" title="Reversible regular language">reversible regular language</fr:link> if and only if it is regular, and if <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}]]></fr:tex> for some strings <fr:tex display="inline"><![CDATA[x, y, z]]></fr:tex>, then for all strings <fr:tex display="inline"><![CDATA[w]]></fr:tex> we have <fr:tex display="inline"><![CDATA[xw \in  \mathcal {L} \iff  yw \in  \mathcal {L}]]></fr:tex>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>369</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>See Theorem 7 in <fr:link type="local" href="inference-of-reversible-languages.xml" addr="inference-of-reversible-languages" title="Inference of Reversible Languages">Inference of Reversible Languages</fr:link>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>545</fr:anchor>
            <fr:addr type="user">tile-000E</fr:addr>
            <fr:route>tile-000E.xml</fr:route>
            <fr:title text="Language of neighborhood relation">Language of neighborhood relation</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Consider the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> where each symbol is either of the form <fr:tex display="inline"><![CDATA[(\text {tile label }t, \text {edge label of }t)]]></fr:tex> or <fr:tex display="inline"><![CDATA[(\text {tile label }t, \text {subtile label of }t)]]></fr:tex>. We define a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> on <fr:tex display="inline"><![CDATA[\Delta  \times  \Delta ]]></fr:tex>, representing a binary relation on <fr:tex display="inline"><![CDATA[\Delta ^*]]></fr:tex> between words of the same length.
  Let <fr:tex display="block"><![CDATA[\Sigma  = t_0 \xrightarrow {s_1} t_1 \xrightarrow {s_2} \cdots  \xrightarrow {s_n} t_n]]></fr:tex> be a <fr:em>finite</fr:em> <fr:link type="local" href="tile-0006.xml" addr="tile-0006" title="Conway signature">Conway signature</fr:link> and <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> be an edge label of the corresponding tile. We regard this as a word <fr:tex display="inline"><![CDATA[(t_0, \epsilon )(t_1, s_1) \cdots  (t_n, s_n)]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex>. Suppose the <fr:link type="local" href="tile-0007.xml" addr="tile-0007" title="Recursive neighborhood algorithm">recursive neighborhood algorithm</fr:link> sends <fr:tex display="inline"><![CDATA[(\Sigma _1, \epsilon _1)]]></fr:tex> to <fr:tex display="inline"><![CDATA[(\Sigma _2, \epsilon _2)]]></fr:tex>, then the two corresponding words can be zipped together to form a word over <fr:tex display="inline"><![CDATA[\Delta  \times  \Delta ]]></fr:tex>. We define the set of all such words as the <fr:strong>language of neighborhood relation</fr:strong> <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>.</fr:p>
            <fr:p>Furthermore, consider the set of tile labels <fr:tex display="inline"><![CDATA[\mathrm {T}]]></fr:tex>. We define another language <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex>, called the <fr:em>augmented</fr:em> language of neighborhood relation, over the alphabet <fr:tex display="inline"><![CDATA[(\Delta  \times  \Delta ) \sqcup  \mathrm {T}]]></fr:tex>. Notice that if the <fr:link type="local" href="tile-0007.xml" addr="tile-0007" title="Recursive neighborhood algorithm">recursive neighborhood algorithm</fr:link> sends <fr:tex display="inline"><![CDATA[(\Sigma _1, \epsilon _1)]]></fr:tex> to <fr:tex display="inline"><![CDATA[(\Sigma _2, \epsilon _2)]]></fr:tex>, the two signatures always share the last prototile label <fr:tex display="inline"><![CDATA[t_n]]></fr:tex>. We append the symbol <fr:tex display="inline"><![CDATA[t_n]]></fr:tex> to the corresponding word in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, and define <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> to be all the words of this form.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>547</fr:anchor>
            <fr:addr type="user">misc-000M</fr:addr>
            <fr:route>misc-000M.xml</fr:route>
            <fr:title text="Reversible regular language">Reversible regular language</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A regular language is <fr:strong>reversible</fr:strong> if it can be recognized by a <fr:link type="local" href="misc-000L.xml" addr="misc-000L" title="Bideterministic automaton">bideterministic</fr:link> DFA, which is equivalent to requiring the <fr:link type="local" href="misc-000K.xml" addr="misc-000K" title="Myhill–Nerode automaton">Myhill–Nerode automaton</fr:link> to be bideterministic.</fr:p>
            <fr:p>Note that there are stronger and weaker notions of reversible regular languages in the literature, with inconsistent names.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>549</fr:anchor>
            <fr:addr type="user">tile-0004</fr:addr>
            <fr:route>tile-0004.xml</fr:route>
            <fr:title text="Substitution system">Substitution system</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Given a <fr:link type="local" href="tile-0003.xml" addr="tile-0003" title="Tile system">tile system</fr:link>, a <fr:strong>substitution system</fr:strong> is a map from each prototile to a patch of tiles, such that when we replace each tile in a tiling with the substitution, the resulting patches of tiles can fit together in the same way, forming another tiling. This process is called <fr:strong>deflation</fr:strong>, while the inverse process, if it exists, is called <fr:strong>inflation</fr:strong>. We usually only consider substitution systems where inflation exists and is unique.</fr:p>
            <fr:p>More precisely, given a prototile <fr:tex display="inline"><![CDATA[t]]></fr:tex>, we assign a list of deflated tiles <fr:tex display="inline"><![CDATA[t_i]]></fr:tex>. Each edge of <fr:tex display="inline"><![CDATA[t]]></fr:tex> will be subdivided into several subedges (with their own colors), such that the subdivision only depends on the color, and edges of opposite colors are divided in a way such that the resulting subedges match. For the data of how the deflated tiles glue together, we have a perfect pairing on the set
  <fr:tex display="block"><![CDATA[\{\text {subedges of $t$}\} \sqcup  \coprod _i \{\text {edges of $t_i$}\}]]></fr:tex> such that the paired edges are compatible. Specifically, if two edges of deflated tiles, or two subedges of <fr:tex display="inline"><![CDATA[t]]></fr:tex> are matched, they must be of opposite colors; if an edge of a deflated tile is matched with a subedge, they must share colors.</fr:p>
            <fr:p>In addition to this, the subdivision must also match geometrically, but we shall not give its full definition here, as it suffices to recognize this intuitively.</fr:p>
            <fr:p>For convenience, if two edges <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\epsilon ']]></fr:tex> have opposite colors, we use the <fr:em>same label</fr:em> for their subedges in a substitution. This simplifies the presentation since we avoid using a conversion look-up table, but requires us to be somewhat careful in assigning labels. In general, we can assign the subedge labels counterclockwise for edges with positive colors, and clockwise for negative colors.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
