<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2311</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2309</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>415</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>417</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2307</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:related><fr:backlinks><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2293</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002K</fr:addr><fr:route>hmlg-002K.xml</fr:route><fr:title><fr:tex>\delta</fr:tex>-functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>homological <fr:tex>\delta</fr:tex>-functor</fr:strong> is a sequence of <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functors</fr:link> <fr:tex>T_n : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian categories</fr:link>, with the convention that <fr:tex>T_n = 0</fr:tex> for <fr:tex>n &lt; 0</fr:tex>. For every <fr:link
href="hmlg-000H.xml"
type="local"
addr="hmlg-000H">short exact sequence</fr:link> <fr:tex>0 \to X \to Y \to Z \to 0</fr:tex> in <fr:tex>{\mathcal{A}}</fr:tex>, we have a connecting map <fr:tex>\delta_n : T_n(Z) \to T_{n-1}(X)</fr:tex>, such that this assignment is natural in the exact sequence.
</fr:p><fr:p>
  Similarly, a <fr:strong>cohomological <fr:tex>\delta</fr:tex>-functor</fr:strong> can be defined with <fr:tex>\delta^n : T^n(Z) \to T^{n+1}(X)</fr:tex>. These also have contravariant versions, by replacing <fr:tex>{\mathcal{A}}</fr:tex> with <fr:tex>{\mathcal{A}}^{\textrm{op}}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2295</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2297</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2299</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0018</fr:addr><fr:route>hmlg-0018.xml</fr:route><fr:title>An additive functor is exact iff it preserves quasi-isomorphisms</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian categories</fr:link>, it is <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link> iff it sends <fr:link
href="hmlg-000C.xml"
type="local"
addr="hmlg-000C">quasi-isomorphisms</fr:link> to quasi-isomorphisms.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2038</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.
  </fr:p>

  <fr:p>
    On the other hand, <fr:link
href="todo.xml"
type="local"
addr="todo">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex>f : C_\bullet \to D_\bullet</fr:tex> is a quasi-isomorphism, <fr:tex>H_n (f)</fr:tex> are all isomorphisms. Therefore <fr:tex>H_n (F(f)) = F(H_n(f))</fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2301</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0010</fr:addr><fr:route>hmlg-0010.xml</fr:route><fr:title>Snake lemma</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, given the middle two rows of the diagram
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="1acb2847a1f04e3bee79a6e62fffab2f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
    &amp; {\ker f} &amp; {\ker g} &amp; {\ker h} \\
    {\ker i} &amp; \bullet &amp; \bullet &amp; \bullet &amp; 0 \\
    0 &amp; \bullet &amp; \bullet &amp; \bullet &amp; {\operatorname{coker} j} \\
    &amp; {\operatorname{coker} f} &amp; {\operatorname{coker} g} &amp; {\operatorname{coker} h}
    \arrow["f", from=2-2, to=3-2]
    \arrow["g", from=2-3, to=3-3]
    \arrow["h", from=2-4, to=3-4]
    \arrow[from=1-2, to=2-2]
    \arrow[from=1-3, to=2-3]
    \arrow[from=1-4, to=2-4]
    \arrow[blue, &gt;-&gt;, out=90, in=180, from=2-1, to=1-2]
    \arrow[from=2-1, to=2-2]
    \arrow["i", from=2-2, to=2-3]
    \arrow[from=2-3, to=2-4]
    \arrow[from=3-2, to=3-3]
    \arrow["j", from=3-3, to=3-4]
    \arrow[from=3-4, to=3-5]
    \arrow[blue, -&gt;&gt;, out=0, in=-90, from=4-4, to=3-5]
    \arrow[from=3-2, to=4-2]
    \arrow[from=3-3, to=4-3]
    \arrow[from=3-4, to=4-4]
    \arrow[blue, from=1-2, to=1-3]
    \arrow[blue, from=1-3, to=1-4]
    \arrow[blue, from=4-2, to=4-3]
    \arrow[blue, from=4-3, to=4-4]
    \arrow[blue, dashed, out=0, in=180, from=1-4, to=4-2]
    \arrow[from=2-4, to=2-5]
    \arrow[from=3-1, to=3-2]
  \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <fr:tex>0 \to \ker i \to \ker f \to \ker g \to \ker h \xrightarrow{\partial} \operatorname{coker} f \to \operatorname{coker} g \to \operatorname{coker} h \to \operatorname{coker} j \to 0</fr:tex>. In particular, if <fr:tex>i</fr:tex> is monic and <fr:tex>j</fr:tex> is epic, this leads to a six-term exact sequence.
</fr:p><fr:p>
  There are multiple ways to prove this claim. We can first <fr:link
href="todo.xml"
type="local"
addr="todo">prove it in categories of modules</fr:link>, and <fr:link
href="hmlg-0011.xml"
type="local"
addr="hmlg-0011">use the Freyd–Mitchell embedding</fr:link>. We can also use <fr:link
href="todo.xml"
type="local"
addr="todo">pseudo-elements</fr:link> to <fr:link
href="todo.xml"
type="local"
addr="todo">perform diagram chases</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2303</fr:anchor><fr:addr>hmlg-0011</fr:addr><fr:route>hmlg-0011.xml</fr:route><fr:title>Using the <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">Freyd–Mitchell embedding</fr:link> to prove theorems</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We use the <fr:link
href="hmlg-0010.xml"
type="local"
addr="hmlg-0010">snake lemma</fr:link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.
</fr:p><fr:p>
  Suppose we have already <fr:link
href="todo.xml"
type="local"
addr="todo">proved</fr:link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> <fr:tex>{\mathcal{C}}</fr:tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <fr:tex>{\mathcal{D}}</fr:tex>, which we can embed in a module category <fr:tex>{R\text{-}{\mathsf{Mod}}}</fr:tex>.
</fr:p><fr:p>
  Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <fr:tex>{\mathcal{D}}</fr:tex> is a full abelian subcategory of <fr:tex>{R\text{-}{\mathsf{Mod}}}</fr:tex>, these morphisms are contained in <fr:tex>{\mathcal{D}}</fr:tex>, and the sequence is still exact. And since <fr:tex>{\mathcal{D}}</fr:tex> is a full abelian subcategory of <fr:tex>{\mathcal{C}}</fr:tex>, the sequence is again exact in <fr:tex>{\mathcal{C}}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2305</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>