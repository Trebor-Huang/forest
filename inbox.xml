<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>3557</fr:anchor><fr:taxon>Meta</fr:taxon><fr:addr>inbox</fr:addr><fr:route>inbox.xml</fr:route><fr:title>Inbox</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
  This is where I sort through my forest. Unwritten links are recorded <fr:link
href="todo.xml"
type="local"
addr="todo">here</fr:link>. Here is a list of all the trees:
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3045</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002Q</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since <fr:tex>X</fr:tex> is connected, for each <fr:tex>x</fr:tex> there exists a path back to the point <fr:tex>x_0</fr:tex>. <fr:tex>(x_0 \mathbin{::} -) = {\textrm{id}}</fr:tex> is an auto-equivalence on <fr:tex>JX</fr:tex>, so noting that being an equivalence is a proposition, <fr:tex>(x \mathbin{::} -)</fr:tex> is too, for all <fr:tex>x</fr:tex>.
  </fr:p>

  <fr:p>
    Now consider a family of spaces indexed by <fr:tex>\Sigma X</fr:tex>. For the north and south pole we assign the space <fr:tex>JX</fr:tex>, and for each path between the poles induced by an element <fr:tex>x \in X</fr:tex>, we assign the equivalence <fr:tex>(x \mathbin{::} -)</fr:tex>, which by univalence induces a path.
    The total space of this kind of families is characterized by the flattening lemma, in Section 6.12 of the <fr:link
href="hott-book.xml"
type="local"
addr="hott-book">HoTT book</fr:link>. In this case, we have two copies of <fr:tex>JX</fr:tex> such that for each <fr:tex>x \in X</fr:tex>, <fr:tex>\vec{x} \in JX</fr:tex> we connect <fr:tex>\vec{x}</fr:tex> in the former copy to <fr:tex>x \mathbin{::} \vec{x}</fr:tex> in the latter with a path.
  </fr:p>

  <fr:p>
    The total space is in fact contractible. Take the center to be <fr:tex>[]</fr:tex> in the north copy of <fr:tex>JX</fr:tex>. For any other point <fr:tex>\vec{x}</fr:tex> in the north copy, we can move to the south copy via the neutral element <fr:tex>(x_0 \mathbin{::} -)</fr:tex>, go along the path <fr:tex>(x_0 \mathbin{::} -) = {\textrm{id}}</fr:tex> in the south copy, and go back to the north copy removing the first entry. This allows us to recursively reach the empty list. For an element in the south copy, we can similarly move through <fr:tex>(x_0 \mathbin{::} -)</fr:tex> to the north copy and continue there.
  </fr:p>

  <fr:p>
    We still need to arrange for the contraction of the paths. This can be easily seen by drawing a diagram of all the boundaries, though tedious to completely write down. This then establishes that we have a fiber sequence <fr:tex>JX \to 1 \to \Sigma X</fr:tex>, where the middle term is the total space constructed above, and <fr:tex>JX</fr:tex> is the fiber on top of the north pole of <fr:tex>\Sigma X</fr:tex>. Hence <fr:tex>JX</fr:tex> must be equivalent to the loop space <fr:tex>\Omega \Sigma X</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3047</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>hott-book</fr:addr><fr:route>hott-book.xml</fr:route><fr:title>Homotopy Type Theory: Univalent Foundations of Mathematics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author>The Univalent Foundations Program</fr:author></fr:authors><fr:meta
name="external">https://homotopytypetheory.org/book/</fr:meta></fr:frontmatter><fr:mainmatter></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3049</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002R</fr:addr><fr:route>hmlg-002R.xml</fr:route><fr:title>James construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pointed space <fr:tex>(X, x_0)</fr:tex>, the <fr:strong>James construction</fr:strong> <fr:tex>J X</fr:tex> is the homotopy coherent version of a free monoid (a.k.a. the type of lists or strings), such that the point acts as the neutral element. The space is constructed inductively from a point <fr:tex>[] \in JX</fr:tex>. For each point <fr:tex>y \in X</fr:tex> and <fr:tex>\vec{x} \in JX</fr:tex>, we have another point <fr:tex>y \mathbin{::} \vec{x} \in JX</fr:tex>. And finally for <fr:tex>\vec{x} \in JX</fr:tex> we adjoin a path from <fr:tex>x_0 \mathbin{::} \vec{x}</fr:tex> to <fr:tex>\vec{x}</fr:tex>.
</fr:p><fr:p>
  There is a map <fr:tex>X \to JX</fr:tex> given by <fr:tex>x \mapsto x \mathbin{::} []</fr:tex>, written as <fr:tex>[x]</fr:tex> for short.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3051</fr:anchor><fr:addr>hmlg-002Q</fr:addr><fr:route>hmlg-002Q.xml</fr:route><fr:title>Synthetic characterization of the James construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="hmlg-002R.xml"
type="local"
addr="hmlg-002R">James construction</fr:link> <fr:tex>JX</fr:tex> of a connected pointed space <fr:tex>X</fr:tex> is equivalent to the space <fr:tex>\Omega \Sigma X</fr:tex>, which is very intriguing considering that <fr:tex>\Omega \Sigma X</fr:tex> actually has a group structure up to homotopy. Its synthetic proof is enlightening.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002Q</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since <fr:tex>X</fr:tex> is connected, for each <fr:tex>x</fr:tex> there exists a path back to the point <fr:tex>x_0</fr:tex>. <fr:tex>(x_0 \mathbin{::} -) = {\textrm{id}}</fr:tex> is an auto-equivalence on <fr:tex>JX</fr:tex>, so noting that being an equivalence is a proposition, <fr:tex>(x \mathbin{::} -)</fr:tex> is too, for all <fr:tex>x</fr:tex>.
  </fr:p>

  <fr:p>
    Now consider a family of spaces indexed by <fr:tex>\Sigma X</fr:tex>. For the north and south pole we assign the space <fr:tex>JX</fr:tex>, and for each path between the poles induced by an element <fr:tex>x \in X</fr:tex>, we assign the equivalence <fr:tex>(x \mathbin{::} -)</fr:tex>, which by univalence induces a path.
    The total space of this kind of families is characterized by the flattening lemma, in Section 6.12 of the <fr:link
href="hott-book.xml"
type="local"
addr="hott-book">HoTT book</fr:link>. In this case, we have two copies of <fr:tex>JX</fr:tex> such that for each <fr:tex>x \in X</fr:tex>, <fr:tex>\vec{x} \in JX</fr:tex> we connect <fr:tex>\vec{x}</fr:tex> in the former copy to <fr:tex>x \mathbin{::} \vec{x}</fr:tex> in the latter with a path.
  </fr:p>

  <fr:p>
    The total space is in fact contractible. Take the center to be <fr:tex>[]</fr:tex> in the north copy of <fr:tex>JX</fr:tex>. For any other point <fr:tex>\vec{x}</fr:tex> in the north copy, we can move to the south copy via the neutral element <fr:tex>(x_0 \mathbin{::} -)</fr:tex>, go along the path <fr:tex>(x_0 \mathbin{::} -) = {\textrm{id}}</fr:tex> in the south copy, and go back to the north copy removing the first entry. This allows us to recursively reach the empty list. For an element in the south copy, we can similarly move through <fr:tex>(x_0 \mathbin{::} -)</fr:tex> to the north copy and continue there.
  </fr:p>

  <fr:p>
    We still need to arrange for the contraction of the paths. This can be easily seen by drawing a diagram of all the boundaries, though tedious to completely write down. This then establishes that we have a fiber sequence <fr:tex>JX \to 1 \to \Sigma X</fr:tex>, where the middle term is the total space constructed above, and <fr:tex>JX</fr:tex> is the fiber on top of the north pole of <fr:tex>\Sigma X</fr:tex>. Hence <fr:tex>JX</fr:tex> must be equivalent to the loop space <fr:tex>\Omega \Sigma X</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3053</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that the right adjoint preserves products, and so is <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive</fr:link>. We need to show that <fr:tex>\hom(-, R(I))</fr:tex> is <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, which amounts to saying the composition of <fr:tex>F</fr:tex> and <fr:tex>\hom(-, I)</fr:tex> is exact, which is true because both are exact.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3055</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002P</fr:addr><fr:route>hmlg-002P.xml</fr:route><fr:title>Right adjoint of exact functor preserves injectives</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Suppose <fr:tex>F \dashv R</fr:tex>, <fr:tex>F</fr:tex> is exact and <fr:tex>I</fr:tex> is an <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link>, then <fr:tex>R(I)</fr:tex> is also an injective. Dually, if <fr:tex>L \dashv F</fr:tex>, <fr:tex>F</fr:tex> is exact and <fr:tex>P</fr:tex> is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective</fr:link>, then <fr:tex>L(P)</fr:tex> is also a projective.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that the right adjoint preserves products, and so is <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive</fr:link>. We need to show that <fr:tex>\hom(-, R(I))</fr:tex> is <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, which amounts to saying the composition of <fr:tex>F</fr:tex> and <fr:tex>\hom(-, I)</fr:tex> is exact, which is true because both are exact.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3057</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3059</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title>Abelian groups are injective iff divisible</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An abelian group <fr:tex>G</fr:tex> is <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex>g \in G</fr:tex> and positive integer <fr:tex>n</fr:tex>, there exists a (non-unique) solution of <fr:tex>nx = g</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>344</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3061</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002K</fr:addr><fr:route>hmlg-002K.xml</fr:route><fr:title><fr:tex>\delta</fr:tex>-functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>homological <fr:tex>\delta</fr:tex>-functor</fr:strong> is a sequence of <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functors</fr:link> <fr:tex>T_n : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian categories</fr:link>, with the convention that <fr:tex>T_n = 0</fr:tex> for <fr:tex>n &lt; 0</fr:tex>. For every <fr:link
href="hmlg-000H.xml"
type="local"
addr="hmlg-000H">short exact sequence</fr:link> <fr:tex>0 \to X \to Y \to Z \to 0</fr:tex> in <fr:tex>{\mathcal{A}}</fr:tex>, we have a connecting map <fr:tex>\delta_n : T_n(Z) \to T_{n-1}(X)</fr:tex>, such that this assignment is natural in the exact sequence.
</fr:p><fr:p>
  Similarly, a <fr:strong>cohomological <fr:tex>\delta</fr:tex>-functor</fr:strong> can be defined with <fr:tex>\delta^n : T^n(Z) \to T^{n+1}(X)</fr:tex>. These also have contravariant versions, by replacing <fr:tex>{\mathcal{A}}</fr:tex> with <fr:tex>{\mathcal{A}}^{\textrm{op}}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3063</fr:anchor><fr:addr>hmlg-002M</fr:addr><fr:route>hmlg-002M.xml</fr:route><fr:title>Displayed category of <fr:tex>\delta</fr:tex>-functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="hmlg-002K.xml"
type="local"
addr="hmlg-002K"><fr:tex>\delta</fr:tex>-functors</fr:link> between two <fr:link
href="hmlg-000G.xml"
type="local"
addr="hmlg-000G">abelian categories</fr:link> form a displayed category over the category of <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functors</fr:link> (or we can restrict it to <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">right exact functors</fr:link> for homological <fr:tex>\delta</fr:tex>-functors). Under this setup, the definition of a <fr:link
href="hmlg-002N.xml"
type="local"
addr="hmlg-002N">universal <fr:tex>\delta</fr:tex>-functor</fr:link> can be expressed abstractly as a “relative” kind of terminal object or initial object. It is an object <fr:tex>X</fr:tex> displayed over <fr:tex>x</fr:tex> such that <fr:tex>\hom_f (Y, X) = 1</fr:tex> for every <fr:tex>Y</fr:tex> and <fr:tex>f</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3065</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002L</fr:addr><fr:route>hmlg-002L.xml</fr:route><fr:title>Morphism of <fr:tex>\delta</fr:tex>-functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-002K.xml"
type="local"
addr="hmlg-002K"><fr:tex>\delta</fr:tex>-functors</fr:link>, a morphism between them is given by a sequence of natural transformations <fr:tex>f_n : T_n \to S_n</fr:tex> that additionally commutes with <fr:tex>\delta</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3067</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002N</fr:addr><fr:route>hmlg-002N.xml</fr:route><fr:title>Universal <fr:tex>\delta</fr:tex>-functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-002K.xml"
type="local"
addr="hmlg-002K">homological <fr:tex>\delta</fr:tex>-functor</fr:link> <fr:tex>T_n</fr:tex>, it is <fr:strong>universal</fr:strong> if given any other <fr:tex>\delta</fr:tex>-functor <fr:tex>S_n</fr:tex> and a natural transformation <fr:tex>S_0 \to T_0</fr:tex> at degree 0, it can be uniquely extended to a <fr:link
href="hmlg-002L.xml"
type="local"
addr="hmlg-002L">morphism of <fr:tex>\delta</fr:tex>-functors</fr:link>. Dually, we can reverse the arrows to get the definition of a universal <fr:em>cohomological</fr:em> <fr:tex>\delta</fr:tex>-functor.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3069</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3071</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3073</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3075</fr:anchor><fr:addr>hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title>Exactness of <fr:tex>\hom</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>\hom(P, -)</fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition"></fr:ref> it is left exact. Similarly <fr:tex>\hom(-, I)</fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex>\hom(P, -)</fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex>\hom(P, -)</fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>352</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P \to B</fr:tex> can be lifted through an epimorphism <fr:tex>A \twoheadrightarrow B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P \to A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>353</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P \to B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>356</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Dually, we have the definition of injective objects, which make <fr:tex>\hom(-, I)</fr:tex> exact.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>360</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title>Abelian groups are injective iff divisible</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An abelian group <fr:tex>G</fr:tex> is <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex>g \in G</fr:tex> and positive integer <fr:tex>n</fr:tex>, there exists a (non-unique) solution of <fr:tex>nx = g</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>344</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3077</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001X</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
    A morphism <fr:tex>\rho : {\mathbf{G}_{m}} \times \operatorname{Spec} R \to \operatorname{Spec} R</fr:tex> is given by a ring homomorphism <fr:tex>R \to \mathbb{Z}[x, x^{-1}] \otimes R \cong R[x, x^{-1}]</fr:tex>. Composing with the identity <fr:tex>1 \to {\mathbf{G}_{m}}</fr:tex>, we are required that
    <fr:tex
display="block">R \xrightarrow{\rho} R[x, x^{-1}] \xrightarrow{x \mapsto 1} R</fr:tex>
    is the identity.
  </fr:p>

  <fr:p>
    We can regard <fr:tex>R[x, x^{-1}]</fr:tex> as generated by <fr:tex>(n, r) \in \mathbb{Z} \times R</fr:tex>, where the first number is the degree of <fr:tex>x</fr:tex> and the second number is the coefficient. So they are under the relations <fr:tex>(n, r) + (n, r') = (n, r + r')</fr:tex>, and <fr:tex>(n, r) \cdot (m, r') = (n + m, r r')</fr:tex>. <fr:tex>\rho(r)</fr:tex> is a sum of finitely many <fr:tex>(n, r_n)</fr:tex>, and the identity law requires the sum of <fr:tex>r_n</fr:tex> is <fr:tex>r</fr:tex> again. This decomposes <fr:tex>r</fr:tex> into its components in each degree.
  </fr:p>

  <fr:p>
    Next, the associativity law essentially requires that, if <fr:tex>(n, r_n)</fr:tex> is a summand of some <fr:tex>\rho(r)</fr:tex>, then <fr:tex>\rho(r_n) = (n, r_n)</fr:tex>. So this is indeed a well-defined decomposition. Furthermore, <fr:tex>\rho</fr:tex> being a ring homomorphism guarantees that the grading respects multiplication and addition.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3079</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001X</fr:addr><fr:route>algm-001X.xml</fr:route><fr:title>Ring grading as <fr:tex>{\mathbf{G}_{m}}</fr:tex>-action</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a ring <fr:tex>R</fr:tex>, a <fr:tex>\mathbb{Z}</fr:tex>-<fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">grading</fr:link> on <fr:tex>R</fr:tex> is the same as a <fr:tex>{\mathbf{G}_{m}}</fr:tex>-action on <fr:tex>\operatorname{Spec} R</fr:tex>, where <fr:tex>{\mathbf{G}_{m}}</fr:tex> is <fr:link
href="algm-001V.xml"
type="local"
addr="algm-001V">the scheme of invertible elements</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>476</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001X</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
    A morphism <fr:tex>\rho : {\mathbf{G}_{m}} \times \operatorname{Spec} R \to \operatorname{Spec} R</fr:tex> is given by a ring homomorphism <fr:tex>R \to \mathbb{Z}[x, x^{-1}] \otimes R \cong R[x, x^{-1}]</fr:tex>. Composing with the identity <fr:tex>1 \to {\mathbf{G}_{m}}</fr:tex>, we are required that
    <fr:tex
display="block">R \xrightarrow{\rho} R[x, x^{-1}] \xrightarrow{x \mapsto 1} R</fr:tex>
    is the identity.
  </fr:p>

  <fr:p>
    We can regard <fr:tex>R[x, x^{-1}]</fr:tex> as generated by <fr:tex>(n, r) \in \mathbb{Z} \times R</fr:tex>, where the first number is the degree of <fr:tex>x</fr:tex> and the second number is the coefficient. So they are under the relations <fr:tex>(n, r) + (n, r') = (n, r + r')</fr:tex>, and <fr:tex>(n, r) \cdot (m, r') = (n + m, r r')</fr:tex>. <fr:tex>\rho(r)</fr:tex> is a sum of finitely many <fr:tex>(n, r_n)</fr:tex>, and the identity law requires the sum of <fr:tex>r_n</fr:tex> is <fr:tex>r</fr:tex> again. This decomposes <fr:tex>r</fr:tex> into its components in each degree.
  </fr:p>

  <fr:p>
    Next, the associativity law essentially requires that, if <fr:tex>(n, r_n)</fr:tex> is a summand of some <fr:tex>\rho(r)</fr:tex>, then <fr:tex>\rho(r_n) = (n, r_n)</fr:tex>. So this is indeed a well-defined decomposition. Furthermore, <fr:tex>\rho</fr:tex> being a ring homomorphism guarantees that the grading respects multiplication and addition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3081</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001V</fr:addr><fr:route>algm-001V.xml</fr:route><fr:title>The scheme of invertible elements</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We define the scheme <fr:tex>{\mathbf{G}_{m}}</fr:tex> as <fr:tex>\operatorname{Spec} \mathbb{Z}[x, x^{-1}]</fr:tex>. It can be characterized by the points <fr:tex>\hom({\mathbf{G}_{m}}, \operatorname{Spec} R) = R^\times</fr:tex> being the units of <fr:tex>R</fr:tex>. This scheme has a group structure. Since it is <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine</fr:link>, <fr:tex>1 \to {\mathbf{G}_{m}}</fr:tex> is <fr:link
href="algm-000X.xml"
type="local"
addr="algm-000X">given</fr:link> by the ring homomorphism <fr:tex>\mathbb{Z}[x, x^{-1}] \to \mathbb Z</fr:tex> sending <fr:tex>x</fr:tex> to <fr:tex>1</fr:tex>. The product map is given by a ring homomorphism <fr:tex>\mathbb{Z}[x, x^{-1}] \otimes \mathbb{Z}[y, y^{-1}] \to \mathbb{Z}[z, z^{-1}]</fr:tex> (where we renamed the variables for clarity) sending <fr:tex>x \otimes y</fr:tex> to <fr:tex>z</fr:tex>. The inverse map <fr:tex>\mathbb{Z}[x, x^{-1}] \to \mathbb{Z}[x, x^{-1}]</fr:tex> sends <fr:tex>x</fr:tex> to <fr:tex>x^{-1}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3083</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-002G</fr:addr><fr:route>hmlg-002G.xml</fr:route><fr:title>Coalgebra structure on algebraic cellular complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  There is a natural (differential graded) coalgebra structure on <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complexes</fr:link>. Recall that the tensor unit is <fr:tex>\mathbb{Z}</fr:tex> concentrated at degree 0. The counit map sends every 0-dimensional cell to <fr:tex>1</fr:tex>, and everything else to zero. The comultiplication is induced by the composition (... need simplicial?)
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3085</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002E</fr:addr><fr:route>hmlg-002E.xml</fr:route><fr:title>Abelian group structure on the W-bar construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Suppose the simplicial group <fr:tex>G</fr:tex> is abelian, then the <fr:link
href="hmlg-0021.xml"
type="local"
addr="hmlg-0021">W-bar construction</fr:link> still has an abelian group structure, by multiplication element-wise.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3087</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002F</fr:addr><fr:route>hmlg-002F.xml</fr:route><fr:title>Twisted tensor product</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  (...)
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3089</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-002D</fr:addr><fr:route>hmlg-002D.xml</fr:route><fr:title>Associated twisted product</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="hmlg-002C.xml"
type="local"
addr="hmlg-002C">associated simplicial fiber bundle</fr:link> of <fr:link
href="hmlg-002B.xml"
type="local"
addr="hmlg-002B">twisted products</fr:link> admits a simpler description. Suppose we have simplicial sets <fr:tex>F, B</fr:tex>, a simplicial group <fr:tex>G</fr:tex> with an action <fr:tex>G \times F \to F</fr:tex> and a <fr:link
href="hmlg-002A.xml"
type="local"
addr="hmlg-002A">twisting function</fr:link> <fr:tex>\tau</fr:tex> on <fr:tex>B</fr:tex>. The <fr:strong>associated twisted product</fr:strong> <fr:tex>B \times_\tau F</fr:tex> is defined exactly the same as twisted products, except we replace the factor <fr:tex>G</fr:tex> with <fr:tex>F</fr:tex>. This still makes sense, because we can interpret the multiplication <fr:tex>\tau(b) \cdot \partial_n f</fr:tex> as the <fr:tex>G</fr:tex>-action.
</fr:p><fr:p>
  In particular, if we consider <fr:tex>G</fr:tex> as a simplicial set with a <fr:tex>G</fr:tex>-action on the left via multiplication, then the associated twisted product <fr:tex>B \times_\tau G</fr:tex> is exactly the same as the twisted product <fr:tex>B \times_\tau G</fr:tex>, which explains our identical notation.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3091</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-002C</fr:addr><fr:route>hmlg-002C.xml</fr:route><fr:title>Associated simplicial fiber bundle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0028.xml"
type="local"
addr="hmlg-0028">simplicial principal fiber bundle</fr:link> <fr:tex>p : E \to B</fr:tex> with simplicial group <fr:tex>G</fr:tex>, and a simplicial set <fr:tex>F</fr:tex> with a group action <fr:tex>G \times F \to F</fr:tex>, we can construct a fiber bundle with fiber <fr:tex>F</fr:tex>, such that the twisting behaviour is described by the <fr:link
href="hmlg-0028.xml"
type="local"
addr="hmlg-0028">principal bundle</fr:link> <fr:tex>p</fr:tex>.
</fr:p><fr:p>
  We consider a group action on <fr:tex>E \times F</fr:tex>, by <fr:tex>g \cdot (e, f) = (e \cdot g^{-1}, g \cdot f)</fr:tex>. This action is clearly free. Suppose the quotient simplicial set is <fr:tex>E'</fr:tex>, then we have a <fr:link
href="hmlg-0026.xml"
type="local"
addr="hmlg-0026">simplicial fiber bundle</fr:link> <fr:tex>p' : E' \to B</fr:tex> induced from <fr:tex>p</fr:tex>. There is a <fr:tex>G</fr:tex>-action on the fibers, by acting on the <fr:tex>F</fr:tex> factor.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3093</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002B</fr:addr><fr:route>hmlg-002B.xml</fr:route><fr:title>Twisted product of simplicial sets</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a simplicial set <fr:tex>B</fr:tex>, a simplicial group <fr:tex>G</fr:tex> with a <fr:link
href="hmlg-002A.xml"
type="local"
addr="hmlg-002A">twisting function</fr:link> <fr:tex>\tau</fr:tex>, the <fr:strong>twisted product</fr:strong> is the pullback <fr:tex>B \times_{{\bar{W}} G} {W} G</fr:tex> with the <fr:link
href="hmlg-0021.xml"
type="local"
addr="hmlg-0021">W-bar construction</fr:link>. We write <fr:tex>B \times_\tau G</fr:tex> so as to make explicit the twisting function. This is a <fr:link
href="hmlg-0028.xml"
type="local"
addr="hmlg-0028">simplicial principal fiber bundle</fr:link>.
</fr:p><fr:p>
  More explicitly, we define <fr:tex>B \times_\tau G</fr:tex> to be the same as the Cartesian product <fr:tex>B \times G</fr:tex>, but with one face map altered. The pair <fr:tex>(b, g)</fr:tex> represents the element in <fr:tex>B \times_{{\bar{W}} G} {W} G</fr:tex> whose first component is <fr:tex>b \in B</fr:tex>, and the second component is <fr:tex>(g_0, \dots, g_n) \in {W} G</fr:tex>, where each element is an iterated product
  <fr:tex
display="block">\begin{aligned}     g_n &amp;= g \\     g_{k-1} &amp;= \tau(\partial_{k+1} \cdots \partial_n b) \cdot (\partial_{k} g_{k}).   \end{aligned}</fr:tex>
  This forces the last face map to be
  <fr:tex
display="block">\partial_n (b, g) = (\partial_n b, \tau(b) \cdot \partial_n g),</fr:tex>
  and the other face and degeneracy maps are unchanged.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3095</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002A</fr:addr><fr:route>hmlg-002A.xml</fr:route><fr:title>Twisting function</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a simplicial group <fr:tex>G</fr:tex>, a twisting function on a simplicial set <fr:tex>B</fr:tex> is a simplicial map <fr:tex>B \to {\bar{W}} G</fr:tex> to the <fr:link
href="hmlg-0021.xml"
type="local"
addr="hmlg-0021">W-bar construction</fr:link>. It represents a cocycle valued in <fr:tex>G</fr:tex>. Recall that <fr:tex>({\bar{W}} G)_n = G_0 \times \cdots \times G_{n-1}</fr:tex>. Taking the face map <fr:tex>\partial_{n}</fr:tex> reveals that all but the last component of the map <fr:tex>B_n \to ({\bar{W}} G)_n</fr:tex> are determined by the lower dimension maps. Hence we can obtain a more minimalistic combinatorial description.
</fr:p><fr:p>
  A <fr:strong>twisting function</fr:strong> <fr:tex>\tau</fr:tex> is a family of maps <fr:tex>\tau_n : B_n \to G_{n-1}</fr:tex> such that
  <fr:tex
display="block">\begin{aligned}     \tau(\partial_k b) &amp;= \partial_k \tau(b) &amp;&amp; (k &lt; n-1)\\     \tau(\partial_{n-1} b) &amp;= \partial_{n-1} \tau(b) \cdot \tau(\partial_n b) \\     \tau(\sigma_k b) &amp;= \sigma_k \tau(b) &amp;&amp; (k &lt; n)\\     \tau(\sigma_n b) &amp;= 1   \end{aligned}</fr:tex>
  The corresponding simplicial map <fr:tex>B_n \to ({\bar{W}} G)_n</fr:tex> is then computed by discarding the last <fr:tex>k</fr:tex> vertices of the input <fr:tex>b \in B_n</fr:tex> for <fr:tex>1 \le k \le n</fr:tex>, apply them to <fr:tex>\tau</fr:tex> and placing them at the correct components.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3097</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0029</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given a horn <fr:tex>\Lambda^n_k \to E</fr:tex> and a compatible simplex <fr:tex>\Delta^n \to B</fr:tex>, by the definition of simplicial fiber bundles, we may trivialize the bundle on the simplex locally. But since <fr:tex>F</fr:tex> is Kan, obviously <fr:tex>F \times \Delta^n \to \Delta^n</fr:tex> is also Kan. Hence we may select the required filling.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3099</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0029</fr:addr><fr:route>hmlg-0029.xml</fr:route><fr:title>Kan fiber bundle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0026.xml"
type="local"
addr="hmlg-0026">simplicial fiber bundle</fr:link> <fr:tex>p : E \to B</fr:tex>, it is a Kan fibration iff the fiber <fr:tex>F</fr:tex> is a Kan complex. Hence we call it a <fr:strong>Kan fiber bundle</fr:strong>. The proof yields an <fr:link
href="hmlg-0027.xml"
type="local"
addr="hmlg-0027">effective Kan fibration</fr:link> if all the inputs are effective.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0029</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given a horn <fr:tex>\Lambda^n_k \to E</fr:tex> and a compatible simplex <fr:tex>\Delta^n \to B</fr:tex>, by the definition of simplicial fiber bundles, we may trivialize the bundle on the simplex locally. But since <fr:tex>F</fr:tex> is Kan, obviously <fr:tex>F \times \Delta^n \to \Delta^n</fr:tex> is also Kan. Hence we may select the required filling.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3101</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0027</fr:addr><fr:route>hmlg-0027.xml</fr:route><fr:title>Effective Kan fibration</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>effective Kan fibration</fr:strong> is a Kan fibration of <fr:link
href="hmlg-001T.xml"
type="local"
addr="hmlg-001T">effective simplicial sets</fr:link> equipped with a computable choice of horn-filling. Note that it is different from <fr:em>algebraic</fr:em> Kan fibrations, because morphisms are not required to preserve the choice.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3103</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0026</fr:addr><fr:route>hmlg-0026.xml</fr:route><fr:title>Simplicial fiber bundle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A (strict) <fr:strong>simplicial fiber bundle</fr:strong> <fr:tex>p : E \to B</fr:tex> with fiber <fr:tex>F</fr:tex> is a simplicial map <fr:tex>p</fr:tex> such that for every simplex <fr:tex>\Delta^n \to B</fr:tex>, the pullback of <fr:tex>p</fr:tex> along the simplex is isomorphic to <fr:tex>\Delta^n \times F \to \Delta^n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3105</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0028</fr:addr><fr:route>hmlg-0028.xml</fr:route><fr:title>Simplicial principal fiber bundle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a simplicial group <fr:tex>G</fr:tex>, a <fr:link
href="hmlg-0026.xml"
type="local"
addr="hmlg-0026">fiber bundle</fr:link> <fr:tex>p : E \to B</fr:tex> is <fr:strong>principal</fr:strong> if <fr:tex>G</fr:tex> acts on the fibers freely and transitively <fr:em>on the right</fr:em>. This condition can be checked in each dimension separately.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3107</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0023</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For every product of simplices <fr:tex>\Delta^p \times \Delta^q</fr:tex>, we put on the <fr:link
href="hmlg-0022.xml"
type="local"
addr="hmlg-0022">discrete vector field on <fr:tex>\Delta^p \times \Delta^q</fr:tex></fr:link>. This DVF is <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissible</fr:link> because the time a path stays in <fr:tex>\Delta^p \times \Delta^q</fr:tex> is bounded by a function of <fr:tex>p</fr:tex> and <fr:tex>q</fr:tex>. Then it is sent to a boundary cell.
  </fr:p>

  <fr:p>
    Using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction"></fr:ref>, we get the required chain reduction. This is identical to the Eilenberg–Zilber reduction in literature, but the proof requires some combinatorics, and can be seen in Section 5.13 of <fr:link
href="discrete-vector-fields.xml"
type="local"
addr="discrete-vector-fields">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. However, this formulation gives a much better computational performance.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3109</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0023</fr:addr><fr:route>hmlg-0023.xml</fr:route><fr:title>Eilenberg–Zilber theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We have a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link>
  <fr:tex
display="block">C_* (X \times Y) \Rightarrow\mkern{-14mu}\Rightarrow C_* (X) \otimes C_* (Y).</fr:tex></fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>589</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0023</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For every product of simplices <fr:tex>\Delta^p \times \Delta^q</fr:tex>, we put on the <fr:link
href="hmlg-0022.xml"
type="local"
addr="hmlg-0022">discrete vector field on <fr:tex>\Delta^p \times \Delta^q</fr:tex></fr:link>. This DVF is <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissible</fr:link> because the time a path stays in <fr:tex>\Delta^p \times \Delta^q</fr:tex> is bounded by a function of <fr:tex>p</fr:tex> and <fr:tex>q</fr:tex>. Then it is sent to a boundary cell.
  </fr:p>

  <fr:p>
    Using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction"></fr:ref>, we get the required chain reduction. This is identical to the Eilenberg–Zilber reduction in literature, but the proof requires some combinatorics, and can be seen in Section 5.13 of <fr:link
href="discrete-vector-fields.xml"
type="local"
addr="discrete-vector-fields">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. However, this formulation gives a much better computational performance.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3111</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-0021</fr:addr><fr:route>hmlg-0021.xml</fr:route><fr:title>W-bar construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a simplicial group, we can define a model of its universal principal bundle <fr:tex>{\mathbf{E}} G \to {\mathbf{B}} G</fr:tex> as simplicial sets <fr:tex>{W} G \to {\bar{W}} G</fr:tex>. This is a generalization of the <fr:link
href="hmlg-001W.xml"
type="local"
addr="hmlg-001W">bar construction</fr:link>, if we consider a group <fr:tex>G</fr:tex> as a discrete simplicial set. It classifies principal <fr:tex>G</fr:tex>-bundles in the sense of Theorem 21.13 in <fr:link
href="simplicial-objects.xml"
type="local"
addr="simplicial-objects">Simplicial objects in algebraic topology</fr:link>.
</fr:p><fr:p>
  We define the <fr:tex>n</fr:tex>-simplices of <fr:tex>{W} G</fr:tex> to be
  <fr:tex
display="block">({W} G)_n = G_0 \times G_1 \times \cdots \times G_n</fr:tex>
  so that <fr:tex>G_n</fr:tex> acts on <fr:tex>({W} G)_n</fr:tex> by taking the face map that discards the last <fr:tex>k</fr:tex> vertices for each <fr:tex>k</fr:tex>, and then acting on the appropriate factor on the right. This forces the face maps and degeneracy maps to be
  <fr:tex
display="block">\begin{aligned}     \partial_k (g_0, \dots, g_n) &amp;=       (g_0, \dots, g_{k-1}, \partial_k g_{k+1}, \dots, \partial_k g_n), \\     \sigma_k (g_0, \dots, g_n) &amp;=       (g_0, \dots, g_{k}, \sigma_k g_{k}, \dots, \sigma_k g_n).   \end{aligned}</fr:tex>
  We define <fr:tex>{\bar{W}} G</fr:tex> to be <fr:tex>{W} G</fr:tex> quotiented by the action of <fr:tex>G</fr:tex>. This can be represented as <fr:tex>({\bar{W}} G)_n = G_0 \times \cdots \times G_{n-1}</fr:tex>,
  with the quotient map <fr:tex>({W} G)_n \twoheadrightarrow ({\bar{W}} G)_n</fr:tex> given by
  <fr:tex
display="block">(g_0, \dots, g_n) \mapsto (g_0 (\partial_1 g_1)^{-1}, \dots, g_{n-1} (\partial_n g_n)^{-1}).</fr:tex>
  The face and degeneracy maps can then be computed to be
  <fr:tex
display="block">\begin{aligned}     \partial_k (g_0, \dots, g_{n-1}) &amp;=       (g_0, g_1, \dots, g_{k-1} \cdot \partial_k g_k, \partial_k g_{k+1}, \dots, \partial_k g_{n-1}), \\     \partial_n (g_0, \dots, g_{n-1}) &amp;=       (g_0, g_1, \dots, g_{n-2}) \\     \sigma_k (g_0, \dots, g_{n-1}) &amp;=       (g_0, g_1, \dots, g_{k-1}, 1, \sigma_k g_{k}, \dots, \sigma_k g_{n-1}).   \end{aligned}</fr:tex>
  A quick computation shows that this indeed produces a <fr:link
href="hmlg-0028.xml"
type="local"
addr="hmlg-0028">simplicial principal fiber bundle</fr:link> with fiber <fr:tex>G</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3113</fr:anchor><fr:taxon>Notation</fr:taxon><fr:addr>hmlg-0025</fr:addr><fr:route>hmlg-0025.xml</fr:route><fr:title>Degeneracy maps</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given the monotone surjection <fr:tex>\{0, \dots, n+1\} \to \{0, \dots, n\}</fr:tex> with multiplicity at <fr:tex>k</fr:tex>, we write the corresponding degeneracy map of a simplicial set as <fr:tex>s_k</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3115</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-0022</fr:addr><fr:route>hmlg-0022.xml</fr:route><fr:title>Discrete vector field on <fr:tex>\Delta^p \times \Delta^q</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We construct a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link> on the <fr:link
href="hmlg-001U.xml"
type="local"
addr="hmlg-001U">reduced ACC</fr:link> of <fr:tex>\Delta^p \times \Delta^q</fr:tex> whose critical cells are given by its boundary and one additional cell
  <fr:tex
display="block">(0,0) &lt; (1,0) &lt; \cdots &lt; (p,0) &lt; (p,1) &lt; \cdots &lt; (p,q),</fr:tex>
  in the representation scheme of <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem"></fr:ref>. In particular, this <fr:link
href="hmlg-001R.xml"
type="local"
addr="hmlg-001R">gives rise</fr:link> to a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> <fr:tex>C_*(\Delta^p \times \Delta^q) \Rightarrow\mkern{-14mu}\Rightarrow C_*(\Delta^p) \otimes C_*(\Delta^q)</fr:tex>.
</fr:p><fr:p>
  Regarding the geometric simplices as paths in a <fr:tex>p \times q</fr:tex> grid as specified in <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem"></fr:ref>, we assign a <fr:tex>(p+q)</fr:tex>-simplex as a target cell if it contains a shape <fr:tex>\Rsh</fr:tex>. (The shape must go exactly one step up and one step to the right, since it is not possible otherwise in a geometric <fr:tex>(p+q)</fr:tex>-simplex.) To get its source cell, replace the <fr:em>last occurrence</fr:em> of this shape with <fr:tex>\nearrow</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3117</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-0024</fr:addr><fr:route>hmlg-0024.xml</fr:route><fr:title>Naturality of the Eilenberg–Zilber reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The naturality of the reduction in <fr:link
href="hmlg-0023.xml"
type="local"
addr="hmlg-0023">Eilenberg–Zilber theorem</fr:link> is not obvious. This is because maps sending geometric simplices to degenerate ones does not respect the vector field. We would need additional properties on the maps to guarantee naturality.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3119</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0020</fr:addr><fr:route>hmlg-0020.xml</fr:route><fr:title>Simplices of <fr:tex>\Delta^p \times \Delta^q</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The geometric <fr:tex>n</fr:tex>-simplices of the product simplicial set <fr:tex>\Delta^p \times \Delta^q</fr:tex> are given by a sequence <fr:tex>(u_0, v_0) &lt; (u_1, v_1) &lt; \dots &lt; (u_n, v_n)</fr:tex> of elements in <fr:tex>\{0, \dots, p\} \times \{0, \dots, q\}</fr:tex> endowed with the product partial order. Among these, the interior simplices, i.e. non-boundary simplices are given by sequences such that <fr:tex>u_i</fr:tex> ranges over all <fr:tex>\{0, \dots, p\}</fr:tex> and <fr:tex>v_i</fr:tex> ranges over <fr:tex>\{0, \dots, q\}</fr:tex>.
</fr:p><fr:p>
  We can graphically represent this as a path that only travels upwards and/or rightwards every step in a <fr:tex>p \times q</fr:tex> grid. Face maps are given by removing the corresponding vertex in the path, and directly connecting the surrounding two. But notice that a segment can skip through a grid point, such as going from <fr:tex>(0,0)</fr:tex> to <fr:tex>(2,2)</fr:tex>, skipping through <fr:tex>(1,1)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3121</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-001Z</fr:addr><fr:route>hmlg-001Z.xml</fr:route><fr:title>Chain reduction generated by a discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="hmlg-001R.xml"
type="local"
addr="hmlg-001R">chain reduction generated by a discrete vector field</fr:link> reduces an ACC <fr:tex>(C_k, d)</fr:tex> to a smaller one, which can be explicitly described. Its cells are the critical cells in <fr:tex>C_k</fr:tex>. For the faces of a cell <fr:tex>\sigma</fr:tex>, we start with the faces <fr:tex>d(\sigma)</fr:tex> in the original ACC. Then we move every non-critical cell down along the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">discrete field lines</fr:link>, up to some sign flips, until we get to a critical cell.
</fr:p><fr:p>
  Note that the field lines alternate between <fr:tex>n</fr:tex>- and <fr:tex>(n+1)</fr:tex>-dimensional cells, and we count the movement <fr:tex>n</fr:tex> – <fr:tex>(n+1)</fr:tex> – <fr:tex>n</fr:tex> as a single step. Also, <fr:link
href="hmlg-001S.xml"
type="local"
addr="hmlg-001S">discrete field lines can branch and merge</fr:link>, and the cells need to duplicate and move down every branch.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3123</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001Y</fr:addr><fr:route>hmlg-001Y.xml</fr:route><fr:title>Sphere</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:strong>sphere</fr:strong> <fr:tex>\mathbb{S}^n</fr:tex> can be constructed as an <fr:link
href="hmlg-001T.xml"
type="local"
addr="hmlg-001T">effective simplicial set</fr:link> with exactly two geometric simplices: a zero-dimensional point, and an <fr:tex>n</fr:tex>-dimensional surface. All the faces of the surface are degenerate and comes from the point.
</fr:p><fr:p>
  The <fr:link
href="hmlg-001U.xml"
type="local"
addr="hmlg-001U">associated reduced ACC</fr:link> is <fr:tex>\mathbb{Z}</fr:tex> at degree <fr:tex>0</fr:tex> and <fr:tex>n</fr:tex> and zero elsewhere. The map <fr:tex>d</fr:tex> is constant zero.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3125</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001W</fr:addr><fr:route>hmlg-001W.xml</fr:route><fr:title>Bar construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given any group <fr:tex>G</fr:tex>, we can construct a model of the first Eilenberg–MacLane space <fr:tex>K(G, 1)</fr:tex> as a simplicial set <fr:tex>{\bar{W}}(G)</fr:tex>. Consider the contractible simplicial set <fr:tex>{W}(G)</fr:tex> whose set of <fr:tex>n</fr:tex>-simplices is given by <fr:tex>G^{n+1}</fr:tex>. This has a natural free <fr:tex>G</fr:tex>-action given by multiplying every entry on the left. <fr:tex>{\bar{W}}(G)</fr:tex> is constructed by the quotient of the <fr:tex>G</fr:tex>-action.
</fr:p><fr:p>
  More concretely, the <fr:tex>n</fr:tex>-simplices are given by <fr:tex>n</fr:tex>-tuples, representing the quotient of consecutive elements in the <fr:tex>(n+1)</fr:tex>-tuple in the unquotiented simplicial set above. This is traditionally written as a bracketed sequence of elements separated by <fr:em>bars</fr:em>, <fr:tex>[g_1 \mid g_2 \mid \dots \mid g_n]</fr:tex>, hence we name it the <fr:strong>bar construction</fr:strong>. Face maps are given by removing the corresponding bars so the elements multiply together. Degeneracy maps are given by inserting the identity elements.
</fr:p><fr:p>
  If the group has decidable equality and multiplication, then the simplicial set is also <fr:link
href="hmlg-001T.xml"
type="local"
addr="hmlg-001T">effective</fr:link>. If further more the group is computably finite, then it is of finite type.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3127</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001X</fr:addr><fr:route>hmlg-001X.xml</fr:route><fr:title>Reduction from <fr:tex>K(\mathbb{Z}, 1)</fr:tex> to the circle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  There is a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> from the <fr:link
href="hmlg-001W.xml"
type="local"
addr="hmlg-001W">bar construction</fr:link> <fr:tex>{\bar{W}}(G)</fr:tex> of a group regarded as its <fr:link
href="hmlg-001U.xml"
type="local"
addr="hmlg-001U">reduced algebraic cellular complex</fr:link>, to the <fr:link
href="hmlg-001Y.xml"
type="local"
addr="hmlg-001Y">circle</fr:link> <fr:tex>\mathbb{S}^1</fr:tex>.
</fr:p><fr:p>
  By construction, the geometric simplices of <fr:tex>K(\mathbb{Z}, 1)</fr:tex> are lists <fr:tex>[a_1 \mid a_2 \mid \cdots \mid a_n]</fr:tex> of non-zero integers. We construct an <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissible discrete vector field</fr:link> and use <fr:link
href="hmlg-001R.xml"
type="local"
addr="hmlg-001R">the reduction it generates</fr:link>. We assign a cell <fr:tex>[a_1 \mid \cdots]</fr:tex> as a source if <fr:tex>a_1 \ne 1</fr:tex>. If <fr:tex>a_1 \le 0</fr:tex>, then we assign its target cell to be <fr:tex>[1 \mid a_1 \mid \cdots]</fr:tex>; otherwise we assign <fr:tex>[1 \mid a_1 - 1 \mid \cdots]</fr:tex>. Hence, the critical cells are <fr:tex>[]</fr:tex> and <fr:tex>[1]</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3129</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001U</fr:addr><fr:route>hmlg-001U.xml</fr:route><fr:title>Algebraic cellular complexes associated with a simplicial set</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-001T.xml"
type="local"
addr="hmlg-001T">(effective) simplicial set</fr:link> <fr:tex>X</fr:tex>, there are two major <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complexes</fr:link> (or <fr:link
href="hmlg-0002.xml"
type="local"
addr="hmlg-0002">chain complexes</fr:link>) we can associate to it. We can consider the free abelian group generated by <fr:tex>{\Gamma}(\Delta^n, X)</fr:tex> at degree <fr:tex>n</fr:tex>, where the boundary map is given by an alternating sum of face maps: <fr:tex
display="block">d_n = \sum_{i=0}^n (-1)^{i} \partial_i.</fr:tex> This satisfies <fr:tex>d^2 = 0</fr:tex> by the simplicial identities. ALternatively, we can consider only the geometric simplices, regarding degenerate ones are zero. More formally, we quotient out the previous chain complex by the subgroups generated by degenerate simplicies. They are both obviously <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective</fr:link> by construction.
</fr:p><fr:p>
  The first chain complex is called the <fr:strong>non-reduced</fr:strong> complex, while the second one is the <fr:strong>reduced</fr:strong> complex. By <fr:ref
addr="hmlg-001V"
href="hmlg-001V.xml"
taxon="Construction"></fr:ref> the two chain complexes are related by a chain reduction. So we will write <fr:tex>C_* X</fr:tex> for the reduced complex, leaving no notation for the non-reduced one unless otherwise stated.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3131</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001T</fr:addr><fr:route>hmlg-001T.xml</fr:route><fr:title>Effective simplicial set</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>effective</fr:strong> simplicial set consists of a sequence of types <fr:tex>\operatorname{Geom}_n(X)</fr:tex> with decidable equality, representing the <fr:strong>geometric</fr:strong>, a.k.a. non-degenerate, simplices. The full set of simplices, written <fr:tex>{\Gamma}(\Delta^n, X)</fr:tex> or more simply <fr:tex>X_n</fr:tex>, is given by a geometric simplex <fr:tex>g \in \operatorname{Geom}_k(X)</fr:tex> for some <fr:tex>k</fr:tex> together with a <fr:strong>degeneracy symbol</fr:strong>, defined as a surjection <fr:tex>\eta : [n+1] \twoheadrightarrow [k+1]</fr:tex>, formally representing the degeneracy map that brought <fr:tex>g</fr:tex> up to dimension <fr:tex>n</fr:tex>, written as <fr:tex>\eta^* g</fr:tex>. The effective simplicial set is also required to have computable <fr:strong>face maps</fr:strong> <fr:tex>\partial_i : \operatorname{Geom}_{n+1}(X) \to {\Gamma}(\Delta^n, X)</fr:tex> for <fr:tex>0 \le i \le n+1</fr:tex>, so that the usual simplicial identities hold. The simplicial set is <fr:strong>of finite type</fr:strong> if each <fr:tex>\operatorname{Geom}_n(X)</fr:tex> is computably finite.
</fr:p><fr:p>
  Alternatively, we can make a definition that more closely follows the traditional one, requiring a sequence of types with decidable equality representing <fr:em>all</fr:em> simplices instead of geometric ones. We then need to impose an additional requirement that the degeneracy of a simplex is decidable. The equivalence of the two definitions is given by the Eilenberg–Zilber lemma.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3133</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001V</fr:addr><fr:route>hmlg-001V.xml</fr:route><fr:title>Reduction from the non-reduced chain complex to the reduced chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We construct a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> from the non-reduced chain complex to the reduced chain complex in <fr:ref
addr="hmlg-001U"
href="hmlg-001U.xml"
taxon="Definition"></fr:ref>, by constructing a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link> and using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction"></fr:ref>.
</fr:p><fr:p>
  We consider placing vectors on degenerate simplicies, so that all degenerate simplices are sources or targets. For each non-trivial degeneracy symbol, if the first degeneration has even multiplicity, we assign it to be a source, with the corresponding target to have one more multiplicity at the place, and vice versa. For example, the degeneracy symbol <fr:tex>[6] \twoheadrightarrow [4]</fr:tex> given by the table of values <fr:tex>(0, 1, 1, 2, 3, 3, 4)</fr:tex> is a source, whose target is <fr:tex>(0, 1, 1, 1, 2, 3, 3, 4) : [7] \twoheadrightarrow [4]</fr:tex>.
</fr:p><fr:p>
  To verify this indeed gives a discrete vector field, we need to show that the source is a regular face of the target. This is true since an odd consective sum of <fr:tex>(-1)^{i}</fr:tex> gives <fr:tex>\pm 1</fr:tex>. Furthermore, we need to show the admissibility of the vector field. I claim that length of the field lines originating from one cell is bounded by two times the geometric dimension (i.e. the dimension of the associated geometric simplex). On one hand, the geometric dimensions of the target and the source are the same. On the other hand, moving from the target to the next source cell requires us to pick a regular face that does not point back to the target. This is equivalent to picking a place in the degeneracy symbol with no multiplicity. Hence the geometric dimension will decrease by one.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3135</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000M</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    This is indeed a Boolean algebra since measure-zero sets form a Boolean ideal of the Lebesgue <fr:tex>\sigma</fr:tex>-algebra. So we just need to show the existence of arbitrary joins. Given a family <fr:tex>X_\alpha</fr:tex> of measurable sets, we inductively construct a countable union. On each step, consider the area of each set outside of the current union. Select a set such that this excess area is within <fr:tex>\frac12</fr:tex> of the supremum. Since <fr:tex>\mu([0,1]) = 1</fr:tex>, such a process must lead to an excess area converging to zero.
  </fr:p>

  <fr:p>
    By construction, every set <fr:tex>X_\alpha</fr:tex> has zero area outside of this countable union, so they are under the union in the Boolean algebra. And the countable union <fr:tex>\bigcup_{k=1}^\infty X_{\alpha_k}</fr:tex> is the join of <fr:tex>X_{\alpha_k}</fr:tex> in the algebra, since a countable union of neglegible set is still neglegible. Hence by chasing elements, it must be the join of the entire family <fr:tex>X_\alpha</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3137</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000L</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Consider the set of <fr:em>atoms</fr:em> <fr:tex>A</fr:tex>, defined as minimal non-bottom elements. It suffices to prove the algebra is <fr:em>atomic</fr:em>, i.e. every non-bottom element has an atom below it. This is because we can remove all the atoms that an element contains, and the result must be <fr:tex>\bot</fr:tex>. So every element is given by a join of atoms. Such a join must be unique, since the intersection of different atoms is empty, so given two ways to write an element as a join of atoms, we take the intersection and see that they must agree. This shows that the elements are in bijection with <fr:tex>{\mathcal{P}}(A)</fr:tex>, with joins, meets and complements given by unions, intersections and complements, respectively.
  </fr:p>

  <fr:p>
    To show atomicity, consider <fr:tex
display="block">\top = \bigwedge_{b \in B} (b \lor \neg b) = \bigvee_{S \subseteq B} \left[ \bigwedge_{b \in S} b \wedge \bigwedge_{b \notin S} \neg b \right].</fr:tex> Consider the disjunctive clauses in here not equal to <fr:tex>\bot</fr:tex> (which must exist unless <fr:tex>\top = \bot</fr:tex> which trivially satisfies the requirements). They must be atoms because any element <fr:tex>x</fr:tex> strictly below them must be below all the conjunctive items, so either <fr:tex>x &lt; x</fr:tex> or <fr:tex>x &lt; \neg x</fr:tex>. The former is absurd and the latter implies <fr:tex>x = \bot</fr:tex>.
  </fr:p>

  <fr:p>
    Taking the meet of the equation with an arbitrary element <fr:tex>x</fr:tex> gives <fr:tex
display="block">x = \bigvee_{S \subseteq B} \left[x \wedge \bigwedge_{b \in S} b \wedge \bigwedge_{b \notin S} \neg b \right].</fr:tex> If there are no atoms <fr:tex>a \le x</fr:tex>, then all the clauses must be <fr:tex>\bot</fr:tex> meaning <fr:tex>x = \bot</fr:tex>. This finishes the proof.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3139</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By definition, we just need to prove the functor <fr:tex>{\mathcal{C}}^M \to {\mathcal{C}}</fr:tex> creates these limits and colimits. Given a diagram <fr:tex>(M X_i \xrightarrow{\alpha_i} X_i)</fr:tex> in <fr:tex>{\mathcal{C}}^M</fr:tex>, we can simply define an <fr:tex>M</fr:tex>-algebra structure on <fr:tex>\lim X_i</fr:tex> by assigning <fr:tex>M(\lim X_i) \to \lim X_i</fr:tex> the obvious map. This is the limit of the original diagram by a simple diagram chase, hence it is lifted. The cones over the diagram are determined by their image under the forgetful functor, so the lift is unique, which means the limit is trivially reflected.
  </fr:p>

  <fr:p>
    For colimits, if <fr:tex>M</fr:tex> preserves a colimit, then we can similarly define an algebra structure as <fr:tex>M(\operatorname*{colim} X_i) \cong \operatorname*{colim} M X_i \to \operatorname*{colim} X_i</fr:tex>. The lift is also unique, which means it is reflected.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3141</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For necessity, using <fr:ref
addr="ualg-000I"
href="ualg-000I.xml"
taxon="Theorem"></fr:ref>, we only need to verify that a monad <fr:tex>M</fr:tex> preserves the relevant coequalizers, which is true since <fr:link
href="ualg-000D.xml"
type="local"
addr="ualg-000D">they are absolute</fr:link>.
  </fr:p>

  <fr:p>
    For sufficiency, we observe the proof of <fr:ref
addr="ualg-000E"
href="ualg-000E.xml"
taxon="Theorem"></fr:ref>. Notice that the coequalizers involved are of the form <fr:tex>F\alpha, \epsilon : FGFA \rightrightarrows FA</fr:tex>. The images of these under <fr:tex>G</fr:tex> are indeed split by <fr:tex>\eta : GFA \to GFGFA</fr:tex> and <fr:tex>\eta : A \to GFA</fr:tex>. Therefore we just have to show <fr:tex>G</fr:tex> reflects isomorphisms. Given an isomorphism <fr:tex>Gf : GA \cong GB</fr:tex>, we have a split coequalizer <fr:tex>GA \rightrightarrows GB \to GA</fr:tex> where the two maps on the left are <fr:tex>Gf</fr:tex>, and the map on the right is its inverse. This creates a map <fr:tex>g : B \to A</fr:tex> which is the coequalizer of <fr:tex>f</fr:tex> with itself. So this map must be an isomorphism. We then consider the coequalizer <fr:tex>GB \rightrightarrows GA \to GB</fr:tex>, where the two maps on the left are <fr:tex>Gg</fr:tex> and the map on the right is <fr:tex>Gf</fr:tex>. Since <fr:tex>G</fr:tex> reflects this limit, <fr:tex>f</fr:tex> must also be an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3143</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-000H</fr:addr><fr:route>ualg-000H.xml</fr:route><fr:title>Beck monadicity theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>G : {\mathcal{D}} \to {\mathcal{C}}</fr:tex> be a functor with a left adjoint <fr:tex>F</fr:tex>. <fr:tex>G</fr:tex> is <fr:link
href="ualg-000A.xml"
type="local"
addr="ualg-000A">monadic</fr:link> iff <fr:tex>G</fr:tex> <fr:link
href="ualg-000G.xml"
type="local"
addr="ualg-000G">creates</fr:link> coequalizers whose image under <fr:tex>G</fr:tex> is <fr:link
href="ualg-000B.xml"
type="local"
addr="ualg-000B">split</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>765</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For necessity, using <fr:ref
addr="ualg-000I"
href="ualg-000I.xml"
taxon="Theorem"></fr:ref>, we only need to verify that a monad <fr:tex>M</fr:tex> preserves the relevant coequalizers, which is true since <fr:link
href="ualg-000D.xml"
type="local"
addr="ualg-000D">they are absolute</fr:link>.
  </fr:p>

  <fr:p>
    For sufficiency, we observe the proof of <fr:ref
addr="ualg-000E"
href="ualg-000E.xml"
taxon="Theorem"></fr:ref>. Notice that the coequalizers involved are of the form <fr:tex>F\alpha, \epsilon : FGFA \rightrightarrows FA</fr:tex>. The images of these under <fr:tex>G</fr:tex> are indeed split by <fr:tex>\eta : GFA \to GFGFA</fr:tex> and <fr:tex>\eta : A \to GFA</fr:tex>. Therefore we just have to show <fr:tex>G</fr:tex> reflects isomorphisms. Given an isomorphism <fr:tex>Gf : GA \cong GB</fr:tex>, we have a split coequalizer <fr:tex>GA \rightrightarrows GB \to GA</fr:tex> where the two maps on the left are <fr:tex>Gf</fr:tex>, and the map on the right is its inverse. This creates a map <fr:tex>g : B \to A</fr:tex> which is the coequalizer of <fr:tex>f</fr:tex> with itself. So this map must be an isomorphism. We then consider the coequalizer <fr:tex>GB \rightrightarrows GA \to GB</fr:tex>, where the two maps on the left are <fr:tex>Gg</fr:tex> and the map on the right is <fr:tex>Gf</fr:tex>. Since <fr:tex>G</fr:tex> reflects this limit, <fr:tex>f</fr:tex> must also be an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3145</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>ualg-000M</fr:addr><fr:route>ualg-000M.xml</fr:route><fr:title>Complete Boolean algebra not isomorphic to a powerset</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Consider the Lebesgue measurable sets on the interval <fr:tex>[0,1]</fr:tex> quotiented by measure-zero sets. This is a complete Boolean algebra, but it is not a powerset, showing the necessity of complete distributivity in <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>734</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000M</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    This is indeed a Boolean algebra since measure-zero sets form a Boolean ideal of the Lebesgue <fr:tex>\sigma</fr:tex>-algebra. So we just need to show the existence of arbitrary joins. Given a family <fr:tex>X_\alpha</fr:tex> of measurable sets, we inductively construct a countable union. On each step, consider the area of each set outside of the current union. Select a set such that this excess area is within <fr:tex>\frac12</fr:tex> of the supremum. Since <fr:tex>\mu([0,1]) = 1</fr:tex>, such a process must lead to an excess area converging to zero.
  </fr:p>

  <fr:p>
    By construction, every set <fr:tex>X_\alpha</fr:tex> has zero area outside of this countable union, so they are under the union in the Boolean algebra. And the countable union <fr:tex>\bigcup_{k=1}^\infty X_{\alpha_k}</fr:tex> is the join of <fr:tex>X_{\alpha_k}</fr:tex> in the algebra, since a countable union of neglegible set is still neglegible. Hence by chasing elements, it must be the join of the entire family <fr:tex>X_\alpha</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3147</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000J</fr:addr><fr:route>ualg-000J.xml</fr:route><fr:title>Completely distributive complete Boolean algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>completely distributive complete Boolean algebra</fr:strong> is a Boolean algebra with arbitrary join and meet that distribute over each other.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3149</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-000L</fr:addr><fr:route>ualg-000L.xml</fr:route><fr:title>Completely distributive complete Boolean algebras are powersets</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Every <fr:link
href="ualg-000J.xml"
type="local"
addr="ualg-000J">completely distributive complete Boolean algebra</fr:link> is isomorphic to the set algebra of a powerset, and homomorphisms are given by inverse image map. In other words, the category of CDCBA is isomorphic to <fr:tex>{\mathsf{Set}}^{{\textrm{op}}}</fr:tex> and the forgetful functor is given by the powerset <fr:tex>{\mathcal{P}}(X) = 2^X</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>740</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000L</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Consider the set of <fr:em>atoms</fr:em> <fr:tex>A</fr:tex>, defined as minimal non-bottom elements. It suffices to prove the algebra is <fr:em>atomic</fr:em>, i.e. every non-bottom element has an atom below it. This is because we can remove all the atoms that an element contains, and the result must be <fr:tex>\bot</fr:tex>. So every element is given by a join of atoms. Such a join must be unique, since the intersection of different atoms is empty, so given two ways to write an element as a join of atoms, we take the intersection and see that they must agree. This shows that the elements are in bijection with <fr:tex>{\mathcal{P}}(A)</fr:tex>, with joins, meets and complements given by unions, intersections and complements, respectively.
  </fr:p>

  <fr:p>
    To show atomicity, consider <fr:tex
display="block">\top = \bigwedge_{b \in B} (b \lor \neg b) = \bigvee_{S \subseteq B} \left[ \bigwedge_{b \in S} b \wedge \bigwedge_{b \notin S} \neg b \right].</fr:tex> Consider the disjunctive clauses in here not equal to <fr:tex>\bot</fr:tex> (which must exist unless <fr:tex>\top = \bot</fr:tex> which trivially satisfies the requirements). They must be atoms because any element <fr:tex>x</fr:tex> strictly below them must be below all the conjunctive items, so either <fr:tex>x &lt; x</fr:tex> or <fr:tex>x &lt; \neg x</fr:tex>. The former is absurd and the latter implies <fr:tex>x = \bot</fr:tex>.
  </fr:p>

  <fr:p>
    Taking the meet of the equation with an arbitrary element <fr:tex>x</fr:tex> gives <fr:tex
display="block">x = \bigvee_{S \subseteq B} \left[x \wedge \bigwedge_{b \in S} b \wedge \bigwedge_{b \notin S} \neg b \right].</fr:tex> If there are no atoms <fr:tex>a \le x</fr:tex>, then all the clauses must be <fr:tex>\bot</fr:tex> meaning <fr:tex>x = \bot</fr:tex>. This finishes the proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3151</fr:anchor><fr:addr>ualg-000K</fr:addr><fr:route>ualg-000K.xml</fr:route><fr:title>Free completely distributive complete Boolean algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An element of a free <fr:link
href="ualg-000J.xml"
type="local"
addr="ualg-000J">CDCBA</fr:link> over the set <fr:tex>X</fr:tex> is an expression made out of joins, meets and negation, with literals from <fr:tex>X</fr:tex>. We can push the negation in and use distributivity to put the expression into <fr:link
href="https://en.wikipedia.org/wiki/Disjunctive_normal_form"
type="external">disjunctive normal form</fr:link>. The clauses can be represented by functions <fr:tex>X \to \{\top, \bot, ?\}</fr:tex> representing a literal appearing positively, negatively or not appearing in the conjunction.
</fr:p><fr:p>
  If a literal <fr:tex>b</fr:tex> does not appear in a clause, we can take its conjunction with <fr:tex>\top = b \lor \neg b</fr:tex> and expand using distributivity. This ensures every literal appears either positively or negatively, so the expressions are now represented by a double powerset of <fr:tex>X</fr:tex>, where the inner powerset records which literals appear positively in a clause, and the outer powerset represents the set of clauses.
</fr:p><fr:p>
  In fact, such a representation is unique. We just need to show that the double powerset forms a CDCBA. Disjunction is simply a union. Negation is given by the complement. Conjunction is given by an intersection. We can verify that the required identities all hold. Hence the monad for CDCBAs is the double powerset monad, corresponding to the adjunction <fr:tex>{\mathcal{P}}^{{\textrm{op}}} \dashv {\mathcal{P}}</fr:tex> via <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem"></fr:ref>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3153</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-000I</fr:addr><fr:route>ualg-000I.xml</fr:route><fr:title>Limits and colimits created by a monadic functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="ualg-000A.xml"
type="local"
addr="ualg-000A">monadic functor</fr:link> <fr:link
href="ualg-000G.xml"
type="local"
addr="ualg-000G">creates</fr:link> all limits. It also creates all colimits preserved by the monad.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By definition, we just need to prove the functor <fr:tex>{\mathcal{C}}^M \to {\mathcal{C}}</fr:tex> creates these limits and colimits. Given a diagram <fr:tex>(M X_i \xrightarrow{\alpha_i} X_i)</fr:tex> in <fr:tex>{\mathcal{C}}^M</fr:tex>, we can simply define an <fr:tex>M</fr:tex>-algebra structure on <fr:tex>\lim X_i</fr:tex> by assigning <fr:tex>M(\lim X_i) \to \lim X_i</fr:tex> the obvious map. This is the limit of the original diagram by a simple diagram chase, hence it is lifted. The cones over the diagram are determined by their image under the forgetful functor, so the lift is unique, which means the limit is trivially reflected.
  </fr:p>

  <fr:p>
    For colimits, if <fr:tex>M</fr:tex> preserves a colimit, then we can similarly define an algebra structure as <fr:tex>M(\operatorname*{colim} X_i) \cong \operatorname*{colim} M X_i \to \operatorname*{colim} X_i</fr:tex>. The lift is also unique, which means it is reflected.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3155</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000G</fr:addr><fr:route>ualg-000G.xml</fr:route><fr:title>Preservation, lifting, reflection and creation of limits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Consider a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex>.
</fr:p><fr:ul><fr:li>If a limit cone <fr:tex>L</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex> is mapped to a limit cone in <fr:tex>{\mathcal{D}}</fr:tex>, then the functor <fr:strong>preserves</fr:strong> the limit <fr:tex>I</fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex>D</fr:tex> and a limit cone <fr:tex>L</fr:tex> over <fr:tex>F \mathbin{\circ} D</fr:tex> in <fr:tex>{\mathcal{D}}</fr:tex>, <fr:tex>D</fr:tex> can be extended to a limit cone in <fr:tex>{\mathcal{C}}</fr:tex> that maps to <fr:tex>L</fr:tex>, then the functor <fr:strong>lifts</fr:strong> the limit <fr:tex>L</fr:tex> to <fr:tex>D</fr:tex>.</fr:li>
  <fr:li>If all the cones that maps to a limit cone <fr:tex>L</fr:tex> in <fr:tex>{\mathcal{D}}</fr:tex> are limit cones in <fr:tex>{\mathcal{C}}</fr:tex>, then the functor <fr:strong>reflects</fr:strong> the limit <fr:tex>L</fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex>D</fr:tex> and a limit cone <fr:tex>L</fr:tex> over <fr:tex>F \mathbin{\circ} D</fr:tex> in <fr:tex>{\mathcal{D}}</fr:tex>, <fr:tex>L</fr:tex> is reflected and lifted to <fr:tex>D</fr:tex>, then the limit of <fr:tex>D</fr:tex> is <fr:strong>created</fr:strong>.</fr:li></fr:ul><fr:p>
  This can be easily generalized to cover a type of limits or all limits, and can be dualized to colimits. The definitions here are not agreed upon, and the literature may have slight variations. We consider univalent categories here, so that definitions are automatically adjusted to be equivalence-invariant.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3157</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000F</fr:addr><fr:route>ualg-000F.xml</fr:route><fr:title>Reflexive pair</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>reflexive pair</fr:strong> is the categorical translation of a reflexive relation. It is defined as a pair of arrows <fr:tex>\partial_0, \partial_1 : X \rightrightarrows Y</fr:tex> with a common section <fr:tex>r : Y \to X</fr:tex>, i.e. an arrow <fr:tex>r</fr:tex> such that <fr:tex>\partial_0 \mathbin{\circ} r = \partial_1 \mathbin{\circ} r = {\textrm{id}}_Y</fr:tex>. A coequalizer of a reflexive pair is called a <fr:strong>reflexive coequalizer</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3159</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the first claim, we need a functor <fr:tex>L</fr:tex> such that arrows from <fr:tex>L(GFA \xrightarrow{\alpha} A)</fr:tex> to <fr:tex>X</fr:tex> is in bijection with commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="9eb5469b70f102398bdd48686db3d6df"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      GFA &amp; GFGX \\
      A &amp; GX
      \arrow[from=1-1, to=1-2]
      \arrow["{\alpha}"', from=1-1, to=2-1]
      \arrow["{G \epsilon}", from=1-2, to=2-2]
      \arrow[from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    which are equivalent by <fr:tex>F \dashv G</fr:tex> to the commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="d9768dd526dc1f39f94e11e92cc0b472"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      FGFA &amp; FGX \\
      FA &amp; X
      \arrow["FG\varphi", from=1-1, to=1-2]
      \arrow["F\alpha"', from=1-1, to=2-1]
      \arrow["\epsilon", from=1-2, to=2-2]
      \arrow["\varphi", from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Further notice that <fr:tex>\epsilon \mathbin{\circ} FG\varphi = \varphi \mathbin{\circ} \epsilon</fr:tex> by naturality. So it becomes obvious that <fr:tex>L</fr:tex> should be defined as the coequalizer of the pair <fr:tex
display="block">F \alpha, \epsilon : FGFA \rightrightarrows FA.</fr:tex> This is reflexive by the common section <fr:tex>F\eta</fr:tex>.
  </fr:p>

  <fr:p>
    For the second point, we unfold the unit as a natural family of commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="c8a74b7fc8b0b5ad080a4f875a59fa3f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      GFA &amp; {GFG\operatorname*{colim}(FGFA \rightrightarrows FA)} \\
      A &amp; {G\operatorname*{colim}(FGFA \rightrightarrows FA)}
      \arrow[from=1-1, to=1-2]
      \arrow[from=1-1, to=2-1]
      \arrow[from=1-2, to=2-2]
      \arrow[from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    and when <fr:tex>G</fr:tex> preserves the coequalizers in the diagram, the problem is reduced to showing that the coequalizer of <fr:tex>GF\alpha</fr:tex> and <fr:tex>G\epsilon : GFGFA \rightrightarrows GFA</fr:tex> is isomorphic to <fr:tex>A</fr:tex> via the bottom map, which is just the unit <fr:tex>\eta : A \to GFA</fr:tex> composed with the coequalizing map. This is a routine diagram chase.
  </fr:p>

  <fr:p>
    For the final point, we would like the coequalizer of <fr:tex>FG\epsilon, \epsilon : FGFGX \rightrightarrows FGX</fr:tex> to be isomorphic to <fr:tex>X</fr:tex>. If we apply <fr:tex>G</fr:tex> to the diagram, we get an isomorphism to <fr:tex>GX</fr:tex> by the previous point. So if <fr:tex>G</fr:tex> reflects isomorphisms, we’re done.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3161</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-000E</fr:addr><fr:route>ualg-000E.xml</fr:route><fr:title>Crude monadicity theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>G : {\mathcal{D}} \to {\mathcal{C}}</fr:tex> be a functor with a left adjoint <fr:tex>F</fr:tex>. <fr:tex>M = G \mathbin{\circ} F</fr:tex> is the corresponding monad on <fr:tex>{\mathcal{C}}</fr:tex>. This gives a <fr:link
href="ualg-0009.xml"
type="local"
addr="ualg-0009">comparison functor</fr:link> <fr:tex>K : {\mathcal{A}} \to {\mathcal{C}}^M</fr:tex>.
</fr:p><fr:ol><fr:li>If <fr:tex>{\mathcal{D}}</fr:tex> has all coequalizers (we can weaken this to <fr:link
href="ualg-000F.xml"
type="local"
addr="ualg-000F">reflexive coequalizers</fr:link>), then <fr:tex>K</fr:tex> has a left adjoint.</fr:li>
  <fr:li>If moreover <fr:tex>G</fr:tex> preserves these reflexive coequalizers, the unit <fr:tex>{\textrm{Id}} \to K \mathbin{\circ} L</fr:tex> is an isomorphism.</fr:li>
  <fr:li>Finally, if <fr:tex>G</fr:tex> reflects isomorphisms, then the counit <fr:tex>L \mathbin{\circ} K \to {\textrm{Id}}</fr:tex> is also an isomorphism, making <fr:tex>G</fr:tex> <fr:link
href="ualg-000A.xml"
type="local"
addr="ualg-000A">monadic</fr:link>.</fr:li></fr:ol>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>757</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the first claim, we need a functor <fr:tex>L</fr:tex> such that arrows from <fr:tex>L(GFA \xrightarrow{\alpha} A)</fr:tex> to <fr:tex>X</fr:tex> is in bijection with commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="9eb5469b70f102398bdd48686db3d6df"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      GFA &amp; GFGX \\
      A &amp; GX
      \arrow[from=1-1, to=1-2]
      \arrow["{\alpha}"', from=1-1, to=2-1]
      \arrow["{G \epsilon}", from=1-2, to=2-2]
      \arrow[from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    which are equivalent by <fr:tex>F \dashv G</fr:tex> to the commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="d9768dd526dc1f39f94e11e92cc0b472"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      FGFA &amp; FGX \\
      FA &amp; X
      \arrow["FG\varphi", from=1-1, to=1-2]
      \arrow["F\alpha"', from=1-1, to=2-1]
      \arrow["\epsilon", from=1-2, to=2-2]
      \arrow["\varphi", from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Further notice that <fr:tex>\epsilon \mathbin{\circ} FG\varphi = \varphi \mathbin{\circ} \epsilon</fr:tex> by naturality. So it becomes obvious that <fr:tex>L</fr:tex> should be defined as the coequalizer of the pair <fr:tex
display="block">F \alpha, \epsilon : FGFA \rightrightarrows FA.</fr:tex> This is reflexive by the common section <fr:tex>F\eta</fr:tex>.
  </fr:p>

  <fr:p>
    For the second point, we unfold the unit as a natural family of commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="c8a74b7fc8b0b5ad080a4f875a59fa3f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      GFA &amp; {GFG\operatorname*{colim}(FGFA \rightrightarrows FA)} \\
      A &amp; {G\operatorname*{colim}(FGFA \rightrightarrows FA)}
      \arrow[from=1-1, to=1-2]
      \arrow[from=1-1, to=2-1]
      \arrow[from=1-2, to=2-2]
      \arrow[from=2-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    and when <fr:tex>G</fr:tex> preserves the coequalizers in the diagram, the problem is reduced to showing that the coequalizer of <fr:tex>GF\alpha</fr:tex> and <fr:tex>G\epsilon : GFGFA \rightrightarrows GFA</fr:tex> is isomorphic to <fr:tex>A</fr:tex> via the bottom map, which is just the unit <fr:tex>\eta : A \to GFA</fr:tex> composed with the coequalizing map. This is a routine diagram chase.
  </fr:p>

  <fr:p>
    For the final point, we would like the coequalizer of <fr:tex>FG\epsilon, \epsilon : FGFGX \rightrightarrows FGX</fr:tex> to be isomorphic to <fr:tex>X</fr:tex>. If we apply <fr:tex>G</fr:tex> to the diagram, we get an isomorphism to <fr:tex>GX</fr:tex> by the previous point. So if <fr:tex>G</fr:tex> reflects isomorphisms, we’re done.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3163</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the definition of an <fr:link
href="ualg-000C.xml"
type="local"
addr="ualg-000C">absolute (co)limit</fr:link>, the coequalizer is preserved by every functor. Consider the functor <fr:tex>\hom(Z, -)</fr:tex>. We have <fr:tex>\hom(Z, e)</fr:tex> is a coequalizer map, and hence epimorphic. This means <fr:tex>e</fr:tex> itself is split epimorphic since <fr:tex>{\textrm{id}}_Z</fr:tex> is in the image, i.e. there is a morphism <fr:tex>r : Z \to Y</fr:tex> with <fr:tex>e \mathbin{\circ} r = {\textrm{id}}_Z</fr:tex>.
  </fr:p>

  <fr:p>
    Next, we consider the functor <fr:tex>\hom(Y, -)</fr:tex>. Since this gives a coequalizer of sets, the quotient <fr:tex>\hom(Y, Y) \xrightarrow{e \mathbin{\circ} -} \hom(Y, Z)</fr:tex> is given by the equivalence relation generated by <fr:tex>\partial_0 \mathbin{\circ} f = \partial_1 \mathbin{\circ} f</fr:tex> for every <fr:tex>f : Y \to X</fr:tex>. There is a pair of elements mapped to the same element under <fr:tex>e \mathbin{\circ} -</fr:tex> in this situation: one of them is obviously <fr:tex>{\textrm{id}}_Y</fr:tex>, and the other is <fr:tex>r \mathbin{\circ} e</fr:tex>, since <fr:tex>e \mathbin{\circ} {\textrm{id}}_Y = e = e \mathbin{\circ} r \mathbin{\circ} e</fr:tex>. Hence we get the chain of morphisms related in the way stated in the theorem.
  </fr:p>

  <fr:p>
    Finally, we observe that these are enough to guarantee the given diagram is a coequalizer —— the diagram is a coequalizer simply by virtue of the shape of the diagram. Since any functor preserves the composition relation of morphisms, they must also give coequalizers, and therefore the coequalizer is absolute.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3165</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000C</fr:addr><fr:route>ualg-000C.xml</fr:route><fr:title>Absolute (co)limit</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>absolute (co)limit</fr:strong> is a (co)limit that is preserved by any functor whatsoever. 
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3167</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-000D</fr:addr><fr:route>ualg-000D.xml</fr:route><fr:title>Characterization of absolute coequalizers</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a coequalizer diagram <fr:tex>X \rightrightarrows Y \to Z</fr:tex> where <fr:tex>\partial_0, \partial_1 : X \to Y</fr:tex> are the two parallel arrows and the coequalizing arrow is <fr:tex>e : Y \to Z</fr:tex>, it is <fr:link
href="ualg-000C.xml"
type="local"
addr="ualg-000C">absolute</fr:link>, if and only if the following conditions hold.
</fr:p><fr:ul><fr:li><fr:tex>e</fr:tex> is split epimorphic, i.e. there is an arrow <fr:tex>r</fr:tex> such that <fr:tex>e \mathbin{\circ} r = {\textrm{id}}_Z</fr:tex>.</fr:li>
  <fr:li>There is a list of <fr:tex>n</fr:tex> endomorphisms on <fr:tex>Y</fr:tex> starting with <fr:tex>r \mathbin{\circ} e</fr:tex> and ending with <fr:tex>{\textrm{id}}_Y</fr:tex>, such that for each pair of adjacent morphisms, there is an arrow <fr:tex>s</fr:tex> such that <fr:tex>\partial_0 \mathbin{\circ} s</fr:tex> and <fr:tex>\partial_1 \mathbin{\circ} s</fr:tex> are equal to the two morphisms (in some order).</fr:li></fr:ul><fr:p>
  Note that for <fr:tex>n = 0</fr:tex> this is the trivial coequalizer where <fr:tex>\partial_0 = \partial_1</fr:tex> and <fr:tex>e</fr:tex> is an isomorphism. For <fr:tex>n = 1</fr:tex> this results in the <fr:link
href="ualg-000B.xml"
type="local"
addr="ualg-000B">split coequalizer</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>761</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the definition of an <fr:link
href="ualg-000C.xml"
type="local"
addr="ualg-000C">absolute (co)limit</fr:link>, the coequalizer is preserved by every functor. Consider the functor <fr:tex>\hom(Z, -)</fr:tex>. We have <fr:tex>\hom(Z, e)</fr:tex> is a coequalizer map, and hence epimorphic. This means <fr:tex>e</fr:tex> itself is split epimorphic since <fr:tex>{\textrm{id}}_Z</fr:tex> is in the image, i.e. there is a morphism <fr:tex>r : Z \to Y</fr:tex> with <fr:tex>e \mathbin{\circ} r = {\textrm{id}}_Z</fr:tex>.
  </fr:p>

  <fr:p>
    Next, we consider the functor <fr:tex>\hom(Y, -)</fr:tex>. Since this gives a coequalizer of sets, the quotient <fr:tex>\hom(Y, Y) \xrightarrow{e \mathbin{\circ} -} \hom(Y, Z)</fr:tex> is given by the equivalence relation generated by <fr:tex>\partial_0 \mathbin{\circ} f = \partial_1 \mathbin{\circ} f</fr:tex> for every <fr:tex>f : Y \to X</fr:tex>. There is a pair of elements mapped to the same element under <fr:tex>e \mathbin{\circ} -</fr:tex> in this situation: one of them is obviously <fr:tex>{\textrm{id}}_Y</fr:tex>, and the other is <fr:tex>r \mathbin{\circ} e</fr:tex>, since <fr:tex>e \mathbin{\circ} {\textrm{id}}_Y = e = e \mathbin{\circ} r \mathbin{\circ} e</fr:tex>. Hence we get the chain of morphisms related in the way stated in the theorem.
  </fr:p>

  <fr:p>
    Finally, we observe that these are enough to guarantee the given diagram is a coequalizer —— the diagram is a coequalizer simply by virtue of the shape of the diagram. Since any functor preserves the composition relation of morphisms, they must also give coequalizers, and therefore the coequalizer is absolute.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3169</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000B</fr:addr><fr:route>ualg-000B.xml</fr:route><fr:title>Split coequalizer</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We define a <fr:strong>split coequalizer</fr:strong> to be the following diagram:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="c97cb116ebd1e2d7d20fe5598e96bc5b"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
    X &amp; Y &amp; Z
    \arrow["{\partial_0}", shift left, curve={height=-6pt}, from=1-1, to=1-2]
    \arrow["{\partial_1}"', shift right, curve={height=6pt}, from=1-1, to=1-2]
    \arrow["s"{description}, from=1-2, to=1-1]
    \arrow["q", from=1-2, to=1-3]
    \arrow["r", curve={height=-6pt}, from=1-3, to=1-2]
  \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that <fr:tex>q \mathbin{\circ} r = {\textrm{id}}_Z</fr:tex>, <fr:tex>r \mathbin{\circ} q = \partial_0 \mathbin{\circ} s</fr:tex> and <fr:tex>\partial_1 \mathbin{\circ} s = {\textrm{id}}_Y</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3171</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given an adjunction <fr:tex>F \dashv G</fr:tex> with the corresponding monad <fr:tex>G \mathbin{\circ} F</fr:tex>, the comparison functor is defined as sending <fr:tex>X</fr:tex> to <fr:tex>GFGX \to GX</fr:tex>, given by the counit <fr:tex>FGX \to X</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3173</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title>Monadic functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functors <fr:tex>F \dashv G</fr:tex>, <fr:tex>G</fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
href="ualg-0009.xml"
type="local"
addr="ualg-0009">comparison functor</fr:link> to <fr:tex>{\mathcal{C}}^{G \mathbin{\circ} F}</fr:tex> is an equivalence in <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">the bicategory of decompositions</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3175</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title>The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>842</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given an adjunction <fr:tex>F \dashv G</fr:tex> with the corresponding monad <fr:tex>G \mathbin{\circ} F</fr:tex>, the comparison functor is defined as sending <fr:tex>X</fr:tex> to <fr:tex>GFGX \to GX</fr:tex>, given by the counit <fr:tex>FGX \to X</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3177</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title>The Kleisli category induces the initial decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3179</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0005</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Consider the functor from the Kleisli category to the category of free algebras, sending <fr:tex>X</fr:tex> to the free algebra on <fr:tex>X</fr:tex>. This is fully faithful and surjective on objects.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3181</fr:anchor><fr:addr>ualg-0007</fr:addr><fr:route>ualg-0007.xml</fr:route><fr:title>Decomposition of a monad into adjoint functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functor <fr:tex>F \dashv G</fr:tex>, <fr:tex>G \mathbin{\circ} F</fr:tex> forms a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link>. As a converse, we can consider the adjunctions whose composition is a given monad <fr:tex>M</fr:tex>. These decompositions form a bicategory. The morphisms between two adjunctions are given by functors <fr:tex>L</fr:tex> that make the two triangles below commute.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="f82cf08781527acb41524a4fd4b2fb10"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
    {{\mathcal{D}}_2} &amp; {{\mathcal{D}}_1} &amp; {{\mathcal{C}}}
    \arrow[shift right, from=1-2, to=1-3]
    \arrow[shift right, from=1-3, to=1-2]
    \arrow[shift right, curve={height=18pt}, from=1-1, to=1-3]
    \arrow[shift right, curve={height=18pt}, from=1-3, to=1-1]
    \arrow["L"{description}, from=1-2, to=1-1]
  \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  More precisely, the objects of this bicategory are given by adjunctions <fr:tex>F \dashv G</fr:tex> together with a natural isomorphism <fr:tex>G \mathbin{\circ} F \cong M</fr:tex>. A morphism from <fr:tex>F_1 \dashv G_1</fr:tex> to <fr:tex>F_2 \dashv G_2</fr:tex> is given by a functor <fr:tex>L</fr:tex> together with two natural isomorphisms <fr:tex>L \mathbin{\circ} G_1 \cong G_2</fr:tex>, <fr:tex>F_1 \cong F_2 \mathbin{\circ} L</fr:tex>. A <fr:tex>2</fr:tex>-morphism is given by a natural transformation such that the relevant composition of natural transformations are equal.
</fr:p><fr:p>
  This bicategory has initial and terminal objects.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>885</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title>The Kleisli category induces the initial decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>887</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title>The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>842</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given an adjunction <fr:tex>F \dashv G</fr:tex> with the corresponding monad <fr:tex>G \mathbin{\circ} F</fr:tex>, the comparison functor is defined as sending <fr:tex>X</fr:tex> to <fr:tex>GFGX \to GX</fr:tex>, given by the counit <fr:tex>FGX \to X</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>889</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title>Monadic functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functors <fr:tex>F \dashv G</fr:tex>, <fr:tex>G</fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
href="ualg-0009.xml"
type="local"
addr="ualg-0009">comparison functor</fr:link> to <fr:tex>{\mathcal{C}}^{G \mathbin{\circ} F}</fr:tex> is an equivalence in <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">the bicategory of decompositions</fr:link>.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3183</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>ualg-0006</fr:addr><fr:route>ualg-0006.xml</fr:route><fr:title>Objects of the Kleisli category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An object of <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">the Kleisli category of a monad</fr:link> can be considered as a <fr:link
href="ualg-0003.xml"
type="local"
addr="ualg-0003">free algebra</fr:link>, but <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">equipped with a canonical choice of generators</html:mark>. Hence although <fr:link
href="ualg-0005.xml"
type="local"
addr="ualg-0005">the Kleisli category is equivalent to the category of free algebras</fr:link>, the objects are essentially different. This manifests as the curious fact that the Kleisli category is not univalent, since an equality of Kleisli objects requires an isomorphism of the generators, but an isomorphism only requires the two free algebras to be isomorphic.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3185</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0005</fr:addr><fr:route>ualg-0005.xml</fr:route><fr:title>The Kleisli category is equivalent to the category of free algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given category <fr:tex>{\mathcal{C}}</fr:tex>, <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">the Kleisli category of a monad</fr:link> <fr:tex>M : {\mathcal{C}} \to {\mathcal{C}}</fr:tex> is equivalent to the full subcategory of the <fr:tex>M</fr:tex>-<fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebras</fr:link> spanned by the <fr:link
href="ualg-0003.xml"
type="local"
addr="ualg-0003">free algebras</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>918</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0005</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Consider the functor from the Kleisli category to the category of free algebras, sending <fr:tex>X</fr:tex> to the free algebra on <fr:tex>X</fr:tex>. This is fully faithful and surjective on objects.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3187</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0004</fr:addr><fr:route>ualg-0004.xml</fr:route><fr:title>The Kleisli category of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M : {\mathcal{C}} \to {\mathcal{C}}</fr:tex> and two objects <fr:tex>X, Y</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex>, a <fr:strong>Kleisli arrow</fr:strong> from <fr:tex>X</fr:tex> to <fr:tex>Y</fr:tex> is simply any arrow <fr:tex>X \to MY</fr:tex>. This represents an algebra homomorphism from the free algebra generated by <fr:tex>X</fr:tex> to that of <fr:tex>Y</fr:tex>.
</fr:p><fr:p>
  The identity Kleisli arrow is defined as <fr:tex>\eta : X \to MX</fr:tex>. The composition of <fr:tex>f : X \to MY</fr:tex> and <fr:tex>g : Y \to MZ</fr:tex> is given by <fr:tex
display="block">X \xrightarrow{f} MY \xrightarrow{Mg} M^2 Z \xrightarrow{\mu} MZ.</fr:tex> This forms a category whose objects are the objects of <fr:tex>{\mathcal{C}}</fr:tex>, as a formal symbol standing for the free algebra generated by those objects, and morphisms are Kleisli arrows. This is the <fr:strong>Kleisli category</fr:strong> <fr:tex>{\mathcal{C}}_M</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3189</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We verify that they form an adjunction. Algebra homomorphisms <fr:tex>\varphi : F_M X \to Y</fr:tex> are given by commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8a6373922bbdf02e099f1678dbddae08"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
      {M^2 X} &amp; MY \\
      MX &amp; Y
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    while morphisms <fr:tex>f : X \to Y</fr:tex> fits in the diagram as such: 
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="6c339c9c83c0224f37d79a66abdf1772"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
      {M^2 X} &amp; MY \\
      MX &amp; Y \\
      X
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]
      \arrow["f"', from=3-1, to=2-2]
      \arrow["\eta", from=3-1, to=2-1]
      \arrow[from=2-1, to=1-2]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Given a homomorphism <fr:tex>\varphi</fr:tex> of algebras, we can compute <fr:tex>f</fr:tex> by composing with <fr:tex>\eta</fr:tex>. On the other hand, given <fr:tex>f</fr:tex>, we define <fr:tex>\varphi</fr:tex> by <fr:tex>\alpha_Y \mathbin{\circ} Mf</fr:tex>. This creates a commutative square because
    <fr:tex
display="block">\begin{aligned}       \alpha_Y \mathbin{\circ} M \varphi       &amp;= \alpha_Y \mathbin{\circ} M\alpha_Y \mathbin{\circ} M^2 f \\       &amp;= \alpha_Y \mathbin{\circ} \mu \mathbin{\circ} M^2 f \\       &amp;= \alpha_Y \mathbin{\circ} M f \mathbin{\circ} \mu \\       &amp;= \varphi \mathbin{\circ} \mu.     \end{aligned}</fr:tex></fr:p>

  <fr:p>
    We just have to verify that the two conversions are mutual inverses. In one way, we need to verify <fr:tex>\alpha_Y \mathbin{\circ} M f \mathbin{\circ} \eta = f</fr:tex>. This is true because by the naturality of <fr:tex>\eta</fr:tex> we get <fr:tex>M f \mathbin{\circ} \eta = \eta \mathbin{\circ} f</fr:tex>. Then by the definition of <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebra</fr:link> <fr:tex>\alpha_Y \mathbin{\circ} \eta = {\textrm{id}}</fr:tex>, proving the equality. On the other hand, we need to show <fr:tex>\alpha_Y \mathbin{\circ} M(\varphi \mathbin{\circ} \eta) = \varphi</fr:tex>. This follows from the algebra identity <fr:tex>\alpha_Y \mathbin{\circ} M \alpha_Y = \alpha_Y \mathbin{\circ} \mu</fr:tex> and the monad identity <fr:tex>\mu \mathbin{\circ} M \eta = {\textrm{id}}</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3191</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0002</fr:addr><fr:route>ualg-0002.xml</fr:route><fr:title>Algebra of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M : {\mathcal{C}} \to {\mathcal{C}}</fr:tex>, an <fr:tex>M</fr:tex>-<fr:strong>algebra</fr:strong> is defined as an object <fr:tex>X</fr:tex> equipped with a morphism <fr:tex>\alpha : MX \to X</fr:tex>, such that the following two diagrams commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="f1a85fd45bde9ea416d003b2413fdb9b"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
  {M^2X} &amp; MX &amp; X &amp; MX \\
  MX &amp; X &amp;&amp; X
  \arrow["\alpha"', from=2-1, to=2-2]
  \arrow["\alpha", from=1-2, to=2-2]
  \arrow["\mu"', from=1-1, to=2-1]
  \arrow["M\alpha", from=1-1, to=1-2]
  \arrow["\operatorname{id}"', from=1-3, to=2-4]
  \arrow["\eta", from=1-3, to=1-4]
  \arrow["\alpha", from=1-4, to=2-4]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  In an unbiased formulation, we require the natural transformation <fr:tex>M^n \to M</fr:tex> of the monad evaluated at the object <fr:tex>X</fr:tex> composed with <fr:tex>\alpha : MX \to X</fr:tex> to be equal to <fr:tex
display="block">M^n X \xrightarrow{M^{n-1}\alpha} M^{n-1}X \to \cdots \xrightarrow{\alpha} X.</fr:tex></fr:p><fr:p>
  The algebras of a monad form a category <fr:tex>{\mathcal{C}}^M</fr:tex>, whose morphisms are commutative squares. This is also known as the <fr:strong>Eilenberg–Moore category</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3193</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>ualg-0003</fr:addr><fr:route>ualg-0003.xml</fr:route><fr:title>Free monad algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M</fr:tex> on a category <fr:tex>{\mathcal{C}}</fr:tex>, there is a canonical adjunction between the <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">category of algebras</fr:link> <fr:tex>{\mathcal{C}}^M</fr:tex> and <fr:tex>{\mathcal{C}}</fr:tex>. The <fr:strong>forgetful functor</fr:strong> <fr:tex>U_M</fr:tex> takes an <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebra</fr:link> and forgets the algebra structure. The <fr:strong>free functor</fr:strong> <fr:tex>F_M</fr:tex> takes an object <fr:tex>X</fr:tex> and produces an algebra on <fr:tex>MX</fr:tex> given by the monad multiplication map <fr:tex>\mu : M^2 X \to MX</fr:tex>, called the <fr:strong>free algebra</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>942</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We verify that they form an adjunction. Algebra homomorphisms <fr:tex>\varphi : F_M X \to Y</fr:tex> are given by commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8a6373922bbdf02e099f1678dbddae08"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
      {M^2 X} &amp; MY \\
      MX &amp; Y
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    while morphisms <fr:tex>f : X \to Y</fr:tex> fits in the diagram as such: 
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="6c339c9c83c0224f37d79a66abdf1772"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
      {M^2 X} &amp; MY \\
      MX &amp; Y \\
      X
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]
      \arrow["f"', from=3-1, to=2-2]
      \arrow["\eta", from=3-1, to=2-1]
      \arrow[from=2-1, to=1-2]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Given a homomorphism <fr:tex>\varphi</fr:tex> of algebras, we can compute <fr:tex>f</fr:tex> by composing with <fr:tex>\eta</fr:tex>. On the other hand, given <fr:tex>f</fr:tex>, we define <fr:tex>\varphi</fr:tex> by <fr:tex>\alpha_Y \mathbin{\circ} Mf</fr:tex>. This creates a commutative square because
    <fr:tex
display="block">\begin{aligned}       \alpha_Y \mathbin{\circ} M \varphi       &amp;= \alpha_Y \mathbin{\circ} M\alpha_Y \mathbin{\circ} M^2 f \\       &amp;= \alpha_Y \mathbin{\circ} \mu \mathbin{\circ} M^2 f \\       &amp;= \alpha_Y \mathbin{\circ} M f \mathbin{\circ} \mu \\       &amp;= \varphi \mathbin{\circ} \mu.     \end{aligned}</fr:tex></fr:p>

  <fr:p>
    We just have to verify that the two conversions are mutual inverses. In one way, we need to verify <fr:tex>\alpha_Y \mathbin{\circ} M f \mathbin{\circ} \eta = f</fr:tex>. This is true because by the naturality of <fr:tex>\eta</fr:tex> we get <fr:tex>M f \mathbin{\circ} \eta = \eta \mathbin{\circ} f</fr:tex>. Then by the definition of <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebra</fr:link> <fr:tex>\alpha_Y \mathbin{\circ} \eta = {\textrm{id}}</fr:tex>, proving the equality. On the other hand, we need to show <fr:tex>\alpha_Y \mathbin{\circ} M(\varphi \mathbin{\circ} \eta) = \varphi</fr:tex>. This follows from the algebra identity <fr:tex>\alpha_Y \mathbin{\circ} M \alpha_Y = \alpha_Y \mathbin{\circ} \mu</fr:tex> and the monad identity <fr:tex>\mu \mathbin{\circ} M \eta = {\textrm{id}}</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3195</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0001</fr:addr><fr:route>ualg-0001.xml</fr:route><fr:title>Monad on a category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>monad</fr:strong> on a category <fr:tex>{\mathcal{C}}</fr:tex> is a functor <fr:tex>M : {\mathcal{C}} \to {\mathcal{C}}</fr:tex> equipped with natural transformations <fr:tex>\eta : {\textrm{Id}} \to M</fr:tex> and <fr:tex>\mu : M \mathbin{\circ} M \to M</fr:tex> satisfying identity and associativity laws. In an unbiased way, we have a family of natural transformations <fr:tex>M^n \to M</fr:tex> with associativity.
</fr:p><fr:p>
  In short, it is a monoid in the category of endofunctors equipped with composition as the monoidal product.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3197</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    The DVF partitions the chain groups into a direct sum <fr:tex>C_k^{s} \oplus C_k^t \oplus C_k^c</fr:tex>, corresponding to source, target and critical cells. We would like to create a reduction to the critical cells only. To do this, we invoke <fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G"><fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">perturbation</fr:link> of the larger chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> and start with a simpler chain reduction.
  </fr:p>

  <fr:p>
    Consider the algebraic cellular complex whose chain groups are <fr:tex>C_k</fr:tex>, but the differential <fr:tex>d'(\sigma) = \pm \tau</fr:tex> iff <fr:tex>\overrightharpoon{\tau \sigma}</fr:tex> is in the vector field, and zero otherwise. The sign is determined as the sign of <fr:tex>\tau</fr:tex> in <fr:tex>d(\sigma)</fr:tex>. Hence <fr:tex>d' : C_{k+1}^{t} \to C_k^s</fr:tex>, and is zero otherwise. Therefore using the <fr:link
href="hmlg-001H.xml"
type="local"
addr="hmlg-001H">characterization of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> as a direct sum with a split exact chain complex, we see that this complex can be reduced to the complex on <fr:tex>C_k^p</fr:tex> whose differential is identically zero.
  </fr:p>

  <fr:p>
    Next, we try to perturb <fr:tex>d'</fr:tex> to <fr:tex>d</fr:tex>. We need <fr:tex>{h_{\rho}} \mathbin{\circ} (d' - d)</fr:tex> to be locally nilpotent, where <fr:tex>\rho</fr:tex> is the reduction constructed above. <fr:tex>{h_{\rho}}</fr:tex> can be viewed as the inverse of <fr:tex>d'</fr:tex>, as it maps the source cell to the target cell. Expanding the definition, we see that this map transports cells down the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">discrete field line</fr:link>. Since the vector field is admissible, such a transportation eventually terminates and it becomes zero.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3199</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001R</fr:addr><fr:route>hmlg-001R.xml</fr:route><fr:title>Chain reduction generated by a discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissible discrete vector field</fr:link> on an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> <fr:tex>(C_k, d)</fr:tex>, we can generate a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link>. It will be computable when the cellular complex is <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>583</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    The DVF partitions the chain groups into a direct sum <fr:tex>C_k^{s} \oplus C_k^t \oplus C_k^c</fr:tex>, corresponding to source, target and critical cells. We would like to create a reduction to the critical cells only. To do this, we invoke <fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G"><fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">perturbation</fr:link> of the larger chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> and start with a simpler chain reduction.
  </fr:p>

  <fr:p>
    Consider the algebraic cellular complex whose chain groups are <fr:tex>C_k</fr:tex>, but the differential <fr:tex>d'(\sigma) = \pm \tau</fr:tex> iff <fr:tex>\overrightharpoon{\tau \sigma}</fr:tex> is in the vector field, and zero otherwise. The sign is determined as the sign of <fr:tex>\tau</fr:tex> in <fr:tex>d(\sigma)</fr:tex>. Hence <fr:tex>d' : C_{k+1}^{t} \to C_k^s</fr:tex>, and is zero otherwise. Therefore using the <fr:link
href="hmlg-001H.xml"
type="local"
addr="hmlg-001H">characterization of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> as a direct sum with a split exact chain complex, we see that this complex can be reduced to the complex on <fr:tex>C_k^p</fr:tex> whose differential is identically zero.
  </fr:p>

  <fr:p>
    Next, we try to perturb <fr:tex>d'</fr:tex> to <fr:tex>d</fr:tex>. We need <fr:tex>{h_{\rho}} \mathbin{\circ} (d' - d)</fr:tex> to be locally nilpotent, where <fr:tex>\rho</fr:tex> is the reduction constructed above. <fr:tex>{h_{\rho}}</fr:tex> can be viewed as the inverse of <fr:tex>d'</fr:tex>, as it maps the source cell to the target cell. Expanding the definition, we see that this map transports cells down the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">discrete field line</fr:link>. Since the vector field is admissible, such a transportation eventually terminates and it becomes zero.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3201</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-001S</fr:addr><fr:route>hmlg-001S.xml</fr:route><fr:title>Discrete field lines can branch and merge</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although we make an analogy between a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link> and a vector field, the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">field lines</fr:link> of a DVF may branch out. For instance, take a triangle <fr:tex>\tau</fr:tex> with three edges <fr:tex>\sigma_1, \sigma_2, \sigma_3</fr:tex>. We can have a vector <fr:tex>\overrightharpoon{\sigma_1 \tau}</fr:tex> pointing into the triangle, and <fr:tex>\sigma_2, \sigma_3</fr:tex> each having vectors pointing out. Similarly multiple field lines may join when they reach a lower-degree cell. Because of this, we need to take care in the phrasing of <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissibility</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3203</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001U</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose we have a covering sieve <fr:tex>S \hookrightarrow \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex>, then an element <fr:tex>f \in {\Gamma}(U, F)</fr:tex> uniquely corresponds to a matching family <fr:tex>s \in \hom(S, F)</fr:tex>. In the category of elements <fr:tex>\int_{{\mathcal{C}}} F</fr:tex>, <fr:tex>s</fr:tex> corresponds to a sieve over <fr:tex>f</fr:tex>. This is the required Grothendieck coverage.
  </fr:p>

  <fr:p>
    Another way to construct this is through the <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>. The subobject classifier of a slice category is simply <fr:tex>\Omega \times F \to F</fr:tex>. Hence we can let <fr:tex>j</fr:tex> act on the <fr:tex>\Omega</fr:tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3205</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001P</fr:addr><fr:route>hmlg-001P.xml</fr:route><fr:title>Admissible discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link>, if is <fr:strong>admissible</fr:strong> if the lengths of the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">field lines</fr:link> starting from a cell are bounded. In other words, we can assign a natural number to every cell such that the field lines starting from this cell have length bounded by the number. The number can be different for each cell, and can be unbounded overall.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3207</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001Q</fr:addr><fr:route>hmlg-001Q.xml</fr:route><fr:title>Discrete field line</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link>, the discrete version of <fr:strong>field lines</fr:strong> is defined as a sequence of cells alternating between degree <fr:tex>p</fr:tex> and <fr:tex>(p-1)</fr:tex> starting and ending with lower-degree cells, with a few requirements.
</fr:p><fr:ul><fr:li>When the degree increases, the two cells must occur as a vector in the DVF.</fr:li>
  <fr:li>When the degree decreases, the degree <fr:tex>(p-1)</fr:tex> cell must be a (possible non-<fr:link
href="hmlg-001O.xml"
type="local"
addr="hmlg-001O">regular</fr:link>) face of the degree <fr:tex>p</fr:tex> cell.</fr:li>
  <fr:li>Two degree <fr:tex>(p-1)</fr:tex> cells separated by a degree <fr:tex>p</fr:tex> cell must not be the same.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3209</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001N</fr:addr><fr:route>hmlg-001N.xml</fr:route><fr:title>Discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>discrete vector field</fr:strong> (DVF) of degree <fr:tex>p</fr:tex> on an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> is given by a collection of pairs of cells <fr:tex>(\sigma, \tau)</fr:tex>, where <fr:tex>\sigma</fr:tex> is a <fr:link
href="hmlg-001O.xml"
type="local"
addr="hmlg-001O">regular face</fr:link> of the degree <fr:tex>p</fr:tex> cell <fr:tex>\tau</fr:tex>, standing for a vector pointing from <fr:tex>\sigma</fr:tex> to <fr:tex>\tau</fr:tex>, which we will write as <fr:tex>\overrightharpoon{\sigma \tau}</fr:tex>. We require that every cell appears at most once in these vectors.
</fr:p><fr:p>
  A DVF naturally partitions the cells into three kinds: the <fr:em>sources</fr:em>, the <fr:em>targets</fr:em>, and the rest of the cells are called <fr:em>critical cells</fr:em>. This name comes from the analogy to Morse theory. Indeed there is a notion of <fr:link
href="https://en.wikipedia.org/wiki/Discrete_Morse_theory"
type="external">discrete Morse function</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3211</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001O</fr:addr><fr:route>hmlg-001O.xml</fr:route><fr:title>Regular face in an algebraic cellular complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> and a cell <fr:tex>\sigma</fr:tex>, a <fr:strong>regular face</fr:strong> of <fr:tex>\sigma</fr:tex> is a cell whose coefficient in <fr:tex>d\sigma</fr:tex> is <fr:tex>\pm 1</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3213</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001T</fr:addr><fr:route>algm-001T.xml</fr:route><fr:title>Slice of presheaf category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We have an equivalence of categories
  <fr:tex
display="block">{\mathsf{Psh}}({\mathcal{C}})/P \cong {\mathsf{Psh}}\left(\int_{{\mathcal{C}}} P\right).</fr:tex>
  In the special case that <fr:tex>P = \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex>, we have
  <fr:tex
display="block">{\mathsf{Psh}}({\mathcal{C}})/\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U) \cong {\mathsf{Psh}}({\mathcal{C}}/U).</fr:tex></fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3215</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001U</fr:addr><fr:route>algm-001U.xml</fr:route><fr:title>Slice of sheaf category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex> with a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link> <fr:tex>J</fr:tex> and a sheaf <fr:tex>F</fr:tex>, there is a Grothendieck coverage <fr:tex>J'</fr:tex> on <fr:tex>\int_{{\mathcal{C}}} F</fr:tex> such that the equivalence in <fr:ref
addr="algm-001T"
href="algm-001T.xml"
taxon="Theorem"></fr:ref> restricts to an equivalence
  <fr:tex
display="block">{\mathsf{Sh}}({\mathcal{C}}, J)/F \cong {\mathsf{Sh}}\left(\int_{{\mathcal{C}}} F, J'\right).</fr:tex></fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1059</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001U</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose we have a covering sieve <fr:tex>S \hookrightarrow \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex>, then an element <fr:tex>f \in {\Gamma}(U, F)</fr:tex> uniquely corresponds to a matching family <fr:tex>s \in \hom(S, F)</fr:tex>. In the category of elements <fr:tex>\int_{{\mathcal{C}}} F</fr:tex>, <fr:tex>s</fr:tex> corresponds to a sieve over <fr:tex>f</fr:tex>. This is the required Grothendieck coverage.
  </fr:p>

  <fr:p>
    Another way to construct this is through the <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>. The subobject classifier of a slice category is simply <fr:tex>\Omega \times F \to F</fr:tex>. Hence we can let <fr:tex>j</fr:tex> act on the <fr:tex>\Omega</fr:tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3217</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title>Dense subobject of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a subobject <fr:tex>F \hookrightarrow G</fr:tex> is <fr:tex>j</fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex>G \to \Omega \xrightarrow{j} \Omega</fr:tex> is the constant true. In terms of the corresponding <fr:tex>J \hookrightarrow \Omega</fr:tex>, we need the pullback of it with <fr:tex>G \to \Omega</fr:tex> to be <fr:tex>{\textrm{id}} : G \to G</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3219</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001O</fr:addr><fr:route>algm-001O.xml</fr:route><fr:title>Exponentials of sheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The exponentials of sheaves coincide with those of presheaves. To see this, we assume <fr:tex>X^Y</fr:tex> is the exponential of sheaves and calculate
  <fr:tex
display="block">\begin{aligned}     {\Gamma}(U, X^Y)     &amp;= \hom_{{\mathsf{Psh}}}(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U), X^Y) \\     &amp;= \hom_{{\mathsf{Sh}}}(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)^{++}, X^Y) \\     &amp;= \hom_{{\mathsf{Sh}}}(Y \times \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)^{++}, X) \\     &amp;= \hom_{{\mathsf{Sh}}}(Y^{++} \times \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)^{++}, X) \\     &amp;= \hom_{{\mathsf{Sh}}}((Y \times \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U))^{++}, X) \\     &amp;= \hom_{{\mathsf{Psh}}}(Y \times \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U), X) \\   \end{aligned}</fr:tex>
  which is evidently <fr:tex>{\Gamma}(U, X^Y)</fr:tex> but this time the exponential is taken in the category of presheaves. We used the fact that <fr:link
href="todo.xml"
type="local"
addr="todo">the plus construction preserves finite product</fr:link>. However, we still need to prove that this indeed forms a sheaf.
</fr:p><fr:p>
  Expressing the <fr:link
href="algm-001P.xml"
type="local"
addr="algm-001P">sheaf condition using Lawvere–Tierney operators</fr:link>, we only need to show for <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q">dense subobjects</fr:link> <fr:tex>F \hookrightarrow G</fr:tex> that <fr:tex>\hom(G, X^Y) \to \hom(F, X^Y)</fr:tex> is a bijection. This is equivalent to <fr:tex
display="block">\hom(Y \times G, X) \to \hom(Y \times F, X).</fr:tex> Note that the subobject <fr:tex>Y \times F \hookrightarrow Y \times G</fr:tex> corresponds to the characteristic function <fr:tex>Y \times G \to G \to \Omega</fr:tex>. Hence the denseness of <fr:tex>F \hookrightarrow G</fr:tex> implies the denseness of <fr:tex>Y \times F \hookrightarrow Y \times G</fr:tex>. Since <fr:tex>X</fr:tex> is a sheaf, we conclude that <fr:tex>X^Y</fr:tex> is also a sheaf.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3221</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title>Local object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a class of arrows <fr:tex>S</fr:tex>, an <fr:tex>S</fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex>X</fr:tex> such that for every <fr:tex>f : A \to B</fr:tex> in <fr:tex>S</fr:tex>, the composition map <fr:tex
display="block">\hom(B, X) \to \hom(A, X)</fr:tex> is an isomorphism.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3223</fr:anchor><fr:addr>algm-001P</fr:addr><fr:route>algm-001P.xml</fr:route><fr:title>Sheaf condition using Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Knowing the <fr:link
href="algm-001N.xml"
type="local"
addr="algm-001N">correspondence</fr:link> of Grothendieck coverages on <fr:tex>{\mathcal{C}}</fr:tex> and Lawvere–Tierney operators on <fr:tex>{\mathsf{Psh}}({\mathcal{C}})</fr:tex>, we naturally want to rewrite the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> to use <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operators</fr:link> instead of <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverages</fr:link>.
</fr:p><fr:p>
  Recall that the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> requires for every covering sieve <fr:tex>S \hookrightarrow \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex> that the composition <fr:tex>\hom(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U), X) \to \hom(S, X)</fr:tex> is an isomorphism. We can reify this to a definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1137</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title>Local object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a class of arrows <fr:tex>S</fr:tex>, an <fr:tex>S</fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex>X</fr:tex> such that for every <fr:tex>f : A \to B</fr:tex> in <fr:tex>S</fr:tex>, the composition map <fr:tex
display="block">\hom(B, X) \to \hom(A, X)</fr:tex> is an isomorphism.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Now we just need to pick out the class of morphisms <fr:tex>S \hookrightarrow \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex> using the Lawvere–Tierney operator <fr:tex>j</fr:tex>. Note that this operator does not necessarily live in a presheaf topos, so we must find a way to generalize this class of arrows to not necessarily representable presheaves. Since every presheaf is a colimit of representables, we can look at the corresponding colimit of morphisms <fr:tex>\operatorname*{colim} S_i \hookrightarrow \operatorname*{colim} \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U_i)</fr:tex>. A local object will satisfy
  <fr:tex
display="block">\begin{aligned}     \hom(\operatorname*{colim}\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U_i), X) \cong \lim\hom(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U_i), X) \quad \\     \xrightarrow{\sim} \lim\hom(S_i, X) \cong \hom(\operatorname*{colim} S_i, X).   \end{aligned}</fr:tex>
  Hence we can safely include these arrows into the class and still get the same concept of local objects. Now it’s illuminating to look at the characteristic maps. A sieve <fr:tex>S \to \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U)</fr:tex> corresponds to a characteristic map in <fr:tex>\hom(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U), \Omega) \cong {\Gamma}(U, \Omega)</fr:tex>. Generalizing to an arbitrary presheaf expressed (canonically) as a colimit of representables, we need the image of every section to be a covering sieve.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1139</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title>Dense subobject of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a subobject <fr:tex>F \hookrightarrow G</fr:tex> is <fr:tex>j</fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex>G \to \Omega \xrightarrow{j} \Omega</fr:tex> is the constant true. In terms of the corresponding <fr:tex>J \hookrightarrow \Omega</fr:tex>, we need the pullback of it with <fr:tex>G \to \Omega</fr:tex> to be <fr:tex>{\textrm{id}} : G \to G</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  In terms of sieves, for every section <fr:tex>s \in {\Gamma}(U, G)</fr:tex>, the sieve of arrows on <fr:tex>U</fr:tex> along whom the restriction of <fr:tex>s</fr:tex> is in <fr:tex>F</fr:tex> must be a covering sieve. We have arrived at the desired reformulation of the sheaf condition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1141</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title>Sheaf of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a <fr:tex>j</fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex>j</fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
href="algm-001R.xml"
type="local"
addr="algm-001R">local object</fr:link> under the <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q"><fr:tex>j</fr:tex>-dense monomorphisms</fr:link>.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3225</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title>Sheaf of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a <fr:tex>j</fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex>j</fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
href="algm-001R.xml"
type="local"
addr="algm-001R">local object</fr:link> under the <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q"><fr:tex>j</fr:tex>-dense monomorphisms</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3227</fr:anchor><fr:addr>algm-001N</fr:addr><fr:route>algm-001N.xml</fr:route><fr:title>Grothendieck coverages and Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Consider a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> on a presheaf category. Then we may calculate the subobject classifier as in <fr:ref
addr="algm-001M"
href="algm-001M.xml"
taxon="Construction"></fr:ref>.
</fr:p><fr:p>
  By the definition of subobject classifiers, a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> can be equivalently expressed as a subobject <fr:tex>J \subseteq \Omega</fr:tex>. Translating the condition of preserving finite intersections, it needs to contain the improper sieve, be upwards closed and closed under finite intersections. And <fr:tex>j \mathbin{\circ} j = j</fr:tex> implies the following pullback square:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="39ee037d205ec6b04533261f1eda08f3"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}%tex
    J &amp; J \\
    \Omega &amp; \Omega
    \arrow[hook, from=1-2, to=2-2]
    \arrow["j"', from=2-1, to=2-2]
    \arrow[hook, from=1-1, to=2-1]
    \arrow[from=1-1, to=1-2]
    \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  In other words, a sieve is contained in <fr:tex>J</fr:tex> iff its image under <fr:tex>j</fr:tex> is also contained in <fr:tex>J</fr:tex>. Unfolding this, a sieve <fr:tex>S</fr:tex> is contained in <fr:tex>J</fr:tex> iff the arrows <fr:tex>g</fr:tex> such that <fr:tex>g^* S</fr:tex> is contained in <fr:tex>J</fr:tex> also form a sieve in <fr:tex>J</fr:tex>. Looking at the definition of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, we see that they are equivalent, if we regard <fr:tex>J</fr:tex> as picking out the covering sieves.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3229</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001L</fr:addr><fr:route>algm-001L.xml</fr:route><fr:title>Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, a <fr:strong>Lawvere–Tierney operator</fr:strong> is a morphism <fr:tex>j : \Omega \to \Omega</fr:tex> where <fr:tex>\Omega</fr:tex> is the subobject classifier, such that <fr:tex>j</fr:tex> preserves finite intersections, and <fr:tex>j \mathbin{\circ} j = j</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3231</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001M</fr:addr><fr:route>algm-001M.xml</fr:route><fr:title>Subobject classifier of presheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The subobject classifier <fr:tex>\Omega</fr:tex> of presheaves can be given by a quick calculation.
  <fr:tex
display="block">{\Gamma}(U, \Omega)   \cong \hom(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U), \Omega)   \cong \operatorname{Sub}(\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(U))</fr:tex>
  By definition, this is the set of <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieves</fr:link> on <fr:tex>U</fr:tex>, and the functorial action is the <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link>. For a monomorphism <fr:tex>F \hookrightarrow G</fr:tex>, an element <fr:tex>s \in {\Gamma}(U, G)</fr:tex> is sent to the sieve consisting of arrows <fr:tex>f : V \to U</fr:tex> such that the restriction along <fr:tex>f</fr:tex> is included in <fr:tex>F</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3233</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001K</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We define <fr:tex>{\Gamma}(U, P^{{\operatorname{sep}}})</fr:tex> to be a quotient of <fr:tex>{\Gamma}(U, P)</fr:tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <fr:tex>P \to Q</fr:tex> to a separated presheaf, if two sections of <fr:tex>P</fr:tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <fr:tex>Q</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3235</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We construct sheafification as <fr:link
href="algm-001G.xml"
type="local"
addr="algm-001G">an iterated plus construction</fr:link>. This produces a functor. By <fr:ref
addr="algm-001H"
href="algm-001H.xml"
taxon="Theorem"></fr:ref> we have a natural bijection
    <fr:tex
display="block">\hom(P^{++}, F) \cong \hom(P^+, F) \cong \hom(P, F).</fr:tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <fr:tex>P \to P^+</fr:tex> and <fr:tex>P^+ \to P^{++}</fr:tex>, we see that the unit of the adjunction is given by the composition <fr:tex>P \to P^{++}</fr:tex>.
  </fr:p>

  <fr:p>
    Alternatively, using <fr:ref
addr="algm-001K"
href="algm-001K.xml"
taxon="Construction"></fr:ref>, we may compose two adjunctions to first <fr:link
href="algm-001K.xml"
type="local"
addr="algm-001K">separate</fr:link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3237</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For every morphism <fr:tex>P \to F</fr:tex>, there is a unique way to extend the map to <fr:tex>P^+</fr:tex> using the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> of <fr:tex>F</fr:tex>. A section of <fr:tex>P^+</fr:tex> consists of a matching family <fr:tex>s_f</fr:tex>, and it is also the gluing of <fr:tex>\eta_P(s_f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3239</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001K</fr:addr><fr:route>algm-001K.xml</fr:route><fr:title>Separation of presheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, the inclusion of <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated presheaves</fr:link> to presheaves has a left adjoint <fr:tex>(-)^{{\operatorname{sep}}}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1225</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001K</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We define <fr:tex>{\Gamma}(U, P^{{\operatorname{sep}}})</fr:tex> to be a quotient of <fr:tex>{\Gamma}(U, P)</fr:tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <fr:tex>P \to Q</fr:tex> to a separated presheaf, if two sections of <fr:tex>P</fr:tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <fr:tex>Q</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3241</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001I</fr:addr><fr:route>algm-001I.xml</fr:route><fr:title>Sheaf condition in terms of plus construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a presheaf <fr:tex>P</fr:tex>, the morphism <fr:tex>P \to P^+</fr:tex> to its <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link> is a monomorphism iff <fr:tex>P</fr:tex> is <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated</fr:link>, and it is an isomorphism iff <fr:tex>P</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3243</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001J</fr:addr><fr:route>algm-001J.xml</fr:route><fr:title>Sheafification</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Sheafification</fr:strong> is defined as the left adjoint of the inclusion from <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaves</fr:link> to the category of presheaves. Hence it freely constructs a sheaf from a presheaf.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1241</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We construct sheafification as <fr:link
href="algm-001G.xml"
type="local"
addr="algm-001G">an iterated plus construction</fr:link>. This produces a functor. By <fr:ref
addr="algm-001H"
href="algm-001H.xml"
taxon="Theorem"></fr:ref> we have a natural bijection
    <fr:tex
display="block">\hom(P^{++}, F) \cong \hom(P^+, F) \cong \hom(P, F).</fr:tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <fr:tex>P \to P^+</fr:tex> and <fr:tex>P^+ \to P^{++}</fr:tex>, we see that the unit of the adjunction is given by the composition <fr:tex>P \to P^{++}</fr:tex>.
  </fr:p>

  <fr:p>
    Alternatively, using <fr:ref
addr="algm-001K"
href="algm-001K.xml"
taxon="Construction"></fr:ref>, we may compose two adjunctions to first <fr:link
href="algm-001K.xml"
type="local"
addr="algm-001K">separate</fr:link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3245</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001H</fr:addr><fr:route>algm-001H.xml</fr:route><fr:title>Universal property of <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any presheaf <fr:tex>P</fr:tex> and sheaf <fr:tex>F</fr:tex>, there is a natural bijection <fr:tex
display="block">\hom(P, F) \cong \hom(P^+, F)</fr:tex> given by composition with <fr:tex>\eta_P : P \to P^+</fr:tex>.
</fr:p><fr:p>
  As a corollary of this and <fr:ref
addr="algm-001G"
href="algm-001G.xml"
taxon="Theorem"></fr:ref>, when restricted to separated presheaves, it is left adjoint to the forgetful functor from sheaves to separated presheaves.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1233</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For every morphism <fr:tex>P \to F</fr:tex>, there is a unique way to extend the map to <fr:tex>P^+</fr:tex> using the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> of <fr:tex>F</fr:tex>. A section of <fr:tex>P^+</fr:tex> consists of a matching family <fr:tex>s_f</fr:tex>, and it is also the gluing of <fr:tex>\eta_P(s_f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3247</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first prove that <fr:tex>P^+</fr:tex> is separated. Suppose there are two gluings of a set of descent data on a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">covering sieve</fr:link> <fr:tex>S</fr:tex> over <fr:tex>A</fr:tex>, then we have two sieves <fr:tex>S_1, S_2</fr:tex> over <fr:tex>A</fr:tex> with compatible families <fr:tex>s_{1, f}, s_{2, f}</fr:tex>. Since they are gluings of the same descent data, the restriction along any morphism <fr:tex>g : U \to A</fr:tex> in <fr:tex>S</fr:tex> would be equal. Hence there is a common refinement of <fr:tex>g^* S_1</fr:tex> and <fr:tex>g^* S_2</fr:tex> where the two families become equal. Expanding this, there is a covering sieve on <fr:tex>U</fr:tex> such that <fr:tex>g \mathbin{\circ} h \in S_1 \cap S_2</fr:tex> for every <fr:tex>h</fr:tex> in the sieve, and <fr:tex>s_{1, g \mathbin{\circ} h} = s_{2, g \mathbin{\circ} h}</fr:tex>. But then by the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, <fr:tex>g \mathbin{\circ} h</fr:tex> for all <fr:tex>h</fr:tex> in the said sieve and <fr:tex>g \in S</fr:tex> also generates a covering sieve. Hence <fr:tex>s_1</fr:tex> and <fr:tex>s_2</fr:tex> are already equal on a covering subsieve, and so they are equal in <fr:tex>{\Gamma}(A, P^+)</fr:tex>.
  </fr:p>

  <fr:p>
    Let’s see why <fr:tex>P^+</fr:tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">compatible family</fr:link> of local sections of <fr:tex>P^+</fr:tex> is a family of covering sieves <fr:tex>S_f</fr:tex> over <fr:tex>U</fr:tex> for each morphism <fr:tex>f : U \to A</fr:tex> in <fr:tex>S</fr:tex>, and for each <fr:tex>S_f</fr:tex> a family of sections <fr:tex>s_{f, g} \in {\Gamma}(V, P)</fr:tex> where <fr:tex>g : V \to U</fr:tex> lies in <fr:tex>S_f</fr:tex>. By the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, the union <fr:tex>\bigcup_{f \in S} f \mathbin{\circ} S_f</fr:tex> is a sieve, since <fr:tex>S_f \subseteq f^* (f \mathbin{\circ} S_f)</fr:tex>. (Warning: <fr:tex>f \mathbin{\circ} S_f</fr:tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <fr:tex>s'</fr:tex> by <fr:tex>s'_{f \mathbin{\circ} g} = s_{f, g}</fr:tex>. Hence we need to prove <fr:tex>s_{f, g} = s_{f', g'}</fr:tex> if <fr:tex>f \mathbin{\circ} g = f' \mathbin{\circ} g'</fr:tex>.
  </fr:p>

  <fr:p>
    Since the families <fr:tex>s_{f}</fr:tex> are compatible, given any <fr:tex>g : V \to U</fr:tex> we have <fr:tex>s_{f, g \mathbin{\circ} r} = s_{f \mathbin{\circ} g, r}</fr:tex> for a family of arrows <fr:tex>r</fr:tex> that generates a covering sieve on <fr:tex>V</fr:tex>. However we cannot necessarily take <fr:tex>r = {\textrm{id}}</fr:tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <fr:tex>s_{f, g \mathbin{\circ} r} = s_{f \mathbin{\circ} g, r}</fr:tex> forms a compatible family over <fr:tex>V</fr:tex> as <fr:tex>r</fr:tex> ranges over the covering sieve. And therefore <fr:tex>s_{f, g}</fr:tex> and <fr:tex>s_{f \mathbin{\circ} g, {\textrm{id}}}</fr:tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3249</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001A</fr:addr><fr:route>algm-001A.xml</fr:route><fr:title>Grothendieck coverage</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, a <fr:strong>Grothendieck coverage</fr:strong> declares some <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieves</fr:link> to be coverings, such that the following holds.
</fr:p><fr:ul><fr:li>The maximal sieve <fr:tex>\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(A) \subseteq \mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(A)</fr:tex> is always a covering.</fr:li>
  <fr:li>Covering sieves are upwards closed, i.e. if <fr:tex>S \subseteq S'</fr:tex> and <fr:tex>S</fr:tex> is a covering sieve, then so is <fr:tex>S'</fr:tex>.</fr:li>
  <fr:li>If <fr:tex>S</fr:tex> is a covering sieve of <fr:tex>A</fr:tex>, and <fr:tex>g : B \to A</fr:tex> is a morphism, then the <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link> <fr:tex>g^* S</fr:tex> is also a covering.</fr:li>
  <fr:li>Suppose <fr:tex>S</fr:tex> is a sieve, then the collection of arrows <fr:tex>g</fr:tex> such that <fr:tex>g^* S</fr:tex> is a covering is a sieve itself. If this sieve is a covering, then <fr:tex>S</fr:tex> is also a covering.</fr:li></fr:ul><fr:p>
  A Grothendieck coverage can be viewed as a <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">coverage</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3251</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0019</fr:addr><fr:route>algm-0019.xml</fr:route><fr:title>Coverage</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>coverage</fr:strong> on an arbitrary category <fr:tex>{\mathcal{C}}</fr:tex> is given by a family of covers. A <fr:strong>cover</fr:strong> of some object <fr:tex>A</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex> is a family of maps with codomain <fr:tex>A</fr:tex>. Given a cover <fr:tex>f_i : U_i \to A</fr:tex> and a map <fr:tex>g : B \to A</fr:tex>, there is a cover of <fr:tex>B</fr:tex> such that its composition with <fr:tex>g</fr:tex> is a <fr:strong>refinement</fr:strong> of <fr:tex>f_i</fr:tex>, in the sense that every map in the cover factors through one of <fr:tex>f_i</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3253</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001D</fr:addr><fr:route>algm-001D.xml</fr:route><fr:title>Descent data of presheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, a <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieve</fr:link> <fr:tex>S</fr:tex> and a presheaf <fr:tex>P : {\mathcal{C}}^{\textrm{op}} \to {\mathsf{Set}}</fr:tex>, a set of <fr:strong>descent data</fr:strong> or a <fr:strong>compatible family</fr:strong> is a morphism <fr:tex>S \to P</fr:tex>. Expanding this, it is a family of <fr:em>local sections</fr:em> <fr:tex>s \in {\Gamma}(U, P)</fr:tex> assigned for each morphism <fr:tex>U \to A</fr:tex> in the sieve <fr:tex>S</fr:tex>, such that the local sections are compatible on restriction. There is an obvious map from the sections <fr:tex>{\Gamma}(A, P)</fr:tex> to the descent data given by restriction.
</fr:p><fr:p>
  More generally, given a general <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">cover</fr:link>, a set of descent data is a family of sections <fr:tex>s_i \in {\Gamma}(U_i, P)</fr:tex> for each morphism <fr:tex>f_i : U_i \to A</fr:tex> in the cover, such that in any common restriction of <fr:tex>U_i</fr:tex> and <fr:tex>U_j</fr:tex>, the sections agree. This can be equivalently expressed as the descent data of the sieve generated by the cover.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3255</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001G</fr:addr><fr:route>algm-001G.xml</fr:route><fr:title>Iterated <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link> produces a sheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given any presheaf <fr:tex>P</fr:tex>, <fr:tex>P^+</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated presheaf</fr:link>, and if <fr:tex>P</fr:tex> is already separated, <fr:tex>P^+</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf</fr:link>. Therefore <fr:tex>P^{++}</fr:tex> is always a sheaf.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1237</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first prove that <fr:tex>P^+</fr:tex> is separated. Suppose there are two gluings of a set of descent data on a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">covering sieve</fr:link> <fr:tex>S</fr:tex> over <fr:tex>A</fr:tex>, then we have two sieves <fr:tex>S_1, S_2</fr:tex> over <fr:tex>A</fr:tex> with compatible families <fr:tex>s_{1, f}, s_{2, f}</fr:tex>. Since they are gluings of the same descent data, the restriction along any morphism <fr:tex>g : U \to A</fr:tex> in <fr:tex>S</fr:tex> would be equal. Hence there is a common refinement of <fr:tex>g^* S_1</fr:tex> and <fr:tex>g^* S_2</fr:tex> where the two families become equal. Expanding this, there is a covering sieve on <fr:tex>U</fr:tex> such that <fr:tex>g \mathbin{\circ} h \in S_1 \cap S_2</fr:tex> for every <fr:tex>h</fr:tex> in the sieve, and <fr:tex>s_{1, g \mathbin{\circ} h} = s_{2, g \mathbin{\circ} h}</fr:tex>. But then by the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, <fr:tex>g \mathbin{\circ} h</fr:tex> for all <fr:tex>h</fr:tex> in the said sieve and <fr:tex>g \in S</fr:tex> also generates a covering sieve. Hence <fr:tex>s_1</fr:tex> and <fr:tex>s_2</fr:tex> are already equal on a covering subsieve, and so they are equal in <fr:tex>{\Gamma}(A, P^+)</fr:tex>.
  </fr:p>

  <fr:p>
    Let’s see why <fr:tex>P^+</fr:tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">compatible family</fr:link> of local sections of <fr:tex>P^+</fr:tex> is a family of covering sieves <fr:tex>S_f</fr:tex> over <fr:tex>U</fr:tex> for each morphism <fr:tex>f : U \to A</fr:tex> in <fr:tex>S</fr:tex>, and for each <fr:tex>S_f</fr:tex> a family of sections <fr:tex>s_{f, g} \in {\Gamma}(V, P)</fr:tex> where <fr:tex>g : V \to U</fr:tex> lies in <fr:tex>S_f</fr:tex>. By the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, the union <fr:tex>\bigcup_{f \in S} f \mathbin{\circ} S_f</fr:tex> is a sieve, since <fr:tex>S_f \subseteq f^* (f \mathbin{\circ} S_f)</fr:tex>. (Warning: <fr:tex>f \mathbin{\circ} S_f</fr:tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <fr:tex>s'</fr:tex> by <fr:tex>s'_{f \mathbin{\circ} g} = s_{f, g}</fr:tex>. Hence we need to prove <fr:tex>s_{f, g} = s_{f', g'}</fr:tex> if <fr:tex>f \mathbin{\circ} g = f' \mathbin{\circ} g'</fr:tex>.
  </fr:p>

  <fr:p>
    Since the families <fr:tex>s_{f}</fr:tex> are compatible, given any <fr:tex>g : V \to U</fr:tex> we have <fr:tex>s_{f, g \mathbin{\circ} r} = s_{f \mathbin{\circ} g, r}</fr:tex> for a family of arrows <fr:tex>r</fr:tex> that generates a covering sieve on <fr:tex>V</fr:tex>. However we cannot necessarily take <fr:tex>r = {\textrm{id}}</fr:tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <fr:tex>s_{f, g \mathbin{\circ} r} = s_{f \mathbin{\circ} g, r}</fr:tex> forms a compatible family over <fr:tex>V</fr:tex> as <fr:tex>r</fr:tex> ranges over the covering sieve. And therefore <fr:tex>s_{f, g}</fr:tex> and <fr:tex>s_{f \mathbin{\circ} g, {\textrm{id}}}</fr:tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3257</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001E</fr:addr><fr:route>algm-001E.xml</fr:route><fr:title>Plus construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link> on <fr:tex>{\mathcal{C}}</fr:tex> and a presheaf <fr:tex>P : {\mathcal{C}}^{\textrm{op}} \to {\mathsf{Set}}</fr:tex>, the <fr:strong>plus construction</fr:strong> produces a new presheaf <fr:tex>P^+</fr:tex> by taking a directed limit over all the <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">descent data</fr:link>. More precisely, we assign <fr:tex
display="block">{\Gamma}(A, P^+) = \operatorname*{colim}_{S \text{ covers } A} \hom(S, P).</fr:tex> This means the sections of <fr:tex>P^+</fr:tex> are compatible families of sections of <fr:tex>P</fr:tex>, and two families are considered equal if they are equal on a common covering subsieve.
</fr:p><fr:p>
  Given a map <fr:tex>g : B \to A</fr:tex>, we have a <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link> <fr:tex>\hom(S, P) \to \hom(g^*S, P)</fr:tex>. This induces the functorial action of <fr:tex>P^+</fr:tex>. There is an obvious natural transformation <fr:tex>P \to P^+</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3259</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001C</fr:addr><fr:route>algm-001C.xml</fr:route><fr:title>Pullback of sieves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieve</fr:link> <fr:tex>S</fr:tex> over <fr:tex>A</fr:tex> and a morphism <fr:tex>g : B \to A</fr:tex>, the <fr:strong>pullback</fr:strong> <fr:tex>g^* S</fr:tex> is a sieve over <fr:tex>B</fr:tex>. <fr:tex>h : C \to B</fr:tex> is in this sieve iff <fr:tex>g \mathbin{\circ} h</fr:tex> is in <fr:tex>S</fr:tex>. There is a natural map <fr:tex>g^* S \to S</fr:tex> given by <fr:tex>g \mathbin{\circ} -</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3261</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001F</fr:addr><fr:route>algm-001F.xml</fr:route><fr:title>Sheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex> equipped with a <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">coverage</fr:link>, we define a presheaf <fr:tex>P : {\mathcal{C}}^{\textrm{op}} \to {\mathsf{Set}}</fr:tex> to be a <fr:strong>sheaf</fr:strong> if it satisfies the <fr:strong>sheaf condition</fr:strong>: for every cover of <fr:tex>A</fr:tex>, the map from sections of <fr:tex>A</fr:tex> to <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">descent data</fr:link> of the cover is a bijection. It is a <fr:strong>separated presheaf</fr:strong> if the map is an injection.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3263</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001B</fr:addr><fr:route>algm-001B.xml</fr:route><fr:title>Sieve</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>sieve</fr:strong> over an object <fr:tex>A</fr:tex> of an arbitrary category <fr:tex>{\mathcal{C}}</fr:tex> is a subfunctor of <fr:tex>\mathop{\mkern{-2mu}\text{よ}\mkern{-2mu}}(A)</fr:tex>. More explicitly, it selects some arrows with codomain <fr:tex>A</fr:tex>, such that the selected arrows absorbs composition (i.e. if <fr:tex>f : B \to A</fr:tex> is selected and <fr:tex>g : C \to B</fr:tex>, then <fr:tex>g \mathbin{\circ} f</fr:tex> is also selected).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3265</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001M</fr:addr><fr:route>hmlg-001M.xml</fr:route><fr:title>Chain reduction of mapping cones</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reductions</fr:link> <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex> and <fr:tex>\rho' : C' \Rightarrow\mkern{-14mu}\Rightarrow D'</fr:tex>, we can construct a reduction from the mapping cone <fr:tex>\operatorname{Cone}(f)</fr:tex> of a chain map <fr:tex>f : C \to C'</fr:tex> to (the action of <fr:tex>\rho</fr:tex> on <fr:tex>f</fr:tex>).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3267</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.
  </fr:p>

  <fr:p>
    For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3269</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0018</fr:addr><fr:route>algm-0018.xml</fr:route><fr:title>A space is noetherian iff hereditarily quasi-compact</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian</fr:link> iff it is <fr:em>hereditarily</fr:em> <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>, that is, if all its opens are quasi-compact.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1405</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.
  </fr:p>

  <fr:p>
    For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3271</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0017</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We prove that if some affine cover <fr:tex>\{\operatorname{Spec}(R_i) \hookrightarrow X\}</fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex>\operatorname{Spec}(S) \hookrightarrow X</fr:tex>, using <fr:link
href="algm-0016.xml"
type="local"
addr="algm-0016">Nike’s trick</fr:link>, we see that the intersection with <fr:tex>\operatorname{Spec}(R_i)</fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex>\operatorname{Spec}(S) \hookrightarrow X</fr:tex> with the said property, and therefore itself also.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3273</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0016</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex>\mathfrak{p}</fr:tex> of <fr:tex>R_1</fr:tex>. We can pick a distinguished open <fr:tex>D(f)</fr:tex> of <fr:tex>\operatorname{Spec}(R_2)</fr:tex> contained in the intersection and containing <fr:tex>\mathfrak{p}</fr:tex>, and a distinguished open <fr:tex>D(g)</fr:tex> of <fr:tex>\operatorname{Spec}(R_1)</fr:tex> contained in <fr:tex>D(f)</fr:tex> and containing <fr:tex>\mathfrak{p}</fr:tex>. Now we prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname{Spec}(R_2)</fr:tex>.
  </fr:p>

  <fr:p>
    It suffices to prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname{Spec}(R_2 [f^{-1}])</fr:tex>, since this would imply the existence of an element <fr:tex>g'/f^{n} \in R_2[f^{-1}]</fr:tex>, and we can take <fr:tex>D(g') \cap D(f) = D(g' f)</fr:tex> in <fr:tex>\operatorname{Spec}(R_2)</fr:tex>. Now there is an inclusion map <fr:tex>\operatorname{Spec}(R_2[f^{-1}]) \to \operatorname{Spec}(R_1)</fr:tex>, which amounts to a ring homomorphism <fr:tex>\varphi</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. In this case, <fr:tex>D(\varphi(g))</fr:tex> is the required distinguished open, since <fr:tex>\varphi^{-1}D(u)</fr:tex> is equal to <fr:tex>D(\varphi(u))</fr:tex> in <fr:tex>\operatorname{Spec}(R_2 [f^{-1}])</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3275</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0016</fr:addr><fr:route>algm-0016.xml</fr:route><fr:title>Nike’s trick</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The intersections of two <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine</fr:link> subschemes <fr:tex>\operatorname{Spec}(R_1), \operatorname{Spec}(R_2) \hookrightarrow X</fr:tex> can be covered by affine schemes distinguished in both of them.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1417</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0016</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex>\mathfrak{p}</fr:tex> of <fr:tex>R_1</fr:tex>. We can pick a distinguished open <fr:tex>D(f)</fr:tex> of <fr:tex>\operatorname{Spec}(R_2)</fr:tex> contained in the intersection and containing <fr:tex>\mathfrak{p}</fr:tex>, and a distinguished open <fr:tex>D(g)</fr:tex> of <fr:tex>\operatorname{Spec}(R_1)</fr:tex> contained in <fr:tex>D(f)</fr:tex> and containing <fr:tex>\mathfrak{p}</fr:tex>. Now we prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname{Spec}(R_2)</fr:tex>.
  </fr:p>

  <fr:p>
    It suffices to prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname{Spec}(R_2 [f^{-1}])</fr:tex>, since this would imply the existence of an element <fr:tex>g'/f^{n} \in R_2[f^{-1}]</fr:tex>, and we can take <fr:tex>D(g') \cap D(f) = D(g' f)</fr:tex> in <fr:tex>\operatorname{Spec}(R_2)</fr:tex>. Now there is an inclusion map <fr:tex>\operatorname{Spec}(R_2[f^{-1}]) \to \operatorname{Spec}(R_1)</fr:tex>, which amounts to a ring homomorphism <fr:tex>\varphi</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. In this case, <fr:tex>D(\varphi(g))</fr:tex> is the required distinguished open, since <fr:tex>\varphi^{-1}D(u)</fr:tex> is equal to <fr:tex>D(\varphi(u))</fr:tex> in <fr:tex>\operatorname{Spec}(R_2 [f^{-1}])</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3277</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0017</fr:addr><fr:route>algm-0017.xml</fr:route><fr:title>Affine local properties</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Suppose a property on affine subschemes <fr:tex>\operatorname{Spec}(R) \hookrightarrow X</fr:tex> is closed under taking distinguished subsets <fr:tex>\operatorname{Spec}(R_f) \hookrightarrow X</fr:tex>, and for <fr:tex>\gcd\{f_i\} = 1</fr:tex>, the property being true on <fr:tex>\operatorname{Spec}(R_{f_i}) \hookrightarrow X</fr:tex> implies it being true on <fr:tex>\operatorname{Spec}(R) \hookrightarrow X</fr:tex>. Then such a property is called <fr:strong>affine local</fr:strong>. We then say that <fr:tex>X</fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.
</fr:p><fr:p>
  If the property <fr:tex>P</fr:tex> only depends on <fr:tex>\operatorname{Spec}(R)</fr:tex> and not <fr:tex>X</fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex>P'</fr:tex> on schemes, which we will usually refer to as <fr:strong>locally</fr:strong> <fr:tex>P</fr:tex>. Suppose the scheme is furthermore <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex>P</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1421</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0017</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We prove that if some affine cover <fr:tex>\{\operatorname{Spec}(R_i) \hookrightarrow X\}</fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex>\operatorname{Spec}(S) \hookrightarrow X</fr:tex>, using <fr:link
href="algm-0016.xml"
type="local"
addr="algm-0016">Nike’s trick</fr:link>, we see that the intersection with <fr:tex>\operatorname{Spec}(R_i)</fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex>\operatorname{Spec}(S) \hookrightarrow X</fr:tex> with the said property, and therefore itself also.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3279</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0015</fr:addr><fr:route>algm-0015.xml</fr:route><fr:title>Irreducible space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:strong>irreducible</fr:strong> iff finitely many non-empty opens always has non-empty intersection. In other words, iff it is non-empty and cannot be written as a union of two closed sets.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3281</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0014</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We need to give a natural bijection
    <fr:tex
display="block">\hom(X, \operatorname{Spec}(R)) \cong \hom(R, {\Gamma}(\top, {\mathscr{O}}_X)).</fr:tex>
    In other words, maps <fr:tex>X \to \operatorname{Spec}(R)</fr:tex> between locally ringed spaces are uniquely specified by the action of global sections.
  </fr:p>

  <fr:p>
    Since <fr:tex>X</fr:tex> is glued from affine open subschemes, a map from <fr:tex>X</fr:tex> is equivalent to a map from each open subscheme <fr:tex>\operatorname{Spec}(S_i)</fr:tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <fr:tex>R \to S_i</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. The elements of <fr:tex>{\Gamma}(\top, {\mathscr{O}}_X)</fr:tex> are also given by a set of compatible elements from <fr:tex>S_i</fr:tex>. Hence these two sets are naturally bijective.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3283</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    To specify a point <fr:tex>P</fr:tex>, we need to specify which opens <fr:tex>D_+(f)</fr:tex> it belongs to, where <fr:tex>f</fr:tex> ranges over positively graded elements. Equivalently, we specify the closeds <fr:tex>V_+(f)</fr:tex>. Since <fr:tex>V_+(f) \cap V_+(g) \subseteq V_+(f + g)</fr:tex>, if <fr:tex>P \in V_+(f)</fr:tex> and <fr:tex>P \in V_+(g)</fr:tex> then <fr:tex>P \in V_+(f + g)</fr:tex>. Similarly since <fr:tex>V_+(f) \subseteq V_+(f g)</fr:tex>, <fr:tex>P \in V_+(f)</fr:tex> implies <fr:tex>P \in V_+(f g)</fr:tex>. Collecting all the elements whose distinguished closed contains <fr:tex>P</fr:tex>, we get an ideal <fr:tex>\mathfrak{a}</fr:tex> whose zeroth degree vanishes.
  </fr:p>

  <fr:p>
    We have <fr:tex>V_+(f g) = V_+(f) \cup V_+(g)</fr:tex>, so if <fr:tex>\mathfrak{a} \mid f g</fr:tex>, then either <fr:tex>\mathfrak{a} \mid f</fr:tex> or <fr:tex>\mathfrak{a} \mid g</fr:tex>. This is almost the condition for prime ideals, but recall that <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <fr:ref
addr="algm-0011"
href="algm-0011.xml"
taxon="Theorem"></fr:ref>.
  </fr:p>

  <fr:p>
    Next, we prove these ideals are in bijection with prime ideals not dividing <fr:tex>\mathord{\odot}</fr:tex>. One direction of the correspondence is obvious: we take a prime ideal <fr:tex>\mathfrak{p}</fr:tex> and remove the zeroth degree, which amounts to taking <fr:tex>\operatorname{lcm}(\mathfrak{p}, \mathord{\odot})</fr:tex>.
  </fr:p>

  <fr:p>
    We prove injectivity. Suppose primes <fr:tex>\mathfrak{p}</fr:tex> and <fr:tex>\mathfrak{q}</fr:tex> satisfy <fr:tex>\operatorname{lcm}(\mathfrak{p}, \mathord{\odot}) = \operatorname{lcm}(\mathfrak{q}, \mathord{\odot})</fr:tex>, then <fr:tex>\mathfrak{p} \mid \operatorname{lcm}(\mathfrak{q}, \mathord{\odot}) \mid \mathfrak{q} \cdot \mathord{\odot}</fr:tex>, so either <fr:tex>\mathfrak{p} \mid \mathord{\odot}</fr:tex> which is forbidden, or <fr:tex>\mathfrak{p} \mid \mathfrak{q}</fr:tex>. Conversely we must have <fr:tex>\mathfrak{q} \mid \mathfrak{p}</fr:tex>, hence <fr:tex>\mathfrak{p} = \mathfrak{q}</fr:tex>.
  </fr:p>

  <fr:p>
    We prove surjectivity. Given an ideal <fr:tex>\mathfrak{a}</fr:tex>, we need to supplement it with a zeroth degree component <fr:tex>\mathfrak{a}_0</fr:tex> so that together they make a prime ideal not divided by <fr:tex>\mathord{\odot}</fr:tex>. We define <fr:tex>\mathfrak{a}_0 \mid c</fr:tex> iff there exists some positively graded <fr:tex>\mathfrak{a} \nmid f</fr:tex> such that <fr:tex>\mathfrak{a} \mid cf</fr:tex>. The verification is routine element chasing.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3285</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>\operatorname{Proj}(S)</fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex>D_+ (f)</fr:tex> the affine scheme <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> (which is possible because the open subspace <fr:tex>D_+ (f)</fr:tex> is homeomorphic to <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> as a space). Given two positively graded elements <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, we have an isomorphism between <fr:tex>\operatorname{Proj}(S)</fr:tex> restricted to <fr:tex>D_+ (f g)</fr:tex> and <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> restricted to <fr:tex>D(g^{\deg f}/f^{\deg g})</fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3287</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0014</fr:addr><fr:route>algm-0014.xml</fr:route><fr:title>Adjunction of global section and <fr:tex>\operatorname{Spec}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We have an adjunction of functors <fr:tex
display="block">{\mathsf{CRing}}^{\textrm{op}} \xtofrom[{\Gamma}(\top, {\mathscr{O}}_{(-)})]{\operatorname{Spec}} {\mathsf{Sch}},</fr:tex> with <fr:tex>\operatorname{Spec}</fr:tex> being the right adjoint (or <fr:tex>\operatorname{Spec} : {\mathsf{CRing}} \to {\mathsf{Sch}}^{\textrm{op}}</fr:tex> being the left adjoint). In fact, we can replace <fr:tex>{\mathsf{Sch}}</fr:tex> with the category of <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed spaces</fr:link> <fr:tex>{\mathsf{LRS}}</fr:tex>, of whom <fr:tex>{\mathsf{Sch}}</fr:tex> is a full subcategory.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1451</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0014</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We need to give a natural bijection
    <fr:tex
display="block">\hom(X, \operatorname{Spec}(R)) \cong \hom(R, {\Gamma}(\top, {\mathscr{O}}_X)).</fr:tex>
    In other words, maps <fr:tex>X \to \operatorname{Spec}(R)</fr:tex> between locally ringed spaces are uniquely specified by the action of global sections.
  </fr:p>

  <fr:p>
    Since <fr:tex>X</fr:tex> is glued from affine open subschemes, a map from <fr:tex>X</fr:tex> is equivalent to a map from each open subscheme <fr:tex>\operatorname{Spec}(S_i)</fr:tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <fr:tex>R \to S_i</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. The elements of <fr:tex>{\Gamma}(\top, {\mathscr{O}}_X)</fr:tex> are also given by a set of compatible elements from <fr:tex>S_i</fr:tex>. Hence these two sets are naturally bijective.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3289</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0011</fr:addr><fr:route>algm-0011.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname{Proj}(S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens of the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link> <fr:tex>\operatorname{Proj}(S)</fr:tex> are in bijection with graded radical ideals with <fr:tex>\mathfrak{r}_0 = 0</fr:tex>. Hence we write <fr:tex>D_+ (\mathfrak{r})</fr:tex> for this open. The proof is exactly the same as <fr:ref
addr="algm-0008"
href="algm-0008.xml"
taxon="Theorem"></fr:ref>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3291</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>algm-000Z</fr:addr><fr:route>algm-000Z.xml</fr:route><fr:title>Geometry of graded rings</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  To define projective spaces, we start with an affine space, and restricts ourselves to regions invariant under dilation — or using the language of points, we consider lines through the origin as points. Hence we need to define how an element of a ring (which is geometrically a function on the affine space) behaves under dilation.
</fr:p><fr:p>
  In polynomial rings, for example, the polynomial <fr:tex>x^2 + 2y + 7</fr:tex> becomes <fr:tex>\lambda^2 x^2 + 2 \lambda y + 7</fr:tex> under a dilation by <fr:tex>\lambda</fr:tex>. Note how each term can be classified by the power of <fr:tex>\lambda</fr:tex> it obtains. Hence, what we need is a <fr:strong>grading</fr:strong> on the ring, which partitions <fr:tex>R = \bigoplus_d R_d</fr:tex> (as abelian groups). <fr:tex>R_d</fr:tex> is intuitively the elements that get the factor <fr:tex>\lambda^d</fr:tex> upon dilation. The multiplication of a degree <fr:tex>p</fr:tex> element with a degree <fr:tex>q</fr:tex> element should produce a degree <fr:tex>(p+q)</fr:tex> element, since <fr:tex>\lambda^p \lambda^q = \lambda^{p+q}</fr:tex>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1493</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title>Graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex>R_d</fr:tex>, where <fr:tex>d \in D</fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block">R_p \otimes R_q \to R_{p+q}</fr:tex> and a identity element <fr:tex>1 \in R_0</fr:tex> satisfying the associativity and identity laws.
</fr:p><fr:p>
  Usually, the grading is one of <fr:tex>\mathbb Z</fr:tex> or <fr:tex>\mathbb N</fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex>D^2</fr:tex> instead of <fr:tex>D</fr:tex>, whatever the context implies the grading is.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  The opens of a projective space should come from the non-vanishing region of a homogeneous function, i.e. elements with a single degree. This ensures that dilation doesn’t change the opens. However, we would have multiple ways to represent the entire space: in a two-dimensional affine space, <fr:tex>D(x) \cup D(y)</fr:tex> and <fr:tex>D(1)</fr:tex> are both invariant under dilation, but the former excludes the origin, while the latter does not. In a projective setting, we don’t care about the origin at all, and considering that all homogeneous polynomials of positive degree vanish at the origin, we should make that mandatory. Hence, we only consider the opens corresponding to positively graded elements, which we write as <fr:tex>D_+ (f)</fr:tex>. We can construct a space similar to the <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">localic spectrum of a commutative ring</fr:link>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1495</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title>Projective spectrum of a graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb N</fr:tex>-graded ring <fr:tex>S_\bullet</fr:tex>, we construct a locale analogous to <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the <fr:tex>\operatorname{Spec}</fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex>D_+ (f)</fr:tex> for each positively graded element <fr:tex>f</fr:tex>, and impose the same relations: <fr:tex>D_+</fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex>D_+ (\sum_i f_i) \subseteq \bigcup_i D_+(f_i)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As for the structure sheaf, we need to decide what the sections over <fr:tex>D_+ (f)</fr:tex> are. They should be functions defined on the affine space <fr:tex>D(f) \subseteq \operatorname{Spec}(S)</fr:tex>, but invariant under dilation. Note that it is stronger than requiring vanishing region be invariant. We actually need the grade <fr:tex>0</fr:tex> elements here. Recalling from <fr:link
href="algm-000I.xml"
type="local"
addr="algm-000I">structure sheaf of a ring spectrum</fr:link> that <fr:tex>{\Gamma}(D(f), {\mathscr{O}}_{\operatorname{Spec}(S)}) = S[f^{-1}]</fr:tex> (which can be given a canonical grading since <fr:tex>f</fr:tex> is a graded element), we can make the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1497</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title>Structure sheaf of <fr:tex>\operatorname{Proj}(S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Fix a <fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>. For a positively graded element <fr:tex>f</fr:tex>, we have a graded ring localization <fr:tex>S[f^{-1}]_\bullet</fr:tex>. Let <fr:tex>{\Gamma}(D_+(f), {\mathscr{O}})</fr:tex> be the zeroth degree component <fr:tex>S[f^{-1}]_0</fr:tex>. This defines a sheaf over the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link>, and moreover gives a <fr:link
href="algm-000R.xml"
type="local"
addr="algm-000R">scheme</fr:link> <fr:tex>\operatorname{Proj}(S)</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1465</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>\operatorname{Proj}(S)</fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex>D_+ (f)</fr:tex> the affine scheme <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> (which is possible because the open subspace <fr:tex>D_+ (f)</fr:tex> is homeomorphic to <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> as a space). Given two positively graded elements <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, we have an isomorphism between <fr:tex>\operatorname{Proj}(S)</fr:tex> restricted to <fr:tex>D_+ (f g)</fr:tex> and <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> restricted to <fr:tex>D(g^{\deg f}/f^{\deg g})</fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3293</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title>Graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex>R_d</fr:tex>, where <fr:tex>d \in D</fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block">R_p \otimes R_q \to R_{p+q}</fr:tex> and a identity element <fr:tex>1 \in R_0</fr:tex> satisfying the associativity and identity laws.
</fr:p><fr:p>
  Usually, the grading is one of <fr:tex>\mathbb Z</fr:tex> or <fr:tex>\mathbb N</fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex>D^2</fr:tex> instead of <fr:tex>D</fr:tex>, whatever the context implies the grading is.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3295</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0013</fr:addr><fr:route>algm-0013.xml</fr:route><fr:title>Irrelevant ideal</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb N</fr:tex>-<fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>, its <fr:strong>irrelevant ideal</fr:strong> <fr:tex>\mathord{\odot}</fr:tex> is defined by the subset <fr:tex>S_+</fr:tex> of all positively graded elements.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3297</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0012</fr:addr><fr:route>algm-0012.xml</fr:route><fr:title>Points of the projective spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The points of the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective scheme</fr:link> <fr:tex>\operatorname{Proj}(S)</fr:tex> are given by prime ideals not dividing the <fr:link
href="algm-0013.xml"
type="local"
addr="algm-0013">irrelevant ideal</fr:link> <fr:tex>\mathord{\odot}</fr:tex>. This is in bijection with ideals with <fr:tex>\mathfrak{p}_0 = 0</fr:tex> (equivalently <fr:tex>\mathord{\odot} \nmid \mathfrak{p}</fr:tex>), and the condition for prime ideals holds for positively graded elements, i.e. <fr:tex
display="block">\mathfrak{p} \mid x y \iff (\mathfrak{p} \mid x \lor \mathfrak{p} \mid y)</fr:tex> for positively graded <fr:tex>x</fr:tex> and <fr:tex>y</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1459</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    To specify a point <fr:tex>P</fr:tex>, we need to specify which opens <fr:tex>D_+(f)</fr:tex> it belongs to, where <fr:tex>f</fr:tex> ranges over positively graded elements. Equivalently, we specify the closeds <fr:tex>V_+(f)</fr:tex>. Since <fr:tex>V_+(f) \cap V_+(g) \subseteq V_+(f + g)</fr:tex>, if <fr:tex>P \in V_+(f)</fr:tex> and <fr:tex>P \in V_+(g)</fr:tex> then <fr:tex>P \in V_+(f + g)</fr:tex>. Similarly since <fr:tex>V_+(f) \subseteq V_+(f g)</fr:tex>, <fr:tex>P \in V_+(f)</fr:tex> implies <fr:tex>P \in V_+(f g)</fr:tex>. Collecting all the elements whose distinguished closed contains <fr:tex>P</fr:tex>, we get an ideal <fr:tex>\mathfrak{a}</fr:tex> whose zeroth degree vanishes.
  </fr:p>

  <fr:p>
    We have <fr:tex>V_+(f g) = V_+(f) \cup V_+(g)</fr:tex>, so if <fr:tex>\mathfrak{a} \mid f g</fr:tex>, then either <fr:tex>\mathfrak{a} \mid f</fr:tex> or <fr:tex>\mathfrak{a} \mid g</fr:tex>. This is almost the condition for prime ideals, but recall that <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <fr:ref
addr="algm-0011"
href="algm-0011.xml"
taxon="Theorem"></fr:ref>.
  </fr:p>

  <fr:p>
    Next, we prove these ideals are in bijection with prime ideals not dividing <fr:tex>\mathord{\odot}</fr:tex>. One direction of the correspondence is obvious: we take a prime ideal <fr:tex>\mathfrak{p}</fr:tex> and remove the zeroth degree, which amounts to taking <fr:tex>\operatorname{lcm}(\mathfrak{p}, \mathord{\odot})</fr:tex>.
  </fr:p>

  <fr:p>
    We prove injectivity. Suppose primes <fr:tex>\mathfrak{p}</fr:tex> and <fr:tex>\mathfrak{q}</fr:tex> satisfy <fr:tex>\operatorname{lcm}(\mathfrak{p}, \mathord{\odot}) = \operatorname{lcm}(\mathfrak{q}, \mathord{\odot})</fr:tex>, then <fr:tex>\mathfrak{p} \mid \operatorname{lcm}(\mathfrak{q}, \mathord{\odot}) \mid \mathfrak{q} \cdot \mathord{\odot}</fr:tex>, so either <fr:tex>\mathfrak{p} \mid \mathord{\odot}</fr:tex> which is forbidden, or <fr:tex>\mathfrak{p} \mid \mathfrak{q}</fr:tex>. Conversely we must have <fr:tex>\mathfrak{q} \mid \mathfrak{p}</fr:tex>, hence <fr:tex>\mathfrak{p} = \mathfrak{q}</fr:tex>.
  </fr:p>

  <fr:p>
    We prove surjectivity. Given an ideal <fr:tex>\mathfrak{a}</fr:tex>, we need to supplement it with a zeroth degree component <fr:tex>\mathfrak{a}_0</fr:tex> so that together they make a prime ideal not divided by <fr:tex>\mathord{\odot}</fr:tex>. We define <fr:tex>\mathfrak{a}_0 \mid c</fr:tex> iff there exists some positively graded <fr:tex>\mathfrak{a} \nmid f</fr:tex> such that <fr:tex>\mathfrak{a} \mid cf</fr:tex>. The verification is routine element chasing.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3299</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title>Projective spectrum of a graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb N</fr:tex>-graded ring <fr:tex>S_\bullet</fr:tex>, we construct a locale analogous to <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the <fr:tex>\operatorname{Spec}</fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex>D_+ (f)</fr:tex> for each positively graded element <fr:tex>f</fr:tex>, and impose the same relations: <fr:tex>D_+</fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex>D_+ (\sum_i f_i) \subseteq \bigcup_i D_+(f_i)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3301</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title>Structure sheaf of <fr:tex>\operatorname{Proj}(S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Fix a <fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>. For a positively graded element <fr:tex>f</fr:tex>, we have a graded ring localization <fr:tex>S[f^{-1}]_\bullet</fr:tex>. Let <fr:tex>{\Gamma}(D_+(f), {\mathscr{O}})</fr:tex> be the zeroth degree component <fr:tex>S[f^{-1}]_0</fr:tex>. This defines a sheaf over the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link>, and moreover gives a <fr:link
href="algm-000R.xml"
type="local"
addr="algm-000R">scheme</fr:link> <fr:tex>\operatorname{Proj}(S)</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1465</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>\operatorname{Proj}(S)</fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex>D_+ (f)</fr:tex> the affine scheme <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> (which is possible because the open subspace <fr:tex>D_+ (f)</fr:tex> is homeomorphic to <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> as a space). Given two positively graded elements <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, we have an isomorphism between <fr:tex>\operatorname{Proj}(S)</fr:tex> restricted to <fr:tex>D_+ (f g)</fr:tex> and <fr:tex>\operatorname{Spec}(S[f^{-1}]_0)</fr:tex> restricted to <fr:tex>D(g^{\deg f}/f^{\deg g})</fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3303</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given two rings <fr:tex>R</fr:tex>, <fr:tex>S</fr:tex>, a ring homomorphism <fr:tex>\varphi : S \to R</fr:tex> naturally induces a map of <fr:link
href="algm-0004.xml"
type="local"
addr="algm-0004">distinguished opens</fr:link> <fr:tex>f \mapsto \varphi(f)</fr:tex>. This is a continuous map <fr:tex>\operatorname{Spec}(R) \to \operatorname{Spec}(S)</fr:tex>, because <fr:tex>\varphi</fr:tex> preserves <fr:tex>\operatorname{lcm}</fr:tex> and <fr:tex>\gcd</fr:tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <fr:tex>{\Gamma}(D(s), {\mathscr{O}}_{\operatorname{Spec}(S)}) \to {\Gamma}(D(r), {\mathscr{O}}_{\operatorname{Spec}(R)})</fr:tex> whenever <fr:tex>D(r) \subseteq \varphi^{-1}D(s) = D(\varphi(s))</fr:tex>. This is just a homomorphism <fr:tex>S[s^{-1}] \to R[r^{-1}]</fr:tex>, which is obvious because <fr:tex>\varphi(s)</fr:tex> must be invertible in <fr:tex>R[r^{-1}]</fr:tex>.
  </fr:p>

  <fr:p>
    We need to prove our map is <fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">local</fr:link>. Using the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">characterization on stalks</fr:link>, we just need to verify that <fr:tex>S_{\varphi^{-1}(\mathfrak{p})} \to R_{\mathfrak{p}}</fr:tex> reflects invertibility. This is true by construction. Hence we have a map <fr:tex>\hom_{{\mathsf{CRing}}}(S, R) \to \hom_{{\mathsf{Sch}}}(\operatorname{Spec}(R), \operatorname{Spec}(S))</fr:tex>.
  </fr:p>

  <fr:p>
    In the reverse direction, given a morphism <fr:tex>\varphi : \operatorname{Spec}(R) \to \operatorname{Spec}(S)</fr:tex>, we can extract a ring homomorphism by looking at the global sections
    <fr:tex
display="block">S \cong {\Gamma}(\top, \varphi^{-1}{\mathscr{O}}_{\operatorname{Spec}(S)}) \to {\Gamma}(\top, {\mathscr{O}}_{\operatorname{Spec}(R)}) \cong R.</fr:tex>
    We obviously have going from <fr:tex>{\mathsf{CRing}}</fr:tex> to <fr:tex>{\mathsf{Sch}}</fr:tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:

    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cf65e16cf4b03239ee9cfe91fa803b6a"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      S &amp; R \\
      {S_{\mathfrak{q}}} &amp; {R_{\mathfrak{p}}}
      \arrow[from=1-1, to=1-2]
      \arrow[from=2-1, to=2-2]
      \arrow[two heads, from=1-1, to=2-1]
      \arrow[two heads, from=1-2, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


    where <fr:tex>\left[\mathfrak{q}\right]</fr:tex> is the image of the point <fr:tex>\left[\mathfrak{p}\right]</fr:tex> under the underlying continuous map of <fr:tex>\varphi</fr:tex>. This fixes the action of <fr:tex>\varphi</fr:tex> on the stalks. Furthermore, the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">locality</fr:link> implies the preimage of <fr:tex>\mathfrak{p}</fr:tex> under the ring homomorphism divides <fr:tex>\mathfrak{q}</fr:tex>, and since <fr:tex>\mathfrak{q}</fr:tex> is maximal in the local ring <fr:tex>S_{\mathfrak{q}}</fr:tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3305</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Note that the stalk <fr:tex>(\varphi^{-1}{\mathscr{O}}_{Y})_x = {\mathscr{O}}_{Y, \varphi(x)}</fr:tex>. A germ being invertible implies for some neighborhood <fr:tex>U</fr:tex> of <fr:tex>x</fr:tex>, it comes from an invertible section <fr:tex>f \in {\Gamma}(U, \varphi^{-1}{\mathscr{O}}_Y)</fr:tex>, so the image in <fr:tex>{\Gamma}(U, {\mathscr{O}}_X)</fr:tex> is also invertible, and hence the image germ. The locality condition gives the converse.
  </fr:p>

  <fr:p>
    On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3307</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000W</fr:addr><fr:route>algm-000W.xml</fr:route><fr:title>Action of morphisms on stalks of locally ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000S.xml"
type="local"
addr="algm-000S">morphism of ringed spaces</fr:link> <fr:tex>\varphi : X \to Y</fr:tex>, if it is <fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">local</fr:link>, a germ is invertible iff its <fr:link
href="algm-000V.xml"
type="local"
addr="algm-000V">pullback</fr:link> under <fr:tex>\varphi</fr:tex> is invertible. If the space <fr:tex>X</fr:tex> has enough points, then the inverse implication is also true.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1547</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Note that the stalk <fr:tex>(\varphi^{-1}{\mathscr{O}}_{Y})_x = {\mathscr{O}}_{Y, \varphi(x)}</fr:tex>. A germ being invertible implies for some neighborhood <fr:tex>U</fr:tex> of <fr:tex>x</fr:tex>, it comes from an invertible section <fr:tex>f \in {\Gamma}(U, \varphi^{-1}{\mathscr{O}}_Y)</fr:tex>, so the image in <fr:tex>{\Gamma}(U, {\mathscr{O}}_X)</fr:tex> is also invertible, and hence the image germ. The locality condition gives the converse.
  </fr:p>

  <fr:p>
    On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3309</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000X</fr:addr><fr:route>algm-000X.xml</fr:route><fr:title>Morphisms of affine schemes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">Morphism</fr:link> of <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine schemes</fr:link> are in natural bijection with ring homomorphisms in the opposite direction. In other words, there is a fully faithful embedding <fr:tex>{\mathsf{CRing}}^{\textrm{op}} \to {\mathsf{Sch}}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>491</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given two rings <fr:tex>R</fr:tex>, <fr:tex>S</fr:tex>, a ring homomorphism <fr:tex>\varphi : S \to R</fr:tex> naturally induces a map of <fr:link
href="algm-0004.xml"
type="local"
addr="algm-0004">distinguished opens</fr:link> <fr:tex>f \mapsto \varphi(f)</fr:tex>. This is a continuous map <fr:tex>\operatorname{Spec}(R) \to \operatorname{Spec}(S)</fr:tex>, because <fr:tex>\varphi</fr:tex> preserves <fr:tex>\operatorname{lcm}</fr:tex> and <fr:tex>\gcd</fr:tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <fr:tex>{\Gamma}(D(s), {\mathscr{O}}_{\operatorname{Spec}(S)}) \to {\Gamma}(D(r), {\mathscr{O}}_{\operatorname{Spec}(R)})</fr:tex> whenever <fr:tex>D(r) \subseteq \varphi^{-1}D(s) = D(\varphi(s))</fr:tex>. This is just a homomorphism <fr:tex>S[s^{-1}] \to R[r^{-1}]</fr:tex>, which is obvious because <fr:tex>\varphi(s)</fr:tex> must be invertible in <fr:tex>R[r^{-1}]</fr:tex>.
  </fr:p>

  <fr:p>
    We need to prove our map is <fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">local</fr:link>. Using the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">characterization on stalks</fr:link>, we just need to verify that <fr:tex>S_{\varphi^{-1}(\mathfrak{p})} \to R_{\mathfrak{p}}</fr:tex> reflects invertibility. This is true by construction. Hence we have a map <fr:tex>\hom_{{\mathsf{CRing}}}(S, R) \to \hom_{{\mathsf{Sch}}}(\operatorname{Spec}(R), \operatorname{Spec}(S))</fr:tex>.
  </fr:p>

  <fr:p>
    In the reverse direction, given a morphism <fr:tex>\varphi : \operatorname{Spec}(R) \to \operatorname{Spec}(S)</fr:tex>, we can extract a ring homomorphism by looking at the global sections
    <fr:tex
display="block">S \cong {\Gamma}(\top, \varphi^{-1}{\mathscr{O}}_{\operatorname{Spec}(S)}) \to {\Gamma}(\top, {\mathscr{O}}_{\operatorname{Spec}(R)}) \cong R.</fr:tex>
    We obviously have going from <fr:tex>{\mathsf{CRing}}</fr:tex> to <fr:tex>{\mathsf{Sch}}</fr:tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:

    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cf65e16cf4b03239ee9cfe91fa803b6a"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      S &amp; R \\
      {S_{\mathfrak{q}}} &amp; {R_{\mathfrak{p}}}
      \arrow[from=1-1, to=1-2]
      \arrow[from=2-1, to=2-2]
      \arrow[two heads, from=1-1, to=2-1]
      \arrow[two heads, from=1-2, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


    where <fr:tex>\left[\mathfrak{q}\right]</fr:tex> is the image of the point <fr:tex>\left[\mathfrak{p}\right]</fr:tex> under the underlying continuous map of <fr:tex>\varphi</fr:tex>. This fixes the action of <fr:tex>\varphi</fr:tex> on the stalks. Furthermore, the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">locality</fr:link> implies the preimage of <fr:tex>\mathfrak{p}</fr:tex> under the ring homomorphism divides <fr:tex>\mathfrak{q}</fr:tex>, and since <fr:tex>\mathfrak{q}</fr:tex> is maximal in the local ring <fr:tex>S_{\mathfrak{q}}</fr:tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3311</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000V</fr:addr><fr:route>algm-000V.xml</fr:route><fr:title>Terminology of pullbacks</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In general, a pullback is any contravariant functorial action. In other words, we have a functor <fr:tex>F : {\mathcal{C}}^{\textrm{op}} \to {\mathcal{D}}</fr:tex>, and pulling back along a morphism <fr:tex>f</fr:tex> in <fr:tex>{\mathcal{C}}</fr:tex> means the action of <fr:tex>F(f)</fr:tex>.
</fr:p><fr:p>
  In differential geometry, we have a set of <fr:tex>k</fr:tex>-forms <fr:tex>\Omega^k(M)</fr:tex>, which forms a functor <fr:tex>{\mathsf{Mfd}}^{\textrm{op}} \to {\mathsf{Set}}</fr:tex>. Pullbacks of differential forms is then the functorial action. In the special case of <fr:tex>k = 0</fr:tex>, this corresponds to composition, which is sometimes also referred to as pullbacks.
</fr:p><fr:p>
  The categorical pullback can also be construed as a contravariant action, which forms the functor from <fr:tex>{\mathcal{C}}^{\textrm{op}}</fr:tex> to the <fr:tex>2</fr:tex>-category <fr:tex>{\mathsf{Cat}}</fr:tex> given by taking slices.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3313</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000U</fr:addr><fr:route>algm-000U.xml</fr:route><fr:title>Morphism of locally ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed spaces</fr:link>, a <fr:link
href="algm-000S.xml"
type="local"
addr="algm-000S">morphism of ringed spaces</fr:link> <fr:tex>\varphi</fr:tex> between them is <fr:strong>local</fr:strong> when sections of <fr:tex>\varphi^{-1}{\mathscr{O}}_Y</fr:tex> are invertible iff their images in <fr:tex>{\mathscr{O}}_X</fr:tex> are invertible, i.e. the following diagram is a pullback:

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="198899d151858ff4911e2572bf2e6342"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
    {\varphi^{-1}{\mathscr{O}}_Y^\times} &amp; {{\mathscr{O}}_X^\times} \\
    {\varphi^{-1}{\mathscr{O}}_Y} &amp; {{\mathscr{O}}_X}
    \arrow[hook, from=1-1, to=2-1]
    \arrow[hook, from=1-2, to=2-2]
    \arrow[from=1-1, to=1-2]
    \arrow[from=2-1, to=2-2]
    \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
  \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  Note that the <fr:link
href="algm-000T.xml"
type="local"
addr="algm-000T">subsheaf of units</fr:link> is given by a finite limit, hence <fr:tex>\varphi^{-1}</fr:tex> preserves it. Since the lower map map <fr:tex>\varphi^{-1} {\mathscr{O}}_Y \to {\mathscr{O}}_X</fr:tex> is a ring homomorphism on the sections, it maps units to units. Hence restriction to the upper map makes sense.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3315</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000T</fr:addr><fr:route>algm-000T.xml</fr:route><fr:title>Subsheaf of units</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a sheaf <fr:tex>{\mathscr{O}}</fr:tex> of rings, we can define a subsheaf <fr:tex>{\mathscr{O}}^\times</fr:tex> consisting of the invertible elements, i.e. <fr:tex>{\Gamma}(U, {\mathscr{O}}^\times) = {\Gamma}(U, {\mathscr{O}})^\times</fr:tex>. This is the <fr:strong>subsheaf of units</fr:strong>.
</fr:p><fr:p>
  This can be equivalently expressed as a pullback of <fr:tex>{\mathscr{O}} \times {\mathscr{O}} \xrightarrow{(f,g) \mapsto f g} {\mathscr{O}}</fr:tex> and <fr:tex>1 \xrightarrow{1} {\mathscr{O}}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3317</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Q</fr:addr><fr:route>algm-000Q.xml</fr:route><fr:title>Affine scheme</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>affine scheme</fr:strong> is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> of the form <fr:tex>\operatorname{Spec}(R)</fr:tex> for some commutative ring <fr:tex>R</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3319</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>algm-000O</fr:addr><fr:route>algm-000O.xml</fr:route><fr:title>Locally ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locality</fr:link> requirement for a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link> is to guarantee that the sections behave like functions valued in some field.
</fr:p><fr:p>
  It is impossible in general to discuss the vanishing region of a section <fr:tex>f \in {\Gamma}(U, {\mathscr{O}})</fr:tex>. For instance, the germs of continuous functions are non-zero on their support, which is the closure of the non-vanishing region. In algebraic geometry, such an overspill destroys most valuable information. We can talk about the maximal region on which the section is invertible, but this is different from being non-zero if sections don’t behave like functions. Similarly, it is also impossible to discuss the value of a section at some point in general. In locally ringed space, we have <fr:ref
addr="algm-000P"
href="algm-000P.xml"
taxon="Definition"></fr:ref>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3321</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000S</fr:addr><fr:route>algm-000S.xml</fr:route><fr:title>Morphism of ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed spaces</fr:link> <fr:tex>X, Y</fr:tex>, a morphism <fr:tex>\varphi : X \to Y</fr:tex> is given by a continuous map of the underlying spaces, and a sheaf morphism <fr:tex>\varphi^{-1} {\mathscr{O}}_Y \to {\mathscr{O}}_X</fr:tex>, equivalently <fr:tex>{\mathscr{O}}_Y \to \varphi_* {\mathscr{O}}_X</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3323</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000R</fr:addr><fr:route>algm-000R.xml</fr:route><fr:title>Scheme</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>scheme</fr:strong> is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> with an open covering on which the space is isomorphic to <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine schemes</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3325</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000P</fr:addr><fr:route>algm-000P.xml</fr:route><fr:title>Value of section at a point</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> and a section <fr:tex>f \in {\Gamma}(U, {\mathscr{O}})</fr:tex>, the germ of <fr:tex>f</fr:tex> at a point is an element of a local ring. The image of this element in the residue field, i.e. the quotient by the unique maximal ideal is called the <fr:strong>value</fr:strong> of this section at this point.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3327</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000N</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.
  </fr:p>

  <fr:p>
    In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We take a directed limit. The elements are from some <fr:tex>R[f^{-1}]</fr:tex> with <fr:tex>\mathfrak{p} \nmid f</fr:tex>, i.e. the elements can be written as <fr:tex>g/f^n</fr:tex>. Two elements are equal iff their common restriction to some <fr:tex>D(f)</fr:tex> is equal, i.e. <fr:tex>g_1/f_1^n = g_2/f_2^m</fr:tex> iff <fr:tex>(g_1 f_2^m - g_2 f_1^n) f^k = 0</fr:tex>. These are exactly the definition of the localization away from <fr:tex>\mathfrak{p}</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3331</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000L</fr:addr><fr:route>algm-000L.xml</fr:route><fr:title>Locally ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link>, i.e. a space <fr:tex>X</fr:tex> with a sheaf of rings <fr:tex>{\mathscr{O}}</fr:tex>, it is said to be <fr:strong>locally ringed</fr:strong> iff the following conditions hold.
</fr:p><fr:ul><fr:li>If <fr:tex>{\Gamma}(U, {\mathscr{O}}) = 0</fr:tex>, then <fr:tex>U</fr:tex> is empty.</fr:li>
  <fr:li>Suppose <fr:tex>f + g \in {\Gamma}(U, {\mathscr{O}})</fr:tex> is invertible, then we can cover <fr:tex>U</fr:tex> with two open sets such that <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> are invertible when restricted respectively.</fr:li></fr:ul><fr:p>
  This can be unified as one condition: If a finite sum in <fr:tex>{\Gamma}(U, {\mathscr{O}})</fr:tex> is invertible, then each summand is invertible when restricted to an open, which jointly covers <fr:tex>U</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3333</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000M</fr:addr><fr:route>algm-000M.xml</fr:route><fr:title>Ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>ringed space</fr:strong> is a space equipped with a sheaf of rings, called the <fr:strong>structure sheaf</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3335</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000K</fr:addr><fr:route>algm-000K.xml</fr:route><fr:title>Sheaf and stalk from <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The proofs in <fr:ref
addr="algm-000I"
href="algm-000I.xml"
taxon="Definition"></fr:ref> and <fr:ref
addr="algm-000J"
href="algm-000J.xml"
taxon="Theorem"></fr:ref> do not make use of the multiplication on the numerators. Therefore they immediately generalizes to modules. In particular, we have a sheaf corresponding to an <fr:tex>R</fr:tex>-module <fr:tex>M</fr:tex>, whose sections over <fr:tex>D(f)</fr:tex> form the <fr:tex>R[f^{-1}]</fr:tex>-module <fr:tex>M[f^{-1}]</fr:tex>. The stalk on <fr:tex>\left[\mathfrak{p}\right]</fr:tex> is isomorphic to <fr:tex>M_{\left[\mathfrak{p}\right]}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3337</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000J</fr:addr><fr:route>algm-000J.xml</fr:route><fr:title>Stalk of the structure sheaf on <fr:tex>\operatorname{Spec}(R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a point <fr:tex>\left[\mathfrak{p}\right] \in \operatorname{Spec}(R)</fr:tex>, the stalk at the point is the localization <fr:tex>R_{\mathfrak{p}}</fr:tex>. In particular, the ring spectrum is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> by <fr:ref
addr="algm-000N"
href="algm-000N.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1660</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We take a directed limit. The elements are from some <fr:tex>R[f^{-1}]</fr:tex> with <fr:tex>\mathfrak{p} \nmid f</fr:tex>, i.e. the elements can be written as <fr:tex>g/f^n</fr:tex>. Two elements are equal iff their common restriction to some <fr:tex>D(f)</fr:tex> is equal, i.e. <fr:tex>g_1/f_1^n = g_2/f_2^m</fr:tex> iff <fr:tex>(g_1 f_2^m - g_2 f_1^n) f^k = 0</fr:tex>. These are exactly the definition of the localization away from <fr:tex>\mathfrak{p}</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3339</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000N</fr:addr><fr:route>algm-000N.xml</fr:route><fr:title>Stalks of locally ringed topological space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed</fr:link> topological space, it is <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed</fr:link> iff every stalk is a local ring.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1654</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000N</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.
  </fr:p>

  <fr:p>
    In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3341</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex>f_i \in R</fr:tex> such that <fr:tex>\bigcup_i D(f_i) = D(f)</fr:tex>, we need to show that
    <fr:tex
display="block">R[f^{-1}] \to \prod_{i \in I} R[f_i^{-1}] \rightrightarrows \prod_{i \ne j} R[(f_i f_j)^{-1}]</fr:tex>
    is an equalizer. Notice that <fr:tex>R[f_i^{-1}] \cong R[f^{-1}][f_i^{-1}]</fr:tex>. So we may reassign <fr:tex>S = R[f^{-1}]</fr:tex>. This simplifies the problem to
    <fr:tex
display="block">S \to \prod_{i \in I} S[f_i^{-1}] \rightrightarrows \prod_{i \ne j} S[(f_i f_j)^{-1}],</fr:tex>
    where <fr:tex>D(f_i)</fr:tex> covers the whole space <fr:tex>\operatorname{Spec}(S)</fr:tex>. 
  </fr:p>

  <fr:p>
    We first describe the intuition. Since we know <fr:tex>\operatorname{Spec}(S)</fr:tex> is <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex>g_i/f_i^{d_i} \in S[f_i^{-1}]</fr:tex> that are equal in their common domain. Since <fr:tex>D(f_i) = D(f_i^{d_i})</fr:tex> covers <fr:tex>\operatorname{Spec}(S)</fr:tex>, we have a linear combination <fr:tex>1 = \sum_i c_i f_i^{d_i}</fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex>f</fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block">\begin{aligned}       f &amp;= \sum_{i \in I} c_i f_i^{d_i} f \\       &amp;= \sum c_i f_i^{d_i} \frac{g_i}{f_i^{d_i}} \\       &amp;= \sum c_i g_i.     \end{aligned}</fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.
  </fr:p>

  <fr:p>
    Suppose there are elements <fr:tex>g_i/f_i^d \in S[f_i^{-1}]</fr:tex>, where we are allowed to use a single exponent <fr:tex>d</fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block">(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.</fr:tex> If there is a solution <fr:tex>f</fr:tex> to the gluing problem, it would need to satisfy <fr:tex>(f f_i^d - g_i) f_i^M = 0</fr:tex>. Since <fr:tex>D(f_i) = D(f_i^R)</fr:tex> covers <fr:tex>\operatorname{Spec}(S)</fr:tex>, we have a linear combination <fr:tex>1 = \sum_i c_i f_i^R</fr:tex> for large enough <fr:tex>R</fr:tex>. Hence
    <fr:tex
display="block">f = \sum_{i \in I} c_i f f_i^R = \sum c_i g_i f_i^{R-d}.</fr:tex> This uniquely determines <fr:tex>f</fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex>D(f_j)</fr:tex>, we have
    <fr:tex
display="block">\begin{aligned}       f f_j^d \cdot f_j^R &amp;= \sum c_i g_i f_i^{R-d} f_j^{R+d} \\       &amp;= \sum c_i g_j f_i^{R} f_j^{R} \\       &amp;= g_j f_j^R \cdot \sum c_i f_i^R = g_j f_j^R.     \end{aligned}</fr:tex>
    This reasoning is valid as long as <fr:tex>R &gt; N + 2d</fr:tex>.
  </fr:p>

  <fr:p>
    If there are infinitely many opens, we first use <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compactness</fr:link> to select a finite number <fr:tex>D(f_1), \dots, D(f_k)</fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex>f</fr:tex> for <fr:tex>D(f_1), \dots, D(f_k)</fr:tex>. Then consider the solution on <fr:tex>{D(f_1), \dots, D(f_k)}, D(g)</fr:tex> for every <fr:tex>g</fr:tex>. This solution must be equal to <fr:tex>f</fr:tex> by uniqueness. Therefore <fr:tex>f</fr:tex> restrict to the correct function on each <fr:tex>D(g)</fr:tex>, showing that <fr:tex>f</fr:tex> is the required solution.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3343</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Translating via <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>, we have a proper ideal <fr:tex>\mathfrak{r}</fr:tex> that cannot be written as <fr:tex>\operatorname{lcm}(\mathfrak{r}_1, \mathfrak{r}_2)</fr:tex> non-trivially. Suppose <fr:tex>\mathfrak{r} \mid f g</fr:tex>, then <fr:tex>\mathfrak{r} \mid \sqrt{f g} \mid \operatorname{lcm}(f, g)</fr:tex>. So
    <fr:tex
display="block">\begin{aligned}       \mathfrak{r} &amp;= \gcd(\mathfrak{r}, \operatorname{lcm}(f, g)) \\       &amp;= \operatorname{lcm}(\gcd(\mathfrak{r}, f), \gcd(\mathfrak{r}, g)).     \end{aligned}</fr:tex>
    Hence at least one of the two must be equal to <fr:tex>\mathfrak{r}</fr:tex>. So <fr:tex>\mathfrak{r} \mid f</fr:tex> or <fr:tex>\mathfrak{r} \mid g</fr:tex>.
  </fr:p>

  <fr:p>
    An irreducible closed is an irreducible <fr:em>component</fr:em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3345</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000H</fr:addr><fr:route>algm-000H.xml</fr:route><fr:title>Irreducible closeds in a ring spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A closed <fr:tex>V(\mathfrak{r})</fr:tex> in <fr:tex>\operatorname{Spec}(R)</fr:tex> is irreducible iff <fr:tex>\mathfrak{r}</fr:tex> is prime, and it is an irreducible component iff <fr:tex>\mathfrak{r}</fr:tex> is a minimal prime ideal, i.e. prime ideals that divide no other prime ideals.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Translating via <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>, we have a proper ideal <fr:tex>\mathfrak{r}</fr:tex> that cannot be written as <fr:tex>\operatorname{lcm}(\mathfrak{r}_1, \mathfrak{r}_2)</fr:tex> non-trivially. Suppose <fr:tex>\mathfrak{r} \mid f g</fr:tex>, then <fr:tex>\mathfrak{r} \mid \sqrt{f g} \mid \operatorname{lcm}(f, g)</fr:tex>. So
    <fr:tex
display="block">\begin{aligned}       \mathfrak{r} &amp;= \gcd(\mathfrak{r}, \operatorname{lcm}(f, g)) \\       &amp;= \operatorname{lcm}(\gcd(\mathfrak{r}, f), \gcd(\mathfrak{r}, g)).     \end{aligned}</fr:tex>
    Hence at least one of the two must be equal to <fr:tex>\mathfrak{r}</fr:tex>. So <fr:tex>\mathfrak{r} \mid f</fr:tex> or <fr:tex>\mathfrak{r} \mid g</fr:tex>.
  </fr:p>

  <fr:p>
    An irreducible closed is an irreducible <fr:em>component</fr:em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3347</fr:anchor><fr:addr>algm-000G</fr:addr><fr:route>algm-000G.xml</fr:route><fr:title>Noetherian rings and <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian spaces</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">spectrum</fr:link> of a noetherian ring is always noetherian: the closeds corresponds to radical ideals. The converse does not hold. Consider a polynomial ring with infinitely many indeterminates <fr:tex>x_1, x_2, \dots</fr:tex> quotiented by the relations <fr:tex>x_k^k = 0</fr:tex>. <fr:link
href="algm-000E.xml"
type="local"
addr="algm-000E">The ideals in the quotient ring</fr:link> correspond to ideals in the polynomial ring dividing <fr:tex>x_k^k</fr:tex> for every <fr:tex>k</fr:tex>. So there are only two radical ideals: the trivial one, and the one that divides all indeterminates, but not constants. Hence the spectrum must be a noetherian space, but the ring is obviously not noetherian since it is not finitely generated itself.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3349</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000I</fr:addr><fr:route>algm-000I.xml</fr:route><fr:title>Structure sheaf of a ring spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a sheaf <fr:tex>{\mathscr{O}}</fr:tex> of rings on <fr:tex>\operatorname{Spec}(R)</fr:tex> called the <fr:strong>structure sheaf</fr:strong>. Let <fr:tex>{\Gamma}(D(f), {\mathscr{O}}) = R[f^{-1}]</fr:tex>. Suppose <fr:tex>D(f) \subseteq D(g)</fr:tex> we define the restriction morphism to be the localization map <fr:tex>R[g^{-1}] \to R[f^{-1}]</fr:tex>, since by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref> the latter is a further localization of the former. This turns <fr:tex>\operatorname{Spec}(R)</fr:tex> into a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1487</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex>f_i \in R</fr:tex> such that <fr:tex>\bigcup_i D(f_i) = D(f)</fr:tex>, we need to show that
    <fr:tex
display="block">R[f^{-1}] \to \prod_{i \in I} R[f_i^{-1}] \rightrightarrows \prod_{i \ne j} R[(f_i f_j)^{-1}]</fr:tex>
    is an equalizer. Notice that <fr:tex>R[f_i^{-1}] \cong R[f^{-1}][f_i^{-1}]</fr:tex>. So we may reassign <fr:tex>S = R[f^{-1}]</fr:tex>. This simplifies the problem to
    <fr:tex
display="block">S \to \prod_{i \in I} S[f_i^{-1}] \rightrightarrows \prod_{i \ne j} S[(f_i f_j)^{-1}],</fr:tex>
    where <fr:tex>D(f_i)</fr:tex> covers the whole space <fr:tex>\operatorname{Spec}(S)</fr:tex>. 
  </fr:p>

  <fr:p>
    We first describe the intuition. Since we know <fr:tex>\operatorname{Spec}(S)</fr:tex> is <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex>g_i/f_i^{d_i} \in S[f_i^{-1}]</fr:tex> that are equal in their common domain. Since <fr:tex>D(f_i) = D(f_i^{d_i})</fr:tex> covers <fr:tex>\operatorname{Spec}(S)</fr:tex>, we have a linear combination <fr:tex>1 = \sum_i c_i f_i^{d_i}</fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex>f</fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block">\begin{aligned}       f &amp;= \sum_{i \in I} c_i f_i^{d_i} f \\       &amp;= \sum c_i f_i^{d_i} \frac{g_i}{f_i^{d_i}} \\       &amp;= \sum c_i g_i.     \end{aligned}</fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.
  </fr:p>

  <fr:p>
    Suppose there are elements <fr:tex>g_i/f_i^d \in S[f_i^{-1}]</fr:tex>, where we are allowed to use a single exponent <fr:tex>d</fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block">(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.</fr:tex> If there is a solution <fr:tex>f</fr:tex> to the gluing problem, it would need to satisfy <fr:tex>(f f_i^d - g_i) f_i^M = 0</fr:tex>. Since <fr:tex>D(f_i) = D(f_i^R)</fr:tex> covers <fr:tex>\operatorname{Spec}(S)</fr:tex>, we have a linear combination <fr:tex>1 = \sum_i c_i f_i^R</fr:tex> for large enough <fr:tex>R</fr:tex>. Hence
    <fr:tex
display="block">f = \sum_{i \in I} c_i f f_i^R = \sum c_i g_i f_i^{R-d}.</fr:tex> This uniquely determines <fr:tex>f</fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex>D(f_j)</fr:tex>, we have
    <fr:tex
display="block">\begin{aligned}       f f_j^d \cdot f_j^R &amp;= \sum c_i g_i f_i^{R-d} f_j^{R+d} \\       &amp;= \sum c_i g_j f_i^{R} f_j^{R} \\       &amp;= g_j f_j^R \cdot \sum c_i f_i^R = g_j f_j^R.     \end{aligned}</fr:tex>
    This reasoning is valid as long as <fr:tex>R &gt; N + 2d</fr:tex>.
  </fr:p>

  <fr:p>
    If there are infinitely many opens, we first use <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compactness</fr:link> to select a finite number <fr:tex>D(f_1), \dots, D(f_k)</fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex>f</fr:tex> for <fr:tex>D(f_1), \dots, D(f_k)</fr:tex>. Then consider the solution on <fr:tex>{D(f_1), \dots, D(f_k)}, D(g)</fr:tex> for every <fr:tex>g</fr:tex>. This solution must be equal to <fr:tex>f</fr:tex> by uniqueness. Therefore <fr:tex>f</fr:tex> restrict to the correct function on each <fr:tex>D(g)</fr:tex>, showing that <fr:tex>f</fr:tex> is the required solution.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3351</fr:anchor><fr:addr>trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title>Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  I try to adhere to several principles when composing trees.
</fr:p><fr:ul><fr:li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </fr:li>
  <fr:li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex>\mathfrak{a} \mid x</fr:tex> instead of <fr:tex>x \in \mathfrak{a}</fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex>\operatorname{Spec}(A)</fr:tex>, we do not identify them.
  </fr:li>
  <fr:li>
    Apply <fr:link
href="https://ncatlab.org/nlab/show/biased+definition"
type="external">unbiased terminology</fr:link> and <fr:link
href="https://ncatlab.org/nlab/show/negative+thinking"
type="external">negative thinking</fr:link>.
  </fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3353</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0009</fr:addr><fr:route>algm-0009.xml</fr:route><fr:title><fr:tex>\operatorname{Spec}{R}</fr:tex> is disconnected iff <fr:tex>R</fr:tex> is a product of non-zero rings</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, <fr:tex>\operatorname{Spec}{R}</fr:tex> is disconnected iff <fr:tex>R \cong R_1 \times R_2</fr:tex>, where <fr:tex>R_1, R_2</fr:tex> are non-zero commutative rings.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1770</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, if <fr:tex>\operatorname{Spec}{R}</fr:tex> is disconnected, we have two opens <fr:tex>D(\mathfrak{a})</fr:tex> and <fr:tex>D(\mathfrak{b})</fr:tex> whose intersection is empty and union is the entire space. In other words radical ideals <fr:tex>\mathfrak{a}, \mathfrak{b}</fr:tex> such that <fr:tex>\sqrt{\gcd(\mathfrak{a}, \mathfrak{b})} = 1</fr:tex> (equivalent to <fr:tex>\gcd(\mathfrak{a}, \mathfrak{b}) = 1</fr:tex>) and <fr:tex>\operatorname{lcm}(\mathfrak{a}, \mathfrak{b}) = 0</fr:tex>. We have <fr:tex>\mathfrak{a} \mid a</fr:tex> and <fr:tex>\mathfrak{b} \mid b</fr:tex> such that <fr:tex>a + b = 1</fr:tex>. But <fr:tex>\operatorname{lcm}(\mathfrak{a}, \mathfrak{b}) \mid a b</fr:tex>, therefore <fr:tex>a b = 0</fr:tex>. This implies <fr:tex>a(1-a) = 0</fr:tex>, or <fr:tex>a^2 = a</fr:tex>. The same goes for <fr:tex>b</fr:tex>.
  </fr:p>

  <fr:p>
    Let <fr:tex>R_1</fr:tex> be the subset of <fr:tex>R</fr:tex> consisting of multiples of <fr:tex>a</fr:tex>. It contains an identity <fr:tex>a</fr:tex>, since <fr:tex>a \cdot a x = a x</fr:tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <fr:tex>R_2</fr:tex>, the multiples of <fr:tex>b</fr:tex>. There is an obvious map <fr:tex>R_1 \times R_2 \to R</fr:tex>, given by <fr:tex>(ax, by) \mapsto ax + by</fr:tex>. This is an injection since <fr:tex>z \mapsto a z</fr:tex> recovers the first argument, and <fr:tex>z \mapsto b z</fr:tex> recovers the second. It is also a surjection because <fr:tex>z = a z + b z</fr:tex> is the image of <fr:tex>(az, bz)</fr:tex>. Hence we found an isomorphism.
  </fr:p>

  <fr:p>
    In the other direction, suppose <fr:tex>R \cong R_1 \times R_2</fr:tex>, then <fr:tex>D((1,0))</fr:tex> and <fr:tex>D((0,1))</fr:tex> separates the spectrum into two disjoint parts.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3355</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <fr:tex>\mathfrak{a}R \subseteq R</fr:tex>. We recursively produce a list of generators. Suppose we have already selected <fr:tex>f_1, \dots, f_n</fr:tex>. If this doesn’t generate <fr:tex>\mathfrak{a}R</fr:tex>, then we select another one of the lowest degree. We prove that this procedure terminates.
  </fr:p>

  <fr:p>
    Consider the initial coefficient <fr:tex>c_i</fr:tex> of <fr:tex>f_i</fr:tex>. The ideal <fr:tex>\mathfrak{c}_k</fr:tex> generated by the first <fr:tex>k</fr:tex> elements must eventually stabilize. Let’s say <fr:tex>c_{n+1} = \sum_{i=1}^n b_i c_i</fr:tex>. Then we can subtract <fr:tex>f_{n+1}</fr:tex> by suitable multiples of <fr:tex>f_1, \dots, f_n</fr:tex> to cancel the leading term. This must not belong to ideal generated by <fr:tex>f_1, \dots, f_n</fr:tex>, which contradicts our choice of generators, being of the lowest degree.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3357</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <fr:tex>Z</fr:tex> can be written as a finite union. If <fr:tex>Z</fr:tex> is irreducible then we’re done. Otherwise <fr:tex>Z = Z_1 \cup Z_2</fr:tex> is a non-trivial union of two closeds. By the induction hypothesis <fr:tex>Z_1</fr:tex> and <fr:tex>Z_2</fr:tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.
  </fr:p>

  <fr:p>
    We then prove uniqueness. Suppose
    <fr:tex
display="block">Z_1 \cup \cdots \cup Z_n = Z'_1 \cup \cdots \cup Z'_m.</fr:tex>
    Consider the intersection with <fr:tex>Z_1</fr:tex>. The left hand side collapses to <fr:tex>Z_1</fr:tex>. The right hand side becomes <fr:tex>\bigcup_{i=1}^m (Z'_i \cap Z_1)</fr:tex>. Since <fr:tex>Z_1</fr:tex> is irreducible, <fr:tex>Z'_i \cap Z_1</fr:tex> must be either <fr:tex>Z_1</fr:tex> or empty. In the former case, since <fr:tex>Z'_i</fr:tex> is also irreducible, <fr:tex>Z'_i = Z_1</fr:tex>. Therefore each <fr:tex>Z_j</fr:tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3359</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex>\bigcup_i D(f_i) = \top</fr:tex>, then there is a finite union equal to <fr:tex>\top</fr:tex>. Algebraically this means <fr:tex>\sqrt{\gcd\{f_i\}} = 1</fr:tex>, equivalently <fr:tex>\gcd\{f_i\} = 1</fr:tex>. So we have a linear combination <fr:tex>\sum_k a_k f_k = 1</fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3361</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, if <fr:tex>\operatorname{Spec}{R}</fr:tex> is disconnected, we have two opens <fr:tex>D(\mathfrak{a})</fr:tex> and <fr:tex>D(\mathfrak{b})</fr:tex> whose intersection is empty and union is the entire space. In other words radical ideals <fr:tex>\mathfrak{a}, \mathfrak{b}</fr:tex> such that <fr:tex>\sqrt{\gcd(\mathfrak{a}, \mathfrak{b})} = 1</fr:tex> (equivalent to <fr:tex>\gcd(\mathfrak{a}, \mathfrak{b}) = 1</fr:tex>) and <fr:tex>\operatorname{lcm}(\mathfrak{a}, \mathfrak{b}) = 0</fr:tex>. We have <fr:tex>\mathfrak{a} \mid a</fr:tex> and <fr:tex>\mathfrak{b} \mid b</fr:tex> such that <fr:tex>a + b = 1</fr:tex>. But <fr:tex>\operatorname{lcm}(\mathfrak{a}, \mathfrak{b}) \mid a b</fr:tex>, therefore <fr:tex>a b = 0</fr:tex>. This implies <fr:tex>a(1-a) = 0</fr:tex>, or <fr:tex>a^2 = a</fr:tex>. The same goes for <fr:tex>b</fr:tex>.
  </fr:p>

  <fr:p>
    Let <fr:tex>R_1</fr:tex> be the subset of <fr:tex>R</fr:tex> consisting of multiples of <fr:tex>a</fr:tex>. It contains an identity <fr:tex>a</fr:tex>, since <fr:tex>a \cdot a x = a x</fr:tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <fr:tex>R_2</fr:tex>, the multiples of <fr:tex>b</fr:tex>. There is an obvious map <fr:tex>R_1 \times R_2 \to R</fr:tex>, given by <fr:tex>(ax, by) \mapsto ax + by</fr:tex>. This is an injection since <fr:tex>z \mapsto a z</fr:tex> recovers the first argument, and <fr:tex>z \mapsto b z</fr:tex> recovers the second. It is also a surjection because <fr:tex>z = a z + b z</fr:tex> is the image of <fr:tex>(az, bz)</fr:tex>. Hence we found an isomorphism.
  </fr:p>

  <fr:p>
    In the other direction, suppose <fr:tex>R \cong R_1 \times R_2</fr:tex>, then <fr:tex>D((1,0))</fr:tex> and <fr:tex>D((0,1))</fr:tex> separates the spectrum into two disjoint parts.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3363</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We can first put the opens in disjunctive normal form
    <fr:tex
display="block">U = \bigcup_{i \in I} \bigcap_{j=1}^{n_i} D(f_{i, j}).</fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex>f_i = \prod_j f_{i, j}</fr:tex>, we have <fr:tex>U = \bigcup_i D(f_i)</fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex>U</fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex>D(f)</fr:tex> can be added, i.e. <fr:tex>D(f) \nsubseteq U</fr:tex>. This would uniquely determine <fr:tex>U</fr:tex>.
  </fr:p>

  <fr:p>
    Such a saturated set would have to be closed under addition since <fr:tex>D(f+g) \subseteq D(f) \cup D(g)</fr:tex>, and for the nullary case it must include <fr:tex>D(0) = \bot</fr:tex>. It also has to absorb multiplication, because <fr:tex>D(f \cdot g) \subseteq D(f)</fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex>D(\mathfrak{a})</fr:tex> for the union <fr:tex>\bigcup_{\mathfrak{a} \mid f} D(f)</fr:tex>.
  </fr:p>

  <fr:p>
    There is one last requirement we haven’t dealt with, i.e. <fr:tex>D(f \cdot g)</fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex>D(f)</fr:tex> and <fr:tex>D(g)</fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex>D(f^n) = D(f)</fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex>f \cdot g</fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, which is true.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3365</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0004</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex
display="block">D(\mathfrak{a}) = \bigcup_{\mathfrak{a} \mid f} D(f).</fr:tex> Alternatively, <fr:tex>V(\mathfrak{a}) = \bigcap_{\mathfrak{a} \mid f} V(f)</fr:tex>. Since <fr:tex>\mathfrak{a} \mid f</fr:tex> implies <fr:tex>V(\mathfrak{a}) \subseteq V(f)</fr:tex>, we have the forward inclusion. For the backwards inclusion, suppose <fr:tex>\left[\mathfrak{p}\right] \notin V(\mathfrak{a})</fr:tex>, i.e. <fr:tex>\mathfrak{p} \nmid \mathfrak{a}</fr:tex>, then by definition there is an element <fr:tex>\mathfrak{a} \mid f</fr:tex> such that <fr:tex>\mathfrak{p} \nmid f</fr:tex>, meaning that <fr:tex>\left[\mathfrak{p}\right] \notin V(f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3367</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, then <fr:tex>\mathfrak{a} \mid f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak{p} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak{a} \nmid f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak{a}</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak{d}</fr:tex> still in this set, since <fr:tex>\mathfrak{d}</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak{q}</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak{q} \nmid x, y</fr:tex> such that <fr:tex>\mathfrak{q} \mid x y</fr:tex>, then <fr:tex>\mathfrak{q}' = \gcd(\mathfrak{q}, x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak{q}</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y \mid f^n</fr:tex>, so <fr:tex>\mathfrak{q} \mid x y \mid f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3369</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000F</fr:addr><fr:route>algm-000F.xml</fr:route><fr:title>Hilbert basis theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If a commutative ring <fr:tex>R</fr:tex> is noetherian, then <fr:tex>R[x]</fr:tex> is also noetherian.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1774</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <fr:tex>\mathfrak{a}R \subseteq R</fr:tex>. We recursively produce a list of generators. Suppose we have already selected <fr:tex>f_1, \dots, f_n</fr:tex>. If this doesn’t generate <fr:tex>\mathfrak{a}R</fr:tex>, then we select another one of the lowest degree. We prove that this procedure terminates.
  </fr:p>

  <fr:p>
    Consider the initial coefficient <fr:tex>c_i</fr:tex> of <fr:tex>f_i</fr:tex>. The ideal <fr:tex>\mathfrak{c}_k</fr:tex> generated by the first <fr:tex>k</fr:tex> elements must eventually stabilize. Let’s say <fr:tex>c_{n+1} = \sum_{i=1}^n b_i c_i</fr:tex>. Then we can subtract <fr:tex>f_{n+1}</fr:tex> by suitable multiples of <fr:tex>f_1, \dots, f_n</fr:tex> to cancel the leading term. This must not belong to ideal generated by <fr:tex>f_1, \dots, f_n</fr:tex>, which contradicts our choice of generators, being of the lowest degree.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3371</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000B</fr:addr><fr:route>algm-000B.xml</fr:route><fr:title>A <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">ring spectrum</fr:link> is quasi-compact</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The space <fr:tex>\operatorname{Spec}(R)</fr:tex> is always <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1720</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex>\bigcup_i D(f_i) = \top</fr:tex>, then there is a finite union equal to <fr:tex>\top</fr:tex>. Algebraically this means <fr:tex>\sqrt{\gcd\{f_i\}} = 1</fr:tex>, equivalently <fr:tex>\gcd\{f_i\} = 1</fr:tex>. So we have a linear combination <fr:tex>\sum_k a_k f_k = 1</fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3373</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000D</fr:addr><fr:route>algm-000D.xml</fr:route><fr:title>A closed in a noetherian space is uniquely a finite union of irreducible closeds</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If <fr:tex>X</fr:tex> is a <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian space</fr:link>, then a closed <fr:tex>Z \subseteq X</fr:tex> can be written uniquely as the union of finitely many irreducible closeds.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1780</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <fr:tex>Z</fr:tex> can be written as a finite union. If <fr:tex>Z</fr:tex> is irreducible then we’re done. Otherwise <fr:tex>Z = Z_1 \cup Z_2</fr:tex> is a non-trivial union of two closeds. By the induction hypothesis <fr:tex>Z_1</fr:tex> and <fr:tex>Z_2</fr:tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.
  </fr:p>

  <fr:p>
    We then prove uniqueness. Suppose
    <fr:tex
display="block">Z_1 \cup \cdots \cup Z_n = Z'_1 \cup \cdots \cup Z'_m.</fr:tex>
    Consider the intersection with <fr:tex>Z_1</fr:tex>. The left hand side collapses to <fr:tex>Z_1</fr:tex>. The right hand side becomes <fr:tex>\bigcup_{i=1}^m (Z'_i \cap Z_1)</fr:tex>. Since <fr:tex>Z_1</fr:tex> is irreducible, <fr:tex>Z'_i \cap Z_1</fr:tex> must be either <fr:tex>Z_1</fr:tex> or empty. In the former case, since <fr:tex>Z'_i</fr:tex> is also irreducible, <fr:tex>Z'_i = Z_1</fr:tex>. Therefore each <fr:tex>Z_j</fr:tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3375</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname{Spec}(R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens in <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the locale</fr:link> <fr:tex>\operatorname{Spec}(R)</fr:tex> bijectively corresponds to radical ideals of <fr:tex>R</fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1481</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We can first put the opens in disjunctive normal form
    <fr:tex
display="block">U = \bigcup_{i \in I} \bigcap_{j=1}^{n_i} D(f_{i, j}).</fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex>f_i = \prod_j f_{i, j}</fr:tex>, we have <fr:tex>U = \bigcup_i D(f_i)</fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex>U</fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex>D(f)</fr:tex> can be added, i.e. <fr:tex>D(f) \nsubseteq U</fr:tex>. This would uniquely determine <fr:tex>U</fr:tex>.
  </fr:p>

  <fr:p>
    Such a saturated set would have to be closed under addition since <fr:tex>D(f+g) \subseteq D(f) \cup D(g)</fr:tex>, and for the nullary case it must include <fr:tex>D(0) = \bot</fr:tex>. It also has to absorb multiplication, because <fr:tex>D(f \cdot g) \subseteq D(f)</fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex>D(\mathfrak{a})</fr:tex> for the union <fr:tex>\bigcup_{\mathfrak{a} \mid f} D(f)</fr:tex>.
  </fr:p>

  <fr:p>
    There is one last requirement we haven’t dealt with, i.e. <fr:tex>D(f \cdot g)</fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex>D(f)</fr:tex> and <fr:tex>D(g)</fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex>D(f^n) = D(f)</fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex>f \cdot g</fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3377</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0004</fr:addr><fr:route>algm-0004.xml</fr:route><fr:title>Distinguished opens of <fr:tex>\operatorname{Spec}(R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We define a basis of opens on <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001"><fr:tex>\operatorname{Spec}(R)</fr:tex></fr:link> by <fr:tex>D(f)</fr:tex> for every element <fr:tex>f \in R</fr:tex>. These are called <fr:strong>distinguished opens</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1554</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0004</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex
display="block">D(\mathfrak{a}) = \bigcup_{\mathfrak{a} \mid f} D(f).</fr:tex> Alternatively, <fr:tex>V(\mathfrak{a}) = \bigcap_{\mathfrak{a} \mid f} V(f)</fr:tex>. Since <fr:tex>\mathfrak{a} \mid f</fr:tex> implies <fr:tex>V(\mathfrak{a}) \subseteq V(f)</fr:tex>, we have the forward inclusion. For the backwards inclusion, suppose <fr:tex>\left[\mathfrak{p}\right] \notin V(\mathfrak{a})</fr:tex>, i.e. <fr:tex>\mathfrak{p} \nmid \mathfrak{a}</fr:tex>, then by definition there is an element <fr:tex>\mathfrak{a} \mid f</fr:tex> such that <fr:tex>\mathfrak{p} \nmid f</fr:tex>, meaning that <fr:tex>\left[\mathfrak{p}\right] \notin V(f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3379</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000E</fr:addr><fr:route>algm-000E.xml</fr:route><fr:title>Ideals under quotient and localization</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, the ideals of <fr:tex>R/\mathfrak{a}</fr:tex> bijectively corresponds to the ideals in <fr:tex>R</fr:tex> that divides <fr:tex>\mathfrak{a}</fr:tex>. The ideals of <fr:tex>R[S^{-1}]</fr:tex> are generated by images of ideals in <fr:tex>R</fr:tex> under the localization map, written as <fr:tex>\mathfrak{b}[S^{-1}]</fr:tex>, isomorphic to <fr:tex>\mathfrak{b} \otimes_R R[S^{-1}]</fr:tex>.
</fr:p><fr:p>
  The prime ideals in <fr:tex>R</fr:tex> that doesn’t intersect <fr:tex>S</fr:tex> bijectively correspond to prime ideals in <fr:tex>R[S^{-1}]</fr:tex> via the localization map.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3381</fr:anchor><fr:addr>algm-0005</fr:addr><fr:route>algm-0005.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <fr:tex>f/g</fr:tex>, so the domain should be the non-vanishing part of <fr:tex>g</fr:tex>, which we denote as <fr:tex>D(g)</fr:tex>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1828</fr:anchor><fr:addr>algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title>Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</fr:p><fr:p>
  For example, on the space given by <fr:tex>xy = zw</fr:tex>, we can define a funtion given by <fr:tex>x/w</fr:tex>, which is equal to <fr:tex>z/y</fr:tex>. They are only jointly undefined on <fr:tex>w = z = 0</fr:tex>, but there is no single expression that achieves this.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Recognizing this, we can try to freely generate a locale using <fr:tex>D(g)</fr:tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1830</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a frame generated by the symbols <fr:tex>D(f)</fr:tex> for <fr:tex>f \in R</fr:tex>, subject to the following relations:
  <fr:tex
display="block">\begin{aligned}     D(0) &amp;= \bot \\     D(1) &amp;= \top \\     D(f \cdot g) &amp;= D(f) \cap D(g) \\     D(f + g) &amp;\subseteq D(f) \cup D(g)   \end{aligned}</fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex>\operatorname{Spec}(R)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname{Spec}(R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens in <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the locale</fr:link> <fr:tex>\operatorname{Spec}(R)</fr:tex> bijectively corresponds to radical ideals of <fr:tex>R</fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1481</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We can first put the opens in disjunctive normal form
    <fr:tex
display="block">U = \bigcup_{i \in I} \bigcap_{j=1}^{n_i} D(f_{i, j}).</fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex>f_i = \prod_j f_{i, j}</fr:tex>, we have <fr:tex>U = \bigcup_i D(f_i)</fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex>U</fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex>D(f)</fr:tex> can be added, i.e. <fr:tex>D(f) \nsubseteq U</fr:tex>. This would uniquely determine <fr:tex>U</fr:tex>.
  </fr:p>

  <fr:p>
    Such a saturated set would have to be closed under addition since <fr:tex>D(f+g) \subseteq D(f) \cup D(g)</fr:tex>, and for the nullary case it must include <fr:tex>D(0) = \bot</fr:tex>. It also has to absorb multiplication, because <fr:tex>D(f \cdot g) \subseteq D(f)</fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex>D(\mathfrak{a})</fr:tex> for the union <fr:tex>\bigcup_{\mathfrak{a} \mid f} D(f)</fr:tex>.
  </fr:p>

  <fr:p>
    There is one last requirement we haven’t dealt with, i.e. <fr:tex>D(f \cdot g)</fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex>D(f)</fr:tex> and <fr:tex>D(g)</fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex>D(f^n) = D(f)</fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex>f \cdot g</fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3383</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a frame generated by the symbols <fr:tex>D(f)</fr:tex> for <fr:tex>f \in R</fr:tex>, subject to the following relations:
  <fr:tex
display="block">\begin{aligned}     D(0) &amp;= \bot \\     D(1) &amp;= \top \\     D(f \cdot g) &amp;= D(f) \cap D(g) \\     D(f + g) &amp;\subseteq D(f) \cup D(g)   \end{aligned}</fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex>\operatorname{Spec}(R)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3385</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000C</fr:addr><fr:route>algm-000C.xml</fr:route><fr:title>Noetherian space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:strong>noetherian</fr:strong> if every descending chain of closeds, or equivalently every ascending chain of opens stabilizes. In other words, the partial order of closeds is well-founded.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3387</fr:anchor><fr:addr>algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title>Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</fr:p><fr:p>
  For example, on the space given by <fr:tex>xy = zw</fr:tex>, we can define a funtion given by <fr:tex>x/w</fr:tex>, which is equal to <fr:tex>z/y</fr:tex>. They are only jointly undefined on <fr:tex>w = z = 0</fr:tex>, but there is no single expression that achieves this.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3389</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000A</fr:addr><fr:route>algm-000A.xml</fr:route><fr:title>Terminology of compactness in algebraic geometry</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3391</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title>The radical ideal is the lcm of prime ideal divisors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any ideal <fr:tex>\mathfrak{a}</fr:tex> of a commutative ring, the radical <fr:tex>\sqrt{\mathfrak{a}}</fr:tex> is the lowest common multiple of the prime ideals <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, then <fr:tex>\mathfrak{a} \mid f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak{p} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak{a} \nmid f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak{a}</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak{d}</fr:tex> still in this set, since <fr:tex>\mathfrak{d}</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak{q}</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak{q} \nmid x, y</fr:tex> such that <fr:tex>\mathfrak{q} \mid x y</fr:tex>, then <fr:tex>\mathfrak{q}' = \gcd(\mathfrak{q}, x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak{q}</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y \mid f^n</fr:tex>, so <fr:tex>\mathfrak{q} \mid x y \mid f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3393</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0002</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex> implies <fr:tex>\sqrt{\mathfrak{p}} \mid \sqrt{\mathfrak{a}}</fr:tex>, but <fr:tex>\mathfrak{p} = \sqrt{\mathfrak{p}}</fr:tex>, we see that <fr:tex>D(\mathfrak{a}) = D(\sqrt{\mathfrak{a}})</fr:tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <fr:tex>\mathfrak{p}</fr:tex> we have <fr:tex>\mathfrak{p} \mid \mathfrak{b} \implies \mathfrak{p} \mid \mathfrak{a}</fr:tex>. We need to prove that <fr:tex>\sqrt{\mathfrak{a}} \mid f \implies \sqrt{\mathfrak{b}} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    Given <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f</fr:tex> for all prime ideals <fr:tex>\mathfrak{p} \mid \sqrt{\mathfrak{a}}</fr:tex> (which is equivalent to <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>). So we know that for all <fr:tex>\mathfrak{p} \mid \mathfrak{b}</fr:tex>, <fr:tex>\mathfrak{p} \mid f</fr:tex>. This is now purely a condition on <fr:tex>\mathfrak{b}</fr:tex>. The next lemma finishes the proof.
  </fr:p>

  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title>The radical ideal is the lcm of prime ideal divisors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any ideal <fr:tex>\mathfrak{a}</fr:tex> of a commutative ring, the radical <fr:tex>\sqrt{\mathfrak{a}}</fr:tex> is the lowest common multiple of the prime ideals <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, then <fr:tex>\mathfrak{a} \mid f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak{p} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak{a} \nmid f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak{a}</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak{d}</fr:tex> still in this set, since <fr:tex>\mathfrak{d}</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak{q}</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak{q} \nmid x, y</fr:tex> such that <fr:tex>\mathfrak{q} \mid x y</fr:tex>, then <fr:tex>\mathfrak{q}' = \gcd(\mathfrak{q}, x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak{q}</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y \mid f^n</fr:tex>, so <fr:tex>\mathfrak{q} \mid x y \mid f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3395</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0002</fr:addr><fr:route>algm-0002.xml</fr:route><fr:title>Radical ideals bijectively correspond to open sets</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an arbitrary <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link>, we have <fr:tex>D(\mathfrak{a}) = D(\sqrt{\mathfrak{a}})</fr:tex>. There is a containment of opens <fr:tex>D(\mathfrak{a}) \subseteq D(\mathfrak{b})</fr:tex> — equivalently <fr:tex>V(\mathfrak{b}) \subseteq V(\mathfrak{a})</fr:tex> — iff <fr:tex>\sqrt{\mathfrak{b}} \mid \sqrt{\mathfrak{a}}</fr:tex>, and the points contained in an open set completely determines the radical ideal.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1732</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0002</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex> implies <fr:tex>\sqrt{\mathfrak{p}} \mid \sqrt{\mathfrak{a}}</fr:tex>, but <fr:tex>\mathfrak{p} = \sqrt{\mathfrak{p}}</fr:tex>, we see that <fr:tex>D(\mathfrak{a}) = D(\sqrt{\mathfrak{a}})</fr:tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <fr:tex>\mathfrak{p}</fr:tex> we have <fr:tex>\mathfrak{p} \mid \mathfrak{b} \implies \mathfrak{p} \mid \mathfrak{a}</fr:tex>. We need to prove that <fr:tex>\sqrt{\mathfrak{a}} \mid f \implies \sqrt{\mathfrak{b}} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    Given <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f</fr:tex> for all prime ideals <fr:tex>\mathfrak{p} \mid \sqrt{\mathfrak{a}}</fr:tex> (which is equivalent to <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>). So we know that for all <fr:tex>\mathfrak{p} \mid \mathfrak{b}</fr:tex>, <fr:tex>\mathfrak{p} \mid f</fr:tex>. This is now purely a condition on <fr:tex>\mathfrak{b}</fr:tex>. The next lemma finishes the proof.
  </fr:p>

  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title>The radical ideal is the lcm of prime ideal divisors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any ideal <fr:tex>\mathfrak{a}</fr:tex> of a commutative ring, the radical <fr:tex>\sqrt{\mathfrak{a}}</fr:tex> is the lowest common multiple of the prime ideals <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt{\mathfrak{a}} \mid f</fr:tex>, then <fr:tex>\mathfrak{a} \mid f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak{p} \mid \mathfrak{a}</fr:tex>, we have <fr:tex>\mathfrak{p} \mid f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak{p} \mid f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak{a} \nmid f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak{a}</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak{d}</fr:tex> still in this set, since <fr:tex>\mathfrak{d}</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak{q}</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak{q} \nmid x, y</fr:tex> such that <fr:tex>\mathfrak{q} \mid x y</fr:tex>, then <fr:tex>\mathfrak{q}' = \gcd(\mathfrak{q}, x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak{q}</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y \mid f^n</fr:tex>, so <fr:tex>\mathfrak{q} \mid x y \mid f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3397</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0001</fr:addr><fr:route>algm-0001.xml</fr:route><fr:title>Topological spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The topological <fr:strong>spectrum</fr:strong> of a commutative ring <fr:tex>R</fr:tex>, denoted <fr:tex>\operatorname{Spec}(R)</fr:tex>, is a topological space whose points are given by prime ideals of <fr:tex>R</fr:tex>. We denote the point corresponding to <fr:tex>\mathfrak{p}</fr:tex> as <fr:tex>\left[\mathfrak{p}\right]</fr:tex>. We define an open <fr:tex>D(\mathfrak{a})</fr:tex> for each ideal <fr:tex>\mathfrak{a}</fr:tex> which contains the point <fr:tex>\left[\mathfrak{p}\right]</fr:tex> when <fr:tex>\mathfrak{p} \nmid \mathfrak{a}</fr:tex>. The corresponding closed is written as <fr:tex>V(\mathfrak{a})</fr:tex>.
</fr:p><fr:p>
  We abuse the notation and write <fr:tex>D(f)</fr:tex> for the case where <fr:tex>\mathfrak{a}</fr:tex> is generated by <fr:tex>f</fr:tex>. Similar notations apply to <fr:tex>V</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3399</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001J</fr:addr><fr:route>hmlg-001J.xml</fr:route><fr:title>Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a mathematical object <fr:tex>X</fr:tex> canonically associated with an <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective</fr:link> chain complex <fr:tex>C_\bullet (X)</fr:tex> (e.g. the <fr:link
href="hmlg-001U.xml"
type="local"
addr="hmlg-001U">normalized chain complex</fr:link> of a <fr:link
href="hmlg-001T.xml"
type="local"
addr="hmlg-001T">simplicial set</fr:link>), it is said to be equipped with the structure of <fr:strong>effective homology</fr:strong>, if we have a <fr:link
href="hmlg-001I.xml"
type="local"
addr="hmlg-001I">strong homology equivalence</fr:link> <fr:tex>C_\bullet (X) \mathbin{\Leftarrow \mkern{-13mu} \Leftrightarrow \mkern{-13mu} \Rightarrow} E_\bullet</fr:tex>, such that <fr:tex>E_\bullet</fr:tex> is <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective of finite type</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3401</fr:anchor><fr:addr>hmlg-001K</fr:addr><fr:route>hmlg-001K.xml</fr:route><fr:title>Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  This is a set of notes on effective homology and algebraic topology. Main references are <fr:link
href="constructive-homological-algebra.xml"
type="local"
addr="constructive-homological-algebra">Constructive Homological Algebra and Applications</fr:link> and <fr:link
href="discrete-vector-fields.xml"
type="local"
addr="discrete-vector-fields">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. We assume basic familiarity with the classical aspects of the theory, although there will also be links within this forest to the relevant concepts.
</fr:p><fr:ul><fr:li><fr:link
href="hmlg-0021.xml"
type="local"
addr="hmlg-0021">W-bar construction</fr:link>, simplicial principal bundles, twisted products by <fr:link
href="simplicial-objects.xml"
type="local"
addr="simplicial-objects">Simplicial objects in algebraic topology</fr:link></fr:li>
  <fr:li>classifying space, loop space</fr:li>
  <fr:li>composition of <fr:link
href="hmlg-001I.xml"
type="local"
addr="hmlg-001I">strong homology equivalence</fr:link>, tensor product, cone, bicomplex</fr:li>
  <fr:li>simplicial group, Kan complex</fr:li>
  <fr:li>organize into notes</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3403</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001I</fr:addr><fr:route>hmlg-001I.xml</fr:route><fr:title>Strong homology equivalence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>strong homology equivalence</fr:strong> between chain complexes <fr:tex>C</fr:tex> and <fr:tex>D</fr:tex> is a span of chain reductions, i.e. a third chain complex <fr:tex>X</fr:tex> with <fr:tex>X \Rightarrow\mkern{-14mu}\Rightarrow C</fr:tex> and <fr:tex>X \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex>. We denote a strong homology equivalence with <fr:tex>C \mathbin{\Leftarrow \mkern{-13mu} \Leftrightarrow \mkern{-13mu} \Rightarrow} D</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3405</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001G</fr:addr><fr:route>hmlg-001G.xml</fr:route><fr:title><fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">Perturbation</fr:link> of the larger chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a reduction <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex> and a perturbation <fr:tex>\delta_C</fr:tex> for <fr:tex>C</fr:tex>, we assume that <fr:tex>{h_{\rho}} \mathbin{\circ} \delta_C</fr:tex> is pointwise nilpotent, i.e. <fr:tex
display="block">\forall c \in C_k, \exists n \in \mathbb{N}, \; ({h_{\rho}}\delta_C)^n (c) = 0.</fr:tex> We can construct a new chain reduction <fr:tex>\rho' : C' \Rightarrow\mkern{-14mu}\Rightarrow D'</fr:tex>, where <fr:tex>C'</fr:tex> is <fr:tex>C</fr:tex> perturbed by <fr:tex>\delta_C</fr:tex>.
</fr:p><fr:p>
  Note that this situation is much harder compared to <fr:ref
addr="hmlg-001E"
href="hmlg-001E.xml"
taxon="Construction"></fr:ref>, as it is generally impossible without the added condition.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1009</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For this construction using the third equivalent definition of a chain reduction in <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>, i.e. a homotopy operator on <fr:tex>C</fr:tex> such that <fr:tex>h \mathbin{\circ} h = 0</fr:tex> and <fr:tex>h \mathbin{\circ} d_C \mathbin{\circ} h = h</fr:tex>.
  </fr:p>

  <fr:p>
    We need to construct a new homotopy operator such that <fr:tex>h' \mathbin{\circ} h' = 0</fr:tex> and <fr:tex>h' \mathbin{\circ} (d_C + \delta_C) \mathbin{\circ} h' = h'</fr:tex>. We approach this through a “perturbative” mindset. Starting with <fr:tex>h_0 = h</fr:tex>, the second equation is off by a difference of <fr:tex>h_0 \delta_C h_0</fr:tex>. We simply add this as a correction term, <fr:tex>h_1 = h_0 + \alpha h_0 \delta_C h_0</fr:tex> where <fr:tex>\alpha</fr:tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <fr:tex>h_0 \delta_C h_0 \delta_C \cdots h_0</fr:tex>, since nothing else has the same type.) We still have <fr:tex>h_1 \mathbin{\circ} h_1 = 0</fr:tex>, and for the second equation this creates a new error term
    <fr:tex
display="block">\begin{aligned}       &amp;\quad h_1 (d_C + \delta_C) h_1 - h_1 \\       &amp;= (1 + \alpha) h_0 \delta_C h_0 + 2 (\alpha + \alpha^2) h_0 \delta_C h_0 \delta_C h_0 + \alpha^2 h_0 \delta_C h_0 \delta_C h_0 \delta_C h_0     \end{aligned}</fr:tex>
    and we can eliminate the first and second order part by setting <fr:tex>\alpha = -1</fr:tex>. The natural next step would be to add a further correction <fr:tex>h_2 = h_1 + \beta h_0 \delta_C h_0 \delta_C h_0</fr:tex>. This turns out to require <fr:tex>\beta = +1</fr:tex>, and so on.
  </fr:p>

  <fr:p>
    From the informal discussion above, we can conjecture the formula
    <fr:tex
display="block">h' = \sum_{k=0}^\infty (-1)^k (h \delta_C)^k h.</fr:tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <fr:tex>h' \mathbin{\circ} h' = 0</fr:tex> from <fr:tex>h \mathbin{\circ} h = 0</fr:tex>, and the second equation follows from a nice telescopic sum
    <fr:tex
display="block">\begin{aligned}       h' \mathbin{\circ} (d_C + \delta_C) \mathbin{\circ} h'       &amp;= \sum_{i, j} (-1)^{i + j} (h \delta_C)^i h (d_C + \delta_C) (h \delta_C)^j h \\       &amp;= \sum_{i, j} (-1)^{i + j} \left[(h \delta_C)^{i + j + 1} h + (h \delta_C)^{i + j} h\right] \\       &amp;= \sum_{k} (k+1) (-1)^k \left[(h \delta_C)^{k + 1} h + (h \delta_C)^k h\right] \\       &amp;= \sum_k (-1)^k (h \delta_C)^k h = h'.     \end{aligned}</fr:tex></fr:p>

  <fr:p>
    We can reconstruct the other two components of the reduction <fr:tex>{\iota_{\rho'}}</fr:tex> and <fr:tex>{\pi_{\rho'}}</fr:tex> through <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>. In particular, <fr:tex>D'</fr:tex> is given by a perturbation of <fr:tex>D</fr:tex>. We only write down the results below for easy reference.
    <fr:tex
display="block">\begin{aligned}     {\pi_{\rho'}} &amp;= \sum_{k=0}^\infty (-1)^k {\pi_{\rho}} (\delta_C {h_{\rho}})^k \\     {\iota_{\rho'}} &amp;= \sum_{k=0}^\infty (-1)^k ({h_{\rho}} \delta_C)^k {\iota_{\rho}} \\     \delta_D &amp;= \sum_{k=0}^\infty (-1)^k {\pi_{\rho}} \delta_C ({h_{\rho}} \delta_C)^k {\iota_{\rho}}.     \end{aligned}</fr:tex></fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3407</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A chain reduction consists of maps <fr:tex>C_k \mathrel{\smash{\xtofrom[g_k]{f_k}}} D_k</fr:tex> such that <fr:tex>f_k \mathbin{\circ} g_k = {\textrm{id}}</fr:tex>. Therefore <fr:tex>C_\bullet</fr:tex> <fr:link
href="todo.xml"
type="local"
addr="todo">splits</fr:link> as <fr:tex>D_\bullet \oplus E_\bullet</fr:tex>, and the boundary maps are preserved since <fr:tex>f, g</fr:tex> are chain maps. We have a homotopy <fr:tex>h_k : D_k \oplus E_k \to D_{k+1} \oplus E_{k+1}</fr:tex>, which we may write as a <fr:tex>(2 \times 2)</fr:tex>-matrix. <fr:tex>f \mathbin{\circ} h = 0</fr:tex> demands the first row to be zero, and <fr:tex>h \mathbin{\circ} g = 0</fr:tex> requires the first column to vanish. This leaves us with
    <fr:tex
display="block">\begin{bmatrix}       0 &amp; 0 \\       0 &amp; r_k     \end{bmatrix}</fr:tex>
    such that <fr:tex>r_{k+1} \mathbin{\circ} r_k = 0</fr:tex>, since <fr:tex>h \mathbin{\circ} h = 0</fr:tex>.
  </fr:p>

  <fr:p>
    Substituting the requirement that <fr:tex>h</fr:tex> is a homotopy <fr:tex>{\textrm{id}} \to g \mathbin{\circ} f</fr:tex>, we get the equation <fr:tex
display="block">d_{k+1} \mathbin{\circ} r_k + r_{k-1} \mathbin{\circ} d_k = {\textrm{id}},</fr:tex> where <fr:tex>d</fr:tex> is the boundary operator on <fr:tex>E_\bullet</fr:tex>. In other words, <fr:tex>r</fr:tex> is a null-homotopy of <fr:tex>E_\bullet</fr:tex>, rendering it <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>. Conversely, given <fr:tex>C \cong D \oplus E</fr:tex>, we can reconstruct <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> as the projection and inclusion maps, with <fr:tex>h</fr:tex> obtained out of <fr:tex>r</fr:tex> in the manner depicted above.
  </fr:p>

  <fr:p>
    On the other hand, given only the homotopy operator, we expect to have <fr:tex>d \mathbin{\circ} h + h \mathbin{\circ} d = {\textrm{id}} - g \mathbin{\circ} f</fr:tex>. And since <fr:tex>g \mathbin{\circ} f</fr:tex> should be the projector of <fr:tex>C</fr:tex> onto the subspace <fr:tex>D</fr:tex>, <fr:tex>{\textrm{id}} - g \mathbin{\circ} f</fr:tex> should be the projector onto <fr:tex>E</fr:tex>. We are thus led to proving <fr:tex>p = d \mathbin{\circ} h + h \mathbin{\circ} d</fr:tex> is indeed a projector.
    <fr:tex
display="block">\begin{aligned}       p_k \mathbin{\circ} p_k &amp;= (d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k) \mathbin{\circ} (d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k) \\       &amp;= d_{k+1} \mathbin{\circ} \overbrace{h_k \mathbin{\circ} d_{k+1} \mathbin{\circ} h_k}^{h_k} + d_{k+1} \mathbin{\circ} \overbrace{h_k \mathbin{\circ} h_{k-1}}^{0} \mathbin{\circ} d_k \\       &amp;\qquad + h_{k-1} \mathbin{\circ} \underbrace{d_k \mathbin{\circ} d_{k+1}}_{0} \mathbin{\circ} h_k + \underbrace{h_{k-1} \mathbin{\circ} d_k \mathbin{\circ} h_{k-1}}_{h_{k-1}} \mathbin{\circ} d_k \\       &amp;= d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k = p_k.     \end{aligned}</fr:tex>
    Therefore we conclude that <fr:tex>p_k</fr:tex> splits <fr:tex>C_k \cong D_k \oplus E_k</fr:tex>. More over, <fr:tex>p \mathbin{\circ} d = d \mathbin{\circ} h \mathbin{\circ} d = d \mathbin{\circ} p</fr:tex>, meaning <fr:tex>p</fr:tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <fr:tex>h \mathbin{\circ} p = p \mathbin{\circ} h = h \mathbin{\circ} d \mathbin{\circ} h = h</fr:tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <fr:tex>E_k</fr:tex> to get a homotopy from <fr:tex>{\textrm{id}}_E</fr:tex> to <fr:tex>0</fr:tex>.
  </fr:p>

  <fr:p>
    Finally, restricting <fr:tex>h</fr:tex> onto <fr:tex>D_k</fr:tex> we see that it must be zero, since <fr:tex>h({\textrm{id}} - p) = h - h \mathbin{\circ} d \mathbin{\circ} h = 0</fr:tex>. This means that all the information of <fr:tex>h</fr:tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For this construction using the third equivalent definition of a chain reduction in <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>, i.e. a homotopy operator on <fr:tex>C</fr:tex> such that <fr:tex>h \mathbin{\circ} h = 0</fr:tex> and <fr:tex>h \mathbin{\circ} d_C \mathbin{\circ} h = h</fr:tex>.
  </fr:p>

  <fr:p>
    We need to construct a new homotopy operator such that <fr:tex>h' \mathbin{\circ} h' = 0</fr:tex> and <fr:tex>h' \mathbin{\circ} (d_C + \delta_C) \mathbin{\circ} h' = h'</fr:tex>. We approach this through a “perturbative” mindset. Starting with <fr:tex>h_0 = h</fr:tex>, the second equation is off by a difference of <fr:tex>h_0 \delta_C h_0</fr:tex>. We simply add this as a correction term, <fr:tex>h_1 = h_0 + \alpha h_0 \delta_C h_0</fr:tex> where <fr:tex>\alpha</fr:tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <fr:tex>h_0 \delta_C h_0 \delta_C \cdots h_0</fr:tex>, since nothing else has the same type.) We still have <fr:tex>h_1 \mathbin{\circ} h_1 = 0</fr:tex>, and for the second equation this creates a new error term
    <fr:tex
display="block">\begin{aligned}       &amp;\quad h_1 (d_C + \delta_C) h_1 - h_1 \\       &amp;= (1 + \alpha) h_0 \delta_C h_0 + 2 (\alpha + \alpha^2) h_0 \delta_C h_0 \delta_C h_0 + \alpha^2 h_0 \delta_C h_0 \delta_C h_0 \delta_C h_0     \end{aligned}</fr:tex>
    and we can eliminate the first and second order part by setting <fr:tex>\alpha = -1</fr:tex>. The natural next step would be to add a further correction <fr:tex>h_2 = h_1 + \beta h_0 \delta_C h_0 \delta_C h_0</fr:tex>. This turns out to require <fr:tex>\beta = +1</fr:tex>, and so on.
  </fr:p>

  <fr:p>
    From the informal discussion above, we can conjecture the formula
    <fr:tex
display="block">h' = \sum_{k=0}^\infty (-1)^k (h \delta_C)^k h.</fr:tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <fr:tex>h' \mathbin{\circ} h' = 0</fr:tex> from <fr:tex>h \mathbin{\circ} h = 0</fr:tex>, and the second equation follows from a nice telescopic sum
    <fr:tex
display="block">\begin{aligned}       h' \mathbin{\circ} (d_C + \delta_C) \mathbin{\circ} h'       &amp;= \sum_{i, j} (-1)^{i + j} (h \delta_C)^i h (d_C + \delta_C) (h \delta_C)^j h \\       &amp;= \sum_{i, j} (-1)^{i + j} \left[(h \delta_C)^{i + j + 1} h + (h \delta_C)^{i + j} h\right] \\       &amp;= \sum_{k} (k+1) (-1)^k \left[(h \delta_C)^{k + 1} h + (h \delta_C)^k h\right] \\       &amp;= \sum_k (-1)^k (h \delta_C)^k h = h'.     \end{aligned}</fr:tex></fr:p>

  <fr:p>
    We can reconstruct the other two components of the reduction <fr:tex>{\iota_{\rho'}}</fr:tex> and <fr:tex>{\pi_{\rho'}}</fr:tex> through <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>. In particular, <fr:tex>D'</fr:tex> is given by a perturbation of <fr:tex>D</fr:tex>. We only write down the results below for easy reference.
    <fr:tex
display="block">\begin{aligned}     {\pi_{\rho'}} &amp;= \sum_{k=0}^\infty (-1)^k {\pi_{\rho}} (\delta_C {h_{\rho}})^k \\     {\iota_{\rho'}} &amp;= \sum_{k=0}^\infty (-1)^k ({h_{\rho}} \delta_C)^k {\iota_{\rho}} \\     \delta_D &amp;= \sum_{k=0}^\infty (-1)^k {\pi_{\rho}} \delta_C ({h_{\rho}} \delta_C)^k {\iota_{\rho}}.     \end{aligned}</fr:tex></fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3411</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-001H</fr:addr><fr:route>hmlg-001H.xml</fr:route><fr:title>Characterization of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The following data are equivalent.
</fr:p><fr:ul><fr:li>A <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex>.</fr:li>
  <fr:li>A splitting <fr:tex>C \cong D \oplus E</fr:tex>, where <fr:tex>E</fr:tex> is a <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>.</fr:li>
  <fr:li>A <fr:link
href="hmlg-0016.xml"
type="local"
addr="hmlg-0016">chain homotopy</fr:link> <fr:tex>h : C \to C</fr:tex> satisfying <fr:tex>h \mathbin{\circ} h = 0</fr:tex> and <fr:tex>h \mathbin{\circ} d_C \mathbin{\circ} h = h</fr:tex>.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1013</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A chain reduction consists of maps <fr:tex>C_k \mathrel{\smash{\xtofrom[g_k]{f_k}}} D_k</fr:tex> such that <fr:tex>f_k \mathbin{\circ} g_k = {\textrm{id}}</fr:tex>. Therefore <fr:tex>C_\bullet</fr:tex> <fr:link
href="todo.xml"
type="local"
addr="todo">splits</fr:link> as <fr:tex>D_\bullet \oplus E_\bullet</fr:tex>, and the boundary maps are preserved since <fr:tex>f, g</fr:tex> are chain maps. We have a homotopy <fr:tex>h_k : D_k \oplus E_k \to D_{k+1} \oplus E_{k+1}</fr:tex>, which we may write as a <fr:tex>(2 \times 2)</fr:tex>-matrix. <fr:tex>f \mathbin{\circ} h = 0</fr:tex> demands the first row to be zero, and <fr:tex>h \mathbin{\circ} g = 0</fr:tex> requires the first column to vanish. This leaves us with
    <fr:tex
display="block">\begin{bmatrix}       0 &amp; 0 \\       0 &amp; r_k     \end{bmatrix}</fr:tex>
    such that <fr:tex>r_{k+1} \mathbin{\circ} r_k = 0</fr:tex>, since <fr:tex>h \mathbin{\circ} h = 0</fr:tex>.
  </fr:p>

  <fr:p>
    Substituting the requirement that <fr:tex>h</fr:tex> is a homotopy <fr:tex>{\textrm{id}} \to g \mathbin{\circ} f</fr:tex>, we get the equation <fr:tex
display="block">d_{k+1} \mathbin{\circ} r_k + r_{k-1} \mathbin{\circ} d_k = {\textrm{id}},</fr:tex> where <fr:tex>d</fr:tex> is the boundary operator on <fr:tex>E_\bullet</fr:tex>. In other words, <fr:tex>r</fr:tex> is a null-homotopy of <fr:tex>E_\bullet</fr:tex>, rendering it <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>. Conversely, given <fr:tex>C \cong D \oplus E</fr:tex>, we can reconstruct <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> as the projection and inclusion maps, with <fr:tex>h</fr:tex> obtained out of <fr:tex>r</fr:tex> in the manner depicted above.
  </fr:p>

  <fr:p>
    On the other hand, given only the homotopy operator, we expect to have <fr:tex>d \mathbin{\circ} h + h \mathbin{\circ} d = {\textrm{id}} - g \mathbin{\circ} f</fr:tex>. And since <fr:tex>g \mathbin{\circ} f</fr:tex> should be the projector of <fr:tex>C</fr:tex> onto the subspace <fr:tex>D</fr:tex>, <fr:tex>{\textrm{id}} - g \mathbin{\circ} f</fr:tex> should be the projector onto <fr:tex>E</fr:tex>. We are thus led to proving <fr:tex>p = d \mathbin{\circ} h + h \mathbin{\circ} d</fr:tex> is indeed a projector.
    <fr:tex
display="block">\begin{aligned}       p_k \mathbin{\circ} p_k &amp;= (d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k) \mathbin{\circ} (d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k) \\       &amp;= d_{k+1} \mathbin{\circ} \overbrace{h_k \mathbin{\circ} d_{k+1} \mathbin{\circ} h_k}^{h_k} + d_{k+1} \mathbin{\circ} \overbrace{h_k \mathbin{\circ} h_{k-1}}^{0} \mathbin{\circ} d_k \\       &amp;\qquad + h_{k-1} \mathbin{\circ} \underbrace{d_k \mathbin{\circ} d_{k+1}}_{0} \mathbin{\circ} h_k + \underbrace{h_{k-1} \mathbin{\circ} d_k \mathbin{\circ} h_{k-1}}_{h_{k-1}} \mathbin{\circ} d_k \\       &amp;= d_{k+1} \mathbin{\circ} h_k + h_{k-1} \mathbin{\circ} d_k = p_k.     \end{aligned}</fr:tex>
    Therefore we conclude that <fr:tex>p_k</fr:tex> splits <fr:tex>C_k \cong D_k \oplus E_k</fr:tex>. More over, <fr:tex>p \mathbin{\circ} d = d \mathbin{\circ} h \mathbin{\circ} d = d \mathbin{\circ} p</fr:tex>, meaning <fr:tex>p</fr:tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <fr:tex>h \mathbin{\circ} p = p \mathbin{\circ} h = h \mathbin{\circ} d \mathbin{\circ} h = h</fr:tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <fr:tex>E_k</fr:tex> to get a homotopy from <fr:tex>{\textrm{id}}_E</fr:tex> to <fr:tex>0</fr:tex>.
  </fr:p>

  <fr:p>
    Finally, restricting <fr:tex>h</fr:tex> onto <fr:tex>D_k</fr:tex> we see that it must be zero, since <fr:tex>h({\textrm{id}} - p) = h - h \mathbin{\circ} d \mathbin{\circ} h = 0</fr:tex>. This means that all the information of <fr:tex>h</fr:tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3413</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001E</fr:addr><fr:route>hmlg-001E.xml</fr:route><fr:title><fr:link
href="hmlg-001C.xml"
type="local"
addr="hmlg-001C">Perturbation</fr:link> of the smaller chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a reduction <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex> and a perturbation <fr:tex>\delta_D</fr:tex> for <fr:tex>D</fr:tex>, we can construct a perturbation <fr:tex>\delta_C</fr:tex> for <fr:tex>C</fr:tex>, such that the same <fr:tex>\rho</fr:tex> can serve as a reduction of the perturbed chain complexes.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1952</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Let the reduction <fr:tex>\rho</fr:tex> be made out of the three maps <fr:tex>{\pi_{\rho}} : C \to D</fr:tex>, <fr:tex>{\iota_{\rho}} : D \to C</fr:tex> and <fr:tex>{h_{\rho}} : C \to C</fr:tex>. Then since <fr:tex>C</fr:tex> splits as the direct sum of <fr:tex>D</fr:tex> and an <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">acyclic</fr:link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <fr:tex>\delta_C = {\iota_{\rho}} \mathbin{\circ} \delta_D \mathbin{\circ} {\pi_{\rho}}</fr:tex>. A quick computation shows that <fr:tex>\rho</fr:tex> is still a reduction of the perturbed chain complexes.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3415</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Let the reduction <fr:tex>\rho</fr:tex> be made out of the three maps <fr:tex>{\pi_{\rho}} : C \to D</fr:tex>, <fr:tex>{\iota_{\rho}} : D \to C</fr:tex> and <fr:tex>{h_{\rho}} : C \to C</fr:tex>. Then since <fr:tex>C</fr:tex> splits as the direct sum of <fr:tex>D</fr:tex> and an <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">acyclic</fr:link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <fr:tex>\delta_C = {\iota_{\rho}} \mathbin{\circ} \delta_D \mathbin{\circ} {\pi_{\rho}}</fr:tex>. A quick computation shows that <fr:tex>\rho</fr:tex> is still a reduction of the perturbed chain complexes.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3417</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-001B</fr:addr><fr:route>hmlg-001B.xml</fr:route><fr:title>Terminology of <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The terminology chosen here differs from that in <fr:link
href="kenzo.xml"
type="local"
addr="kenzo">Kenzo</fr:link>. What we call effective is named <fr:em>locally effective</fr:em>; and what we call effective of finite type is named <fr:em>effective</fr:em> instead.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3419</fr:anchor><fr:addr>hmlg-001D</fr:addr><fr:route>hmlg-001D.xml</fr:route><fr:title>Geometric interpretation of <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An ACC can be viewed as the algebraic distillation of a <fr:link
href="hmlg-0002.xml"
type="local"
addr="hmlg-0002">chain complex</fr:link>. The generators in dimension <fr:tex>n</fr:tex> are regarded as <fr:tex>n</fr:tex>-cells. However, we only record a formal sum of the boundaries, and forget the exact configuration. Hence, ACC is a suitable middle ground for both geometric transformations and algebraic operations.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3421</fr:anchor><fr:addr>hmlg-001F</fr:addr><fr:route>hmlg-001F.xml</fr:route><fr:title>Geometric interpretation of <fr:link
href="hmlg-001C.xml"
type="local"
addr="hmlg-001C">perturbations</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">ACCs</fr:link>, the effect of a perturbation is to “reconnect” the cells. But it may not create or delete cells, since the abelian groups are unchanged.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3423</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001C</fr:addr><fr:route>hmlg-001C.xml</fr:route><fr:title>Perturbation of chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>perturbation</fr:strong> of a chain complex with boundary operator <fr:tex>d</fr:tex> is an operator <fr:tex>\delta</fr:tex> of degree <fr:tex>(-1)</fr:tex> such that <fr:tex>d + \delta</fr:tex> also forms a boundary operator.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3425</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001A</fr:addr><fr:route>hmlg-001A.xml</fr:route><fr:title>Effective <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link>, suppose we can encode the basis sets <fr:tex>C_\bullet</fr:tex> such that they have <fr:link
href="todo.xml"
type="local"
addr="todo">decidable equality</fr:link>, and the maps <fr:tex>C_k \to \mathbb{Z}[C_{k-1}]</fr:tex> are computable, then we say the ACC is <fr:strong>effective</fr:strong>. Suppose further that <fr:tex>C_\bullet</fr:tex> are (computably) finite sets, then we say it is <fr:strong>effective of finite type</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3427</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.
  </fr:p>

  <fr:p>
    On the other hand, <fr:link
href="todo.xml"
type="local"
addr="todo">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex>f : C_\bullet \to D_\bullet</fr:tex> is a quasi-isomorphism, <fr:tex>H_n (f)</fr:tex> are all isomorphisms. Therefore <fr:tex>H_n (F(f)) = F(H_n(f))</fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3429</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0018</fr:addr><fr:route>hmlg-0018.xml</fr:route><fr:title>An additive functor is exact iff it preserves quasi-isomorphisms</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian categories</fr:link>, it is <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link> iff it sends <fr:link
href="hmlg-000C.xml"
type="local"
addr="hmlg-000C">quasi-isomorphisms</fr:link> to quasi-isomorphisms.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2038</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.
  </fr:p>

  <fr:p>
    On the other hand, <fr:link
href="todo.xml"
type="local"
addr="todo">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex>f : C_\bullet \to D_\bullet</fr:tex> is a quasi-isomorphism, <fr:tex>H_n (f)</fr:tex> are all isomorphisms. Therefore <fr:tex>H_n (F(f)) = F(H_n(f))</fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3431</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0016</fr:addr><fr:route>hmlg-0016.xml</fr:route><fr:title>Chain homotopy</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_\bullet</fr:tex> and <fr:tex>D_\bullet</fr:tex> with two <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain maps</fr:link> <fr:tex>f, g : C \to D</fr:tex> between them, a <fr:strong>chain homotopy</fr:strong> from <fr:tex>f</fr:tex> to <fr:tex>g</fr:tex> is given by a family of maps <fr:tex>h_n : C_n \to D_{n+1}</fr:tex>, such that
  <fr:tex
display="block">d_{n+1} \mathbin{\circ} h_n + h_{n-1} \mathbin{\circ} d_n = f_n - g_n.</fr:tex>
  Note that the two <fr:tex>d</fr:tex>’s denote the boundary map of different chain complexes.
</fr:p><fr:p>
  The chain homotopy can be written as <fr:tex>h : f \to g</fr:tex> or as <fr:tex>h : C \to D</fr:tex>. This causes no confusion, and the latter is convenient in situations where the maps <fr:tex>f, g</fr:tex> matter less than their difference <fr:tex>f - g</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3433</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0017</fr:addr><fr:route>hmlg-0017.xml</fr:route><fr:title>Chain reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C, D</fr:tex>, a <fr:strong>chain reduction</fr:strong> consists of a chain map <fr:tex>\pi : C \to D</fr:tex>, a chain map <fr:tex>\iota : D \to C</fr:tex> and a <fr:link
href="hmlg-0016.xml"
type="local"
addr="hmlg-0016">chain homotopy</fr:link> <fr:tex>h : {\textrm{id}} \to g \mathbin{\circ} f</fr:tex>, such that <fr:tex>\pi \mathbin{\circ} \iota = {\textrm{id}}</fr:tex>, and <fr:tex
display="block">\pi \mathbin{\circ} h = h \mathbin{\circ} \iota = h \mathbin{\circ} h = 0.</fr:tex> Here the compositions are understood to have the appropriate subscript so the degrees match.
</fr:p><fr:p>
  We write the reduction as <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex>. The three components are denoted <fr:tex>{\pi_{\rho}} : C \to D</fr:tex>, <fr:tex>{\iota_{\rho}} : D \to C</fr:tex> and <fr:tex>{h_{\rho}} : C \to C</fr:tex>, respectively.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3435</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0019</fr:addr><fr:route>hmlg-0019.xml</fr:route><fr:title>Chain reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> <fr:tex>C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex>, <fr:tex>D</fr:tex> is embedded as a subcomplex of <fr:tex>C</fr:tex>. It is cleanly separated, indicating that <fr:link
href="hmlg-001H.xml"
type="local"
addr="hmlg-001H">it is split</fr:link>. The other part of <fr:tex>C</fr:tex> is <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>, and so its homology component is drawn as empty, with the components separated.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="fd1c27ef6ebe2220f005df13d5d597c8"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
  %tex
  \begin{scope}
    \clip (-1.9, -1.4) rectangle (5.9, 1.7);
    \tikzset{every path/.style={thick}}

    \draw (-3.6,0) -- (-0.4,0) arc (0:180:1.6);
    \draw (-1.6,0) -- (1.6,0) arc (0:180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4,0) -- (3.6,0) arc (0:180:1.6);
    \draw (2.4,0) -- (5.6,0) arc (0:180:1.6);
    \draw (4.4,0) -- (7.6,0) arc (0:180:1.6);

    % arccos(1/1.6) = 51.318deg
    \draw (-1.6, -0.1) -- (-0.4, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4, -0.1) -- (1.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (2.4, -0.1) -- (3.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \draw (4.4, -0.1) -- (5.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
  \end{scope}
  \node at (2, -1.6) {\(C_n\)};
  \node at (2, 1.1) {\(H_n\)};
  \draw[thick, decoration={brace, mirror}, decorate] (-2.1, 1.6) -- node[left] {\(C_\bullet\)} (-2.1, -1.35);
  \draw[thick, decoration={brace}, decorate] (6.1, 1.6) -- node[right] {\(D_\bullet\)} (6.1, 0);
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3437</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0013</fr:addr><fr:route>hmlg-0013.xml</fr:route><fr:title>Algebraic cellular complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>algebraic cellular complex</fr:strong> (or ACC) is a <fr:link
href="hmlg-0002.xml"
type="local"
addr="hmlg-0002">chain complex</fr:link> of free abelian groups. The generators are called <fr:strong>cells</fr:strong>, and the boundary maps can be expressed using the generators as a basis, yielding the <fr:strong>incidence matrices</fr:strong>.
</fr:p><fr:p>
  More precisely, we may define an ACC as a sequence of sets <fr:tex>C_\bullet</fr:tex>, with a sequence of functions <fr:tex>d : C_k \to \mathbb{Z}[C_{k-1}]</fr:tex>, such that <fr:tex>d^2 = 0</fr:tex> is satisfied. When a generator has non-zero coefficient in some <fr:tex>d\sigma</fr:tex>, the generator is called a <fr:strong>face</fr:strong> of <fr:tex>\sigma</fr:tex>.
</fr:p><fr:p>
  Note that the generators of these chain groups are <fr:link
href="ualg-0006.xml"
type="local"
addr="ualg-0006">canonically chosen</fr:link> as part of the data. So a more accurate definition is a chain complex in the <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> of abelian groups.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3439</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0015</fr:addr><fr:route>hmlg-0015.xml</fr:route><fr:title>Filtered chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Combining <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization"></fr:ref> and <fr:ref
addr="hmlg-0014"
href="hmlg-0014.xml"
taxon="Visualization"></fr:ref>, we arrive at the following picture. Each family of colors corresponds to the filtration <fr:tex>F_\bullet C_n</fr:tex> in one dimension, and the different shades corresponds to the degree in the filtration.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="103afdf2b7bffdacb6e656d35c314f3e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
  \tikzset{every path/.style={thick, fill opacity = 0.2, line join = round}}
  \foreach \depth in {4,3,2,1} {
    \fill[blue!80!yellow] (-4,4) -- (0,0) -- ({\depth}, 0) -- ({\depth - 4}, 4) -- cycle;
    \fill[green!80!purple] (0,0) -- (4,4) -- ({\depth + 4}, 4) -- ({\depth}, 0) -- cycle;
    \fill[yellow!80!red] (4,4) -- (8,0) -- ({\depth + 8}, 0) -- ({\depth + 4}, 4) -- cycle;
  }

  \foreach \depth in {4,3,2,1} {
    \draw ({\depth - 5},4) -- ({\depth - 1},0) -- ({\depth}, 0) -- ({\depth - 4}, 4) -- cycle;
    \draw ({\depth - 1},0) -- ({\depth + 3},4) -- ({\depth + 4}, 4) -- ({\depth}, 0) -- cycle;
    \draw ({\depth + 3},4) -- ({\depth + 7},0) -- ({\depth + 8}, 0) -- ({\depth + 4}, 4) -- cycle;
  }
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  Note that we arranged so that only the higher degree (i.e. the lighter color) components may touch the lower degree components in the next dimension. So the intersection is a triangle shape instead of a complete diamond grid. This corresponds to the requirement that the boundary map sends <fr:tex>F_i C_j</fr:tex> to <fr:tex>F_i C_{j+1}</fr:tex>.
</fr:p><fr:p>
  We can see the associated spectral sequences directly from the visualization. We start with the graded components, which form strands of chain complexes. Here the second degree is highlighted.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="c5a329f6f98c72c312c75ed2b0cb087d"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
    \tikzset{every path/.style={thick, fill opacity = 0.4, line join = round}}
    \foreach \depth in {2} {
      \fill[blue!80!yellow] ({\depth - 5},4) -- ({\depth - 1},0) -- ({\depth}, 0) -- ({\depth - 4}, 4) -- cycle;
      \fill[green!80!purple] ({\depth - 1},0) -- ({\depth + 3},4) -- ({\depth + 4}, 4) -- ({\depth}, 0) -- cycle;
      \fill[yellow!80!red] ({\depth + 3},4) -- ({\depth + 7},0) -- ({\depth + 8}, 0) -- ({\depth + 4}, 4) -- cycle;
    }

    \foreach \depth in {4,3,2,1} {
      \draw ({\depth - 5},4) -- ({\depth - 1},0) -- ({\depth}, 0) -- ({\depth - 4}, 4) -- cycle;
      \draw ({\depth - 1},0) -- ({\depth + 3},4) -- ({\depth + 4}, 4) -- ({\depth}, 0) -- cycle;
      \draw ({\depth + 3},4) -- ({\depth + 7},0) -- ({\depth + 8}, 0) -- ({\depth + 4}, 4) -- cycle;
    }
  \end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  The homology chops off the intersections, and so we enter the first page of the spectral sequence, consisting of strands with the top and bottom part cut off. Repeatedly taking homology, we are finally left with the rectangular part in the middle, which is the graded components of the desired homology group of the entire complex.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3441</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0014</fr:addr><fr:route>hmlg-0014.xml</fr:route><fr:title>Filtered object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can visualize a filtered object <fr:tex>F_1 A \subseteq F_2 A \subseteq F_3 A \subseteq A</fr:tex> as nested rectangles. The graded components of this filtration are the individual rectangular regions.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="4aa6db34dc1ed2b05a4c86c08044719f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
  \tikzset{every path/.style={thick, fill = blue!80!yellow, fill opacity = 0.1}}
  \filldraw (0,-1) rectangle (4,1);
  \filldraw (0,-1) rectangle (3,1);
  \filldraw (0,-1) rectangle (2,1);
  \filldraw (0,-1) rectangle (1,1);
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3443</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-0012</fr:addr><fr:route>hmlg-0012.xml</fr:route><fr:title>Long exact sequence of homologies</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a short exact sequence of chain complexes
  <fr:tex
display="block">0 \to A_\bullet \to B_\bullet \to C_\bullet \to 0,</fr:tex>
  there is a long exact sequence of homology groups
  <fr:tex
display="block">\cdots \to H_{n+1}(C) \xrightarrow{\partial} H_n(A) \to H_n (B) \to H_n (C) \xrightarrow{\partial} H_{n-1} (A) \to \cdots</fr:tex>
  The map <fr:tex>\partial</fr:tex> here is, after unpacking some quotients, simply the boundary map <fr:tex>B_n \to B_{n-1}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3445</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0010</fr:addr><fr:route>hmlg-0010.xml</fr:route><fr:title>Snake lemma</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, given the middle two rows of the diagram
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="1acb2847a1f04e3bee79a6e62fffab2f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
    &amp; {\ker f} &amp; {\ker g} &amp; {\ker h} \\
    {\ker i} &amp; \bullet &amp; \bullet &amp; \bullet &amp; 0 \\
    0 &amp; \bullet &amp; \bullet &amp; \bullet &amp; {\operatorname{coker} j} \\
    &amp; {\operatorname{coker} f} &amp; {\operatorname{coker} g} &amp; {\operatorname{coker} h}
    \arrow["f", from=2-2, to=3-2]
    \arrow["g", from=2-3, to=3-3]
    \arrow["h", from=2-4, to=3-4]
    \arrow[from=1-2, to=2-2]
    \arrow[from=1-3, to=2-3]
    \arrow[from=1-4, to=2-4]
    \arrow[blue, &gt;-&gt;, out=90, in=180, from=2-1, to=1-2]
    \arrow[from=2-1, to=2-2]
    \arrow["i", from=2-2, to=2-3]
    \arrow[from=2-3, to=2-4]
    \arrow[from=3-2, to=3-3]
    \arrow["j", from=3-3, to=3-4]
    \arrow[from=3-4, to=3-5]
    \arrow[blue, -&gt;&gt;, out=0, in=-90, from=4-4, to=3-5]
    \arrow[from=3-2, to=4-2]
    \arrow[from=3-3, to=4-3]
    \arrow[from=3-4, to=4-4]
    \arrow[blue, from=1-2, to=1-3]
    \arrow[blue, from=1-3, to=1-4]
    \arrow[blue, from=4-2, to=4-3]
    \arrow[blue, from=4-3, to=4-4]
    \arrow[blue, dashed, out=0, in=180, from=1-4, to=4-2]
    \arrow[from=2-4, to=2-5]
    \arrow[from=3-1, to=3-2]
  \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <fr:tex>0 \to \ker i \to \ker f \to \ker g \to \ker h \xrightarrow{\partial} \operatorname{coker} f \to \operatorname{coker} g \to \operatorname{coker} h \to \operatorname{coker} j \to 0</fr:tex>. In particular, if <fr:tex>i</fr:tex> is monic and <fr:tex>j</fr:tex> is epic, this leads to a six-term exact sequence.
</fr:p><fr:p>
  There are multiple ways to prove this claim. We can first <fr:link
href="todo.xml"
type="local"
addr="todo">prove it in categories of modules</fr:link>, and <fr:link
href="hmlg-0011.xml"
type="local"
addr="hmlg-0011">use the Freyd–Mitchell embedding</fr:link>. We can also use <fr:link
href="todo.xml"
type="local"
addr="todo">pseudo-elements</fr:link> to <fr:link
href="todo.xml"
type="local"
addr="todo">perform diagram chases</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3447</fr:anchor><fr:addr>hmlg-0011</fr:addr><fr:route>hmlg-0011.xml</fr:route><fr:title>Using the <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">Freyd–Mitchell embedding</fr:link> to prove theorems</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We use the <fr:link
href="hmlg-0010.xml"
type="local"
addr="hmlg-0010">snake lemma</fr:link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.
</fr:p><fr:p>
  Suppose we have already <fr:link
href="todo.xml"
type="local"
addr="todo">proved</fr:link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> <fr:tex>{\mathcal{C}}</fr:tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <fr:tex>{\mathcal{D}}</fr:tex>, which we can embed in a module category <fr:tex>{R\text{-}{\mathsf{Mod}}}</fr:tex>.
</fr:p><fr:p>
  Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <fr:tex>{\mathcal{D}}</fr:tex> is a full abelian subcategory of <fr:tex>{R\text{-}{\mathsf{Mod}}}</fr:tex>, these morphisms are contained in <fr:tex>{\mathcal{D}}</fr:tex>, and the sequence is still exact. And since <fr:tex>{\mathcal{D}}</fr:tex> is a full abelian subcategory of <fr:tex>{\mathcal{C}}</fr:tex>, the sequence is again exact in <fr:tex>{\mathcal{C}}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3449</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>f</fr:tex> being monic is equivalent to the following square being a pullback square:
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="ad929c5530d9c44eb95094753ba26442"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      X &amp; X \\
      X &amp; Y
      \arrow["f"', from=2-1, to=2-2]
      \arrow["f", from=1-2, to=2-2]
      \arrow["{\textrm{id}}"', from=1-1, to=2-1]
      \arrow["{\textrm{id}}", from=1-1, to=1-2]
      \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span></fr:p>

  <fr:p>
    For the forward implication, we consider the diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="87d6c86cbda4c17c65fa2c9359eaea88"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      Z \\
      &amp; X &amp; X \\
      &amp; X &amp; Y
      \arrow["f"', from=3-2, to=3-3]
      \arrow["f", from=2-3, to=3-3]
      \arrow["{\textrm{id}}"', from=2-2, to=3-2]
      \arrow["{\textrm{id}}", from=2-2, to=2-3]
      \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
      \arrow[dashed, from=1-1, to=2-2]
      \arrow["g"', curve={height=6pt}, from=1-1, to=3-2]
      \arrow["h", curve={height=-6pt}, from=1-1, to=2-3]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Since <fr:tex>f</fr:tex> is mono, this diagram commutes iff <fr:tex>g = h</fr:tex>, in which case there is a unique way to fill in the dashed arrow, which is <fr:tex>g</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, if the diagram is a pullback, then for every pair of morphisms <fr:tex>g, h : Z \rightrightarrows X</fr:tex>, we can draw the diagram above, and obtain the dashed arrow <fr:tex>k : Z \to X</fr:tex>. The diagram commuting implies <fr:tex>g = {\textrm{id}} \mathbin{\circ} k = h</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3451</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3453</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3455</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3457</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>415</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>417</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3459</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3461</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3463</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3465</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Z</fr:addr><fr:route>hmlg-000Z.xml</fr:route><fr:title>Monomorphisms can be expressed using finite limits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a morphism <fr:tex>f : X \to Y</fr:tex> in an arbitrary category, we can express the condition of being monic using finite limits.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2159</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>f</fr:tex> being monic is equivalent to the following square being a pullback square:
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="ad929c5530d9c44eb95094753ba26442"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      X &amp; X \\
      X &amp; Y
      \arrow["f"', from=2-1, to=2-2]
      \arrow["f", from=1-2, to=2-2]
      \arrow["{\textrm{id}}"', from=1-1, to=2-1]
      \arrow["{\textrm{id}}", from=1-1, to=1-2]
      \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span></fr:p>

  <fr:p>
    For the forward implication, we consider the diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="87d6c86cbda4c17c65fa2c9359eaea88"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
      Z \\
      &amp; X &amp; X \\
      &amp; X &amp; Y
      \arrow["f"', from=3-2, to=3-3]
      \arrow["f", from=2-3, to=3-3]
      \arrow["{\textrm{id}}"', from=2-2, to=3-2]
      \arrow["{\textrm{id}}", from=2-2, to=2-3]
      \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
      \arrow[dashed, from=1-1, to=2-2]
      \arrow["g"', curve={height=6pt}, from=1-1, to=3-2]
      \arrow["h", curve={height=-6pt}, from=1-1, to=2-3]
    \end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Since <fr:tex>f</fr:tex> is mono, this diagram commutes iff <fr:tex>g = h</fr:tex>, in which case there is a unique way to fill in the dashed arrow, which is <fr:tex>g</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, if the diagram is a pullback, then for every pair of morphisms <fr:tex>g, h : Z \rightrightarrows X</fr:tex>, we can draw the diagram above, and obtain the dashed arrow <fr:tex>k : Z \to X</fr:tex>. The diagram commuting implies <fr:tex>g = {\textrm{id}} \mathbin{\circ} k = h</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3467</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3469</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3471</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3473</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3475</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3477</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  (TODO)
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3479</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title>Freyd–Mitchell embedding theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex>R</fr:tex>-modules for some ring <fr:tex>R</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1159</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  (TODO)
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3481</fr:anchor><fr:addr>hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>395</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y \subseteq X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0 \to C_\bullet(Y) \hookrightarrow C_\bullet(X) \to C_\bullet(X, Y) \to 0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>388</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>390</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>393</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>415</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>417</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:addr>hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title>Exactness of <fr:tex>\hom</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>\hom(P, -)</fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition"></fr:ref> it is left exact. Similarly <fr:tex>\hom(-, I)</fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex>\hom(P, -)</fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex>\hom(P, -)</fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>352</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P \to B</fr:tex> can be lifted through an epimorphism <fr:tex>A \twoheadrightarrow B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P \to A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>353</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P \to B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>356</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Dually, we have the definition of injective objects, which make <fr:tex>\hom(-, I)</fr:tex> exact.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>360</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title>Abelian groups are injective iff divisible</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An abelian group <fr:tex>G</fr:tex> is <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex>g \in G</fr:tex> and positive integer <fr:tex>n</fr:tex>, there exists a (non-unique) solution of <fr:tex>nx = g</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>344</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3483</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3485</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3487</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3489</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3491</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3493</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3495</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3497</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3499</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y \subseteq X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0 \to C_\bullet(Y) \hookrightarrow C_\bullet(X) \to C_\bullet(X, Y) \to 0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>388</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>390</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>393</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3501</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0 \to A \to B \to C \to 0.</fr:tex> The short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3503</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-000N</fr:addr><fr:route>hmlg-000N.xml</fr:route><fr:title>Signs in bicomplexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Some sources require a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> to have anti-commuting squares. In this way, the <fr:link
href="hmlg-000M.xml"
type="local"
addr="hmlg-000M">total complex</fr:link> has the simpler differential <fr:tex>\partial = d + \delta</fr:tex>. These two definitions are convertible by flipping the signs of the horizontal boundary maps in every other row.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3505</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000M</fr:addr><fr:route>hmlg-000M.xml</fr:route><fr:title>Total complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> <fr:tex>C_{\bullet, \bullet}</fr:tex>, we can collapse it into a chain complex in two ways. In either way, <fr:tex>C_{p, q}</fr:tex> is contained in the total complex at degree <fr:tex>(m+n)</fr:tex>. We can use the direct sum to combine them: <fr:tex
display="block">\operatorname{Tot}^\oplus(C)_n = \bigoplus_{n = p+q} C_{p, q},</fr:tex> or the direct product: <fr:tex
display="block">\operatorname{Tot}^\Pi(C)_n = \prod_{n=p+q} C_{p,q}.</fr:tex></fr:p><fr:p>
  The total differential acts on elements in <fr:tex>C_{p, q}</fr:tex> by <fr:tex
display="block">\partial(x) = d(x) + (-1)^q \delta(x),</fr:tex> where <fr:tex>d</fr:tex> is the vertical map, and <fr:tex>\delta</fr:tex> the horizontal map. The <fr:link
href="hmlg-000N.xml"
type="local"
addr="hmlg-000N">sign</fr:link> here is to ensure that <fr:tex>\partial^2 = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3507</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3509</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3511</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="1bc610e48445afb8a9637cc0ed34c98c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3513</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title>Chain complex of <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of <fr:tex>R</fr:tex>-modules is given by a sequence of modules <fr:tex>M_\bullet</fr:tex> together with <fr:tex>R</fr:tex>-linear maps <fr:tex>d_n : R_n \to R_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3514</fr:anchor><fr:addr>hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title>Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex>C_n</fr:tex> freely generated by cells of dimension <fr:tex>n</fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex>d_n : C_n \to C_{n-1}</fr:tex>. The critical feature of the operator is <fr:tex
display="block">d_{n-1} \mathbin{\circ} d_n = 0,</fr:tex> simply written as <fr:tex>d^2 = 0</fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2265</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title>Chain complex of abelian groups</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex>G_\bullet</fr:tex> together with homomorphisms <fr:tex>d_n : G_n \to G_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2266</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title>Chain complex of <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of <fr:tex>R</fr:tex>-modules is given by a sequence of modules <fr:tex>M_\bullet</fr:tex> together with <fr:tex>R</fr:tex>-linear maps <fr:tex>d_n : R_n \to R_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2267</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n \to C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1} \to C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0 \subseteq B_n \subseteq Z_n \subseteq C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2269</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="1bc610e48445afb8a9637cc0ed34c98c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2271</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_\bullet, D_\bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n \to D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="86a1a2daf12c432968b620ab79e2fc4c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  \cdots &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp; \cdots \\
  \cdots &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp; \cdots
  \arrow["d", from=1-3, to=1-4]
  \arrow["{f_n}"', from=1-3, to=2-3]
  \arrow["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow["d"', from=2-3, to=2-4]
  \arrow["d"', from=2-2, to=2-3]
  \arrow["d", from=1-2, to=1-3]
  \arrow[from=1-1, to=1-2]
  \arrow[from=2-1, to=2-2]
  \arrow[from=1-4, to=1-5]
  \arrow[from=2-4, to=2-5]
  \arrow["{f_{n+1}}"', from=1-2, to=2-2]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2275</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C \to D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C) \to H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f \mathbin{\circ} g</fr:tex> induces composition homomorphism <fr:tex>(f \mathbin{\circ} g)_* = f_* \mathbin{\circ} g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2273</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2277</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2279</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2281</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0 \to A \to B \to C \to 0.</fr:tex> The short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2283</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3516</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_\bullet, D_\bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n \to D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="86a1a2daf12c432968b620ab79e2fc4c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  \cdots &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp; \cdots \\
  \cdots &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp; \cdots
  \arrow["d", from=1-3, to=1-4]
  \arrow["{f_n}"', from=1-3, to=2-3]
  \arrow["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow["d"', from=2-3, to=2-4]
  \arrow["d"', from=2-2, to=2-3]
  \arrow["d", from=1-2, to=1-3]
  \arrow[from=1-1, to=1-2]
  \arrow[from=2-1, to=2-2]
  \arrow[from=1-4, to=1-5]
  \arrow[from=2-4, to=2-5]
  \arrow["{f_{n+1}}"', from=1-2, to=2-2]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3518</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C \to D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C) \to H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f \mathbin{\circ} g</fr:tex> induces composition homomorphism <fr:tex>(f \mathbin{\circ} g)_* = f_* \mathbin{\circ} g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2273</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3520</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n \to C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1} \to C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0 \subseteq B_n \subseteq Z_n \subseteq C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3522</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3524</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3526</fr:anchor><fr:addr>hmlg-0001</fr:addr><fr:route>hmlg-0001.xml</fr:route><fr:title>Homological Algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes primarily based on <fr:link
href="homological-algebra.xml"
type="local"
addr="homological-algebra">Weibel</fr:link> and <fr:link
href="wwli.xml"
type="local"
addr="wwli">Wen-Wei Li</fr:link>’s <fr:link
href="methods-of-algebra-2.xml"
type="local"
addr="methods-of-algebra-2">unpublished book</fr:link>.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2285</fr:anchor><fr:addr>hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title>Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex>C_n</fr:tex> freely generated by cells of dimension <fr:tex>n</fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex>d_n : C_n \to C_{n-1}</fr:tex>. The critical feature of the operator is <fr:tex
display="block">d_{n-1} \mathbin{\circ} d_n = 0,</fr:tex> simply written as <fr:tex>d^2 = 0</fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2265</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title>Chain complex of abelian groups</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex>G_\bullet</fr:tex> together with homomorphisms <fr:tex>d_n : G_n \to G_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2266</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title>Chain complex of <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of <fr:tex>R</fr:tex>-modules is given by a sequence of modules <fr:tex>M_\bullet</fr:tex> together with <fr:tex>R</fr:tex>-linear maps <fr:tex>d_n : R_n \to R_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2267</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n \to C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1} \to C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0 \subseteq B_n \subseteq Z_n \subseteq C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2269</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="1bc610e48445afb8a9637cc0ed34c98c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end{tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2271</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_\bullet, D_\bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n \to D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="86a1a2daf12c432968b620ab79e2fc4c"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  \cdots &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp; \cdots \\
  \cdots &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp; \cdots
  \arrow["d", from=1-3, to=1-4]
  \arrow["{f_n}"', from=1-3, to=2-3]
  \arrow["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow["d"', from=2-3, to=2-4]
  \arrow["d"', from=2-2, to=2-3]
  \arrow["d", from=1-2, to=1-3]
  \arrow[from=1-1, to=1-2]
  \arrow[from=2-1, to=2-2]
  \arrow[from=1-4, to=1-5]
  \arrow[from=2-4, to=2-5]
  \arrow["{f_{n+1}}"', from=1-2, to=2-2]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2275</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C \to D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C) \to H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f \mathbin{\circ} g</fr:tex> induces composition homomorphism <fr:tex>(f \mathbin{\circ} g)_* = f_* \mathbin{\circ} g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2273</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2277</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2279</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2281</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0 \to A \to B \to C \to 0.</fr:tex> The short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2283</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>2287</fr:anchor><fr:addr>hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>395</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{\alpha, \bullet}</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_\bullet = \bigoplus_\alpha C_{\alpha, \bullet}</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod_\alpha C_{\alpha, \bullet}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y \subseteq X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0 \to C_\bullet(Y) \hookrightarrow C_\bullet(X) \to C_\bullet(X, Y) \to 0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>388</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n} \to A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta : A_{m, n} \to A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 = \delta^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m, \bullet}</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>390</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m, \bullet}</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>393</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_\bullet : C_\bullet \to D_\bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b921c19bad8a4df5748e728001aeb54e"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
      \begin{tikzcd}
  &amp;&amp; {\operatorname{im} f} &amp; {\operatorname{coim} f} \\
  &amp; C &amp;&amp;&amp; D \\
  {\ker f} &amp;&amp;&amp;&amp;&amp; {\operatorname{coker} f}
  \arrow["\sim", from=1-3, to=1-4]
  \arrow[from=2-2, to=1-3]
  \arrow[from=1-4, to=2-5]
  \arrow[from=3-1, to=2-2]
  \arrow[from=2-5, to=3-6]
\end{tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>{\mathcal{C}}</fr:tex>, an <fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom(Y, Z) \otimes \hom(X, Y) \to \hom(X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>{\mathcal{C}}</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i \to X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} = \begin{cases}       {\textrm{id}} &amp; (i = j) \\       0 &amp; (i \ne j)     \end{cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom(X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod_i X_i \to \prod_i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod_i X_i \xrightarrow{\pi_j} X_j \xrightarrow{\iota_j} \coprod_i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>{\mathsf{Ab}}</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X \to 0 \to Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X \to Y</fr:tex>, the following composition
    <fr:tex
display="block">X \xrightarrow{\Delta} X \oplus X \xrightarrow{f \oplus g} Y \oplus Y \xrightarrow{\nabla} Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X \oplus X \to Y \oplus Y</fr:tex> is given by a <fr:tex>2 \times 2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f \oplus g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F : {\mathcal{C}} \to {\mathcal{D}}</fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom_{{\mathcal{C}}}(X, Y)</fr:tex>, i.e. it is an <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y \stackrel{\sim\,}{\to} F(X \times Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X) \times F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1) \to 1</fr:tex> and <fr:tex>F(X \times Y) \to F(X) \times F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y) \to F(X + Y) \stackrel{\sim\,}{\to} F(X \times Y) \to F(X) \times F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F \dashv G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>415</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>{\mathsf{Ab}}</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>417</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X \to Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X / \ker f</fr:tex>, and the cokernel <fr:tex>Y / \operatorname{im} f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.
</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F : {\mathcal{A}} \to {\mathcal{B}}</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0 \to A \to B \to C.</fr:tex></fr:li></fr:ul><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A \to B \to C \to 0.</fr:tex></fr:li></fr:ul><fr:p>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A \to B \to C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A \rightarrowtail B \to C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B \to C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:addr>hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title>Exactness of <fr:tex>\hom</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since <fr:tex>\hom(P, -)</fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition"></fr:ref> it is left exact. Similarly <fr:tex>\hom(-, I)</fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex>\hom(P, -)</fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex>\hom(P, -)</fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>352</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P \to B</fr:tex> can be lifted through an epimorphism <fr:tex>A \twoheadrightarrow B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P \to A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>353</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P \to B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>356</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title>Projective modules are direct summands of free modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In the <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> of modules over a ring <fr:tex>R</fr:tex>, the <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex>P \oplus Q = R^{\oplus n}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A free module evidently projective. If <fr:tex>P</fr:tex> is a direct summand of a projective module <fr:tex>Q</fr:tex>, then we can extend any map <fr:tex>P \to B</fr:tex> to <fr:tex>Q</fr:tex> by zero. Then the projectivity of <fr:tex>Q</fr:tex> implies that of <fr:tex>P</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>P</fr:tex> is projective, then we have an epimorphism <fr:tex>R^{\oplus |P|} \twoheadrightarrow P</fr:tex>. The identity map <fr:tex>P \to P</fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex>P</fr:tex> is its direct summand.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Dually, we have the definition of injective objects, which make <fr:tex>\hom(-, I)</fr:tex> exact.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title>Injective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, an object <fr:tex>I</fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex>B \to I</fr:tex> can be extended along monomorphisms <fr:tex>B \rightarrowtail A</fr:tex>. Equivalently, it is a <fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">projective object</fr:link> in the dual category.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>360</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title>Abelian groups are injective iff divisible</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An abelian group <fr:tex>G</fr:tex> is <fr:link
href="hmlg-002J.xml"
type="local"
addr="hmlg-002J">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex>g \in G</fr:tex> and positive integer <fr:tex>n</fr:tex>, there exists a (non-unique) solution of <fr:tex>nx = g</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>344</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, suppose the group is injective, then the map <fr:tex>\mathbb{Z} \to G</fr:tex> defined by <fr:tex>k \mapsto k g</fr:tex> can be extended along the monomorphism <fr:tex>(n \times -) : \mathbb{Z} \to \mathbb{Z}</fr:tex>. This provides the division.
  </fr:p>

  <fr:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex>f : A \to G</fr:tex> and an injection <fr:tex>A \hookrightarrow B</fr:tex>, we extend <fr:tex>f</fr:tex> to <fr:tex>B</fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex>f</fr:tex> to some subgroup of <fr:tex>B</fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex>f</fr:tex> is an element. Hence it has a maximal element <fr:tex>\phi</fr:tex>. Suppose it is defined on <fr:tex>B' \subsetneq B</fr:tex>, then there is an element <fr:tex>b \in B</fr:tex> not in <fr:tex>B'</fr:tex>. Suppose <fr:tex>n b \notin B'</fr:tex> for all non-zero integers <fr:tex>n</fr:tex>, then we can define a larger homomorphism on <fr:tex>B + \mathbb{Z} b</fr:tex>, contradicting the maximality. Suppose there is some <fr:tex>n b \in B'</fr:tex>, then by divisibility we can assign <fr:tex>\phi(b)</fr:tex> a division of <fr:tex>\phi(n b)</fr:tex> by <fr:tex>n</fr:tex>. This too contradicts maximality.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="true"><fr:frontmatter><fr:anchor>3528</fr:anchor><fr:addr>trebor-0001</fr:addr><fr:route>index.xml</fr:route><fr:title>Trebor’s forest</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  This is my forest, which is <fr:link
href="https://www.jonmsterling.com/jms-005P.xml"
type="external">a way of organizing notes</fr:link>. Here is <fr:link
href="https://www.jonmsterling.com/jms-009H.xml"
type="external">a list of other websites organized as forests</fr:link>. Some of the contents here:
</fr:p><fr:ul><fr:li><fr:link
href="hmlg-0001.xml"
type="local"
addr="hmlg-0001">Notes on homological algebra</fr:link></fr:li>
  <fr:li><fr:link
href="hmlg-001K.xml"
type="local"
addr="hmlg-001K">Effective homology</fr:link></fr:li>
  <fr:li>Algebraic geometry (Under namespace <fr:code>algm</fr:code>, not organized)</fr:li>
  <fr:li><fr:link
href="ualg-000H.xml"
type="local"
addr="ualg-000H">Beck monadicity theorem</fr:link></fr:li></fr:ul><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>771</fr:anchor><fr:addr>trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title>Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  I try to adhere to several principles when composing trees.
</fr:p><fr:ul><fr:li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </fr:li>
  <fr:li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex>\mathfrak{a} \mid x</fr:tex> instead of <fr:tex>x \in \mathfrak{a}</fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex>\operatorname{Spec}(A)</fr:tex>, we do not identify them.
  </fr:li>
  <fr:li>
    Apply <fr:link
href="https://ncatlab.org/nlab/show/biased+definition"
type="external">unbiased terminology</fr:link> and <fr:link
href="https://ncatlab.org/nlab/show/negative+thinking"
type="external">negative thinking</fr:link>.
  </fr:li></fr:ul></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3530</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title>Chain complex of abelian groups</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex>G_\bullet</fr:tex> together with homomorphisms <fr:tex>d_n : G_n \to G_{n-1}</fr:tex>, such that <fr:tex>d_{n-1} \mathbin{\circ} d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3531</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P \to B</fr:tex> can be lifted through an epimorphism <fr:tex>A \twoheadrightarrow B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P \to A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3532</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P \to B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3533</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>constructive-homological-algebra</fr:addr><fr:route>constructive-homological-algebra.xml</fr:route><fr:title>Constructive Homological Algebra and Applications</fr:title><fr:date><fr:year>2013</fr:year><fr:month>8</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author>Julio Rubio García and Francis Sergeraert</fr:author></fr:authors><fr:meta
name="doi">10.48550/arXiv.1208.3816</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  This text was written and used for a MAP Summer School at the University of Genova, August 28 to September 2, 2006. Available since then on the web site of the second author, it has been used and referenced by several colleagues working in Commutative Algebra and Algebraic Topology. To make safer such references, it was suggested to place it on the Arxiv repository. It is a relatively detailed exposition of the use of the <fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">Basic Perturbation Lemma</fr:link> to make constructive Homological Algebra (standard Homological Algebra is not constructive) and how this technology can be used in Commutative Algebra (Koszul complexes) and Algebraic Topology (effective versions of spectral sequences).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3535</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>discrete-vector-fields</fr:addr><fr:route>discrete-vector-fields.xml</fr:route><fr:title>Discrete Vector Fields and Fundamental Algebraic Topology</fr:title><fr:date><fr:year>2010</fr:year><fr:month>5</fr:month><fr:day>31</fr:day></fr:date><fr:authors><fr:author>Ana Romero and Francis Sergeraert</fr:author></fr:authors><fr:meta
name="doi">10.48550/arXiv.1005.5685</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  We show in this text how the most important homology equivalences of fundamental Algebraic Topology can be obtained as <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">reductions</fr:link> <fr:link
href="hmlg-001Z.xml"
type="local"
addr="hmlg-001Z">associated</fr:link> to <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector fields</fr:link>. Mainly the homology equivalences whose existence — most often non-constructive — is proved by the main spectral sequences, the Serre and Eilenberg-Moore spectral sequences. On the contrary, the constructive existence is here systematically looked for and obtained.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3537</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>homological-algebra</fr:addr><fr:route>homological-algebra.xml</fr:route><fr:title>An Introduction to Homological Algebra</fr:title><fr:date><fr:year>2008</fr:year><fr:month>10</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author>Charles Weibel</fr:author></fr:authors><fr:meta
name="doi">10.1007/b98977</fr:meta></fr:frontmatter><fr:mainmatter></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3539</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>simplicial-objects</fr:addr><fr:route>simplicial-objects.xml</fr:route><fr:title>Simplicial objects in algebraic topology</fr:title><fr:date><fr:year>1967</fr:year></fr:date><fr:authors><fr:author>Jon Peter May</fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A copy of the book can be found at <fr:link
href="https://ncatlab.org/nlab/files/May_SimplicialObjectsInAlgebraicTopology.pdf"
type="external">https://ncatlab.org/nlab/files/May_SimplicialObjectsInAlgebraicTopology.pdf</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3541</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>kenzo</fr:addr><fr:route>kenzo.xml</fr:route><fr:title>Kenzo</fr:title><fr:authors><fr:author>Julio Rubio García, Francis Sergeraert et al.</fr:author></fr:authors><fr:meta
name="external">https://github.com/gheber/kenzo</fr:meta><fr:meta
name="external">https://www-fourier.ujf-grenoble.fr/~sergerar/Kenzo/</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  Kenzo is a symbolic software for effective homology computation.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3543</fr:anchor><fr:taxon>Person</fr:taxon><fr:addr>trebor</fr:addr><fr:route>trebor.xml</fr:route><fr:title>Trebor</fr:title><fr:meta
name="institution">Tsinghua University</fr:meta><fr:meta
name="position">Bachelor Student</fr:meta><fr:meta
name="external">https://github.com/Trebor-Huang</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  My name is 黄栩 (<fr:em>Huang Xu</fr:em>), but I go by the name <fr:em>Trebor</fr:em> online. I’m interested in (homotopy) type theory, category theory and jazz.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3544</fr:anchor><fr:taxon>Person</fr:taxon><fr:addr>wwli</fr:addr><fr:route>wwli.xml</fr:route><fr:title>Wen-Wei Li</fr:title><fr:meta
name="institution">Peking University</fr:meta><fr:meta
name="position">Professor</fr:meta><fr:meta
name="external">https://www.wwli.asia/</fr:meta></fr:frontmatter><fr:mainmatter></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3545</fr:anchor><fr:addr>common</fr:addr><fr:route>common.xml</fr:route><fr:title>Common import</fr:title></fr:frontmatter><fr:mainmatter><fr:p>This tree defines some commonly imported stuff.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>3546</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>methods-of-algebra-2</fr:addr><fr:route>methods-of-algebra-2.xml</fr:route><fr:title>代数学方法 卷二: 线性代数</fr:title><fr:authors><fr:author><fr:link
href="wwli.xml"
type="local"
addr="wwli">Wen-Wei Li</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.wwli.asia/downloads/books/Al-jabr-2.pdf</fr:meta></fr:frontmatter><fr:mainmatter></fr:mainmatter></fr:tree></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context></fr:context><fr:related><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>3556</fr:anchor><fr:taxon>Meta</fr:taxon><fr:addr>todo</fr:addr><fr:route>todo.xml</fr:route><fr:title>Unfinished trees</fr:title></fr:frontmatter><fr:mainmatter><fr:p>Here are the unfinished trees. The links not written is also shown in the backlinks section.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>1151</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-002F</fr:addr><fr:route>hmlg-002F.xml</fr:route><fr:title>Twisted tensor product</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  (...)
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>1153</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-002D</fr:addr><fr:route>hmlg-002D.xml</fr:route><fr:title>Associated twisted product</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="hmlg-002C.xml"
type="local"
addr="hmlg-002C">associated simplicial fiber bundle</fr:link> of <fr:link
href="hmlg-002B.xml"
type="local"
addr="hmlg-002B">twisted products</fr:link> admits a simpler description. Suppose we have simplicial sets <fr:tex>F, B</fr:tex>, a simplicial group <fr:tex>G</fr:tex> with an action <fr:tex>G \times F \to F</fr:tex> and a <fr:link
href="hmlg-002A.xml"
type="local"
addr="hmlg-002A">twisting function</fr:link> <fr:tex>\tau</fr:tex> on <fr:tex>B</fr:tex>. The <fr:strong>associated twisted product</fr:strong> <fr:tex>B \times_\tau F</fr:tex> is defined exactly the same as twisted products, except we replace the factor <fr:tex>G</fr:tex> with <fr:tex>F</fr:tex>. This still makes sense, because we can interpret the multiplication <fr:tex>\tau(b) \cdot \partial_n f</fr:tex> as the <fr:tex>G</fr:tex>-action.
</fr:p><fr:p>
  In particular, if we consider <fr:tex>G</fr:tex> as a simplicial set with a <fr:tex>G</fr:tex>-action on the left via multiplication, then the associated twisted product <fr:tex>B \times_\tau G</fr:tex> is exactly the same as the twisted product <fr:tex>B \times_\tau G</fr:tex>, which explains our identical notation.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>1155</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001M</fr:addr><fr:route>hmlg-001M.xml</fr:route><fr:title>Chain reduction of mapping cones</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reductions</fr:link> <fr:tex>\rho : C \Rightarrow\mkern{-14mu}\Rightarrow D</fr:tex> and <fr:tex>\rho' : C' \Rightarrow\mkern{-14mu}\Rightarrow D'</fr:tex>, we can construct a reduction from the mapping cone <fr:tex>\operatorname{Cone}(f)</fr:tex> of a chain map <fr:tex>f : C \to C'</fr:tex> to (the action of <fr:tex>\rho</fr:tex> on <fr:tex>f</fr:tex>).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>1157</fr:anchor><fr:addr>hmlg-001K</fr:addr><fr:route>hmlg-001K.xml</fr:route><fr:title>Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  This is a set of notes on effective homology and algebraic topology. Main references are <fr:link
href="constructive-homological-algebra.xml"
type="local"
addr="constructive-homological-algebra">Constructive Homological Algebra and Applications</fr:link> and <fr:link
href="discrete-vector-fields.xml"
type="local"
addr="discrete-vector-fields">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. We assume basic familiarity with the classical aspects of the theory, although there will also be links within this forest to the relevant concepts.
</fr:p><fr:ul><fr:li><fr:link
href="hmlg-0021.xml"
type="local"
addr="hmlg-0021">W-bar construction</fr:link>, simplicial principal bundles, twisted products by <fr:link
href="simplicial-objects.xml"
type="local"
addr="simplicial-objects">Simplicial objects in algebraic topology</fr:link></fr:li>
  <fr:li>classifying space, loop space</fr:li>
  <fr:li>composition of <fr:link
href="hmlg-001I.xml"
type="local"
addr="hmlg-001I">strong homology equivalence</fr:link>, tensor product, cone, bicomplex</fr:li>
  <fr:li>simplicial group, Kan complex</fr:li>
  <fr:li>organize into notes</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"><fr:frontmatter><fr:anchor>1161</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title>Freyd–Mitchell embedding theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex>R</fr:tex>-modules for some ring <fr:tex>R</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1159</fr:anchor><fr:taxon>Proof</fr:taxon><fr:addr>#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  (TODO)
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>