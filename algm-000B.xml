<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1922</fr:anchor><fr:addr
type="user">algm-000B</fr:addr><fr:route>algm-000B.xml</fr:route><fr:title
text="A ring spectrum is quasi-compact">A <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">ring spectrum</fr:link> is quasi-compact</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is always <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1876</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = \top ]]></fr:tex>, then there is a finite union equal to <fr:tex
display="inline"><![CDATA[\top ]]></fr:tex>. Algebraically this means <fr:tex
display="inline"><![CDATA[\sqrt {\gcd \{f_i\}} = 1]]></fr:tex>, equivalently <fr:tex
display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>. So we have a linear combination <fr:tex
display="inline"><![CDATA[\sum _k a_k f_k = 1]]></fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1924</fr:anchor><fr:addr
type="user">algm-000I</fr:addr><fr:route>algm-000I.xml</fr:route><fr:title
text="Structure sheaf of a ring spectrum">Structure sheaf of a ring spectrum</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a sheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex> of rings on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> called the <fr:strong>structure sheaf</fr:strong>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D(f), \mathscr {O}) = R[f^{-1}]]]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[D(f) \subseteq  D(g)]]></fr:tex> we define the restriction morphism to be the localization map <fr:tex
display="inline"><![CDATA[R[g^{-1}] \to  R[f^{-1}]]]></fr:tex>, since by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" /> the latter is a further localization of the former. This turns <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> into a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1609</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex
display="inline"><![CDATA[f_i \in  R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = D(f)]]></fr:tex>, we need to show that
    <fr:tex
display="block"><![CDATA[R[f^{-1}] \to  \prod _{i \in  I} R[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} R[(f_i f_j)^{-1}]]]></fr:tex>
    is an equalizer. Notice that <fr:tex
display="inline"><![CDATA[R[f_i^{-1}] \cong  R[f^{-1}][f_i^{-1}]]]></fr:tex>. So we may reassign <fr:tex
display="inline"><![CDATA[S = R[f^{-1}]]]></fr:tex>. This simplifies the problem to
    <fr:tex
display="block"><![CDATA[S \to  \prod _{i \in  I} S[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} S[(f_i f_j)^{-1}],]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[D(f_i)]]></fr:tex> covers the whole space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>.</fr:p>

  <fr:p>We first describe the intuition. Since we know <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex> is <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex
display="inline"><![CDATA[g_i/f_i^{d_i} \in  S[f_i^{-1}]]]></fr:tex> that are equal in their common domain. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^{d_i})]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^{d_i}]]></fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f &= \sum _{i \in  I} c_i f_i^{d_i} f \\       &= \sum  c_i f_i^{d_i} \frac {g_i}{f_i^{d_i}} \\       &= \sum  c_i g_i.     \end {aligned}]]></fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.</fr:p>

  <fr:p>Suppose there are elements <fr:tex
display="inline"><![CDATA[g_i/f_i^d \in  S[f_i^{-1}]]]></fr:tex>, where we are allowed to use a single exponent <fr:tex
display="inline"><![CDATA[d]]></fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block"><![CDATA[(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.]]></fr:tex> If there is a solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to the gluing problem, it would need to satisfy <fr:tex
display="inline"><![CDATA[(f f_i^d - g_i) f_i^M = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^R)]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^R]]></fr:tex> for large enough <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. Hence
    <fr:tex
display="block"><![CDATA[f = \sum _{i \in  I} c_i f f_i^R = \sum  c_i g_i f_i^{R-d}.]]></fr:tex> This uniquely determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex
display="inline"><![CDATA[D(f_j)]]></fr:tex>, we have
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f f_j^d \cdot  f_j^R &= \sum  c_i g_i f_i^{R-d} f_j^{R+d} \\       &= \sum  c_i g_j f_i^{R} f_j^{R} \\       &= g_j f_j^R \cdot  \sum  c_i f_i^R = g_j f_j^R.     \end {aligned}]]></fr:tex>
    This reasoning is valid as long as <fr:tex
display="inline"><![CDATA[R > N + 2d]]></fr:tex>.</fr:p>

  <fr:p>If there are infinitely many opens, we first use <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compactness</fr:link> to select a finite number <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> for <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex>. Then consider the solution on <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k), D(g)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[g]]></fr:tex>. This solution must be equal to <fr:tex
display="inline"><![CDATA[f]]></fr:tex> by uniqueness. Therefore <fr:tex
display="inline"><![CDATA[f]]></fr:tex> restrict to the correct function on each <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, showing that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the required solution.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1926</fr:anchor><fr:addr
type="user">algm-000A</fr:addr><fr:route>algm-000A.xml</fr:route><fr:title
text="Terminology of compactness in algebraic geometry">Terminology of compactness in algebraic geometry</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1928</fr:anchor><fr:addr
type="user">algm-0001</fr:addr><fr:route>algm-0001.xml</fr:route><fr:title
text="Topological spectrum of a commutative ring">Topological spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The topological <fr:strong>spectrum</fr:strong> of a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>, is a topological space whose points are given by prime ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. We denote the point corresponding to <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex>. We define an open <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for each ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> which contains the point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> when <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  \mathfrak {a}]]></fr:tex>. The corresponding closed is written as <fr:tex
display="inline"><![CDATA[V(\mathfrak {a})]]></fr:tex>.</fr:p><fr:p>We abuse the notation and write <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for the case where <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> is generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Similar notations apply to <fr:tex
display="inline"><![CDATA[V]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>