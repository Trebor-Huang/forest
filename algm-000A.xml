<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>2798</fr:anchor>
    <fr:addr type="user">algm-000A</fr:addr>
    <fr:route>algm-000A.xml</fr:route>
    <fr:title text="Terminology of compactness in algebraic geometry">Terminology of compactness in algebraic geometry</fr:title>
    <fr:taxon>Remark</fr:taxon>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>3</fr:month>
      <fr:day>3</fr:day>
    </fr:date>
    <fr:authors>
      <fr:author>
        <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
      </fr:author>
    </fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Backlinks">Backlinks</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>2800</fr:anchor>
            <fr:addr type="user">algm-0018</fr:addr>
            <fr:route>algm-0018.xml</fr:route>
            <fr:title text="A space is noetherian iff hereditarily quasi-compact">A space is noetherian iff hereditarily quasi-compact</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>A space is <fr:link type="local" href="algm-000C.xml" addr="algm-000C" title="Noetherian space">noetherian</fr:link> iff it is <fr:em>hereditarily</fr:em> <fr:link type="local" href="algm-000A.xml" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, that is, if all its opens are quasi-compact.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2338</fr:anchor><fr:addr type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.</fr:p>

  <fr:p>For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>2802</fr:anchor>
            <fr:addr type="user">algm-0017</fr:addr>
            <fr:route>algm-0017.xml</fr:route>
            <fr:title text="Affine local properties">Affine local properties</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>Suppose a property on affine subschemes <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex> is closed under taking distinguished subsets <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_f) \hookrightarrow  X]]></fr:tex>, and for <fr:tex display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>, the property being true on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_{f_i}) \hookrightarrow  X]]></fr:tex> implies it being true on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex>. Then such a property is called <fr:strong>affine local</fr:strong>. We then say that <fr:tex display="inline"><![CDATA[X]]></fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.</fr:p><fr:p>If the property <fr:tex display="inline"><![CDATA[P]]></fr:tex> only depends on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> and not <fr:tex display="inline"><![CDATA[X]]></fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex display="inline"><![CDATA[P']]></fr:tex> on schemes, which we will usually refer to as <fr:strong>locally</fr:strong> <fr:tex display="inline"><![CDATA[P]]></fr:tex>. Suppose the scheme is furthermore <fr:link type="local" href="algm-000A.xml" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex display="inline"><![CDATA[P]]></fr:tex>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2350</fr:anchor><fr:addr type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>We prove that if some affine cover <fr:tex display="inline"><![CDATA[\{\operatorname {Spec}(R_i) \hookrightarrow  X\}]]></fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex>, using <fr:link type="local" href="algm-0016.xml" addr="algm-0016" title="Nike’s trick">Nike’s trick</fr:link>, we see that the intersection with <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_i)]]></fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex> with the said property, and therefore itself also.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>2804</fr:anchor>
            <fr:addr type="user">algm-000B</fr:addr>
            <fr:route>algm-000B.xml</fr:route>
            <fr:title text="A ring spectrum is quasi-compact">A <fr:link type="local" href="algm-0001.xml" addr="algm-0001" title="Topological spectrum of a commutative ring">ring spectrum</fr:link> is quasi-compact</fr:title>
            <fr:taxon>Theorem</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>The space <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is always <fr:link type="local" href="algm-000A.xml" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>.</fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2684</fr:anchor><fr:addr type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" href="trebor.xml" addr="trebor" title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex display="inline"><![CDATA[\bigcup _i D(f_i) = \top ]]></fr:tex>, then there is a finite union equal to <fr:tex display="inline"><![CDATA[\top ]]></fr:tex>. Algebraically this means <fr:tex display="inline"><![CDATA[\sqrt {\gcd \{f_i\}} = 1]]></fr:tex>, equivalently <fr:tex display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>. So we have a linear combination <fr:tex display="inline"><![CDATA[\sum _k a_k f_k = 1]]></fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
