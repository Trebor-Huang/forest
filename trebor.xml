<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3128</fr:anchor><fr:addr
type="user">trebor</fr:addr><fr:route>trebor.xml</fr:route><fr:title
text="Trebor">Trebor</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="institution">Tsinghua University</fr:meta><fr:meta
name="position">Bachelor Student</fr:meta><fr:meta
name="external">https://github.com/Trebor-Huang</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>My name is 黄栩 (<fr:em>Huang Xu</fr:em>), but I go by the name <fr:em>Trebor</fr:em> online. I’m interested in (homotopy) type theory, category theory and jazz.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="true"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3129</fr:anchor><fr:addr
type="user">trebor-0001</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Trebor’s forest">Trebor’s forest</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is my forest. Forests are <fr:link
type="external"
href="https://www.jonmsterling.com/jms-005P.xml">a way of organizing notes</fr:link>, and here is <fr:link
type="external"
href="https://www.jonmsterling.com/jms-009H.xml">a list of other websites organized as forests</fr:link>. Some of the contents here:</fr:p><fr:ul><fr:li><fr:link
type="local"
href="hmlg-0001.xml"
addr="hmlg-0001"
title="Homological Algebra">Notes on homological algebra</fr:link></fr:li>
  <fr:li><fr:link
type="local"
href="hmlg-001K.xml"
addr="hmlg-001K"
title="Effective homology">Effective homology</fr:link></fr:li>
  <fr:li>Algebraic geometry (Under namespace <fr:code>algm</fr:code>, not organized)</fr:li>
  <fr:li><fr:link
type="local"
href="ualg-000H.xml"
addr="ualg-000H"
title="Beck monadicity theorem">Beck monadicity theorem</fr:link></fr:li></fr:ul><fr:p>On a computer, you can press Ctrl–K to search for trees. You can also visit my <fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">contributor page</fr:link> to see a list of my trees.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1381</fr:anchor><fr:addr
type="user">trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title
text="Style of writing">Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I try to adhere to several principles when composing trees.</fr:p><fr:ul><fr:li>If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.</fr:li>
  <fr:li>Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.</fr:li>
  <fr:li>Apply <fr:link
type="external"
href="https://ncatlab.org/nlab/show/biased+definition">unbiased terminology</fr:link> and <fr:link
type="external"
href="https://ncatlab.org/nlab/show/negative+thinking">negative thinking</fr:link>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Contributions">Contributions</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3131</fr:anchor><fr:addr
type="user">algm-002H</fr:addr><fr:route>algm-002H.xml</fr:route><fr:title
text="Adjoint characterization of {Set}">Adjoint characterization of <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a locally small category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the yoneda embedding <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} : \mathcal {C} \to  \mathsf {Psh}(\mathcal {C})]]></fr:tex> has four consecutive left adjoints iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is equivalent to <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex>. See <fr:ref
addr="algm-002A"
href="algm-002A.xml"
taxon="Example" /> and <fr:ref
addr="algm-002B"
href="algm-002B.xml"
taxon="Example" /> for examples with one and two left adjoints, and <fr:ref
addr="algm-002C"
href="algm-002C.xml"
taxon="Theorem" /> for the four consecutive left adjoint over <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3133</fr:anchor><fr:addr
type="user">algm-002F</fr:addr><fr:route>algm-002F.xml</fr:route><fr:title
text="Composition of waves">Composition of waves</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link>, we can freely compose <fr:link
type="local"
href="algm-002D.xml"
addr="algm-002D"
title="Wave">waves</fr:link> with arrows or other waves associatively.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>308</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-002F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Let us use <fr:tex
display="inline"><![CDATA[f, g, h]]></fr:tex> etc. for arrows, and <fr:tex
display="inline"><![CDATA[u, v, w]]></fr:tex> for waves. The composition <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } w \mathbin {\circ } g]]></fr:tex> and its associativity is given by functoriality of waves. We define the composition of two waves by <fr:tex
display="inline"><![CDATA[w \mathbin {\circ } v = \bar {w} \mathbin {\circ } v = w \mathbin {\circ } \bar {v}]]></fr:tex>, which we can verify are equal by a calculation.
    Then <fr:tex
display="inline"><![CDATA[u \mathbin {\circ } v \mathbin {\circ } w = \bar {u} \mathbin {\circ } v \mathbin {\circ } \bar {w}]]></fr:tex> is associative.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3135</fr:anchor><fr:addr
type="user">algm-002G</fr:addr><fr:route>algm-002G.xml</fr:route><fr:title
text="Waves and totally distributive categories">Waves and totally distributive categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, it is a <fr:link
type="local"
href="algm-0028.xml"
addr="algm-0028"
title="Totally distributive category">totally distributive category</fr:link>, iff the <fr:link
type="local"
href="algm-002D.xml"
addr="algm-002D"
title="Wave">wave</fr:link> functor <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} \dashv  \operatorname {?}]]></fr:tex> with an obvious counit <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} \mathbin {\circ } \operatorname {?} \to  \textrm {Id}]]></fr:tex>, <fr:em>and</fr:em> iff the natural transform <fr:tex
display="inline"><![CDATA[\operatorname {?} \mathbin {\circ } \mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} \to  \textrm {Id}]]></fr:tex> is invertible (the inverse will be the unit of the adjunction). In this case, the composition operator <fr:tex
display="inline"><![CDATA[\int ^B \operatorname {wave}(B, C) \times  \operatorname {wave}(A, B) \to  \operatorname {wave}(A, C)]]></fr:tex> of <fr:link
type="local"
href="algm-002D.xml"
addr="algm-002D"
title="Wave">waves</fr:link> is invertible, up to sliding <fr:tex
display="inline"><![CDATA[B]]></fr:tex> around with arrows.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3137</fr:anchor><fr:addr
type="user">algm-002E</fr:addr><fr:route>algm-002E.xml</fr:route><fr:title
text="{Set} is total and cototal"><fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex> is total and cototal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The category of small sets <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex> is a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link>, and so is <fr:tex
display="inline"><![CDATA[\mathsf {Set}^\textrm {op}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>340</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-002E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The first claim is a special case of <fr:ref
addr="algm-002A"
href="algm-002A.xml"
taxon="Example" />. For the second claim, we use the limit characterization of cototality. Given a functor <fr:tex
display="inline"><![CDATA[F : \mathsf {Set} \to  \mathsf {Set}]]></fr:tex>, we need to show the existence of <fr:tex
display="inline"><![CDATA[\lim  (\pi _F : \int  F \to  \mathsf {Set})]]></fr:tex>. We claim that this is a subset of <fr:tex
display="inline"><![CDATA[\mathcal {P}(F(\mathcal {P}(1)))]]></fr:tex>, i.e. we need to show that all the other components of an element in the limit are determined by the <fr:tex
display="inline"><![CDATA[F(\mathcal {P}(1))]]></fr:tex> component. This is true because <fr:tex
display="inline"><![CDATA[\mathcal {P}(1)]]></fr:tex> is a cogenerator of <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex>.</fr:p>

  <fr:p>Another way to see this is to let <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^\textrm {op} \dashv  \operatorname {¿}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^\textrm {op} : \mathsf {Set} \to  (\mathsf {Set} \to  \mathsf {Set})^\textrm {op}]]></fr:tex> is the coyoneda embedding, and calculate
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \operatorname {¿}(F) &= \hom (1, \operatorname {¿}(F)) \\       &= \hom _{\mathsf {Set} \to  \mathsf {Set}} (F, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (1^\textrm {op})) \\       &= \hom (F, \textrm {Id}).     \end {aligned}]]></fr:tex>
    So we only need to prove the natural transformations <fr:tex
display="inline"><![CDATA[FX \to  X]]></fr:tex> form a small set, which works the same way, by substituting <fr:tex
display="inline"><![CDATA[X]]></fr:tex> by the powerset of <fr:tex
display="inline"><![CDATA[1]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3139</fr:anchor><fr:addr
type="user">algm-002B</fr:addr><fr:route>algm-002B.xml</fr:route><fr:title
text="Presheaf category over a small category is totally distributive">Presheaf category over a small category is totally distributive</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A presheaf category over a small categroy <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is not only a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link>, as proven in <fr:ref
addr="algm-002A"
href="algm-002A.xml"
taxon="Example" />, but also a <fr:link
type="local"
href="algm-0028.xml"
addr="algm-0028"
title="Totally distributive category">totally distributive category</fr:link>. This is because <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^*]]></fr:tex> has a left adjoint <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}_!]]></fr:tex> a.k.a. the left Kan extension. We need to be careful because <fr:tex
display="inline"><![CDATA[\mathsf {Psh}^2 (\mathcal {C})]]></fr:tex> is not locally small. The colimit formula for (pointwise) left Kan extensions is
  <fr:tex
display="block"><![CDATA[\operatorname {Lan}_{\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}} F(G) = \operatorname *{colim}_{p : \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X) \leftarrow  G} F(X)]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[F, G \in  \mathsf {Psh}(\mathcal {C})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> ranges over <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. (The reversal of arrow comes from the contravariance of presheaves.) This is still a small limit, so it is fine.</fr:p><fr:p>For the special case of <fr:tex
display="inline"><![CDATA[\mathcal {C} = 1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^* : \mathsf {Psh}(\mathsf {Set}) \to  \mathsf {Set}]]></fr:tex> evaluates at <fr:tex
display="inline"><![CDATA[1]]></fr:tex>. We get
  <fr:tex
display="block"><![CDATA[\operatorname {Lan}_{1} F(G) = \operatorname *{colim}_{1 \leftarrow  G} F = F]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[F, G]]></fr:tex> are sets. So the left adjoint is the constant functor functor <fr:tex
display="inline"><![CDATA[\Delta ]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\Delta (X)(Y) = X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3141</fr:anchor><fr:addr
type="user">algm-002C</fr:addr><fr:route>algm-002C.xml</fr:route><fr:title
text="Adjoint chain over {Set}">Adjoint chain over <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The yoneda embedding <fr:tex
display="inline"><![CDATA[\mathsf {Set} \to  \mathsf {Psh}(\mathsf {Set})]]></fr:tex> has a chain of four left adjoints <fr:tex
display="block"><![CDATA[0_!\dashv \operatorname {ev}_0\dashv \Delta \dashv \operatorname {ev}_1\dashv \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[0_! (X)(Y) = X \times  \hom (Y, 0)]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>316</fr:anchor><fr:addr
type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-002C</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The first three functors appear in <fr:ref
addr="algm-002A"
href="algm-002A.xml"
taxon="Example" /> and <fr:ref
addr="algm-002B"
href="algm-002B.xml"
taxon="Example" />. The next adjoint <fr:tex
display="inline"><![CDATA[\operatorname {ev}_0\dashv \Delta ]]></fr:tex> is dual to <fr:tex
display="inline"><![CDATA[\Delta \dashv \operatorname {ev}_1]]></fr:tex>, and it is also not hard to see manually. Finally, a natural transform <fr:tex
display="inline"><![CDATA[0_! (X) \to  F]]></fr:tex> consists of a single map <fr:tex
display="inline"><![CDATA[X \to  F(0)]]></fr:tex>, since all the other components are empty functions, hence trivial. Moreover, <fr:tex
display="inline"><![CDATA[0_!]]></fr:tex> does not preserve products, so no more left adjoints are possible.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3143</fr:anchor><fr:addr
type="user">algm-002D</fr:addr><fr:route>algm-002D.xml</fr:route><fr:title
text="Wave">Wave</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, we can define a functor <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} : \mathcal {C} \to  \mathsf {Psh}(\mathcal {C})]]></fr:tex> that will serve as the double left adjoint of <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> iff the category is actually a <fr:link
type="local"
href="algm-0028.xml"
addr="algm-0028"
title="Totally distributive category">totally distributive category</fr:link>. Since <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X)(Y) = \hom (Y, X)]]></fr:tex>, we similarly define <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}}(X)(Y) = \operatorname {wave}(Y, X)]]></fr:tex>, and call the elements <fr:strong>waves</fr:strong>.</fr:p><fr:p>A wave <fr:tex
display="inline"><![CDATA[w : Y \rightsquigarrow  X]]></fr:tex> is defined by a family of maps <fr:tex
display="inline"><![CDATA[\hom (X, \operatorname {?} F) \to  F(Y)]]></fr:tex> natural in the presheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\operatorname {?} \dashv  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex>. This is intuitively a categorification of the “way way below” relation <fr:tex
display="inline"><![CDATA[Y \lll  X]]></fr:tex> in posets. If we take <fr:tex
display="inline"><![CDATA[F = \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X)]]></fr:tex>, then we get an actual arrow <fr:tex
display="inline"><![CDATA[\bar {w} : Y \to  X]]></fr:tex>. This defines a natural transform <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} \to  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex>, or equivalently <fr:tex
display="inline"><![CDATA[\operatorname {?} \mathbin {\circ } \mathop {\mkern {-2mu}\text {ろ}\mkern {-2mu}} \to  \textrm {Id}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>324</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-002D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We need to show that <fr:tex
display="inline"><![CDATA[\operatorname {wave}(Y, X)]]></fr:tex> is a small set. Let <fr:tex
display="inline"><![CDATA[Y^*]]></fr:tex> be the functor sending a presheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to the set <fr:tex
display="inline"><![CDATA[F(Y)]]></fr:tex>. The right Kan extension is given by
    <fr:tex
display="block"><![CDATA[\begin {aligned}       Y_* (A)(B) &= \hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (B), Y_* (A)) \\       &= \hom (Y^* (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (B)), A) \\       &= \hom (\hom (Y, B), A) = A^{B^Y}.     \end {aligned}]]></fr:tex>
    Using the fact that <fr:link
type="local"
href="algm-002E.xml"
addr="algm-002E"
title="{Set} is total and cototal"><fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex> is total and cototal</fr:link> and writing <fr:tex
display="inline"><![CDATA[\operatorname {¿}]]></fr:tex> as the witness of cototality, we calculate
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \operatorname {wave}(Y, X) &= \hom _{\mathsf {Psh}(\mathcal {C}) \to  \mathsf {Set}} (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (X^\textrm {op}) \mathbin {\circ } \operatorname {?}, Y^*) \\       &= \hom _{\mathsf {Set} \to  \mathsf {Set}} (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (X^\textrm {op}) \mathbin {\circ } \operatorname {?} \mathbin {\circ } Y_*, \textrm {Id}) \\       &= \hom _{\mathsf {Set} \to  \mathsf {Set}} (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (X^\textrm {op}) \mathbin {\circ } \operatorname {?} \mathbin {\circ } Y_*, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (1^\textrm {op})) \\       &= \hom _{\mathsf {Set}} (1, \operatorname {¿}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (X^\textrm {op}) \mathbin {\circ } \operatorname {?} \mathbin {\circ } Y_*)) \\       &= \operatorname {¿}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} (X^\textrm {op}) \mathbin {\circ } \operatorname {?} \mathbin {\circ } {Y_*})     \end {aligned}]]></fr:tex>
    where the second equality is because the pseudofunctor <fr:tex
display="inline"><![CDATA[(- \to  \mathsf {Set})]]></fr:tex> preserves adjoint pairs. Hence we know this is a small set.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3145</fr:anchor><fr:addr
type="user">algm-002A</fr:addr><fr:route>algm-002A.xml</fr:route><fr:title
text="Presheaf category over a small category is total">Presheaf category over a small category is total</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a small category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the locally small category <fr:tex
display="inline"><![CDATA[\mathsf {Psh}(\mathcal {C})]]></fr:tex> is a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link>. In fact, the left adjoint to <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} : \mathsf {Psh}(\mathcal {C}) \to  \mathsf {Psh}^2(\mathcal {C})]]></fr:tex> is given by <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^*]]></fr:tex>, i.e. the map that sends the double presheaf <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to the presheaf <fr:tex
display="inline"><![CDATA[X \mapsto  R(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X))]]></fr:tex>.</fr:p><fr:p>To see this, we compute <fr:tex
display="inline"><![CDATA[\hom _{\mathsf {Psh}(\mathcal {C})}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^* R, F)]]></fr:tex> to be the set of natural transforms that assign an arrow <fr:tex
display="inline"><![CDATA[R(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X)) \to  F(X)]]></fr:tex> for every object <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. On the other hand, <fr:tex
display="inline"><![CDATA[\hom _{\mathsf {Psh}^2(\mathcal {C})}(R, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} F)]]></fr:tex> assigns an arrow <fr:tex
display="inline"><![CDATA[R(G) \to  \hom (G, F)]]></fr:tex> for every presheaf <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. The latter obviously have a map to the former, and we need to prove that any map in the former uniquely extends to the latter. <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is a colimit of representables, so we can decompose <fr:tex
display="inline"><![CDATA[\hom (G, F)]]></fr:tex> into a limit of <fr:tex
display="inline"><![CDATA[F(X)]]></fr:tex>. The naturality requirement then forces a unique value for each component.</fr:p><fr:p>In particular, if <fr:tex
display="inline"><![CDATA[\mathcal {C} = 0]]></fr:tex>, we get a left adjoint for the yoneda embedding <fr:tex
display="block"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} : \mathsf {Psh}(0) = 1 \to  \mathsf {Psh}(1) = \mathsf {Set}.]]></fr:tex>
  In this case <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> is essentially picking out the terminal object, and <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}^*]]></fr:tex> is the unique functor. We can also take <fr:tex
display="inline"><![CDATA[\mathcal {C} = 1]]></fr:tex>, then
  <fr:tex
display="block"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} : \mathsf {Set} \to  \mathsf {Psh}(\mathsf {Set}),]]></fr:tex>
  and the left adjoint is <fr:tex
display="inline"><![CDATA[F \mapsto  F(1)]]></fr:tex>, evaluating the presheaf at the singleton set. It is also possible to calculate this directly via the colimit characterization of total cocompleteness.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3147</fr:anchor><fr:addr
type="user">algm-0026</fr:addr><fr:route>algm-0026.xml</fr:route><fr:title
text="A total category is cocomplete and complete">A total category is cocomplete and complete</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link> is (small) cocomplete and complete. This shows totality is a strong form of cocompleteness, strong enough to behave like cocompleteness in posets, which also guarantees completeness.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>420</fr:anchor><fr:addr
type="machine">#300</fr:addr><fr:route>unstable-300.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0026</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Using the colimit characterization of totality, given a small diagram <fr:tex
display="inline"><![CDATA[D : I \to  \mathcal {C}]]></fr:tex>, we can attempt to construct a presheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex> assigning <fr:tex
display="inline"><![CDATA[F(X)]]></fr:tex> the set of all objects in <fr:tex
display="inline"><![CDATA[I]]></fr:tex> mapped to <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, and require that <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex> sends the object <fr:tex
display="inline"><![CDATA[i \in  I]]></fr:tex> to <fr:tex
display="inline"><![CDATA[j \in  I]]></fr:tex> if there is an arrow in the colimit diagram going from <fr:tex
display="inline"><![CDATA[j]]></fr:tex> to <fr:tex
display="inline"><![CDATA[i]]></fr:tex> that is mapped to <fr:tex
display="inline"><![CDATA[f]]></fr:tex> (multiple of the same arrow appearing in the colimit diagram doesn’t matter). But this leaves many functoriality requirements unsatisfied, so we freely add elements to <fr:tex
display="inline"><![CDATA[F]]></fr:tex> for them. This will create additional arrows in the corresponding colimit diagram that end at existing objects, so the colimit is still unaffected.</fr:p>

  <fr:p>It is nice to have a more uniform description of this. If we have a single object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in the diagram, then the resulting presheaf will be exactly <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex>. For a general diagram, we need a colimit to glue all the <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex>’s together, and it’s not hard to see the required colimit is exactly <fr:tex
display="inline"><![CDATA[\operatorname *{colim} \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} \mathbin {\circ } D]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is the diagram functor.</fr:p>

  <fr:p>For completeness, we use the same technique in proving cocomplete posets are complete: we can define <fr:tex
display="inline"><![CDATA[\sup  U]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\inf  \{x \mid  x \ge  U\}]]></fr:tex>. In the same spirit, given a diagram <fr:tex
display="inline"><![CDATA[U : I \to  \mathcal {C}]]></fr:tex>, we consider a locally small category whose objects are <fr:tex
display="inline"><![CDATA[(X, F)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F : \operatorname {const}(X) \to  U]]></fr:tex>, and the morphisms are obvious. This is equivalently the comma category <fr:tex
display="inline"><![CDATA[\operatorname {const} \downarrow  U]]></fr:tex>. The limit is then the same as the colimit of the functor <fr:tex
display="inline"><![CDATA[(X, F) \mapsto  X]]></fr:tex>. But this functor can be constructed as <fr:tex
display="inline"><![CDATA[\pi _G : \int  G \to  \mathcal {C}]]></fr:tex> for some presheaf <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, namely <fr:tex
display="inline"><![CDATA[G(Y) = \hom (\operatorname {const}(Y), U)]]></fr:tex>. Therefore the argument goes through despite involving large colimits.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3149</fr:anchor><fr:addr
type="user">algm-0029</fr:addr><fr:route>algm-0029.xml</fr:route><fr:title
text="Adjoint functor theorem for total categories">Adjoint functor theorem for total categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any cocontinuous functor <fr:tex
display="inline"><![CDATA[F]]></fr:tex> from a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> to a locally small category <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, it has a right adjoint without additional assumptions.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>408</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0029</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The idea of the adjoint functor theorem is to construct the large colimit
    <fr:tex
display="block"><![CDATA[G(X) = \operatorname *{colim}_{FY \to  X} Y.]]></fr:tex>
    But this is exactly the kind of colimits mentioned in <fr:ref
addr="algm-0025"
href="algm-0025.xml"
taxon="Definition" />.
    We can construct the right adjoint by letting <fr:tex
display="inline"><![CDATA[G(X) = \operatorname {?}(F^* \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X))]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3151</fr:anchor><fr:addr
type="user">algm-0027</fr:addr><fr:route>algm-0027.xml</fr:route><fr:title
text="Cartesian closed total category">Cartesian closed total category</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link> is cartesian closed iff the left adjoint <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex> preserves binary products.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>414</fr:anchor><fr:addr
type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0027</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>If the total category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is cartesian closed, then
    <fr:tex
display="block"><![CDATA[\hom (F, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A^B)) = \hom (\operatorname {?}(F), A^B) = \hom (\operatorname {?}(F) \times  B, A).]]></fr:tex>
    On the other hand, <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> preserves exponentials, and therefore
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \hom (F, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A^B)) &= \hom (F, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)^{\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B)}) \\       &= \hom (F \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B), \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)) \\       &= \hom (\operatorname {?}(F \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B)), A).     \end {aligned}]]></fr:tex>
    Hence we need the canonical map
    <fr:tex
display="block"><![CDATA[\operatorname {?}(F \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B)) \to  \operatorname {?}(F) \times  \operatorname {?}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B)) \to  \operatorname {?}(F) \times  B]]></fr:tex>
    to be an isomorphism. But the counit <fr:tex
display="inline"><![CDATA[\operatorname {?}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(B)) \to  B]]></fr:tex> is already an isomorphism since <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> is a fully faithful right adjoint. Therefore this happens iff <fr:tex
display="inline"><![CDATA[\operatorname {?}(F \times  G) \to  \operatorname {?}(F) \times  \operatorname {?}(G)]]></fr:tex> is an isomorphism for all representable presheaves <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. Now presheaves are (large) colimits of representables, and being left adjoints, both <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex> and binary products preserve all colimits whatsoever. So we can extend this to all presheaves <fr:tex
display="inline"><![CDATA[G]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, if <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex> preserves binary products, then <fr:tex
display="inline"><![CDATA[(A \times  -)]]></fr:tex> must be cocontinuous: Every small colimit diagram <fr:tex
display="inline"><![CDATA[D : I \to  \mathcal {C}]]></fr:tex> can be <fr:link
type="local"
href="algm-0026.xml"
addr="algm-0026"
title="A total category is cocomplete and complete">equivalently represented</fr:link> as a presheaf <fr:tex
display="inline"><![CDATA[F = \operatorname *{colim}_{i \in  I} \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} D(i)]]></fr:tex> with colimit <fr:tex
display="inline"><![CDATA[\operatorname {?}(F)]]></fr:tex>. The presheaf for the product diagram <fr:tex
display="inline"><![CDATA[A \times  D(i)]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\operatorname *{colim}_{i \in  I} \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A \times  D(i))]]></fr:tex>, which is equivalent to <fr:tex
display="inline"><![CDATA[F \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> preserves product and product is cocontinuous in presheaves.
    (A naive way to construct the presheaf for the product diagram is <fr:tex
display="inline"><![CDATA[F \mathbin {\circ } (A \times  -)]]></fr:tex>, but this doesn’t quite work because of contravariance.)
    We have <fr:tex
display="inline"><![CDATA[\operatorname {?}(F \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)) = \operatorname {?}(F) \times  A]]></fr:tex>, showing cocontinuity.
    Therefore by the <fr:link
type="local"
href="algm-0029.xml"
addr="algm-0029"
title="Adjoint functor theorem for total categories">adjoint functor theorem for total categories</fr:link>, we know exponentials must exist.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3153</fr:anchor><fr:addr
type="user">algm-0025</fr:addr><fr:route>algm-0025.xml</fr:route><fr:title
text="Total category">Total category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a locally small category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, if the Yoneda embedding <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}} : \mathcal {C} \to  \mathsf {Psh}(\mathcal {C})]]></fr:tex> has a left adjoint <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex>, then we say teh category is <fr:strong>total</fr:strong>, or <fr:strong>totally cocomplete</fr:strong>. This is equivalent to requiring the colimit of <fr:tex
display="inline"><![CDATA[\pi _F : \int  F \to  \mathcal {C}]]></fr:tex> to exist for every presheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, which is the value of <fr:tex
display="inline"><![CDATA[L(F)]]></fr:tex>. Notice that <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}]]></fr:tex> being fully faithful implies the counit <fr:tex
display="inline"><![CDATA[\operatorname {?}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)) \to  A]]></fr:tex> is an isomorphism.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>328</fr:anchor><fr:addr
type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0025</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The universal property of the colimit says <fr:tex
display="block"><![CDATA[\hom (\operatorname *{colim} \pi _F, X) \cong  \lim _{(Y, p)} \hom (Y, X).]]></fr:tex>
    Using the characterization of limits in <fr:tex
display="inline"><![CDATA[\mathsf {Set}]]></fr:tex>, an element in this set maps <fr:tex
display="inline"><![CDATA[F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\hom (Y, X)]]></fr:tex> for each <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> naturally, which is exactly <fr:tex
display="inline"><![CDATA[\hom (F, \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(X))]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3155</fr:anchor><fr:addr
type="user">algm-0028</fr:addr><fr:route>algm-0028.xml</fr:route><fr:title
text="Totally distributive category">Totally distributive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-0025.xml"
addr="algm-0025"
title="Total category">total category</fr:link>, if the left adjoint <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex> has a further left adjoint, then it preserves all limits. Since <fr:tex
display="inline"><![CDATA[\operatorname {?}]]></fr:tex> is a kind of colimit operator, this condition is a strong version of complete distributivity. Therefore we call the category <fr:strong>totally distributive</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3157</fr:anchor><fr:addr
type="user">algm-0024</fr:addr><fr:route>algm-0024.xml</fr:route><fr:title
text="Sheafification as a higher inductive type">Sheafification as a higher inductive type</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link>, we can define <fr:link
type="local"
href="algm-001J.xml"
addr="algm-001J"
title="Sheafification">sheafification</fr:link>, and more generally <fr:tex
display="inline"><![CDATA[\infty ]]></fr:tex>-sheafification, as a higher inductive type. Intuitively, it can be thought of as extending a monad on propositions to arbitrary types. The sheafification <fr:tex
display="inline"><![CDATA[X^{++}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is generated by an inclusion map <fr:tex
display="inline"><![CDATA[\eta  : X \to  X^{++}]]></fr:tex>, a free extension of the bind operator <fr:tex
display="inline"><![CDATA[\beta  : \forall  (p : \Omega ), j(p) \to  (p \to  X^{++}) \to  X^{++}]]></fr:tex> and the only relevant monad law
  <fr:tex
display="block"><![CDATA[\beta (u, \lambda  \_. v) = v.]]></fr:tex>
  We can equivalently state this as <fr:tex
display="inline"><![CDATA[g = \beta (-, f)]]></fr:tex> being the unique function satisfying
  <fr:tex
display="block"><![CDATA[\forall (\star  : p), g(\eta (\star )) = f(\star ),]]></fr:tex>
  which is closer to the usual sheaf requirement.</fr:p><fr:p>As we said, <fr:tex
display="inline"><![CDATA[(-)^{++}]]></fr:tex> is a monad with the unit given by <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex>. The binding operator is implemented by <fr:tex
display="block"><![CDATA[\begin {aligned}     \beta (\eta (x), f) &= f(x) \\     \beta (\beta (\star , g), f) &= \beta (\star , \lambda  x. \beta (g(x), f))   \end {aligned}]]></fr:tex>
  where we used the same name <fr:tex
display="inline"><![CDATA[\beta ]]></fr:tex> for all the bind operators.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3159</fr:anchor><fr:addr
type="user">misc-000E</fr:addr><fr:route>misc-000E.xml</fr:route><fr:title
text="Dissolution locale">Dissolution locale</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a locale <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, if we have a map <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex> such that the preimage of every sublocale is closed, and every map <fr:tex
display="inline"><![CDATA[g : Z \to  X]]></fr:tex> satisfying the same property factors through <fr:tex
display="inline"><![CDATA[f]]></fr:tex> uniquely, then we say <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is the <fr:strong>dissolution</fr:strong> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3161</fr:anchor><fr:addr
type="user">misc-000F</fr:addr><fr:route>misc-000F.xml</fr:route><fr:title
text="Dissolution locale">Dissolution locale</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can give a concrete construction of the <fr:link
type="local"
href="misc-000E.xml"
addr="misc-000E"
title="Dissolution locale">dissolution locale</fr:link>. Given a locale <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, we define a new locale <fr:tex
display="inline"><![CDATA[X_d]]></fr:tex> whose poset of <fr:em>closeds</fr:em> is the poset of sublocales of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. Given a sublocale <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, we write <fr:tex
display="inline"><![CDATA[V(\alpha )]]></fr:tex> for the corresponding closed in <fr:tex
display="inline"><![CDATA[X_d]]></fr:tex>. The structure map <fr:tex
display="inline"><![CDATA[\iota  : X_d \to  X]]></fr:tex> is given by sending every closed to the corresponding closed sublocale.</fr:p><fr:p>We prove the universal property of dissolution. Suppose there is another map <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex> such that the preimage of sublocales are closed. We can define a map <fr:tex
display="inline"><![CDATA[\pi  : Y \to  X_d]]></fr:tex> by letting it send <fr:tex
display="inline"><![CDATA[V(\alpha )]]></fr:tex> to the preimage of <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, considered as a closed. This map is unique since the preimage of every closed is fixed by the commutativity requirement.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3163</fr:anchor><fr:addr
type="user">misc-000G</fr:addr><fr:route>misc-000G.xml</fr:route><fr:title
text="Points of the dissolution locale">Points of the dissolution locale</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Classically, for every locale <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, the <fr:link
type="local"
href="misc-000E.xml"
addr="misc-000E"
title="Dissolution locale">dissolution locale</fr:link> <fr:tex
display="inline"><![CDATA[X_d]]></fr:tex> has the same points as <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>490</fr:anchor><fr:addr
type="machine">#239</fr:addr><fr:route>unstable-239.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>misc-000G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We want to prove the canonical map <fr:tex
display="inline"><![CDATA[\hom (1, X_d) \to  \hom (1, X)]]></fr:tex> is a bijection. All the sublocales of <fr:tex
display="inline"><![CDATA[1]]></fr:tex> are closed since there are only two of them. Therefore for every map <fr:tex
display="inline"><![CDATA[1 \to  X]]></fr:tex>, the preimage of every sublocale is trivially closed, and therefore it factors through <fr:tex
display="inline"><![CDATA[X_d \to  X]]></fr:tex> uniquely. This implies the desired bijection.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3165</fr:anchor><fr:addr
type="user">misc-000D</fr:addr><fr:route>misc-000D.xml</fr:route><fr:title
text="Ribbon Hopf algebra">Ribbon Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>ribbon Hopf algebra</fr:strong> is defined as a <fr:link
type="local"
href="misc-0007.xml"
addr="misc-0007"
title="Braided Hopf algebra">braided Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex> together with an element <fr:tex
display="inline"><![CDATA[v]]></fr:tex> of the algebra, such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \epsilon (v) &= 1 \\     \Delta (v) &= (\tau (R) R)^{-1} (v \otimes  v) \\     S(v) &= v.   \end {aligned}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3167</fr:anchor><fr:addr
type="user">misc-000C</fr:addr><fr:route>misc-000C.xml</fr:route><fr:title
text="Dual representation of Hopf algebras">Dual representation of Hopf algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="misc-0003.xml"
addr="misc-0003"
title="Antipode of a Hopf algebra">antipode of a Hopf algebra</fr:link> provides us with the structure to define dual representations. Given a representation <fr:tex
display="inline"><![CDATA[V]]></fr:tex> of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, we can define an action on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex> by <fr:tex
display="inline"><![CDATA[(h \cdot  f)(v) = f(S(h) \cdot  v)]]></fr:tex>. This works out because the antipode is an anti-homomorphism. This induces a contravariant functor on the category of representations.</fr:p><fr:p>Categorically speaking, for <fr:tex
display="inline"><![CDATA[V]]></fr:tex> to have a right dual structure on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex>, we need structure maps <fr:tex
display="inline"><![CDATA[1 \to  V \otimes  V^*]]></fr:tex> and <fr:tex
display="inline"><![CDATA[V^* \otimes  V \to  1]]></fr:tex>. This requires <fr:tex
display="inline"><![CDATA[V]]></fr:tex> to be finite dimensional. In this case, we need to verify the obvious map from linear algebra is indeed a module homomorphism. This essentially follows from <fr:tex
display="inline"><![CDATA[x_{(1)} \cdot  S(x_{(2)}) = \epsilon (x) = S(x_{(1)}) \cdot  x_{(2)}]]></fr:tex>.</fr:p><fr:p>However, this module structure on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex> cannot be taken as the left dual of <fr:tex
display="inline"><![CDATA[V]]></fr:tex>! The reason is the evaluation map <fr:tex
display="inline"><![CDATA[v \otimes  f \mapsto  f(v)]]></fr:tex> doesn’t respect multiplication, since <fr:tex
display="inline"><![CDATA[S(x_{(2)}) x_{(1)}]]></fr:tex> is not necessarily equal to <fr:tex
display="inline"><![CDATA[S(x_{(1)}) \cdot  x_{(2)}]]></fr:tex>. Instead we need another module structure on the same vector space, using <fr:tex
display="inline"><![CDATA[S^{-1}]]></fr:tex> in place of <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. Let this representation be denoted as <fr:tex
display="inline"><![CDATA[{^{\vee }V}]]></fr:tex>, and for clarity we denote the right dual module as <fr:tex
display="inline"><![CDATA[V^{\vee }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3169</fr:anchor><fr:addr
type="user">misc-000B</fr:addr><fr:route>misc-000B.xml</fr:route><fr:title
text="Ribbon Hopf algebra">Ribbon Hopf algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebras</fr:link> already have the concept of <fr:link
type="local"
href="misc-000C.xml"
addr="misc-000C"
title="Dual representation of Hopf algebras">dual modules</fr:link>, and for finite dimensional modules, the dual is a categorical dual. For a <fr:link
type="local"
href="misc-0007.xml"
addr="misc-0007"
title="Braided Hopf algebra">braided Hopf algebra</fr:link>, the modules further form a braided monoidal category. Hence to form ribbon categories, we only need to implement the twisting natural isomorphism <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex>.</fr:p><fr:p>Similar to the discussion in <fr:ref
addr="misc-0006"
href="misc-0006.xml" />, we attempt to represent this isomorphism via an invertible element <fr:tex
display="inline"><![CDATA[v]]></fr:tex>. For it to commute with every module homomorphism, this element needs to be in the center of the algebra. The equation <fr:tex
display="inline"><![CDATA[\theta _1 = \textrm {id}]]></fr:tex> translates to <fr:tex
display="inline"><![CDATA[\epsilon (v) = 1]]></fr:tex>. For <fr:tex
display="inline"><![CDATA[\theta _{X^{\vee }} = (\theta _X)^{\vee }]]></fr:tex>, we need <fr:tex
display="inline"><![CDATA[S(v) = v]]></fr:tex>. Finally we have the equation <fr:tex
display="block"><![CDATA[\beta _{Y, X} \mathbin {\circ } \beta _{X, Y} \mathbin {\circ } \theta _{X \otimes  Y} = \theta _X \otimes  \theta _Y,]]></fr:tex> which translates to <fr:tex
display="inline"><![CDATA[\Delta (v) = (\tau (R) R)^{-1} (v \otimes  v)]]></fr:tex>. This defines ribbon Hopf algebras.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>510</fr:anchor><fr:addr
type="user">misc-000D</fr:addr><fr:route>misc-000D.xml</fr:route><fr:title
text="Ribbon Hopf algebra">Ribbon Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>ribbon Hopf algebra</fr:strong> is defined as a <fr:link
type="local"
href="misc-0007.xml"
addr="misc-0007"
title="Braided Hopf algebra">braided Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex> together with an element <fr:tex
display="inline"><![CDATA[v]]></fr:tex> of the algebra, such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \epsilon (v) &= 1 \\     \Delta (v) &= (\tau (R) R)^{-1} (v \otimes  v) \\     S(v) &= v.   \end {aligned}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3171</fr:anchor><fr:addr
type="user">misc-000A</fr:addr><fr:route>misc-000A.xml</fr:route><fr:title
text="Drinfeld double">Drinfeld double</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex> with <fr:link
type="local"
href="misc-0003.xml"
addr="misc-0003"
title="Antipode of a Hopf algebra">invertible antipode</fr:link>, we construct another Hopf algebra <fr:tex
display="inline"><![CDATA[D(H)]]></fr:tex> on the vector space <fr:tex
display="inline"><![CDATA[(H^\textrm {op})^\circ  \otimes  H]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[H^\textrm {op}]]></fr:tex> is the <fr:link
type="local"
href="misc-0008.xml"
addr="misc-0008"
title="Opposite Hopf algebra">opposite Hopf algebra</fr:link>, and <fr:tex
display="inline"><![CDATA[H^\circ ]]></fr:tex> is the <fr:link
type="local"
href="misc-0009.xml"
addr="misc-0009"
title="Duals of Hopf algebras">Sweedler dual</fr:link>. We define the unit to be <fr:tex
display="inline"><![CDATA[1 \otimes  1]]></fr:tex>, the counit as <fr:tex
display="inline"><![CDATA[\epsilon (f \otimes  a) = \epsilon (a) \cdot  f(1)]]></fr:tex>, and the antipode <fr:tex
display="inline"><![CDATA[S^D(f \otimes  a) = S^\circ  (f) \otimes  S(a)]]></fr:tex>. The comultiplication <fr:tex
display="block"><![CDATA[\Delta ^D (f \otimes  a) = \sum _{i j} (g_i \otimes  b_j) \otimes  (h_i \otimes  c_j)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\Delta ^\circ  (f) = \sum _i g_i \otimes  h_i]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[\Delta  (a) = \sum _j b_j \otimes  c_j]]></fr:tex>. We let
  <fr:tex
display="block"><![CDATA[(f \otimes  a) \cdot  (g \otimes  b) = f \cdot  (x \mapsto  g(S^{-1}(a_{(3)}) x a_{(1)})) \otimes  a_{(2)} b.]]></fr:tex>
  We can regard <fr:tex
display="inline"><![CDATA[(H^\textrm {op})^\circ ]]></fr:tex> as a subalgebra of <fr:tex
display="inline"><![CDATA[D(H)]]></fr:tex> via <fr:tex
display="inline"><![CDATA[f \mapsto  f \otimes  1]]></fr:tex>, and similarly for <fr:tex
display="inline"><![CDATA[H]]></fr:tex> with <fr:tex
display="inline"><![CDATA[a \mapsto  1 \otimes  a]]></fr:tex>. Then we can write <fr:tex
display="inline"><![CDATA[f a = f \otimes  a]]></fr:tex>, and the algebra structure is given by the <fr:em>straightening formula</fr:em>
  <fr:tex
display="block"><![CDATA[a f = (x \mapsto  f(S^{-1}(a_{(3)})x a_{(1)})) a_{(2)}.]]></fr:tex>
  This is the <fr:strong>Drinfeld double</fr:strong> of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>.</fr:p><fr:p>For a finite dimensional Hopf algebra <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, the double <fr:tex
display="inline"><![CDATA[D(H)]]></fr:tex> is <fr:link
type="local"
href="misc-0007.xml"
addr="misc-0007"
title="Braided Hopf algebra">braided</fr:link>, with the universal <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-matrix given by
  <fr:tex
display="block"><![CDATA[R = \sum _{i} (1 \otimes  e_i) \otimes  (e^i \otimes  1)]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[e_i]]></fr:tex> is a set of basis of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[e^i]]></fr:tex> is the dual basis in <fr:tex
display="inline"><![CDATA[H^\circ ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3173</fr:anchor><fr:addr
type="user">misc-0002</fr:addr><fr:route>misc-0002.xml</fr:route><fr:title
text="Hopf algebra">Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a vector space <fr:tex
display="inline"><![CDATA[V]]></fr:tex>, we can equip <fr:tex
display="inline"><![CDATA[V]]></fr:tex> with the structure of an associative algebra, given by multilinear maps <fr:tex
display="inline"><![CDATA[V^{\otimes  m} \to  V]]></fr:tex>, usually written as juxtaposition. We can also equip <fr:tex
display="inline"><![CDATA[V]]></fr:tex> with the structure of an coassociative coalgebra, given by maps <fr:tex
display="inline"><![CDATA[V \to  V^{\otimes  m}]]></fr:tex>. We write the comultiplication as <fr:tex
display="inline"><![CDATA[\Delta  : V \to  V \otimes  V]]></fr:tex>, and the counit <fr:tex
display="inline"><![CDATA[\epsilon  : V \to  \Bbbk ]]></fr:tex>. When multiplication and comultiplication distribute over each other, we call the structure a <fr:strong>bialgebra</fr:strong>.</fr:p><fr:p>In this case, we can write linear maps in a seemingly non-linear fashion, by using the comultiplication to duplicate variables. For example <fr:tex
display="inline"><![CDATA[f(x) = x_{(1)} x_{(2)}]]></fr:tex> stands for the composition of <fr:tex
display="inline"><![CDATA[\Delta  : V \to  V \otimes  V]]></fr:tex> and the multiplication map <fr:tex
display="inline"><![CDATA[V \otimes  V \to  V]]></fr:tex>. Note that the duplicated variables needs to be numbered when the comultiplication is not cocommutative. This is called <fr:strong>Sweedler’s notation</fr:strong>.</fr:p><fr:p>Furthermore, suppose there is a map <fr:tex
display="inline"><![CDATA[S : V \to  V]]></fr:tex> called the <fr:strong>antipode</fr:strong> such that <fr:tex
display="inline"><![CDATA[f(x) = x_{(1)} S(x_{(2)})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g(x) = S(x_{(1)}) x_{(2)}]]></fr:tex> are equal to the map <fr:tex
display="inline"><![CDATA[h(x) = \epsilon (x) \cdot  1]]></fr:tex>. We also write the antipode as <fr:tex
display="inline"><![CDATA[x^{-1}]]></fr:tex> where <fr:tex
display="inline"><![CDATA[x \in  V]]></fr:tex>. But note that if <fr:tex
display="inline"><![CDATA[f : V \to  V]]></fr:tex> is a linear map, the notation <fr:tex
display="inline"><![CDATA[f^{-1}]]></fr:tex> instead stands for the usual set-theoretic inverse map.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3175</fr:anchor><fr:addr
type="user">misc-0003</fr:addr><fr:route>misc-0003.xml</fr:route><fr:title
text="Antipode of a Hopf algebra">Antipode of a Hopf algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link>, the antipode is unique, essentially by the same argument for the uniqueness of inverses in group theory. It is also injective, which means for a finite dimensional algebra, it is automatically invertible as a linear map. However, this is not necessarily the case for infinite dimensional Hopf algebras.</fr:p><fr:p>The obvious candidate for the inverse, <fr:tex
display="inline"><![CDATA[S^{-1} = S]]></fr:tex>, is not necessarily valid. The usual group theoretic proof that the inverse is an involution requires either swapping the label of duplicated variables, or swapping the left and right terms of a multiplication. This means <fr:tex
display="inline"><![CDATA[(x^{-1})^{-1} = x]]></fr:tex> holds only for cocommutative or commutative Hopf algebras.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3177</fr:anchor><fr:addr
type="user">misc-0006</fr:addr><fr:route>misc-0006.xml</fr:route><fr:title
text="Braided Hopf algebra">Braided Hopf algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an arbitrary <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, the <fr:link
type="local"
href="misc-0004.xml"
addr="misc-0004"
title="Tensor product and dual of Hopf algebra representations">monoidal category</fr:link> of its representations may not have a braiding. The obvious braiding <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> that simply swaps the two factors <fr:link
type="local"
href="misc-0005.xml"
addr="misc-0005"
title="Symmetric monoidal product on representations of cocommutative Hopf algebras">works for cocommutative Hopf algebras</fr:link> only. Therefore we need to add suitable structures on <fr:tex
display="inline"><![CDATA[H]]></fr:tex> so that we can select an appropriate map <fr:tex
display="inline"><![CDATA[V \otimes  W \to  W \otimes  V]]></fr:tex> between representations that commute with the <fr:tex
display="inline"><![CDATA[H]]></fr:tex>-action.</fr:p><fr:p>Since the twisting map <fr:tex
display="inline"><![CDATA[\tau  : V \otimes  W \to  W \otimes  V]]></fr:tex> does not work, without loss of generality we could consider modifying it by precomposing an automorphism <fr:tex
display="inline"><![CDATA[V \otimes  W \to  V \otimes  W]]></fr:tex>. (We can also consider a postcomposition, which is equivalent.) But we need to specify such an automorphism for every representation <fr:tex
display="inline"><![CDATA[V, W]]></fr:tex>. So the simplest way to achieve this is to select an invertible element <fr:tex
display="inline"><![CDATA[R \in  H \otimes  H]]></fr:tex>, and demand that the automorphism is given by left multiplication by this element. This has the added benefit that naturality is now automatic, since homomorphisms are required to commute with left multiplication.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[R = \sum _i r_i \otimes  s_i]]></fr:tex>, then the automorphism is given by <fr:tex
display="inline"><![CDATA[v \otimes  w \mapsto  R\cdot  (v \otimes  w) = \sum _i \rho _V (r_i) v \otimes  \rho _V (s_i) w]]></fr:tex>. For this to create a braiding homomorphism, we need <fr:tex
display="inline"><![CDATA[\rho _{W \otimes  V}(a) \tau (R \cdot  (v \otimes  w)) = \tau (R \cdot  \rho _{V \otimes  W}(a) (v \otimes  w))]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[\Delta (a) = \sum _j a_j \otimes  b_j]]></fr:tex>, then this equation expands to
  <fr:tex
display="block"><![CDATA[\sum _{i,j} \rho _W (a_j s_i) w \otimes  \rho _V (b_j r_i) v = \sum _{i,j} \rho _W (s_i b_j) w \otimes  \rho _V (r_i a_j) v.]]></fr:tex>
  Since this needs to hold for all <fr:tex
display="inline"><![CDATA[V]]></fr:tex> and <fr:tex
display="inline"><![CDATA[W]]></fr:tex>, we can conclude that
  <fr:tex
display="block"><![CDATA[\sum _{i,j} a_j s_i \otimes  b_j r_i = \sum _{i,j} s_i b_j \otimes  r_i a_j.]]></fr:tex>
  We can write this more succinctly if we write the natural algebra structure on <fr:tex
display="inline"><![CDATA[H \otimes  H]]></fr:tex> as juxtaposition: <fr:tex
display="inline"><![CDATA[\Delta (a) \tau (R) = \tau (R \Delta (a))]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> is an involution as a linear map, and <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is an invertible element of <fr:tex
display="inline"><![CDATA[H \otimes  H]]></fr:tex>, we can rewrite this as
  <fr:tex
display="block"><![CDATA[\tau (\Delta (a)) = R\Delta (a) R^{-1}.]]></fr:tex></fr:p><fr:p>We also need to satisfy the equation for braiding. This basically says that for <fr:tex
display="inline"><![CDATA[V \otimes  (W_1 \otimes  \cdots  \otimes  W_n)]]></fr:tex>, braiding <fr:tex
display="inline"><![CDATA[V]]></fr:tex> to the right in one step is equal to composing the braiding for <fr:tex
display="inline"><![CDATA[V]]></fr:tex> and <fr:tex
display="inline"><![CDATA[W_i]]></fr:tex> for each <fr:tex
display="inline"><![CDATA[i]]></fr:tex>, up to suitable associators. The same for braiding to the left. Abstract nonsense tells us it suffices to verify <fr:tex
display="inline"><![CDATA[n = 2]]></fr:tex>. We can perform a calculation similar to what we did above, and it results in the equation
  <fr:tex
display="block"><![CDATA[(\textrm {id} \otimes  \Delta )(R) = R_{13} R_{12}]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\textrm {id} \otimes  \Delta  : H \otimes  H \to  H \otimes  (H \otimes  H)]]></fr:tex> applies the comultiplication to the second factor, and <fr:tex
display="inline"><![CDATA[R_{12} : H^{\otimes  3}]]></fr:tex> is the identity on the third factor, only acting on the first two factors. Braiding in the other direction amounts to
  <fr:tex
display="block"><![CDATA[(\Delta  \otimes  \textrm {id})(R) = R_{13} R_{23}.]]></fr:tex>
  We have now arrived at the definition of a braided Hopf algebra.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr
type="user">misc-0007</fr:addr><fr:route>misc-0007.xml</fr:route><fr:title
text="Braided Hopf algebra">Braided Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, suppose it is equipped with an element <fr:tex
display="inline"><![CDATA[R \in  H \otimes  H]]></fr:tex>, such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \tau (\Delta (a)) &= R \Delta (a) R^{-1} \\     (\Delta  \otimes  \textrm {id})(R) &= R_{13} R_{23} \\     (\textrm {id} \otimes  \Delta )(R) &= R_{13} R_{12}   \end {aligned}]]></fr:tex>
  then we call it a <fr:strong>braided Hopf algebra</fr:strong>. Here <fr:tex
display="inline"><![CDATA[\tau  : H \otimes  H \to  H \otimes  H]]></fr:tex> is the twisting map of tensor products, and <fr:tex
display="inline"><![CDATA[R_{i j} \in  H^{\otimes  3}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[R \otimes  1]]></fr:tex> with the appropriate factors permuted.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">misc-000C</fr:addr><fr:route>misc-000C.xml</fr:route><fr:title
text="Dual representation of Hopf algebras">Dual representation of Hopf algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="misc-0003.xml"
addr="misc-0003"
title="Antipode of a Hopf algebra">antipode of a Hopf algebra</fr:link> provides us with the structure to define dual representations. Given a representation <fr:tex
display="inline"><![CDATA[V]]></fr:tex> of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, we can define an action on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex> by <fr:tex
display="inline"><![CDATA[(h \cdot  f)(v) = f(S(h) \cdot  v)]]></fr:tex>. This works out because the antipode is an anti-homomorphism. This induces a contravariant functor on the category of representations.</fr:p><fr:p>Categorically speaking, for <fr:tex
display="inline"><![CDATA[V]]></fr:tex> to have a right dual structure on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex>, we need structure maps <fr:tex
display="inline"><![CDATA[1 \to  V \otimes  V^*]]></fr:tex> and <fr:tex
display="inline"><![CDATA[V^* \otimes  V \to  1]]></fr:tex>. This requires <fr:tex
display="inline"><![CDATA[V]]></fr:tex> to be finite dimensional. In this case, we need to verify the obvious map from linear algebra is indeed a module homomorphism. This essentially follows from <fr:tex
display="inline"><![CDATA[x_{(1)} \cdot  S(x_{(2)}) = \epsilon (x) = S(x_{(1)}) \cdot  x_{(2)}]]></fr:tex>.</fr:p><fr:p>However, this module structure on <fr:tex
display="inline"><![CDATA[V^*]]></fr:tex> cannot be taken as the left dual of <fr:tex
display="inline"><![CDATA[V]]></fr:tex>! The reason is the evaluation map <fr:tex
display="inline"><![CDATA[v \otimes  f \mapsto  f(v)]]></fr:tex> doesn’t respect multiplication, since <fr:tex
display="inline"><![CDATA[S(x_{(2)}) x_{(1)}]]></fr:tex> is not necessarily equal to <fr:tex
display="inline"><![CDATA[S(x_{(1)}) \cdot  x_{(2)}]]></fr:tex>. Instead we need another module structure on the same vector space, using <fr:tex
display="inline"><![CDATA[S^{-1}]]></fr:tex> in place of <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. Let this representation be denoted as <fr:tex
display="inline"><![CDATA[{^{\vee }V}]]></fr:tex>, and for clarity we denote the right dual module as <fr:tex
display="inline"><![CDATA[V^{\vee }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3179</fr:anchor><fr:addr
type="user">misc-0007</fr:addr><fr:route>misc-0007.xml</fr:route><fr:title
text="Braided Hopf algebra">Braided Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, suppose it is equipped with an element <fr:tex
display="inline"><![CDATA[R \in  H \otimes  H]]></fr:tex>, such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \tau (\Delta (a)) &= R \Delta (a) R^{-1} \\     (\Delta  \otimes  \textrm {id})(R) &= R_{13} R_{23} \\     (\textrm {id} \otimes  \Delta )(R) &= R_{13} R_{12}   \end {aligned}]]></fr:tex>
  then we call it a <fr:strong>braided Hopf algebra</fr:strong>. Here <fr:tex
display="inline"><![CDATA[\tau  : H \otimes  H \to  H \otimes  H]]></fr:tex> is the twisting map of tensor products, and <fr:tex
display="inline"><![CDATA[R_{i j} \in  H^{\otimes  3}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[R \otimes  1]]></fr:tex> with the appropriate factors permuted.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3181</fr:anchor><fr:addr
type="user">misc-0009</fr:addr><fr:route>misc-0009.xml</fr:route><fr:title
text="Duals of Hopf algebras">Duals of Hopf algebras</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an coalgebra <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the <fr:strong>linear dual</fr:strong> <fr:tex
display="inline"><![CDATA[A^*]]></fr:tex> consists of linear maps <fr:tex
display="inline"><![CDATA[A \to  \Bbbk ]]></fr:tex>. The coalgebra structure becomes a algebra structure on the dual: suppose <fr:tex
display="inline"><![CDATA[\Delta (a) = \sum _i b_i \otimes  c_i]]></fr:tex>, then
  <fr:tex
display="block"><![CDATA[(f \cdot  g)(a) = \sum _i f(b_i) g(c_i).]]></fr:tex>
  However, it is not clear how we can take the dual coalgebra of an algebra, unless the algebra is finite dimensional.</fr:p><fr:p>Suppose we have a algebra <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, we can take a subspace <fr:tex
display="inline"><![CDATA[A^\circ  \subseteq  A^*]]></fr:tex> consisting of functionals <fr:tex
display="inline"><![CDATA[f]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[a \otimes  b \mapsto  f(a b)]]></fr:tex> decomposes as a finite sum of terms of the form <fr:tex
display="inline"><![CDATA[g_i (a) h_i (b)]]></fr:tex>. This is called the <fr:strong>Sweedler dual</fr:strong>, or restricted dual. Now we can define comultiplication <fr:tex
display="inline"><![CDATA[\Delta ^\circ ]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\sum _i g_i \otimes  h_i]]></fr:tex>. This doesn’t depend on the choice of <fr:tex
display="inline"><![CDATA[g_i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h_i]]></fr:tex> by bilinearity.</fr:p><fr:p>Furthermore, if <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a bialgebra, then the algebra structure on <fr:tex
display="inline"><![CDATA[A^*]]></fr:tex> restricts to an algebra structure on <fr:tex
display="inline"><![CDATA[A^\circ ]]></fr:tex>. The counit <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[A^\circ ]]></fr:tex> since <fr:tex
display="inline"><![CDATA[\epsilon (a b) = \epsilon (a) \epsilon (b)]]></fr:tex>. For the multiplication, suppose we have <fr:tex
display="inline"><![CDATA[\Delta ^\circ  (f) = \sum _i g_i \otimes  h_i]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\Delta ^\circ  (f') = \sum _i g'_i \otimes  h'_i]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[\Delta (a) = \sum _i b_i \otimes  c_i]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\Delta (a') = \sum _i b'_i \otimes  c'_i]]></fr:tex>. By distributivity, <fr:tex
display="inline"><![CDATA[\Delta (a a') = \sum _{i j} b_i b'_j \otimes  c_i c'_j]]></fr:tex>. So the multiplication defined above gives
  <fr:tex
display="block"><![CDATA[\begin {aligned}     (f \cdot  f')(a a') &= \sum _{i j} f(b_i b'_j) f'(c_i c'_j) \\     &= \sum _{i j k \ell } g_k (b_i) h_k (b'_j)  g'_\ell  (c_i) h'_\ell  (c'_j).   \end {aligned}]]></fr:tex>
  If we let <fr:tex
display="inline"><![CDATA[G_{k \ell } (a) = \sum _i g_k (b_i) g'_\ell  (c_i)]]></fr:tex> and similarly for <fr:tex
display="inline"><![CDATA[H_{k \ell }]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[a \otimes  a' \mapsto  (f \cdot  f')(a a')]]></fr:tex> indeed decomposes into the sum of <fr:tex
display="inline"><![CDATA[G_{k \ell } (a) H_{k \ell } (a')]]></fr:tex>. And therefore the multiplication is still inside <fr:tex
display="inline"><![CDATA[A^\circ ]]></fr:tex>. The bialgebra axioms can be easily verified.</fr:p><fr:p>Furthermore, if <fr:tex
display="inline"><![CDATA[A]]></fr:tex> has an antipode <fr:tex
display="inline"><![CDATA[S : A \to  A]]></fr:tex> making it a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link>, this automatically induces <fr:tex
display="inline"><![CDATA[S^* : A^* \to  A^*]]></fr:tex> by <fr:tex
display="inline"><![CDATA[S^* (f)(a) = f(S(a))]]></fr:tex>. And suppose <fr:tex
display="inline"><![CDATA[f \in  A^\circ ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[f(S(a b)) = f(S(b) S(a))]]></fr:tex>, and we can verify <fr:tex
display="inline"><![CDATA[S^*(f)]]></fr:tex> is also in <fr:tex
display="inline"><![CDATA[A^\circ ]]></fr:tex>. This provides an antipode to <fr:tex
display="inline"><![CDATA[A^\circ ]]></fr:tex> too, which is invertible if <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is invertible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3183</fr:anchor><fr:addr
type="user">misc-0008</fr:addr><fr:route>misc-0008.xml</fr:route><fr:title
text="Opposite Hopf algebra">Opposite Hopf algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex> with <fr:link
type="local"
href="misc-0003.xml"
addr="misc-0003"
title="Antipode of a Hopf algebra">invertible antipode</fr:link>, we can replace the comultiplication <fr:tex
display="inline"><![CDATA[\Delta ]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\tau  \mathbin {\circ } \Delta ]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> switches the two factors of tensor product, and the antipode by its inverse. This produces another Hopf algebra called its <fr:strong>opposite</fr:strong>.</fr:p><fr:p>Alternatively, we can replace the multiplication instead. We can also simultaneously replace the multiplication and comultiplication but not the antipode. This forms a square of opposition.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3185</fr:anchor><fr:addr
type="user">misc-0005</fr:addr><fr:route>misc-0005.xml</fr:route><fr:title
text="Symmetric monoidal product on representations of cocommutative Hopf algebras">Symmetric monoidal product on representations of cocommutative Hopf algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex> is cocommutative, i.e. <fr:tex
display="inline"><![CDATA[\Delta (a) \in  H \otimes  H]]></fr:tex> is invariant under swapping the two factors, then the monoidal structure of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>-representations defined in <fr:ref
addr="misc-0004"
href="misc-0004.xml"
taxon="Definition" /> is actually symmetric. The braiding is simply given by the braiding of vector space tensor products, and we only need to show that it is a homomorphism of representations. This immediately follows from the definition.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3187</fr:anchor><fr:addr
type="user">misc-0004</fr:addr><fr:route>misc-0004.xml</fr:route><fr:title
text="Tensor product and dual of Hopf algebra representations">Tensor product and dual of Hopf algebra representations</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="misc-0002.xml"
addr="misc-0002"
title="Hopf algebra">Hopf algebra</fr:link> <fr:tex
display="inline"><![CDATA[H]]></fr:tex>, its representations (i.e. left modules of <fr:tex
display="inline"><![CDATA[H]]></fr:tex> considered as an associative algebra) have a monoidal structure. The underlying vector space is given by the tensor product of vector spaces, and the module structure <fr:tex
display="inline"><![CDATA[\rho _{V_1 \otimes  V_2} : H \otimes  (V_1 \otimes  V_2) \to  V_1 \otimes  V_2]]></fr:tex> is given by the comultiplication: Suppose <fr:tex
display="inline"><![CDATA[\Delta (a) = \sum _i b_i \otimes  c_i]]></fr:tex>, then
  <fr:tex
display="block"><![CDATA[\rho _{V_1 \otimes  V_2} (a) (x \otimes  y) = \sum _i \rho _{V_1}(b_i) x \otimes  \rho _{V_2}(c_i) y.]]></fr:tex>
  Or in Sweedler’s notation, <fr:tex
display="inline"><![CDATA[\rho _{V_1} (a_{(1)}) x \otimes  \rho _{V_2} (a_{(2)}) x]]></fr:tex>. Similarly, the antipode provides a module structure on the dual vector space:
  <fr:tex
display="block"><![CDATA[(\rho _{V^*} (a) \alpha )(x) = \alpha (\rho _V (a^{-1}) x).]]></fr:tex>
  Hence the category of <fr:tex
display="inline"><![CDATA[H]]></fr:tex>-representations is monoidal closed.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3189</fr:anchor><fr:addr
type="user">cplx-000C</fr:addr><fr:route>cplx-000C.xml</fr:route><fr:title
text="Liouville’s theorem">Liouville’s theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A bounded holomorphic function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> defined on the entire complex plane must be constant.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>634</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-000C</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the integral formulas for derivatives in <fr:ref
addr="cplx-000B"
href="cplx-000B.xml" />
    <fr:tex
display="block"><![CDATA[f'(z) = \frac {1}{2 \pi  i} \int _\gamma  \frac {f(w)}{(w - z)^2} \operatorname {d}\mathclose {w},]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is some circle of radius <fr:tex
display="inline"><![CDATA[r]]></fr:tex> enclosing <fr:tex
display="inline"><![CDATA[z]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[f(w)]]></fr:tex> is bounded, the integrand is bounded by <fr:tex
display="inline"><![CDATA[C r^{-2}]]></fr:tex> for some constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex>. But this means the derivative is bounded by <fr:tex
display="inline"><![CDATA[O(r^{-1})]]></fr:tex>. Since the function is holomorphic on the entire plane, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> can be arbitrary large, which means <fr:tex
display="inline"><![CDATA[f'(z) = 0]]></fr:tex>.</fr:p>

  <fr:p>When <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is not defined on the entire plane, this method still gives an upper bound on the magnitude of the derivative <fr:tex
display="block"><![CDATA[|f^{(n)} (z)| \le  M n! \cdot  r^{-n}.]]></fr:tex> This is known as the <fr:strong>Cauchy estimate</fr:strong>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3191</fr:anchor><fr:addr
type="user">cplx-000B</fr:addr><fr:route>cplx-000B.xml</fr:route><fr:title
text="Holomorphic functions have holomorphic derivatives">Holomorphic functions have holomorphic derivatives</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a holomorphic function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> on an open set, it has derivatives of arbitrarily high order, given by the explicit formula
  <fr:tex
display="block"><![CDATA[f^{(n)}(z) = \frac {n!}{2 \pi  i} \int _\gamma  \frac {f(w)}{(w - z)^{n + 1}} \operatorname {d}\mathclose {w},]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is a circle around <fr:tex
display="inline"><![CDATA[z]]></fr:tex> contained in the open set.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>640</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We perform induction. The case for <fr:tex
display="inline"><![CDATA[n = 0]]></fr:tex> is the <fr:link
type="local"
href="cplx-0009.xml"
addr="cplx-0009"
title="Cauchy integral formula">Cauchy integral formula</fr:link>. Suppose it holds for some <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, now using the difference of powers formula
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f^{(n+1)}(z_0) &= \lim _{z \to  z_0} \frac {f^{(n)}(z) - f^{(n)}(z_0)}{z - z_0} \\       &= \lim _{z \to  z_0} \frac {n!}{2 \pi  i (z - z_0)} \int _\gamma  f(w) \left (\frac {1}{(w - z)^{n + 1}} - \frac {1}{(w - z_0)^{n + 1}}\right ) \operatorname {d}\mathclose {w} \\       &= \lim _{z \to  z_0} \frac {n!}{2 \pi  i} \int _\gamma  \frac {f(w)}{(w - z)^{n+1} (w - z_0)^{n+1}} \sum _{k=0}^{n} (w - z)^k (w - z_0)^{n-k} \operatorname {d}\mathclose {w}.     \end {aligned}]]></fr:tex>
    As <fr:tex
display="inline"><![CDATA[z \to  z_0]]></fr:tex> the sum uniformly converges to <fr:tex
display="inline"><![CDATA[(n+1)(w - z_0)^{n}]]></fr:tex>. This proves the claim.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3193</fr:anchor><fr:addr
type="user">cplx-000A</fr:addr><fr:route>cplx-000A.xml</fr:route><fr:title
text="Derivative of holomorphic functions">Derivative of holomorphic functions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="cplx-0009.xml"
addr="cplx-0009"
title="Cauchy integral formula">Cauchy integral formula</fr:link> may look innocent, but it contains a profound element. Namely, that it reduces the value of a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> at a point <fr:tex
display="inline"><![CDATA[f(z)]]></fr:tex> to an integral of <fr:tex
display="inline"><![CDATA[f(w)/(w - z)]]></fr:tex> on a surrounding circle. This expression as a function of <fr:tex
display="inline"><![CDATA[z]]></fr:tex> is smooth and easy to deal with, and we can leverage this to obtain properties of the original function, seemingly out of thin air. Consider for example the derivative of this function, we can compute
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \frac {f(z) - f(z_0)}{z - z_0} &= \frac {1}{2 \pi  i (z - z_0)} \int _\gamma  f(w) \left ( \frac {1}{w - z} - \frac {1}{w - z_0} \right ) \operatorname {d}\mathclose {w} \\     &= \frac {1}{2 \pi  i} \int _\gamma  \frac {f(w)}{(w - z) (w - z_0)} \operatorname {d}\mathclose {w}.   \end {aligned}]]></fr:tex>
  But this obviously converges to <fr:tex
display="inline"><![CDATA[\int _\gamma  f(w) / (w - z_0)^2 \operatorname {d}\mathclose {w}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[z \to  z_0]]></fr:tex>, since the integrand converges uniformly, thanks to the nice behavior of <fr:tex
display="inline"><![CDATA[f(w)/(w - z)]]></fr:tex> as a function of <fr:tex
display="inline"><![CDATA[z]]></fr:tex> as previously mentioned. We have therefore also obtained a formula for the derivative of a holomorphic function. This can now be repeated to obtain higher derivatives.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3195</fr:anchor><fr:addr
type="user">cplx-0009</fr:addr><fr:route>cplx-0009.xml</fr:route><fr:title
text="Cauchy integral formula">Cauchy integral formula</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and a point <fr:tex
display="inline"><![CDATA[a]]></fr:tex> such that a disk containing <fr:tex
display="inline"><![CDATA[a]]></fr:tex> lies within the domain of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have
  <fr:tex
display="block"><![CDATA[f(a) = \frac {1}{2 \pi  i} \int _{\gamma } \frac {f(z)}{z - a} \operatorname {d}\mathclose {z},]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is the boundary of the disk.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Removing a smaller disk of radius <fr:tex
display="inline"><![CDATA[r]]></fr:tex> around <fr:tex
display="inline"><![CDATA[a]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\frac {f(z) - f(a)}{z - a}]]></fr:tex> is an analytic function in this region. Applying <fr:link
type="local"
href="cplx-0006.xml"
addr="cplx-0006"
title="Integral of holomorphic function does not depend on path">Green’s formula</fr:link> we have
    <fr:tex
display="block"><![CDATA[\int _{\gamma } \frac {f(z) - f(a)}{z - a} \operatorname {d}\mathclose {z} = \int _{\gamma '} \frac {f(z) - f(a)}{z - a} \operatorname {d}\mathclose {z}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is the original circle, and <fr:tex
display="inline"><![CDATA[\gamma ']]></fr:tex> is the smaller circle. Now since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is holomorphic, the integrand has a limit as <fr:tex
display="inline"><![CDATA[z \to  a]]></fr:tex> by definition, so in particular it is bounded for small enough <fr:tex
display="inline"><![CDATA[r]]></fr:tex>. Therefore the right hand side is bounded by <fr:tex
display="inline"><![CDATA[2 \pi  r C]]></fr:tex> for a constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, which goes to zero. So the left hand side must be zero since it does not depend on <fr:tex
display="inline"><![CDATA[r]]></fr:tex>.</fr:p>

  <fr:p>Separating the two terms in the integral, we are left to prove
    <fr:tex
display="block"><![CDATA[\int _\gamma  \frac {\operatorname {d}\mathclose {z}}{z - a} = 2 \pi  i.]]></fr:tex>
    This can be done by looking up integral tables.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3197</fr:anchor><fr:addr
type="user">cplx-0008</fr:addr><fr:route>cplx-0008.xml</fr:route><fr:title
text="First consequences of complex differentiability">First consequences of complex differentiability</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>From the definition of a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link>, we can immediately start exploring some of its consequences. It turns out that complex differentiability is much stronger than real differentiability, and the following theorem gives a first glimpse.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>668</fr:anchor><fr:addr
type="user">cplx-0002</fr:addr><fr:route>cplx-0002.xml</fr:route><fr:title
text="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f : U \to  \mathbb {C}]]></fr:tex> be a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> defined on an open set <fr:tex
display="inline"><![CDATA[U \subseteq  \mathbb {C}]]></fr:tex>. Viewed as two functions of two real variables <fr:tex
display="inline"><![CDATA[f(x + i y) = u(x, y) + i v(x, y)]]></fr:tex>, they are differentiable, and moreover satisfies equations
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \frac {\partial  u}{\partial  x} &= \frac {\partial  v}{\partial  y}, \\     \frac {\partial  u}{\partial  y} &= -\frac {\partial  v}{\partial  x}.   \end {aligned}]]></fr:tex>
  These are necessary and sufficient conditions for holomorphicity. We say <fr:tex
display="inline"><![CDATA[v]]></fr:tex> is a <fr:strong>harmonic conjugate</fr:strong> of <fr:tex
display="inline"><![CDATA[u]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[-u]]></fr:tex> is similarly a harmonic conjugate of <fr:tex
display="inline"><![CDATA[v]]></fr:tex>. They determine each other up to a constant, by the Poincaré lemma recovering a function from its differential.</fr:p><fr:p>Intuitively, for a function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be complex differentiable, we need <fr:tex
display="inline"><![CDATA[(f(z + \epsilon ) - f(z)) / \epsilon ]]></fr:tex> to converge to the <fr:em>same</fr:em> value for both real and imaginary <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>. The real and imaginary parts of this equality correspond to the two Cauchy–Riemann equations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>We can write these equations formally in a more suggestive way.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>670</fr:anchor><fr:addr
type="user">cplx-0003</fr:addr><fr:route>cplx-0003.xml</fr:route><fr:title
text="Complexifying the (co)tangent space">Complexifying the (co)tangent space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Considering <fr:tex
display="inline"><![CDATA[\mathbb {C}]]></fr:tex> as a two dimensional real space, the tangent space at a point (take zero as an example) is <fr:tex
display="inline"><![CDATA[\mathbb {R}^2]]></fr:tex>. It comes equipped with a complex structure <fr:tex
display="inline"><![CDATA[J]]></fr:tex> sending <fr:tex
display="inline"><![CDATA[\partial _x \mapsto  \partial _y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _y \mapsto  -\partial _x]]></fr:tex>, acting as multiplication by <fr:tex
display="inline"><![CDATA[i]]></fr:tex>. A (real) smooth function <fr:tex
display="inline"><![CDATA[\mathbb {C} \to  \mathbb {C}]]></fr:tex> then has a Jacobian at each point, which is a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix <fr:tex
display="inline"><![CDATA[M]]></fr:tex>. The <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link> then imposes a condition on this matrix, which can be written as <fr:tex
display="inline"><![CDATA[J M = M J]]></fr:tex>.</fr:p><fr:p>It is sometimes convenient to complexify this vector space <fr:tex
display="inline"><![CDATA[\mathbb {R}^2 \otimes  \mathbb {C} = \mathbb {C}^2]]></fr:tex>. This corresponds to formally allowing the <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> components to be complex-valued. This is because we often want to view a complex function as a scalar field on a two dimensional (real) manifold, but the scalar can be complex. So to do calculus with these scalars, naturally the associated tangent and cotangent spaces needs to be complexified. <fr:tex
display="inline"><![CDATA[J]]></fr:tex> now has two eigenvalues <fr:tex
display="inline"><![CDATA[i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[-i]]></fr:tex>, corresponding to the <fr:strong>holomorphic</fr:strong> and <fr:strong>antiholomorphic</fr:strong> subspaces.</fr:p><fr:p>Of course this only happens in the tangent space, and the coordinate functions cannot be extended to complex domains. The Jacobian then extends to the complexified tangent space. This space has an alternative basis <fr:tex
display="block"><![CDATA[\partial _z = \frac {1}{2}(\partial _x - i \partial _y) \quad \text {and}\quad \partial _{\bar {z}} = \frac {1}{2}(\partial _x + i \partial _y).]]></fr:tex> This has the dual basis on <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-forms, given by <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z} = \operatorname {d}\mathclose {x} + i \operatorname {d}\mathclose {y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {\bar {z}} = \operatorname {d}\mathclose {x} - i \operatorname {d}\mathclose {y}]]></fr:tex>. In this basis, the Cauchy–Riemann equation can be written as <fr:tex
display="inline"><![CDATA[\partial _{\bar {z}} f = 0]]></fr:tex>.</fr:p><fr:p>This gives a heuristic procedure for finding the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">harmonic conjugate</fr:link> of a function.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr
type="user">cplx-0004</fr:addr><fr:route>cplx-0004.xml</fr:route><fr:title
text="Formal method to calculate the harmonic conjugate">Formal method to calculate the harmonic conjugate</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[u]]></fr:tex> is the real part of some <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Then we have <fr:tex
display="inline"><![CDATA[2 u(x, y) = f(x + i y) + \overline {f(x + i y)}]]></fr:tex>. If we could extend the coordinates <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> to complex numbers, then similar to <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">what happens in the tangent space</fr:link>, we have a <fr:tex
display="inline"><![CDATA[(z, \bar {z})]]></fr:tex> coordinate system with <fr:tex
display="inline"><![CDATA[z = x + i y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bar {z} = x - i y]]></fr:tex> acting as <fr:em>independent</fr:em> variables in <fr:tex
display="inline"><![CDATA[\mathbb {C}^2]]></fr:tex>.</fr:p><fr:p>By the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link>, <fr:tex
display="inline"><![CDATA[f(x + i y)]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[z]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\overline {f(x + i y)}]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[\bar {z}]]></fr:tex>. So we can write the latter as another function <fr:tex
display="inline"><![CDATA[g(\bar {z})]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[2 u = f(z) + g(\bar {z})]]></fr:tex>, we can look at the value at the point <fr:tex
display="inline"><![CDATA[(z, \bar {z}) = (\alpha , 0)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\alpha  \in  \mathbb {C}]]></fr:tex>, which corresponds to <fr:tex
display="inline"><![CDATA[x = \alpha  / 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y = - i \alpha  / 2]]></fr:tex>. Hence <fr:tex
display="block"><![CDATA[2 u(\alpha  / 2, - i \alpha  / 2) = f(\alpha ) + g(0),]]></fr:tex> which determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex> up to some constant. This method requires an analytic expression of <fr:tex
display="inline"><![CDATA[u(x, y)]]></fr:tex>, so it makes sense to plug in complex numbers into <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link> is very suggestive of the assumption in Green’s theorem in (real) multi-variable calculus. This prompts us to define notions of line integrals on the complex plane.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>674</fr:anchor><fr:addr
type="user">cplx-0005</fr:addr><fr:route>cplx-0005.xml</fr:route><fr:title
text="Line integral">Line integral</fr:title><fr:taxon>Defintion</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a complex function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and a piecewise differentiable curve <fr:tex
display="inline"><![CDATA[\gamma  : [a, b] \to  \mathbb {C}]]></fr:tex>, we can define a few different kinds of line integrals along <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex>. The first is the <fr:strong>naive line integral</fr:strong>, given by directly integrating
  <fr:tex
display="block"><![CDATA[\int _a^b f(\gamma (t)) \operatorname {d}\mathclose {t}.]]></fr:tex>
  But this depends on the parametrization of the curve.</fr:p><fr:p>We can also define the <fr:strong>complex line integral</fr:strong>, which is independent of parametrization:
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \operatorname {d}\mathclose {z} = \int _a^b f(\gamma (t)) \gamma '(t) \operatorname {d}\mathclose {t}.]]></fr:tex>
  Following the convention of <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">complexifying the (co)tangent space</fr:link>, we can write <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z} = \operatorname {d}\mathclose {x} + i \operatorname {d}\mathclose {y}]]></fr:tex>. This leads to the evident definition of integrating against <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {x}]]></fr:tex>, given by
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \operatorname {d}\mathclose {x} = \int _a^b f(\gamma (t)) \operatorname {Re}\gamma '(t) \operatorname {d}\mathclose {t}.]]></fr:tex> And <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {y}]]></fr:tex> is defined similarly.</fr:p><fr:p>Finally, there is also the <fr:strong>arc length integral</fr:strong>, which is given by
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \left |\operatorname {d}\mathclose {z}\right | = \int _a^b f(\gamma (t)) \left |\gamma '(t)\right | \operatorname {d}\mathclose {t}.]]></fr:tex>
  In particular, integrating the constant function <fr:tex
display="inline"><![CDATA[1]]></fr:tex> gives the length of the curve.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>676</fr:anchor><fr:addr
type="user">cplx-0006</fr:addr><fr:route>cplx-0006.xml</fr:route><fr:title
text="Integral of holomorphic function does not depend on path">Integral of holomorphic function does not depend on path</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex> on an open set <fr:tex
display="inline"><![CDATA[U]]></fr:tex>, the <fr:link
type="local"
href="cplx-0005.xml"
addr="cplx-0005"
title="Line integral">complex line integral</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> along two homotopic paths are equal. This is a direct consequence of the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link> and Green’s theorem. However, we need to be careful with the hypotheses when we have low differentiability.</fr:p><fr:p>We can write down the idea more succinctly using <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">the notation</fr:link> of <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {\bar {z}}]]></fr:tex>. We are integrating along <fr:tex
display="inline"><![CDATA[f(z) \operatorname {d}\mathclose {z}]]></fr:tex>, but this is an closed differential, since <fr:tex
display="block"><![CDATA[\operatorname {d} (f(z) \operatorname {d}\mathclose {z}) = - \partial _{\bar {z}} f(z) \operatorname {d}\mathclose {z} \wedge  \operatorname {d}\mathclose {\bar {z}} = 0.]]></fr:tex>
  This shows the power of complexifying the tangent space.</fr:p><fr:p>This applies when <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is complex differentiable at every point, since complex differentiability implies (real) Fréchet differentiability (i.e. <fr:tex
display="inline"><![CDATA[f]]></fr:tex> can be approximated by a linear map at each point), which suffices for Green’s theorem to apply. It also suffices that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the derivative of another <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link>, and it is Riemann integrable. In this case we can simply apply the fundamental theorem of calculus.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In fact, <fr:ref
addr="cplx-0006"
href="cplx-0006.xml"
taxon="Theorem" /> is still applicable when the function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is holomorphic except at isolated points <fr:tex
display="inline"><![CDATA[z_i]]></fr:tex>, but <fr:tex
display="inline"><![CDATA[f(z)]]></fr:tex> is <fr:tex
display="inline"><![CDATA[o(|z - z_i|^{-1})]]></fr:tex>. This can be seen by making the curve loop around a small disk of radius <fr:tex
display="inline"><![CDATA[r]]></fr:tex> around these bad points. The loop integral goes to zero as <fr:tex
display="inline"><![CDATA[O(r) o(r^{-1}) = o(1)]]></fr:tex>, and so does not affect the result. This is important because there is a function in the definition of complex differentiability, namely
  <fr:tex
display="block"><![CDATA[g(z) = \frac {f(z) - f(a)}{z - a}.]]></fr:tex>
  And so the integral of <fr:tex
display="inline"><![CDATA[g(z)]]></fr:tex> along a circle around <fr:tex
display="inline"><![CDATA[a]]></fr:tex> must be zero. Now we can separate out the second term <fr:tex
display="inline"><![CDATA[f(a) \cdot  \int _\gamma  1/(z - a) \operatorname {d}\mathclose {z}]]></fr:tex>. This can be directly computed to be <fr:tex
display="inline"><![CDATA[2 \pi  i f(a)]]></fr:tex>. This proves the following formula.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>678</fr:anchor><fr:addr
type="user">cplx-0009</fr:addr><fr:route>cplx-0009.xml</fr:route><fr:title
text="Cauchy integral formula">Cauchy integral formula</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and a point <fr:tex
display="inline"><![CDATA[a]]></fr:tex> such that a disk containing <fr:tex
display="inline"><![CDATA[a]]></fr:tex> lies within the domain of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have
  <fr:tex
display="block"><![CDATA[f(a) = \frac {1}{2 \pi  i} \int _{\gamma } \frac {f(z)}{z - a} \operatorname {d}\mathclose {z},]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is the boundary of the disk.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Removing a smaller disk of radius <fr:tex
display="inline"><![CDATA[r]]></fr:tex> around <fr:tex
display="inline"><![CDATA[a]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\frac {f(z) - f(a)}{z - a}]]></fr:tex> is an analytic function in this region. Applying <fr:link
type="local"
href="cplx-0006.xml"
addr="cplx-0006"
title="Integral of holomorphic function does not depend on path">Green’s formula</fr:link> we have
    <fr:tex
display="block"><![CDATA[\int _{\gamma } \frac {f(z) - f(a)}{z - a} \operatorname {d}\mathclose {z} = \int _{\gamma '} \frac {f(z) - f(a)}{z - a} \operatorname {d}\mathclose {z}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is the original circle, and <fr:tex
display="inline"><![CDATA[\gamma ']]></fr:tex> is the smaller circle. Now since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is holomorphic, the integrand has a limit as <fr:tex
display="inline"><![CDATA[z \to  a]]></fr:tex> by definition, so in particular it is bounded for small enough <fr:tex
display="inline"><![CDATA[r]]></fr:tex>. Therefore the right hand side is bounded by <fr:tex
display="inline"><![CDATA[2 \pi  r C]]></fr:tex> for a constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, which goes to zero. So the left hand side must be zero since it does not depend on <fr:tex
display="inline"><![CDATA[r]]></fr:tex>.</fr:p>

  <fr:p>Separating the two terms in the integral, we are left to prove
    <fr:tex
display="block"><![CDATA[\int _\gamma  \frac {\operatorname {d}\mathclose {z}}{z - a} = 2 \pi  i.]]></fr:tex>
    This can be done by looking up integral tables.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The integral of <fr:tex
display="inline"><![CDATA[1/(z-a)]]></fr:tex> can in fact be computed more generally. This also means we can use more general closed curves in <fr:ref
addr="cplx-0009"
href="cplx-0009.xml"
taxon="Theorem" />, which will be useful in calculations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>680</fr:anchor><fr:addr
type="user">cplx-0007</fr:addr><fr:route>cplx-0007.xml</fr:route><fr:title
text="Integration around a pole">Integration around a pole</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a piecewise differentiable closed curve <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> not passing through <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, the complex <fr:link
type="local"
href="cplx-0005.xml"
addr="cplx-0005"
title="Line integral">line integral</fr:link> <fr:tex
display="block"><![CDATA[\int _\gamma  \frac {1}{z - a} \operatorname {d}\mathclose {z}]]></fr:tex> is always a multiple of <fr:tex
display="inline"><![CDATA[2 \pi  i]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>682</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-0007</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Intuitively, <fr:tex
display="inline"><![CDATA[1/(z-a)]]></fr:tex> is the derivative of the function <fr:tex
display="inline"><![CDATA[\log (z - a)]]></fr:tex>. But formalizing this is difficult, since logarithms are not single-valued, so what happens near the branch cuts is not clear. However, we can avoid this by considering the inverse function <fr:tex
display="inline"><![CDATA[\exp ]]></fr:tex> instead.</fr:p>

  <fr:p>Let the path be parametrized by the interval <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex> for convenience. Consider the function <fr:tex
display="block"><![CDATA[g(t) = \int _0^t \frac {\gamma '(t)}{\gamma (t) - a} \operatorname {d}\mathclose {t}.]]></fr:tex> By the intuition above, we expect <fr:tex
display="inline"><![CDATA[g(t) \xlongequal {?} \log (\gamma (t) - a) + C]]></fr:tex>. So we instead consider <fr:tex
display="inline"><![CDATA[h(t) = \exp (g(t))/(\gamma (t) - a)]]></fr:tex> and prove it is a constant. This can be verified by differentiation, using the chain rule and the fundamental theorem of calculus.</fr:p>

  <fr:p>Of course, <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is only piecewise differentiable. So <fr:tex
display="inline"><![CDATA[h(t)]]></fr:tex> is only constant on each piece. But in addition, <fr:tex
display="inline"><![CDATA[h(t)]]></fr:tex> is continuous on the entire curve, so it must be globally constant. Moreover, since <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is a loop, we have <fr:tex
display="inline"><![CDATA[\gamma (0) = \gamma (1)]]></fr:tex>, and since <fr:tex
display="inline"><![CDATA[h(0) = h(1)]]></fr:tex>, we can deduce <fr:tex
display="inline"><![CDATA[1 = \exp (g(0)) = \exp (g(1))]]></fr:tex>, which means the integral <fr:tex
display="inline"><![CDATA[g(1)]]></fr:tex> is a multiple of <fr:tex
display="inline"><![CDATA[2 \pi  i]]></fr:tex> as desired.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3199</fr:anchor><fr:addr
type="user">cplx-0006</fr:addr><fr:route>cplx-0006.xml</fr:route><fr:title
text="Integral of holomorphic function does not depend on path">Integral of holomorphic function does not depend on path</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex> on an open set <fr:tex
display="inline"><![CDATA[U]]></fr:tex>, the <fr:link
type="local"
href="cplx-0005.xml"
addr="cplx-0005"
title="Line integral">complex line integral</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> along two homotopic paths are equal. This is a direct consequence of the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link> and Green’s theorem. However, we need to be careful with the hypotheses when we have low differentiability.</fr:p><fr:p>We can write down the idea more succinctly using <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">the notation</fr:link> of <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {\bar {z}}]]></fr:tex>. We are integrating along <fr:tex
display="inline"><![CDATA[f(z) \operatorname {d}\mathclose {z}]]></fr:tex>, but this is an closed differential, since <fr:tex
display="block"><![CDATA[\operatorname {d} (f(z) \operatorname {d}\mathclose {z}) = - \partial _{\bar {z}} f(z) \operatorname {d}\mathclose {z} \wedge  \operatorname {d}\mathclose {\bar {z}} = 0.]]></fr:tex>
  This shows the power of complexifying the tangent space.</fr:p><fr:p>This applies when <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is complex differentiable at every point, since complex differentiability implies (real) Fréchet differentiability (i.e. <fr:tex
display="inline"><![CDATA[f]]></fr:tex> can be approximated by a linear map at each point), which suffices for Green’s theorem to apply. It also suffices that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the derivative of another <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link>, and it is Riemann integrable. In this case we can simply apply the fundamental theorem of calculus.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3201</fr:anchor><fr:addr
type="user">cplx-0007</fr:addr><fr:route>cplx-0007.xml</fr:route><fr:title
text="Integration around a pole">Integration around a pole</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a piecewise differentiable closed curve <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> not passing through <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, the complex <fr:link
type="local"
href="cplx-0005.xml"
addr="cplx-0005"
title="Line integral">line integral</fr:link> <fr:tex
display="block"><![CDATA[\int _\gamma  \frac {1}{z - a} \operatorname {d}\mathclose {z}]]></fr:tex> is always a multiple of <fr:tex
display="inline"><![CDATA[2 \pi  i]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>682</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>cplx-0007</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Intuitively, <fr:tex
display="inline"><![CDATA[1/(z-a)]]></fr:tex> is the derivative of the function <fr:tex
display="inline"><![CDATA[\log (z - a)]]></fr:tex>. But formalizing this is difficult, since logarithms are not single-valued, so what happens near the branch cuts is not clear. However, we can avoid this by considering the inverse function <fr:tex
display="inline"><![CDATA[\exp ]]></fr:tex> instead.</fr:p>

  <fr:p>Let the path be parametrized by the interval <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex> for convenience. Consider the function <fr:tex
display="block"><![CDATA[g(t) = \int _0^t \frac {\gamma '(t)}{\gamma (t) - a} \operatorname {d}\mathclose {t}.]]></fr:tex> By the intuition above, we expect <fr:tex
display="inline"><![CDATA[g(t) \xlongequal {?} \log (\gamma (t) - a) + C]]></fr:tex>. So we instead consider <fr:tex
display="inline"><![CDATA[h(t) = \exp (g(t))/(\gamma (t) - a)]]></fr:tex> and prove it is a constant. This can be verified by differentiation, using the chain rule and the fundamental theorem of calculus.</fr:p>

  <fr:p>Of course, <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is only piecewise differentiable. So <fr:tex
display="inline"><![CDATA[h(t)]]></fr:tex> is only constant on each piece. But in addition, <fr:tex
display="inline"><![CDATA[h(t)]]></fr:tex> is continuous on the entire curve, so it must be globally constant. Moreover, since <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex> is a loop, we have <fr:tex
display="inline"><![CDATA[\gamma (0) = \gamma (1)]]></fr:tex>, and since <fr:tex
display="inline"><![CDATA[h(0) = h(1)]]></fr:tex>, we can deduce <fr:tex
display="inline"><![CDATA[1 = \exp (g(0)) = \exp (g(1))]]></fr:tex>, which means the integral <fr:tex
display="inline"><![CDATA[g(1)]]></fr:tex> is a multiple of <fr:tex
display="inline"><![CDATA[2 \pi  i]]></fr:tex> as desired.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3203</fr:anchor><fr:addr
type="user">cplx-0005</fr:addr><fr:route>cplx-0005.xml</fr:route><fr:title
text="Line integral">Line integral</fr:title><fr:taxon>Defintion</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a complex function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and a piecewise differentiable curve <fr:tex
display="inline"><![CDATA[\gamma  : [a, b] \to  \mathbb {C}]]></fr:tex>, we can define a few different kinds of line integrals along <fr:tex
display="inline"><![CDATA[\gamma ]]></fr:tex>. The first is the <fr:strong>naive line integral</fr:strong>, given by directly integrating
  <fr:tex
display="block"><![CDATA[\int _a^b f(\gamma (t)) \operatorname {d}\mathclose {t}.]]></fr:tex>
  But this depends on the parametrization of the curve.</fr:p><fr:p>We can also define the <fr:strong>complex line integral</fr:strong>, which is independent of parametrization:
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \operatorname {d}\mathclose {z} = \int _a^b f(\gamma (t)) \gamma '(t) \operatorname {d}\mathclose {t}.]]></fr:tex>
  Following the convention of <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">complexifying the (co)tangent space</fr:link>, we can write <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z} = \operatorname {d}\mathclose {x} + i \operatorname {d}\mathclose {y}]]></fr:tex>. This leads to the evident definition of integrating against <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {x}]]></fr:tex>, given by
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \operatorname {d}\mathclose {x} = \int _a^b f(\gamma (t)) \operatorname {Re}\gamma '(t) \operatorname {d}\mathclose {t}.]]></fr:tex> And <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {y}]]></fr:tex> is defined similarly.</fr:p><fr:p>Finally, there is also the <fr:strong>arc length integral</fr:strong>, which is given by
  <fr:tex
display="block"><![CDATA[\int _\gamma  f(z) \left |\operatorname {d}\mathclose {z}\right | = \int _a^b f(\gamma (t)) \left |\gamma '(t)\right | \operatorname {d}\mathclose {t}.]]></fr:tex>
  In particular, integrating the constant function <fr:tex
display="inline"><![CDATA[1]]></fr:tex> gives the length of the curve.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3205</fr:anchor><fr:addr
type="user">cplx-0002</fr:addr><fr:route>cplx-0002.xml</fr:route><fr:title
text="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f : U \to  \mathbb {C}]]></fr:tex> be a <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> defined on an open set <fr:tex
display="inline"><![CDATA[U \subseteq  \mathbb {C}]]></fr:tex>. Viewed as two functions of two real variables <fr:tex
display="inline"><![CDATA[f(x + i y) = u(x, y) + i v(x, y)]]></fr:tex>, they are differentiable, and moreover satisfies equations
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \frac {\partial  u}{\partial  x} &= \frac {\partial  v}{\partial  y}, \\     \frac {\partial  u}{\partial  y} &= -\frac {\partial  v}{\partial  x}.   \end {aligned}]]></fr:tex>
  These are necessary and sufficient conditions for holomorphicity. We say <fr:tex
display="inline"><![CDATA[v]]></fr:tex> is a <fr:strong>harmonic conjugate</fr:strong> of <fr:tex
display="inline"><![CDATA[u]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[-u]]></fr:tex> is similarly a harmonic conjugate of <fr:tex
display="inline"><![CDATA[v]]></fr:tex>. They determine each other up to a constant, by the Poincaré lemma recovering a function from its differential.</fr:p><fr:p>Intuitively, for a function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be complex differentiable, we need <fr:tex
display="inline"><![CDATA[(f(z + \epsilon ) - f(z)) / \epsilon ]]></fr:tex> to converge to the <fr:em>same</fr:em> value for both real and imaginary <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>. The real and imaginary parts of this equality correspond to the two Cauchy–Riemann equations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3207</fr:anchor><fr:addr
type="user">cplx-0003</fr:addr><fr:route>cplx-0003.xml</fr:route><fr:title
text="Complexifying the (co)tangent space">Complexifying the (co)tangent space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Considering <fr:tex
display="inline"><![CDATA[\mathbb {C}]]></fr:tex> as a two dimensional real space, the tangent space at a point (take zero as an example) is <fr:tex
display="inline"><![CDATA[\mathbb {R}^2]]></fr:tex>. It comes equipped with a complex structure <fr:tex
display="inline"><![CDATA[J]]></fr:tex> sending <fr:tex
display="inline"><![CDATA[\partial _x \mapsto  \partial _y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _y \mapsto  -\partial _x]]></fr:tex>, acting as multiplication by <fr:tex
display="inline"><![CDATA[i]]></fr:tex>. A (real) smooth function <fr:tex
display="inline"><![CDATA[\mathbb {C} \to  \mathbb {C}]]></fr:tex> then has a Jacobian at each point, which is a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix <fr:tex
display="inline"><![CDATA[M]]></fr:tex>. The <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link> then imposes a condition on this matrix, which can be written as <fr:tex
display="inline"><![CDATA[J M = M J]]></fr:tex>.</fr:p><fr:p>It is sometimes convenient to complexify this vector space <fr:tex
display="inline"><![CDATA[\mathbb {R}^2 \otimes  \mathbb {C} = \mathbb {C}^2]]></fr:tex>. This corresponds to formally allowing the <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> components to be complex-valued. This is because we often want to view a complex function as a scalar field on a two dimensional (real) manifold, but the scalar can be complex. So to do calculus with these scalars, naturally the associated tangent and cotangent spaces needs to be complexified. <fr:tex
display="inline"><![CDATA[J]]></fr:tex> now has two eigenvalues <fr:tex
display="inline"><![CDATA[i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[-i]]></fr:tex>, corresponding to the <fr:strong>holomorphic</fr:strong> and <fr:strong>antiholomorphic</fr:strong> subspaces.</fr:p><fr:p>Of course this only happens in the tangent space, and the coordinate functions cannot be extended to complex domains. The Jacobian then extends to the complexified tangent space. This space has an alternative basis <fr:tex
display="block"><![CDATA[\partial _z = \frac {1}{2}(\partial _x - i \partial _y) \quad \text {and}\quad \partial _{\bar {z}} = \frac {1}{2}(\partial _x + i \partial _y).]]></fr:tex> This has the dual basis on <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-forms, given by <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {z} = \operatorname {d}\mathclose {x} + i \operatorname {d}\mathclose {y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {d}\mathclose {\bar {z}} = \operatorname {d}\mathclose {x} - i \operatorname {d}\mathclose {y}]]></fr:tex>. In this basis, the Cauchy–Riemann equation can be written as <fr:tex
display="inline"><![CDATA[\partial _{\bar {z}} f = 0]]></fr:tex>.</fr:p><fr:p>This gives a heuristic procedure for finding the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">harmonic conjugate</fr:link> of a function.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr
type="user">cplx-0004</fr:addr><fr:route>cplx-0004.xml</fr:route><fr:title
text="Formal method to calculate the harmonic conjugate">Formal method to calculate the harmonic conjugate</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[u]]></fr:tex> is the real part of some <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Then we have <fr:tex
display="inline"><![CDATA[2 u(x, y) = f(x + i y) + \overline {f(x + i y)}]]></fr:tex>. If we could extend the coordinates <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> to complex numbers, then similar to <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">what happens in the tangent space</fr:link>, we have a <fr:tex
display="inline"><![CDATA[(z, \bar {z})]]></fr:tex> coordinate system with <fr:tex
display="inline"><![CDATA[z = x + i y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bar {z} = x - i y]]></fr:tex> acting as <fr:em>independent</fr:em> variables in <fr:tex
display="inline"><![CDATA[\mathbb {C}^2]]></fr:tex>.</fr:p><fr:p>By the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link>, <fr:tex
display="inline"><![CDATA[f(x + i y)]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[z]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\overline {f(x + i y)}]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[\bar {z}]]></fr:tex>. So we can write the latter as another function <fr:tex
display="inline"><![CDATA[g(\bar {z})]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[2 u = f(z) + g(\bar {z})]]></fr:tex>, we can look at the value at the point <fr:tex
display="inline"><![CDATA[(z, \bar {z}) = (\alpha , 0)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\alpha  \in  \mathbb {C}]]></fr:tex>, which corresponds to <fr:tex
display="inline"><![CDATA[x = \alpha  / 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y = - i \alpha  / 2]]></fr:tex>. Hence <fr:tex
display="block"><![CDATA[2 u(\alpha  / 2, - i \alpha  / 2) = f(\alpha ) + g(0),]]></fr:tex> which determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex> up to some constant. This method requires an analytic expression of <fr:tex
display="inline"><![CDATA[u(x, y)]]></fr:tex>, so it makes sense to plug in complex numbers into <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3209</fr:anchor><fr:addr
type="user">cplx-0004</fr:addr><fr:route>cplx-0004.xml</fr:route><fr:title
text="Formal method to calculate the harmonic conjugate">Formal method to calculate the harmonic conjugate</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[u]]></fr:tex> is the real part of some <fr:link
type="local"
href="cplx-0001.xml"
addr="cplx-0001"
title="Holomorphic function">holomorphic function</fr:link> <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Then we have <fr:tex
display="inline"><![CDATA[2 u(x, y) = f(x + i y) + \overline {f(x + i y)}]]></fr:tex>. If we could extend the coordinates <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> to complex numbers, then similar to <fr:link
type="local"
href="cplx-0003.xml"
addr="cplx-0003"
title="Complexifying the (co)tangent space">what happens in the tangent space</fr:link>, we have a <fr:tex
display="inline"><![CDATA[(z, \bar {z})]]></fr:tex> coordinate system with <fr:tex
display="inline"><![CDATA[z = x + i y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bar {z} = x - i y]]></fr:tex> acting as <fr:em>independent</fr:em> variables in <fr:tex
display="inline"><![CDATA[\mathbb {C}^2]]></fr:tex>.</fr:p><fr:p>By the <fr:link
type="local"
href="cplx-0002.xml"
addr="cplx-0002"
title="Cauchy–Riemann equations">Cauchy–Riemann equations</fr:link>, <fr:tex
display="inline"><![CDATA[f(x + i y)]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[z]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\overline {f(x + i y)}]]></fr:tex> should only depend on <fr:tex
display="inline"><![CDATA[\bar {z}]]></fr:tex>. So we can write the latter as another function <fr:tex
display="inline"><![CDATA[g(\bar {z})]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[2 u = f(z) + g(\bar {z})]]></fr:tex>, we can look at the value at the point <fr:tex
display="inline"><![CDATA[(z, \bar {z}) = (\alpha , 0)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\alpha  \in  \mathbb {C}]]></fr:tex>, which corresponds to <fr:tex
display="inline"><![CDATA[x = \alpha  / 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y = - i \alpha  / 2]]></fr:tex>. Hence <fr:tex
display="block"><![CDATA[2 u(\alpha  / 2, - i \alpha  / 2) = f(\alpha ) + g(0),]]></fr:tex> which determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex> up to some constant. This method requires an analytic expression of <fr:tex
display="inline"><![CDATA[u(x, y)]]></fr:tex>, so it makes sense to plug in complex numbers into <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3211</fr:anchor><fr:addr
type="user">cplx-0001</fr:addr><fr:route>cplx-0001.xml</fr:route><fr:title
text="Holomorphic function">Holomorphic function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A holomorphic function defined on an open set <fr:tex
display="inline"><![CDATA[U \subseteq  \mathbb {C}]]></fr:tex> is a complex-valued function that is complex differentiable at every point. In other words, the limit
  <fr:tex
display="block"><![CDATA[f'(z) = \lim _{h \to  0} \frac {f(z + h) - f(z)}{h}]]></fr:tex>
  exists for all <fr:tex
display="inline"><![CDATA[z \in  U]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3213</fr:anchor><fr:addr
type="user">misc-0001</fr:addr><fr:route>misc-0001.xml</fr:route><fr:title
text="Berger’s lemma">Berger’s lemma</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a Riemannian manifold <fr:tex
display="inline"><![CDATA[M]]></fr:tex> with metric <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, if the sectional curvature at a point <fr:tex
display="inline"><![CDATA[\operatorname {sec}(v, w)]]></fr:tex> is bounded between <fr:tex
display="inline"><![CDATA[\kappa _1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\kappa _2]]></fr:tex>, we can make some bounds on the curvature tensor, essentially by linear algebra. This is discussed in section 6 from <fr:link
type="local"
href="variete-riemannienne-suffisamment-pincee.xml"
addr="variete-riemannienne-suffisamment-pincee"
title="Sur quelques variétés riemanniennes suffisamment pincées">Sur quelques variétés riemanniennes suffisamment pincées</fr:link>.</fr:p><fr:p>Take an orthonormal set of vectors <fr:tex
display="inline"><![CDATA[X_i, X_j, X_k, X_l]]></fr:tex>. The sectional curvature is given by <fr:tex
display="inline"><![CDATA[\operatorname {sec}(X_i, X_j) = R(X_i, X_j, X_j, X_i)]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[a^2 + b^2 = c^2 + d^2 = 1]]></fr:tex>, then we can generate a family of inequalities
  <fr:tex
display="block"><![CDATA[\kappa _1 < \operatorname {sec}(a X_i + b X_j, c X_k + d X_l) < \kappa _2.]]></fr:tex>
  Let us write <fr:tex
display="inline"><![CDATA[\operatorname {sec}_{i j}]]></fr:tex> for <fr:tex
display="inline"><![CDATA[\operatorname {sec}(X_i, X_j)]]></fr:tex>. Then we can expand the definition to get
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \kappa _1 &< a^2 c^2 \operatorname {sec}_{ik} &&+ 2 a^2 c d R_{ikli} &&+ a^2 d^2 \operatorname {sec}_{il} \\       &+ 2 a b c^2 R_{ikkj} &&+ 2 a b c d (R_{iklj} + R_{ilkj}) &&+ 2 a b d^2 R_{illj} \\       &+ b^2 c^2 \operatorname {sec}_{jk} &&+ 2 b^2 c d R_{jklj} &&+ b^2 d^2 \operatorname {sec}_{jl} &< \kappa _2.   \end {aligned}]]></fr:tex></fr:p><fr:p>In the case <fr:tex
display="inline"><![CDATA[(c, d) = (1, 0)]]></fr:tex>, the inequality expands to
  <fr:tex
display="block"><![CDATA[\kappa _1 < a^2 \operatorname {sec}_{i k} + 2 a b R_{ikkj} + b^2 \operatorname {sec}_{j k} < \kappa _2.]]></fr:tex>
  From the AM–GM inequality, we can take the appropriate signs for <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> to get
  <fr:tex
display="inline"><![CDATA[ |R_{ikkj}| < \sqrt {(\operatorname {sec}_{i k} - \kappa _1)(\operatorname {sec}_{j k} - \kappa _1)}]]></fr:tex>
  and
  <fr:tex
display="inline"><![CDATA[ |R_{ikkj}| < \sqrt {(\operatorname {sec}_{i k} - \kappa _2)(\operatorname {sec}_{j k} - \kappa _2)}]]></fr:tex>.
  We can also just take <fr:tex
display="inline"><![CDATA[a = b = \pm  1/\sqrt {2}]]></fr:tex> to get coarser bounds.</fr:p><fr:p>Now for the general case. Taking <fr:tex
display="inline"><![CDATA[b = ±b']]></fr:tex>, <fr:tex
display="inline"><![CDATA[d = ±d']]></fr:tex> and summing the two inequalities, we cancel out four of the terms. Now take <fr:tex
display="inline"><![CDATA[a \mapsto  -a]]></fr:tex> and permute <fr:tex
display="inline"><![CDATA[(j, k, l) \mapsto  (l, j, k)]]></fr:tex> to get a new inequality. Taking the sum we now have
  <fr:tex
display="block"><![CDATA[\begin {aligned}     2\kappa _1 <&\quad  a^2 c^2 (\operatorname {sec}_{ik} + \operatorname {sec}_{ij})     + a^2 d^2 (\operatorname {sec}_{il} + \operatorname {sec}_{ik}) & \\     & + b^2 c^2 (\operatorname {sec}_{jk} + \operatorname {sec}_{lj})     + b^2 d^2 (\operatorname {sec}_{jl} + \operatorname {sec}_{lk}) & \\     & + 2 a b c d (R_{iklj} + R_{ilkj} - R_{ijkl} - R_{ikjl}) & < 2\kappa _2.   \end {aligned}]]></fr:tex>
  The last term can be reduced to <fr:tex
display="inline"><![CDATA[-6 abcd R_{ljki}]]></fr:tex> by the symmetries of the curvature tensor. AM–GM inequality now gives a rich set of bounds. Finally, we take <fr:tex
display="inline"><![CDATA[a = b = c = d = 1/\sqrt {2}]]></fr:tex> up to a sign. Let <fr:tex
display="inline"><![CDATA[S]]></fr:tex> be the sum of all the sectional curvatures involved. Then we have
  <fr:tex
display="block"><![CDATA[2\kappa _1 < 2 S ± \frac {3}{2} |R_{ljki}| < 2\kappa _2.]]></fr:tex>
  Therefore we have <fr:tex
display="inline"><![CDATA[|R_{ljki}| < \frac {2}{3} (\kappa _2 - \kappa _1)]]></fr:tex>. And of course, if we start with non-strict pinching, we get analogous non-strict bounds.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3215</fr:anchor><fr:addr
type="user">algm-0023</fr:addr><fr:route>algm-0023.xml</fr:route><fr:title
text="Alternative presentation of the localic spectrum of a commutative ring">Alternative presentation of the localic spectrum of a commutative ring</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can give a presentation of the <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">localic spectrum of a commutative ring</fr:link> via posites. The locale <fr:tex
display="inline"><![CDATA[\operatorname {Spec} R]]></fr:tex> is generated by symbols <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>. We write <fr:tex
display="inline"><![CDATA[D(f) \subseteq  D(g)]]></fr:tex> if <fr:tex
display="inline"><![CDATA[g \mid  f^n]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. We also require that, given <fr:tex
display="inline"><![CDATA[D(f_i) \subseteq  D(g)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[g^n = \sum _i c_i f_i]]></fr:tex> for some coefficients <fr:tex
display="inline"><![CDATA[c_i]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = D(g)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3217</fr:anchor><fr:addr
type="user">algm-0021</fr:addr><fr:route>algm-0021.xml</fr:route><fr:title
text="Dense subsite">Dense subsite</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link> on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, we can induce a coverage on any subcategory <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> by restricting the covering sieves to the subcategory. It is <fr:strong>dense</fr:strong> iff every object in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> can be covered by morphisms from objects in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, and for every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex> are in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, we can cover <fr:tex
display="inline"><![CDATA[X]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> such that the compositions with <fr:tex
display="inline"><![CDATA[f]]></fr:tex> are still in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:p><fr:p>We can define sheaves on dense subsites, and they uniquely extend to the entire site. This induces an equivalence of sheaf categories. For locales with the canonical coverage, full dense subsites are exactly topological bases.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3219</fr:anchor><fr:addr
type="user">algm-0022</fr:addr><fr:route>algm-0022.xml</fr:route><fr:title
text="Dense subsite of affine opens">Dense subsite of affine opens</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, the underlying locale (equipped with the canonical coverage) has a <fr:link
type="local"
href="algm-0021.xml"
addr="algm-0021"
title="Dense subsite">dense subsite</fr:link> whose objects are affine opens, and morphisms are distinguished open subspaces. Note that this isn’t a full subcategory, since <fr:link
type="local"
href="algm-0020.xml"
addr="algm-0020"
title="A non-distinguished affine subscheme">there exist affine open subspaces that are not distinguished</fr:link>.</fr:p><fr:p>Since schemes are covered by affine schemes, and distinguished opens form a basis in the <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">localic spectrum of a commutative ring</fr:link>, every open in <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is covered by affine opens. On the other hand, <fr:link
type="local"
href="algm-0016.xml"
addr="algm-0016"
title="Nike’s trick">Nike’s trick</fr:link> guarantees the condition on morphisms for dense subsites.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3221</fr:anchor><fr:addr
type="user">algm-0020</fr:addr><fr:route>algm-0020.xml</fr:route><fr:title
text="A non-distinguished affine subscheme">A non-distinguished affine subscheme</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider the <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine scheme</fr:link> <fr:tex
display="inline"><![CDATA[X = \operatorname {Spec} \mathbb {C}[x, y]/(y^2 - x^3) \simeq  \operatorname {Spec} \mathbb {C}[t^2, t^3]]]></fr:tex>, which is a degenerate cubic curve. We can remove the point <fr:tex
display="inline"><![CDATA[(1,1)]]></fr:tex>, giving the open <fr:tex
display="inline"><![CDATA[U = D(x-1) \cup  D(y-1)]]></fr:tex>. We claim that <fr:tex
display="inline"><![CDATA[U]]></fr:tex> is an affine subscheme but it is not of the form <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="f96098304da00e10f55a64cfbdc3d338"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  \draw [->] (-1, 0) -- (3, 0);
  \draw [->] (0, -3) -- (0, 3);
  \draw [domain=-1.4:1.4, samples=50, thick] plot ({(\x )^2}, {(\x )^3});
  \filldraw [fill = white] (1,1) circle (0.05);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>811</fr:anchor><fr:addr
type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0020</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first prove it is not distinguished. Suppose <fr:tex
display="inline"><![CDATA[U = D(f)]]></fr:tex>, we can choose a representative of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathbb {C}[x, y]]]></fr:tex>. Now substituting <fr:tex
display="inline"><![CDATA[x \mapsto  t^2, y \mapsto  t^3]]></fr:tex>, we need <fr:tex
display="inline"><![CDATA[f(t^2, t^3)]]></fr:tex> to vanish only at <fr:tex
display="inline"><![CDATA[t = 1]]></fr:tex>. Hence this is a polynomial <fr:tex
display="inline"><![CDATA[\lambda  (t - 1)^n]]></fr:tex>. But this is impossible since it has a linear term, which cannot be produced by <fr:tex
display="inline"><![CDATA[t^2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[t^3]]></fr:tex>.</fr:p>

  <fr:p>Now we need to show <fr:tex
display="inline"><![CDATA[U]]></fr:tex> is affine. The coordinate ring is actually given by the subring <fr:tex
display="inline"><![CDATA[R]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathbb {C}[t, (t-1)^{-1}]]]></fr:tex> such that the derivative at zero is zero, which can be verified by gluing. By <fr:ref
addr="algm-001Y"
href="algm-001Y.xml"
taxon="Definition" /> we have a canonical map <fr:tex
display="inline"><![CDATA[U \to  \operatorname {Spec} R]]></fr:tex>. Now restricting to the open <fr:tex
display="inline"><![CDATA[D(t^2 - 1)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(t^3 - 1)]]></fr:tex> respectively, the two schemes are affine. By verifying the isomorphism of global sections, we see that they are isomorphic. Note that
    <fr:tex
display="block"><![CDATA[(t^3 - 1) \cdot  \frac {t^2}{t - 1} - (t^2 - 1) \cdot  \left (\frac {t^3}{t - 1} + 1\right ) = 1.]]></fr:tex>
    So these cover <fr:tex
display="inline"><![CDATA[\operatorname {Spec} R]]></fr:tex> (this is where it differs from <fr:ref
addr="algm-001Z"
href="algm-001Z.xml"
taxon="Example" />), and we have our isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3223</fr:anchor><fr:addr
type="user">algm-001Z</fr:addr><fr:route>algm-001Z.xml</fr:route><fr:title
text="A non-affine scheme">A non-affine scheme</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The open subscheme of <fr:tex
display="inline"><![CDATA[\mathbb {A}_{\mathbb {C}}^2 = \operatorname {Spec} \mathbb {C}[x, y]]]></fr:tex> given by removing the origin, or equivalently the open <fr:tex
display="inline"><![CDATA[D(x) \cup  D(y)]]></fr:tex>, is not <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>831</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to prove the <fr:link
type="local"
href="algm-001Y.xml"
addr="algm-001Y"
title="Affinification">affinification</fr:link> is not an isomorphism. Consider the global sections of the <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">structure sheaf</fr:link>, which comes from the pullback of <fr:tex
display="inline"><![CDATA[\mathbb {C}[x, y, x^{-1}]]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {C}[x, y, y^{-1}]]]></fr:tex> over <fr:tex
display="inline"><![CDATA[\mathbb {C}[x, y, x^{-1}, y^{-1}]]]></fr:tex>. The result is simply <fr:tex
display="inline"><![CDATA[\mathbb {C}[x, y]]]></fr:tex>. We can compute that the affinification map is the inclusion map into <fr:tex
display="inline"><![CDATA[\mathbb {A}_{\mathbb {C}}^2]]></fr:tex>. This cannot be an isomorphism because the underlying space is different.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3225</fr:anchor><fr:addr
type="user">algm-001Y</fr:addr><fr:route>algm-001Y.xml</fr:route><fr:title
text="Affinification">Affinification</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>22</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, we can produce a best <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link> approximation <fr:tex
display="inline"><![CDATA[S \to  S']]></fr:tex> for it. This serves as the adjoint unit of the <fr:link
type="local"
href="algm-0014.xml"
addr="algm-0014"
title="Adjunction of global section and {Spec}">adjunction of global section and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex></fr:link>. Here we give a construction from the ground up.</fr:p><fr:p>We define <fr:tex
display="inline"><![CDATA[S' = \operatorname {Spec} \Gamma (\top , \mathscr {O}_X)]]></fr:tex>. For the map <fr:tex
display="inline"><![CDATA[S \to  S']]></fr:tex>, we define the preimage of the distinguished open <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> to be the non-vanishing open of <fr:tex
display="inline"><![CDATA[f \in  \Gamma (\top , \mathscr {O}_X)]]></fr:tex>, which is defined on each affine subscheme as the distinguished open of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is obviously continuous. We can then pull back a section <fr:tex
display="inline"><![CDATA[f/g]]></fr:tex> by considering them as an element of <fr:tex
display="inline"><![CDATA[\Gamma (\top , \mathscr {O}_X)]]></fr:tex> and restricting them.</fr:p><fr:p>A scheme is affine iff the affinification is an isomorphism. This is a formal consequence that affine schemes form a full subcategory of schemes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3227</fr:anchor><fr:addr
type="user">hmlg-002X</fr:addr><fr:route>hmlg-002X.xml</fr:route><fr:title
text="Commutativity of H {Z}-modules">Commutativity of <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Connective spectra can be thought of as <fr:tex
display="inline"><![CDATA[\infty ]]></fr:tex>-groups that are maximally commutative, within the confines of operadic algebras. This manifests as the little cubes operad, being able to freely move around in high dimensional space.</fr:p><fr:p>However, <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules can be seen as even more commutative. Consider the equation <fr:tex
display="inline"><![CDATA[x + x = x + x]]></fr:tex> swapping the two arguments. It is impossible to talk about the behavior of this path because in operads variables cannot repeat. Hence this might not be homotopic to the trivial path, and indeed it is not in the sphere spectrum <fr:tex
display="inline"><![CDATA[\mathbb {S}]]></fr:tex> — this path is given by the non-trivial element in the second stable homotopy group <fr:tex
display="inline"><![CDATA[\mathbb  Z / 2 \mathbb  Z]]></fr:tex>. <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules requires further that given <fr:tex
display="inline"><![CDATA[n]]></fr:tex> identical elements, the space of different possible sums is contractible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3229</fr:anchor><fr:addr
type="user">hmlg-002W</fr:addr><fr:route>hmlg-002W.xml</fr:route><fr:title
text="Additive functor is faithful iff it reflects exactness">Additive functor is faithful iff it reflects exactness</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> is faithful iff it reflects exactness.</fr:p><fr:p>This implies that faithful additive functors reflects kernels, cokernels, etc. Note that faithful functors need not preserve kernels or cokernels. This is because we can take the direct sum of a faithful functor with an arbitrary additive functor and the result is still faithful. The second summand can behave badly.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>871</fr:anchor><fr:addr
type="machine">#240</fr:addr><fr:route>unstable-240.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first prove the forward implication. Given a sequence
    <fr:tex
display="block"><![CDATA[X \xrightarrow {f} Y \xrightarrow {g} Z]]></fr:tex>
    whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact, by faithfulness <fr:tex
display="inline"><![CDATA[F(g \mathbin {\circ } f) = 0]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f = 0]]></fr:tex>. Now we wish to prove the composite <fr:tex
display="inline"><![CDATA[\ker  g \to  Y \to  \operatorname {coker} f]]></fr:tex> is zero. We can decompose its image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> as
    <fr:tex
display="block"><![CDATA[F(\ker  g) \to  \ker  Fg \to  FY \to  \operatorname {coker} Ff \to  F(\operatorname {coker} f).]]></fr:tex>
    But the inner two morphisms compose to zero, so by faithfulness we get our result.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[F]]></fr:tex> reflects exactness. Given a morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex>, suppose <fr:tex
display="inline"><![CDATA[Ff = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[FX \xrightarrow {\textrm {id}} FX \xrightarrow {Ff} FY]]></fr:tex> is exact. Hence <fr:tex
display="inline"><![CDATA[X \xrightarrow {\textrm {id}} X \xrightarrow {f} Y]]></fr:tex> is also exact, so <fr:tex
display="inline"><![CDATA[f = 0]]></fr:tex> too.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3231</fr:anchor><fr:addr
type="user">hmlg-002V</fr:addr><fr:route>hmlg-002V.xml</fr:route><fr:title
text="Homology is a universal -functor">Homology is a universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Homology <fr:tex
display="inline"><![CDATA[H_\bullet ]]></fr:tex> as a functor from the category of chain complexes (bounded from below) of <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> is a homological <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>. Dually, cohomology is a cohomological <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>883</fr:anchor><fr:addr
type="machine">#241</fr:addr><fr:route>unstable-241.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002V</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Every chain complex injects into its cone, whose cohomology is zero. So cohomology is <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceable</fr:link>. Dually every chain complex is a quotient of its cocone, hence homology is coeffaceable. Therefore by <fr:ref
addr="hmlg-002T"
href="hmlg-002T.xml"
taxon="Theorem" /> we finish the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3233</fr:anchor><fr:addr
type="user">hmlg-002T</fr:addr><fr:route>hmlg-002T.xml</fr:route><fr:title
text="Criterion for universality of -functors">Criterion for universality of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a cohomological <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[T^\bullet ]]></fr:tex>, if each <fr:tex
display="inline"><![CDATA[T^n]]></fr:tex> for <fr:tex
display="inline"><![CDATA[n > 0]]></fr:tex> is <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceable</fr:link>, then it is a <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>. Dually, if a homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor is coeffaceable, then it is universal.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>889</fr:anchor><fr:addr
type="machine">#242</fr:addr><fr:route>unstable-242.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002T</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, consider the exact sequence given by <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceability</fr:link>
    <fr:tex
display="block"><![CDATA[0 \longrightarrow  X \longrightarrow  I \longrightarrow  Y \longrightarrow  0.]]></fr:tex>
    Then we have a long exact sequence
    <fr:tex
display="block"><![CDATA[0 \to  T^0 X \to  T^0 I \to  T^0 Y \xrightarrow {\delta } T^1 X \xrightarrow {0} T^1 I.]]></fr:tex>
    and the rest breaks into infinitely many short exact sequences
    <fr:tex
display="block"><![CDATA[0 \to  T^{n+1} I \to  T^{n+1} Y \to  T^{n+2} X \to  0.]]></fr:tex></fr:p>

  <fr:p>Consider another <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[S^\bullet ]]></fr:tex> with a natural transformation <fr:tex
display="inline"><![CDATA[f : T^0 \to  S^0]]></fr:tex>. We now have a diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="2e2344ae59b281a1ee0aa10523116655"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      {T^0 I} & {T^0 Y} & {T^1 X} \\
      {S^0 I} & {S^0 Y} & {S^1 X}
      \arrow [from=1-1, to=1-2]
      \arrow [from=1-1, to=2-1]
      \arrow ["\delta ", two heads, from=1-2, to=1-3]
      \arrow [from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
      \arrow ["\delta "', from=2-2, to=2-3]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    where we can fill the vertical map on the right, because the composite of the lower left route is zero on the kernel of <fr:tex
display="inline"><![CDATA[\delta  : T^0 Y \to  T^1 X]]></fr:tex>, and uniqueness follows from epimorphism. This then yields a transformation <fr:tex
display="inline"><![CDATA[T^1 \to  S^1]]></fr:tex>, we need to prove it's natural and does not depend on the chosen <fr:tex
display="inline"><![CDATA[I]]></fr:tex>. Then we can repeat the move to extend to arbitrary degrees.</fr:p>

  <fr:p>Given a morphism <fr:tex
display="inline"><![CDATA[\varphi  : X \to  X']]></fr:tex> and the corresponding monomorphisms <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X' \to  I']]></fr:tex>, we can replace <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex> with <fr:tex
display="inline"><![CDATA[X \to  I \times  I']]></fr:tex> since both components of the map are sent to <fr:tex
display="inline"><![CDATA[0]]></fr:tex> by <fr:tex
display="inline"><![CDATA[T^0]]></fr:tex>, an additive functor. This together with the projection map <fr:tex
display="inline"><![CDATA[I \times  I' \to  I]]></fr:tex> forms a commutative square. Taking the cokernel we also have an induced map <fr:tex
display="inline"><![CDATA[\psi  : Y \to  Y']]></fr:tex>.


    This leads to a 3-dimensional diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="50b1237f178df03f2363f27efc3c1cc7"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      {T^0 Y} && {T^1 X} \\
      & {T^0 Y'} && {T^1 X'} \\
      {S^0 Y} && {S^1 X} \\
      & {S^0 Y'} && {S^1 X'}
      \arrow ["\delta ", two heads, from=1-1, to=1-3]
      \arrow ["{T^0 \psi }"', from=1-1, to=2-2]
      \arrow ["f"', from=1-1, to=3-1]
      \arrow ["{T^1 \varphi }", from=1-3, to=2-4]
      \arrow [from=1-3, to=3-3]
      \arrow ["\delta "{pos=0.3}, two heads, from=2-2, to=2-4]
      \arrow ["f"'{pos=0.3}, from=2-2, to=4-2]
      \arrow [from=2-4, to=4-4]
      \arrow [from=3-1, to=3-3]
      \arrow ["{S^0 \psi }"', from=3-1, to=4-2]
      \arrow ["{S^1 \varphi }", from=3-3, to=4-4]
      \arrow ["\delta "', from=4-2, to=4-4]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    where all but the right face commutes. After composing with <fr:tex
display="inline"><![CDATA[\delta  : T^0 Y \to  T^1 X]]></fr:tex>, we can use all five commutative squares to prove that the two compositions are equal. And since the morphism is epimorphic, the right square commutes as expected.</fr:p>

  <fr:p>For independence, we first prove that if two effacements <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X \to  I']]></fr:tex> are connected by a morphism <fr:tex
display="inline"><![CDATA[I \to  I']]></fr:tex>, then the resulting transformations are equal. This is essentially the same as the proof of naturality, except <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is replaced with <fr:tex
display="inline"><![CDATA[\textrm {id}]]></fr:tex>. Now any two effacements are connected by a zigzag, since we can take the diagonal <fr:tex
display="inline"><![CDATA[X \to  I \times  I']]></fr:tex> and project out.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3235</fr:anchor><fr:addr
type="user">hmlg-002S</fr:addr><fr:route>hmlg-002S.xml</fr:route><fr:title
text="Effaceable functor">Effaceable functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> is <fr:strong>effaceable</fr:strong> iff for each object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex>, there exists a monomorphism <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex> whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is zero. Dually, it is <fr:strong>coeffaceable</fr:strong> iff for each object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> there exists an epimorphism <fr:tex
display="inline"><![CDATA[P \to  X]]></fr:tex> whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is zero.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3237</fr:anchor><fr:addr
type="user">hmlg-002U</fr:addr><fr:route>hmlg-002U.xml</fr:route><fr:title
text="Enough injectives">Enough injectives</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> has enough <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injectives</fr:link> if every object has a monomorphism into an injective. Dually, it has enough <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projectives</fr:link> if every object is a quotient of a projective.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3239</fr:anchor><fr:addr
type="user">hmlg-002R</fr:addr><fr:route>hmlg-002R.xml</fr:route><fr:title
text="James construction">James construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pointed space <fr:tex
display="inline"><![CDATA[(X, x_0)]]></fr:tex>, the <fr:strong>James construction</fr:strong> <fr:tex
display="inline"><![CDATA[J X]]></fr:tex> is the homotopy coherent version of a free monoid (a.k.a. the type of lists or strings), such that the point acts as the neutral element. The space is constructed inductively from a point <fr:tex
display="inline"><![CDATA[[] \in  JX]]></fr:tex>. For each point <fr:tex
display="inline"><![CDATA[y \in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex>, we have another point <fr:tex
display="inline"><![CDATA[y \mathbin {::} \vec {x} \in  JX]]></fr:tex>. And finally for <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex> we adjoin a path from <fr:tex
display="inline"><![CDATA[x_0 \mathbin {::} \vec {x}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex>.</fr:p><fr:p>There is a map <fr:tex
display="inline"><![CDATA[X \to  JX]]></fr:tex> given by <fr:tex
display="inline"><![CDATA[x \mapsto  x \mathbin {::} []]]></fr:tex>, written as <fr:tex
display="inline"><![CDATA[[x]]]></fr:tex> for short.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3241</fr:anchor><fr:addr
type="user">hmlg-002Q</fr:addr><fr:route>hmlg-002Q.xml</fr:route><fr:title
text="Synthetic characterization of the James construction">Synthetic characterization of the James construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002R.xml"
addr="hmlg-002R"
title="James construction">James construction</fr:link> <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> of a connected pointed space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equivalent to the space <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex>, which is very intriguing considering that <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex> actually has a group structure up to homotopy. Its synthetic proof is enlightening.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>930</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002Q</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is connected, for each <fr:tex
display="inline"><![CDATA[x]]></fr:tex> there exists a path back to the point <fr:tex
display="inline"><![CDATA[x_0]]></fr:tex>. <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -) = \textrm {id}]]></fr:tex> is an auto-equivalence on <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>, so noting that being an equivalence is a proposition, <fr:tex
display="inline"><![CDATA[(x \mathbin {::} -)]]></fr:tex> is too, for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:p>

  <fr:p>Now consider a family of spaces indexed by <fr:tex
display="inline"><![CDATA[\Sigma  X]]></fr:tex>. For the north and south pole we assign the space <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>, and for each path between the poles induced by an element <fr:tex
display="inline"><![CDATA[x \in  X]]></fr:tex>, we assign the equivalence <fr:tex
display="inline"><![CDATA[(x \mathbin {::} -)]]></fr:tex>, which by univalence induces a path.
    The total space of this kind of families is characterized by the flattening lemma, in Section 6.12 of the <fr:link
type="local"
href="hott-book.xml"
addr="hott-book"
title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT book</fr:link>. In this case, we have two copies of <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> such that for each <fr:tex
display="inline"><![CDATA[x \in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex> we connect <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex> in the former copy to <fr:tex
display="inline"><![CDATA[x \mathbin {::} \vec {x}]]></fr:tex> in the latter with a path.</fr:p>

  <fr:p>The total space is in fact contractible. Take the center to be <fr:tex
display="inline"><![CDATA[[]]]></fr:tex> in the north copy of <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>. For any other point <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex> in the north copy, we can move to the south copy via the neutral element <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -)]]></fr:tex>, go along the path <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -) = \textrm {id}]]></fr:tex> in the south copy, and go back to the north copy removing the first entry. This allows us to recursively reach the empty list. For an element in the south copy, we can similarly move through <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -)]]></fr:tex> to the north copy and continue there.</fr:p>

  <fr:p>We still need to arrange for the contraction of the paths. This can be easily seen by drawing a diagram of all the boundaries, though tedious to completely write down. This then establishes that we have a fiber sequence <fr:tex
display="inline"><![CDATA[JX \to  1 \to  \Sigma  X]]></fr:tex>, where the middle term is the total space constructed above, and <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> is the fiber on top of the north pole of <fr:tex
display="inline"><![CDATA[\Sigma  X]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> must be equivalent to the loop space <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3243</fr:anchor><fr:addr
type="user">hmlg-002P</fr:addr><fr:route>hmlg-002P.xml</fr:route><fr:title
text="Right adjoint of exact functor preserves injectives">Right adjoint of exact functor preserves injectives</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[F \dashv  R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact and <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is an <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link>, then <fr:tex
display="inline"><![CDATA[R(I)]]></fr:tex> is also an injective. Dually, if <fr:tex
display="inline"><![CDATA[L \dashv  F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact and <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective</fr:link>, then <fr:tex
display="inline"><![CDATA[L(P)]]></fr:tex> is also a projective.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>950</fr:anchor><fr:addr
type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that the right adjoint preserves products, and so is <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive</fr:link>. We need to show that <fr:tex
display="inline"><![CDATA[\hom (-, R(I))]]></fr:tex> is <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, which amounts to saying the composition of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is exact, which is true because both are exact.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3245</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3247</fr:anchor><fr:addr
type="user">hmlg-002K</fr:addr><fr:route>hmlg-002K.xml</fr:route><fr:title
text="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:strong> is a sequence of <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functors</fr:link> <fr:tex
display="inline"><![CDATA[T_n : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian categories</fr:link>, with the convention that <fr:tex
display="inline"><![CDATA[T_n = 0]]></fr:tex> for <fr:tex
display="inline"><![CDATA[n < 0]]></fr:tex>. For every <fr:link
type="local"
href="hmlg-000H.xml"
addr="hmlg-000H"
title="Short exact sequence">short exact sequence</fr:link> <fr:tex
display="inline"><![CDATA[0 \to  X \to  Y \to  Z \to  0]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex>, we have a connecting map <fr:tex
display="inline"><![CDATA[\delta _n : T_n(Z) \to  T_{n-1}(X)]]></fr:tex>, such that this assignment is natural in the exact sequence.</fr:p><fr:p>Similarly, a <fr:strong>cohomological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:strong> can be defined with <fr:tex
display="inline"><![CDATA[\delta ^n : T^n(Z) \to  T^{n+1}(X)]]></fr:tex>. Notice that cohomology does not imply contravariance here. These also have contravariant versions, by replacing <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathcal {A}^\textrm {op}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3249</fr:anchor><fr:addr
type="user">hmlg-002M</fr:addr><fr:route>hmlg-002M.xml</fr:route><fr:title
text="Displayed category of -functors">Displayed category of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link> between two <fr:link
type="local"
href="hmlg-000G.xml"
addr="hmlg-000G"
title="Abelian categories">abelian categories</fr:link> form a displayed category over the category of <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functors</fr:link> (or we can restrict it to <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">right exact functors</fr:link> for homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors). Under this setup, the definition of a <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> can be expressed abstractly as a “relative” kind of terminal object or initial object. It is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> displayed over <fr:tex
display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\hom _f (Y, X) = 1]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3251</fr:anchor><fr:addr
type="user">hmlg-002L</fr:addr><fr:route>hmlg-002L.xml</fr:route><fr:title
text="Morphism of -functors">Morphism of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link>, a morphism between them is given by a sequence of natural transformations <fr:tex
display="inline"><![CDATA[f_n : T_n \to  S_n]]></fr:tex> that additionally commutes with <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3253</fr:anchor><fr:addr
type="user">hmlg-002N</fr:addr><fr:route>hmlg-002N.xml</fr:route><fr:title
text="Universal -functor">Universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor">homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[T_n]]></fr:tex>, it is <fr:strong>universal</fr:strong> if given any other <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor <fr:tex
display="inline"><![CDATA[S_n]]></fr:tex> and a natural transformation <fr:tex
display="inline"><![CDATA[S_0 \to  T_0]]></fr:tex> at degree 0, it can be uniquely extended to a <fr:link
type="local"
href="hmlg-002L.xml"
addr="hmlg-002L"
title="Morphism of -functors">morphism of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link>. Dually, we can reverse the arrows to get the definition of a universal <fr:em>cohomological</fr:em> <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3255</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3257</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>977</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3259</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>973</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>974</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>975</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>977</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>979</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>981</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3261</fr:anchor><fr:addr
type="user">algm-001X</fr:addr><fr:route>algm-001X.xml</fr:route><fr:title
text="Ring grading as {G}_{m}-action">Ring grading as <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex>-action</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex>-<fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">grading</fr:link> on <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is the same as a <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex>-action on <fr:tex
display="inline"><![CDATA[\operatorname {Spec} R]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex> is <fr:link
type="local"
href="algm-001V.xml"
addr="algm-001V"
title="The scheme of invertible elements">the scheme of invertible elements</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1107</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001X</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>A morphism <fr:tex
display="inline"><![CDATA[\rho  : \mathbf {G}_{m} \times  \operatorname {Spec} R \to  \operatorname {Spec} R]]></fr:tex> is given by a ring homomorphism <fr:tex
display="inline"><![CDATA[R \to  \mathbb {Z}[x, x^{-1}] \otimes  R \cong  R[x, x^{-1}]]]></fr:tex>. Composing with the identity <fr:tex
display="inline"><![CDATA[1 \to  \mathbf {G}_{m}]]></fr:tex>, we are required that
    <fr:tex
display="block"><![CDATA[R \xrightarrow {\rho } R[x, x^{-1}] \xrightarrow {x \mapsto  1} R]]></fr:tex>
    is the identity.</fr:p>

  <fr:p>We can regard <fr:tex
display="inline"><![CDATA[R[x, x^{-1}]]]></fr:tex> as generated by <fr:tex
display="inline"><![CDATA[(n, r) \in  \mathbb {Z} \times  R]]></fr:tex>, where the first number is the degree of <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and the second number is the coefficient. So they are under the relations <fr:tex
display="inline"><![CDATA[(n, r) + (n, r') = (n, r + r')]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[(n, r) \cdot  (m, r') = (n + m, r r')]]></fr:tex>. <fr:tex
display="inline"><![CDATA[\rho (r)]]></fr:tex> is a sum of finitely many <fr:tex
display="inline"><![CDATA[(n, r_n)]]></fr:tex>, and the identity law requires the sum of <fr:tex
display="inline"><![CDATA[r_n]]></fr:tex> is <fr:tex
display="inline"><![CDATA[r]]></fr:tex> again. This decomposes <fr:tex
display="inline"><![CDATA[r]]></fr:tex> into its components in each degree.</fr:p>

  <fr:p>Next, the associativity law essentially requires that, if <fr:tex
display="inline"><![CDATA[(n, r_n)]]></fr:tex> is a summand of some <fr:tex
display="inline"><![CDATA[\rho (r)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\rho (r_n) = (n, r_n)]]></fr:tex>. So this is indeed a well-defined decomposition. Furthermore, <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> being a ring homomorphism guarantees that the grading respects multiplication and addition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3263</fr:anchor><fr:addr
type="user">algm-001V</fr:addr><fr:route>algm-001V.xml</fr:route><fr:title
text="The scheme of invertible elements">The scheme of invertible elements</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define the scheme <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\operatorname {Spec} \mathbb {Z}[x, x^{-1}]]]></fr:tex>. It can be characterized by the points <fr:tex
display="inline"><![CDATA[\hom (\mathbf {G}_{m}, \operatorname {Spec} R) = R^\times ]]></fr:tex> being the units of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. This scheme has a group structure. Since it is <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link>, <fr:tex
display="inline"><![CDATA[1 \to  \mathbf {G}_{m}]]></fr:tex> is <fr:link
type="local"
href="algm-000X.xml"
addr="algm-000X"
title="Morphisms of affine schemes">given</fr:link> by the ring homomorphism <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \to  \mathbb  Z]]></fr:tex> sending <fr:tex
display="inline"><![CDATA[x]]></fr:tex> to <fr:tex
display="inline"><![CDATA[1]]></fr:tex>. The product map is given by a ring homomorphism <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \otimes  \mathbb {Z}[y, y^{-1}] \to  \mathbb {Z}[z, z^{-1}]]]></fr:tex> (where we renamed the variables for clarity) sending <fr:tex
display="inline"><![CDATA[x \otimes  y]]></fr:tex> to <fr:tex
display="inline"><![CDATA[z]]></fr:tex>. The inverse map <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \to  \mathbb {Z}[x, x^{-1}]]]></fr:tex> sends <fr:tex
display="inline"><![CDATA[x]]></fr:tex> to <fr:tex
display="inline"><![CDATA[x^{-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3265</fr:anchor><fr:addr
type="user">hmlg-002G</fr:addr><fr:route>hmlg-002G.xml</fr:route><fr:title
text="Coalgebra structure on algebraic cellular complexes">Coalgebra structure on algebraic cellular complexes</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There is a natural (differential graded) coalgebra structure on <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complexes</fr:link>. Recall that the tensor unit is <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> concentrated at degree 0. The counit map sends every 0-dimensional cell to <fr:tex
display="inline"><![CDATA[1]]></fr:tex>, and everything else to zero. The comultiplication is induced by the composition (... need simplicial?)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3267</fr:anchor><fr:addr
type="user">hmlg-002E</fr:addr><fr:route>hmlg-002E.xml</fr:route><fr:title
text="Abelian group structure on the W-bar construction">Abelian group structure on the W-bar construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose the simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is abelian, then the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link> still has an abelian group structure, by multiplication element-wise.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3269</fr:anchor><fr:addr
type="user">hmlg-002F</fr:addr><fr:route>hmlg-002F.xml</fr:route><fr:title
text="Twisted tensor product">Twisted tensor product</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>(...)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3271</fr:anchor><fr:addr
type="user">hmlg-002D</fr:addr><fr:route>hmlg-002D.xml</fr:route><fr:title
text="Associated twisted product">Associated twisted product</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002C.xml"
addr="hmlg-002C"
title="Associated simplicial fiber bundle">associated simplicial fiber bundle</fr:link> of <fr:link
type="local"
href="hmlg-002B.xml"
addr="hmlg-002B"
title="Twisted product of simplicial sets">twisted products</fr:link> admits a simpler description. Suppose we have simplicial sets <fr:tex
display="inline"><![CDATA[F, B]]></fr:tex>, a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with an action <fr:tex
display="inline"><![CDATA[G \times  F \to  F]]></fr:tex> and a <fr:link
type="local"
href="hmlg-002A.xml"
addr="hmlg-002A"
title="Twisting function">twisting function</fr:link> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> on <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. The <fr:strong>associated twisted product</fr:strong> <fr:tex
display="inline"><![CDATA[B \times _\tau  F]]></fr:tex> is defined exactly the same as twisted products, except we replace the factor <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. This still makes sense, because we can interpret the multiplication <fr:tex
display="inline"><![CDATA[\tau (b) \cdot  \partial _n f]]></fr:tex> as the <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action.</fr:p><fr:p>In particular, if we consider <fr:tex
display="inline"><![CDATA[G]]></fr:tex> as a simplicial set with a <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action on the left via multiplication, then the associated twisted product <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> is exactly the same as the twisted product <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex>, which explains our identical notation.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3273</fr:anchor><fr:addr
type="user">hmlg-002C</fr:addr><fr:route>hmlg-002C.xml</fr:route><fr:title
text="Associated simplicial fiber bundle">Associated simplicial fiber bundle</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> with simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, and a simplicial set <fr:tex
display="inline"><![CDATA[F]]></fr:tex> with a group action <fr:tex
display="inline"><![CDATA[G \times  F \to  F]]></fr:tex>, we can construct a fiber bundle with fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, such that the twisting behaviour is described by the <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">principal bundle</fr:link> <fr:tex
display="inline"><![CDATA[p]]></fr:tex>.</fr:p><fr:p>We consider a group action on <fr:tex
display="inline"><![CDATA[E \times  F]]></fr:tex>, by <fr:tex
display="inline"><![CDATA[g \cdot  (e, f) = (e \cdot  g^{-1}, g \cdot  f)]]></fr:tex>. This action is clearly free. Suppose the quotient simplicial set is <fr:tex
display="inline"><![CDATA[E']]></fr:tex>, then we have a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">simplicial fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p' : E' \to  B]]></fr:tex> induced from <fr:tex
display="inline"><![CDATA[p]]></fr:tex>. There is a <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action on the fibers, by acting on the <fr:tex
display="inline"><![CDATA[F]]></fr:tex> factor.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3275</fr:anchor><fr:addr
type="user">hmlg-002B</fr:addr><fr:route>hmlg-002B.xml</fr:route><fr:title
text="Twisted product of simplicial sets">Twisted product of simplicial sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial set <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with a <fr:link
type="local"
href="hmlg-002A.xml"
addr="hmlg-002A"
title="Twisting function">twisting function</fr:link> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, the <fr:strong>twisted product</fr:strong> is the pullback <fr:tex
display="inline"><![CDATA[B \times _{\bar {W} G} W G]]></fr:tex> with the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>. We write <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> so as to make explicit the twisting function. This is a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link>.</fr:p><fr:p>More explicitly, we define <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> to be the same as the Cartesian product <fr:tex
display="inline"><![CDATA[B \times  G]]></fr:tex>, but with one face map altered. The pair <fr:tex
display="inline"><![CDATA[(b, g)]]></fr:tex> represents the element in <fr:tex
display="inline"><![CDATA[B \times _{\bar {W} G} W G]]></fr:tex> whose first component is <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex>, and the second component is <fr:tex
display="inline"><![CDATA[(g_0, \dots , g_n) \in  W G]]></fr:tex>, where each element is an iterated product
  <fr:tex
display="block"><![CDATA[\begin {aligned}     g_n &= g \\     g_{k-1} &= \tau (\partial _{k+1} \cdots  \partial _n b) \cdot  (\partial _{k} g_{k}).   \end {aligned}]]></fr:tex>
  This forces the last face map to be
  <fr:tex
display="block"><![CDATA[\partial _n (b, g) = (\partial _n b, \tau (b) \cdot  \partial _n g),]]></fr:tex>
  and the other face and degeneracy maps are unchanged.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3277</fr:anchor><fr:addr
type="user">hmlg-002A</fr:addr><fr:route>hmlg-002A.xml</fr:route><fr:title
text="Twisting function">Twisting function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, a twisting function on a simplicial set <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is a simplicial map <fr:tex
display="inline"><![CDATA[B \to  \bar {W} G]]></fr:tex> to the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>. It represents a cocycle valued in <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. Recall that <fr:tex
display="inline"><![CDATA[(\bar {W} G)_n = G_0 \times  \cdots  \times  G_{n-1}]]></fr:tex>. Taking the face map <fr:tex
display="inline"><![CDATA[\partial _{n}]]></fr:tex> reveals that all but the last component of the map <fr:tex
display="inline"><![CDATA[B_n \to  (\bar {W} G)_n]]></fr:tex> are determined by the lower dimension maps. Hence we can obtain a more minimalistic combinatorial description.</fr:p><fr:p>A <fr:strong>twisting function</fr:strong> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> is a family of maps <fr:tex
display="inline"><![CDATA[\tau _n : B_n \to  G_{n-1}]]></fr:tex> such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \tau (\partial _k b) &= \partial _k \tau (b) && (k < n-1)\\     \tau (\partial _{n-1} b) &= \partial _{n-1} \tau (b) \cdot  \tau (\partial _n b) \\     \tau (\sigma _k b) &= \sigma _k \tau (b) && (k < n)\\     \tau (\sigma _n b) &= 1   \end {aligned}]]></fr:tex>
  The corresponding simplicial map <fr:tex
display="inline"><![CDATA[B_n \to  (\bar {W} G)_n]]></fr:tex> is then computed by discarding the last <fr:tex
display="inline"><![CDATA[k]]></fr:tex> vertices of the input <fr:tex
display="inline"><![CDATA[b \in  B_n]]></fr:tex> for <fr:tex
display="inline"><![CDATA[1 \le  k \le  n]]></fr:tex>, apply them to <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> and placing them at the correct components.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3279</fr:anchor><fr:addr
type="user">hmlg-0029</fr:addr><fr:route>hmlg-0029.xml</fr:route><fr:title
text="Kan fiber bundle">Kan fiber bundle</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">simplicial fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex>, it is a Kan fibration iff the fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is a Kan complex. Hence we call it a <fr:strong>Kan fiber bundle</fr:strong>. The proof yields an <fr:link
type="local"
href="hmlg-0027.xml"
addr="hmlg-0027"
title="Effective Kan fibration">effective Kan fibration</fr:link> if all the inputs are effective.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1174</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0029</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given a horn <fr:tex
display="inline"><![CDATA[\Lambda ^n_k \to  E]]></fr:tex> and a compatible simplex <fr:tex
display="inline"><![CDATA[\Delta ^n \to  B]]></fr:tex>, by the definition of simplicial fiber bundles, we may trivialize the bundle on the simplex locally. But since <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is Kan, obviously <fr:tex
display="inline"><![CDATA[F \times  \Delta ^n \to  \Delta ^n]]></fr:tex> is also Kan. Hence we may select the required filling.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3281</fr:anchor><fr:addr
type="user">hmlg-0027</fr:addr><fr:route>hmlg-0027.xml</fr:route><fr:title
text="Effective Kan fibration">Effective Kan fibration</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>effective Kan fibration</fr:strong> is a Kan fibration of <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective simplicial sets</fr:link> equipped with a computable choice of horn-filling. Note that it is different from <fr:em>algebraic</fr:em> Kan fibrations, because morphisms are not required to preserve the choice.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3283</fr:anchor><fr:addr
type="user">hmlg-0026</fr:addr><fr:route>hmlg-0026.xml</fr:route><fr:title
text="Simplicial fiber bundle">Simplicial fiber bundle</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A (strict) <fr:strong>simplicial fiber bundle</fr:strong> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> with fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is a simplicial map <fr:tex
display="inline"><![CDATA[p]]></fr:tex> such that for every simplex <fr:tex
display="inline"><![CDATA[\Delta ^n \to  B]]></fr:tex>, the pullback of <fr:tex
display="inline"><![CDATA[p]]></fr:tex> along the simplex is isomorphic to <fr:tex
display="inline"><![CDATA[\Delta ^n \times  F \to  \Delta ^n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3285</fr:anchor><fr:addr
type="user">hmlg-0028</fr:addr><fr:route>hmlg-0028.xml</fr:route><fr:title
text="Simplicial principal fiber bundle">Simplicial principal fiber bundle</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> is <fr:strong>principal</fr:strong> if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> acts on the fibers freely and transitively <fr:em>on the right</fr:em>. This condition can be checked in each dimension separately.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3287</fr:anchor><fr:addr
type="user">hmlg-0023</fr:addr><fr:route>hmlg-0023.xml</fr:route><fr:title
text="Eilenberg–Zilber theorem">Eilenberg–Zilber theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link>
  <fr:tex
display="block"><![CDATA[C_* (X \times  Y) \Rightarrow \mkern {-14mu}\Rightarrow  C_* (X) \otimes  C_* (Y).]]></fr:tex></fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1210</fr:anchor><fr:addr
type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0023</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For every product of simplices <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex>, we put on the <fr:link
type="local"
href="hmlg-0022.xml"
addr="hmlg-0022"
title="Discrete vector field on ^p  ^q">discrete vector field on <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:link>. This DVF is <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible</fr:link> because the time a path stays in <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> is bounded by a function of <fr:tex
display="inline"><![CDATA[p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[q]]></fr:tex>. Then it is sent to a boundary cell.</fr:p>

  <fr:p>Using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction" />, we get the required chain reduction. This is identical to the Eilenberg–Zilber reduction in literature, but the proof requires some combinatorics, and can be seen in Section 5.13 of <fr:link
type="local"
href="discrete-vector-fields.xml"
addr="discrete-vector-fields"
title="Discrete Vector Fields and Fundamental Algebraic Topology">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. However, this formulation gives a much better computational performance.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3289</fr:anchor><fr:addr
type="user">hmlg-0021</fr:addr><fr:route>hmlg-0021.xml</fr:route><fr:title
text="W-bar construction">W-bar construction</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group, we can define a model of its universal principal bundle <fr:tex
display="inline"><![CDATA[\mathbf {E} G \to  \mathbf {B} G]]></fr:tex> as simplicial sets <fr:tex
display="inline"><![CDATA[W G \to  \bar {W} G]]></fr:tex>. This is a generalization of the <fr:link
type="local"
href="hmlg-001W.xml"
addr="hmlg-001W"
title="Bar construction">bar construction</fr:link>, if we consider a group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> as a discrete simplicial set. It classifies principal <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-bundles in the sense of Theorem 21.13 in <fr:link
type="local"
href="simplicial-objects.xml"
addr="simplicial-objects"
title="Simplicial objects in algebraic topology">Simplicial objects in algebraic topology</fr:link>.</fr:p><fr:p>We define the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices of <fr:tex
display="inline"><![CDATA[W G]]></fr:tex> to be
  <fr:tex
display="block"><![CDATA[(W G)_n = G_0 \times  G_1 \times  \cdots  \times  G_n]]></fr:tex>
  so that <fr:tex
display="inline"><![CDATA[G_n]]></fr:tex> acts on <fr:tex
display="inline"><![CDATA[(W G)_n]]></fr:tex> by taking the face map that discards the last <fr:tex
display="inline"><![CDATA[k]]></fr:tex> vertices for each <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, and then acting on the appropriate factor on the right. This forces the face maps and degeneracy maps to be
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \partial _k (g_0, \dots , g_n) &=       (g_0, \dots , g_{k-1}, \partial _k g_{k+1}, \dots , \partial _k g_n), \\     \sigma _k (g_0, \dots , g_n) &=       (g_0, \dots , g_{k}, \sigma _k g_{k}, \dots , \sigma _k g_n).   \end {aligned}]]></fr:tex>
  We define <fr:tex
display="inline"><![CDATA[\bar {W} G]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[W G]]></fr:tex> quotiented by the action of <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. This can be represented as <fr:tex
display="inline"><![CDATA[(\bar {W} G)_n = G_0 \times  \cdots  \times  G_{n-1}]]></fr:tex>,
  with the quotient map <fr:tex
display="inline"><![CDATA[(W G)_n \twoheadrightarrow  (\bar {W} G)_n]]></fr:tex> given by
  <fr:tex
display="block"><![CDATA[(g_0, \dots , g_n) \mapsto  (g_0 (\partial _1 g_1)^{-1}, \dots , g_{n-1} (\partial _n g_n)^{-1}).]]></fr:tex>
  The face and degeneracy maps can then be computed to be
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \partial _k (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{k-1} \cdot  \partial _k g_k, \partial _k g_{k+1}, \dots , \partial _k g_{n-1}), \\     \partial _n (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{n-2}) \\     \sigma _k (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{k-1}, 1, \sigma _k g_{k}, \dots , \sigma _k g_{n-1}).   \end {aligned}]]></fr:tex>
  A quick computation shows that this indeed produces a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link> with fiber <fr:tex
display="inline"><![CDATA[G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3291</fr:anchor><fr:addr
type="user">hmlg-0025</fr:addr><fr:route>hmlg-0025.xml</fr:route><fr:title
text="Degeneracy maps">Degeneracy maps</fr:title><fr:taxon>Notation</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given the monotone surjection <fr:tex
display="inline"><![CDATA[\{0, \dots , n+1\} \to  \{0, \dots , n\}]]></fr:tex> with multiplicity at <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, we write the corresponding degeneracy map of a simplicial set as <fr:tex
display="inline"><![CDATA[s_k]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3293</fr:anchor><fr:addr
type="user">hmlg-0022</fr:addr><fr:route>hmlg-0022.xml</fr:route><fr:title
text="Discrete vector field on ^p  ^q">Discrete vector field on <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We construct a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> on the <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">reduced ACC</fr:link> of <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> whose critical cells are given by its boundary and one additional cell
  <fr:tex
display="block"><![CDATA[(0,0) < (1,0) < \cdots  < (p,0) < (p,1) < \cdots  < (p,q),]]></fr:tex>
  in the representation scheme of <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem" />. In particular, this <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">gives rise</fr:link> to a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[C_*(\Delta ^p \times  \Delta ^q) \Rightarrow \mkern {-14mu}\Rightarrow  C_*(\Delta ^p) \otimes  C_*(\Delta ^q)]]></fr:tex>.</fr:p><fr:p>Regarding the geometric simplices as paths in a <fr:tex
display="inline"><![CDATA[p \times  q]]></fr:tex> grid as specified in <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem" />, we assign a <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex>-simplex as a target cell if it contains a shape <fr:tex
display="inline"><![CDATA[\Rsh ]]></fr:tex>. (The shape must go exactly one step up and one step to the right, since it is not possible otherwise in a geometric <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex>-simplex.) To get its source cell, replace the <fr:em>last occurrence</fr:em> of this shape with <fr:tex
display="inline"><![CDATA[\nearrow ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3295</fr:anchor><fr:addr
type="user">hmlg-0024</fr:addr><fr:route>hmlg-0024.xml</fr:route><fr:title
text="Naturality of the Eilenberg–Zilber reduction">Naturality of the Eilenberg–Zilber reduction</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The naturality of the reduction in <fr:link
type="local"
href="hmlg-0023.xml"
addr="hmlg-0023"
title="Eilenberg–Zilber theorem">Eilenberg–Zilber theorem</fr:link> is not obvious. This is because maps sending geometric simplices to degenerate ones does not respect the vector field. We would need additional properties on the maps to guarantee naturality.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3297</fr:anchor><fr:addr
type="user">hmlg-0020</fr:addr><fr:route>hmlg-0020.xml</fr:route><fr:title
text="Simplices of ^p  ^q">Simplices of <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The geometric <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices of the product simplicial set <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> are given by a sequence <fr:tex
display="inline"><![CDATA[(u_0, v_0) < (u_1, v_1) < \dots  < (u_n, v_n)]]></fr:tex> of elements in <fr:tex
display="inline"><![CDATA[\{0, \dots , p\} \times  \{0, \dots , q\}]]></fr:tex> endowed with the product partial order. Among these, the interior simplices, i.e. non-boundary simplices are given by sequences such that <fr:tex
display="inline"><![CDATA[u_i]]></fr:tex> ranges over all <fr:tex
display="inline"><![CDATA[\{0, \dots , p\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[v_i]]></fr:tex> ranges over <fr:tex
display="inline"><![CDATA[\{0, \dots , q\}]]></fr:tex>.</fr:p><fr:p>We can graphically represent this as a path that only travels upwards and/or rightwards every step in a <fr:tex
display="inline"><![CDATA[p \times  q]]></fr:tex> grid. Face maps are given by removing the corresponding vertex in the path, and directly connecting the surrounding two. But notice that a segment can skip through a grid point, such as going from <fr:tex
display="inline"><![CDATA[(0,0)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[(2,2)]]></fr:tex>, skipping through <fr:tex
display="inline"><![CDATA[(1,1)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3299</fr:anchor><fr:addr
type="user">hmlg-001Z</fr:addr><fr:route>hmlg-001Z.xml</fr:route><fr:title
text="Chain reduction generated by a discrete vector field">Chain reduction generated by a discrete vector field</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">chain reduction generated by a discrete vector field</fr:link> reduces an ACC <fr:tex
display="inline"><![CDATA[(C_k, d)]]></fr:tex> to a smaller one, which can be explicitly described. Its cells are the critical cells in <fr:tex
display="inline"><![CDATA[C_k]]></fr:tex>. For the faces of a cell <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>, we start with the faces <fr:tex
display="inline"><![CDATA[d(\sigma )]]></fr:tex> in the original ACC. Then we move every non-critical cell down along the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">discrete field lines</fr:link>, up to some sign flips, until we get to a critical cell.</fr:p><fr:p>Note that the field lines alternate between <fr:tex
display="inline"><![CDATA[n]]></fr:tex>- and <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex>-dimensional cells, and we count the movement <fr:tex
display="inline"><![CDATA[n]]></fr:tex> – <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex> – <fr:tex
display="inline"><![CDATA[n]]></fr:tex> as a single step. Also, <fr:link
type="local"
href="hmlg-001S.xml"
addr="hmlg-001S"
title="Discrete field lines can branch and merge">discrete field lines can branch and merge</fr:link>, and the cells need to duplicate and move down every branch.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3301</fr:anchor><fr:addr
type="user">hmlg-001Y</fr:addr><fr:route>hmlg-001Y.xml</fr:route><fr:title
text="Sphere">Sphere</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>sphere</fr:strong> <fr:tex
display="inline"><![CDATA[\mathbb {S}^n]]></fr:tex> can be constructed as an <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective simplicial set</fr:link> with exactly two geometric simplices: a zero-dimensional point, and an <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-dimensional surface. All the faces of the surface are degenerate and comes from the point.</fr:p><fr:p>The <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">associated reduced ACC</fr:link> is <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> at degree <fr:tex
display="inline"><![CDATA[0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and zero elsewhere. The map <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is constant zero.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3303</fr:anchor><fr:addr
type="user">hmlg-001W</fr:addr><fr:route>hmlg-001W.xml</fr:route><fr:title
text="Bar construction">Bar construction</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, we can construct a model of the first Eilenberg–MacLane space <fr:tex
display="inline"><![CDATA[K(G, 1)]]></fr:tex> as a simplicial set <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex>. Consider the contractible simplicial set <fr:tex
display="inline"><![CDATA[W(G)]]></fr:tex> whose set of <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices is given by <fr:tex
display="inline"><![CDATA[G^{n+1}]]></fr:tex>. This has a natural free <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action given by multiplying every entry on the left. <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex> is constructed by the quotient of the <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action.</fr:p><fr:p>More concretely, the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices are given by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-tuples, representing the quotient of consecutive elements in the <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex>-tuple in the unquotiented simplicial set above. This is traditionally written as a bracketed sequence of elements separated by <fr:em>bars</fr:em>, <fr:tex
display="inline"><![CDATA[[g_1 \mid  g_2 \mid  \dots  \mid  g_n]]]></fr:tex>, hence we name it the <fr:strong>bar construction</fr:strong>. Face maps are given by removing the corresponding bars so the elements multiply together. Degeneracy maps are given by inserting the identity elements.</fr:p><fr:p>If the group has decidable equality and multiplication, then the simplicial set is also <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective</fr:link>. If further more the group is computably finite, then it is of finite type.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3305</fr:anchor><fr:addr
type="user">hmlg-001X</fr:addr><fr:route>hmlg-001X.xml</fr:route><fr:title
text="Reduction from K({Z}, 1) to the circle">Reduction from <fr:tex
display="inline"><![CDATA[K(\mathbb {Z}, 1)]]></fr:tex> to the circle</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There is a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> from the <fr:link
type="local"
href="hmlg-001W.xml"
addr="hmlg-001W"
title="Bar construction">bar construction</fr:link> <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex> of a group regarded as its <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">reduced algebraic cellular complex</fr:link>, to the <fr:link
type="local"
href="hmlg-001Y.xml"
addr="hmlg-001Y"
title="Sphere">circle</fr:link> <fr:tex
display="inline"><![CDATA[\mathbb {S}^1]]></fr:tex>.</fr:p><fr:p>By construction, the geometric simplices of <fr:tex
display="inline"><![CDATA[K(\mathbb {Z}, 1)]]></fr:tex> are lists <fr:tex
display="inline"><![CDATA[[a_1 \mid  a_2 \mid  \cdots  \mid  a_n]]]></fr:tex> of non-zero integers. We construct an <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible discrete vector field</fr:link> and use <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">the reduction it generates</fr:link>. We assign a cell <fr:tex
display="inline"><![CDATA[[a_1 \mid  \cdots ]]]></fr:tex> as a source if <fr:tex
display="inline"><![CDATA[a_1 \ne  1]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[a_1 \le  0]]></fr:tex>, then we assign its target cell to be <fr:tex
display="inline"><![CDATA[[1 \mid  a_1 \mid  \cdots ]]]></fr:tex>; otherwise we assign <fr:tex
display="inline"><![CDATA[[1 \mid  a_1 - 1 \mid  \cdots ]]]></fr:tex>. Hence, the critical cells are <fr:tex
display="inline"><![CDATA[[]]]></fr:tex> and <fr:tex
display="inline"><![CDATA[[1]]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3307</fr:anchor><fr:addr
type="user">hmlg-001U</fr:addr><fr:route>hmlg-001U.xml</fr:route><fr:title
text="Algebraic cellular complexes associated with a simplicial set">Algebraic cellular complexes associated with a simplicial set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">(effective) simplicial set</fr:link> <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, there are two major <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complexes</fr:link> (or <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complexes</fr:link>) we can associate to it. We can consider the free abelian group generated by <fr:tex
display="inline"><![CDATA[\Gamma (\Delta ^n, X)]]></fr:tex> at degree <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, where the boundary map is given by an alternating sum of face maps: <fr:tex
display="block"><![CDATA[d_n = \sum _{i=0}^n (-1)^{i} \partial _i.]]></fr:tex> This satisfies <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> by the simplicial identities. Alternatively, we can consider only the geometric simplices, regarding degenerate ones are zero. More formally, we quotient out the previous chain complex by the subgroups generated by degenerate simplicies. They are both obviously <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link> by construction.</fr:p><fr:p>The first chain complex is called the <fr:strong>non-reduced</fr:strong> complex, while the second one is the <fr:strong>reduced</fr:strong> complex. By <fr:ref
addr="hmlg-001V"
href="hmlg-001V.xml"
taxon="Construction" /> the two chain complexes are related by a chain reduction. So we will write <fr:tex
display="inline"><![CDATA[C_* X]]></fr:tex> for the reduced complex, leaving no notation for the non-reduced one unless otherwise stated.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3309</fr:anchor><fr:addr
type="user">hmlg-001T</fr:addr><fr:route>hmlg-001T.xml</fr:route><fr:title
text="Effective simplicial set">Effective simplicial set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>effective</fr:strong> simplicial set consists of a sequence of types <fr:tex
display="inline"><![CDATA[\operatorname {Geom}_n(X)]]></fr:tex> with decidable equality, representing the <fr:strong>geometric</fr:strong>, a.k.a. non-degenerate, simplices. The full set of simplices, written <fr:tex
display="inline"><![CDATA[\Gamma (\Delta ^n, X)]]></fr:tex> or more simply <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex>, is given by a geometric simplex <fr:tex
display="inline"><![CDATA[g \in  \operatorname {Geom}_k(X)]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[k]]></fr:tex> together with a <fr:strong>degeneracy symbol</fr:strong>, defined as a surjection <fr:tex
display="inline"><![CDATA[\eta  : [n+1] \twoheadrightarrow  [k+1]]]></fr:tex>, formally representing the degeneracy map that brought <fr:tex
display="inline"><![CDATA[g]]></fr:tex> up to dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, written as <fr:tex
display="inline"><![CDATA[\eta ^* g]]></fr:tex>. The effective simplicial set is also required to have computable <fr:strong>face maps</fr:strong> <fr:tex
display="inline"><![CDATA[\partial _i : \operatorname {Geom}_{n+1}(X) \to  \Gamma (\Delta ^n, X)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[0 \le  i \le  n+1]]></fr:tex>, so that the usual simplicial identities hold. The simplicial set is <fr:strong>of finite type</fr:strong> if each <fr:tex
display="inline"><![CDATA[\operatorname {Geom}_n(X)]]></fr:tex> is computably finite.</fr:p><fr:p>Alternatively, we can make a definition that more closely follows the traditional one, requiring a sequence of types with decidable equality representing <fr:em>all</fr:em> simplices instead of geometric ones. We then need to impose an additional requirement that the degeneracy of a simplex is decidable. The equivalence of the two definitions is given by the Eilenberg–Zilber lemma.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3311</fr:anchor><fr:addr
type="user">hmlg-001V</fr:addr><fr:route>hmlg-001V.xml</fr:route><fr:title
text="Reduction from the non-reduced chain complex to the reduced chain complex">Reduction from the non-reduced chain complex to the reduced chain complex</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We construct a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> from the non-reduced chain complex to the reduced chain complex in <fr:ref
addr="hmlg-001U"
href="hmlg-001U.xml"
taxon="Definition" />, by constructing a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> and using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction" />.</fr:p><fr:p>We consider placing vectors on degenerate simplicies, so that all degenerate simplices are sources or targets. For each non-trivial degeneracy symbol, if the first degeneration has even multiplicity, we assign it to be a source, with the corresponding target to have one more multiplicity at the place, and vice versa. For example, the degeneracy symbol <fr:tex
display="inline"><![CDATA[[6] \twoheadrightarrow  [4]]]></fr:tex> given by the table of values <fr:tex
display="inline"><![CDATA[(0, 1, 1, 2, 3, 3, 4)]]></fr:tex> is a source, whose target is <fr:tex
display="inline"><![CDATA[(0, 1, 1, 1, 2, 3, 3, 4) : [7] \twoheadrightarrow  [4]]]></fr:tex>.</fr:p><fr:p>To verify this indeed gives a discrete vector field, we need to show that the source is a regular face of the target. This is true since an odd consective sum of <fr:tex
display="inline"><![CDATA[(-1)^{i}]]></fr:tex> gives <fr:tex
display="inline"><![CDATA[\pm  1]]></fr:tex>. Furthermore, we need to show the admissibility of the vector field. I claim that length of the field lines originating from one cell is bounded by two times the geometric dimension (i.e. the dimension of the associated geometric simplex). On one hand, the geometric dimensions of the target and the source are the same. On the other hand, moving from the target to the next source cell requires us to pick a regular face that does not point back to the target. This is equivalent to picking a place in the degeneracy symbol with no multiplicity. Hence the geometric dimension will decrease by one.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3313</fr:anchor><fr:addr
type="user">ualg-000H</fr:addr><fr:route>ualg-000H.xml</fr:route><fr:title
text="Beck monadicity theorem">Beck monadicity theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[G : \mathcal {D} \to  \mathcal {C}]]></fr:tex> be a functor with a left adjoint <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic</fr:link> iff <fr:tex
display="inline"><![CDATA[G]]></fr:tex> <fr:link
type="local"
href="ualg-000G.xml"
addr="ualg-000G"
title="Preservation, lifting, reflection and creation of limits">creates</fr:link> coequalizers whose image under <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="ualg-000B.xml"
addr="ualg-000B"
title="Split coequalizer">split</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1375</fr:anchor><fr:addr
type="machine">#233</fr:addr><fr:route>unstable-233.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For necessity, using <fr:ref
addr="ualg-000I"
href="ualg-000I.xml"
taxon="Theorem" />, we only need to verify that a monad <fr:tex
display="inline"><![CDATA[M]]></fr:tex> preserves the relevant coequalizers, which is true since <fr:link
type="local"
href="ualg-000D.xml"
addr="ualg-000D"
title="Characterization of absolute coequalizers">they are absolute</fr:link>.</fr:p>

  <fr:p>For sufficiency, we observe the proof of <fr:ref
addr="ualg-000E"
href="ualg-000E.xml"
taxon="Theorem" />. Notice that the coequalizers involved are of the form <fr:tex
display="inline"><![CDATA[F\alpha , \epsilon  : FGFA \rightrightarrows  FA]]></fr:tex>. The images of these under <fr:tex
display="inline"><![CDATA[G]]></fr:tex> are indeed split by <fr:tex
display="inline"><![CDATA[\eta  : GFA \to  GFGFA]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\eta  : A \to  GFA]]></fr:tex>. Therefore we just have to show <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms. Given an isomorphism <fr:tex
display="inline"><![CDATA[Gf : GA \cong  GB]]></fr:tex>, we have a split coequalizer <fr:tex
display="inline"><![CDATA[GA \rightrightarrows  GB \to  GA]]></fr:tex> where the two maps on the left are <fr:tex
display="inline"><![CDATA[Gf]]></fr:tex>, and the map on the right is its inverse. This creates a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex> which is the coequalizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with itself. So this map must be an isomorphism. We then consider the coequalizer <fr:tex
display="inline"><![CDATA[GB \rightrightarrows  GA \to  GB]]></fr:tex>, where the two maps on the left are <fr:tex
display="inline"><![CDATA[Gg]]></fr:tex> and the map on the right is <fr:tex
display="inline"><![CDATA[Gf]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects this limit, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> must also be an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3315</fr:anchor><fr:addr
type="user">ualg-000M</fr:addr><fr:route>ualg-000M.xml</fr:route><fr:title
text="Complete Boolean algebra not isomorphic to a powerset">Complete Boolean algebra not isomorphic to a powerset</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider the Lebesgue measurable sets on the interval <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex> quotiented by measure-zero sets. This is a complete Boolean algebra, but it is not a powerset, showing the necessity of complete distributivity in <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1357</fr:anchor><fr:addr
type="machine">#230</fr:addr><fr:route>unstable-230.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000M</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>This is indeed a Boolean algebra since measure-zero sets form a Boolean ideal of the Lebesgue <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra. So we just need to show the existence of arbitrary joins. Given a family <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex> of measurable sets, we inductively construct a countable union. On each step, consider the area of each set outside of the current union. Select a set such that this excess area is within <fr:tex
display="inline"><![CDATA[\frac 12]]></fr:tex> of the supremum. Since <fr:tex
display="inline"><![CDATA[\mu ([0,1]) = 1]]></fr:tex>, such a process must lead to an excess area converging to zero.</fr:p>

  <fr:p>By construction, every set <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex> has zero area outside of this countable union, so they are under the union in the Boolean algebra. And the countable union <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^\infty  X_{\alpha _k}]]></fr:tex> is the join of <fr:tex
display="inline"><![CDATA[X_{\alpha _k}]]></fr:tex> in the algebra, since a countable union of neglegible set is still neglegible. Hence by chasing elements, it must be the join of the entire family <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3317</fr:anchor><fr:addr
type="user">ualg-000J</fr:addr><fr:route>ualg-000J.xml</fr:route><fr:title
text="Completely distributive complete Boolean algebra">Completely distributive complete Boolean algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>completely distributive complete Boolean algebra</fr:strong> is a Boolean algebra with arbitrary join and meet that distribute over each other.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3319</fr:anchor><fr:addr
type="user">ualg-000L</fr:addr><fr:route>ualg-000L.xml</fr:route><fr:title
text="Completely distributive complete Boolean algebras are powersets">Completely distributive complete Boolean algebras are powersets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Every <fr:link
type="local"
href="ualg-000J.xml"
addr="ualg-000J"
title="Completely distributive complete Boolean algebra">completely distributive complete Boolean algebra</fr:link> is isomorphic to the set algebra of a powerset, and homomorphisms are given by inverse image map. In other words, the category of CDCBA is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Set}^{\textrm {op}}]]></fr:tex> and the forgetful functor is given by the powerset <fr:tex
display="inline"><![CDATA[\mathcal {P}(X) = 2^X]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1363</fr:anchor><fr:addr
type="machine">#231</fr:addr><fr:route>unstable-231.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000L</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the set of <fr:em>atoms</fr:em> <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, defined as minimal non-bottom elements. It suffices to prove the algebra is <fr:em>atomic</fr:em>, i.e. every non-bottom element has an atom below it. This is because we can remove all the atoms that an element contains, and the result must be <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex>. So every element is given by a join of atoms. Such a join must be unique, since the intersection of different atoms is empty, so given two ways to write an element as a join of atoms, we take the intersection and see that they must agree. This shows that the elements are in bijection with <fr:tex
display="inline"><![CDATA[\mathcal {P}(A)]]></fr:tex>, with joins, meets and complements given by unions, intersections and complements, respectively.</fr:p>

  <fr:p>To show atomicity, consider <fr:tex
display="block"><![CDATA[\top  = \bigwedge _{b \in  B} (b \lor  \neg  b) = \bigvee _{S \subseteq  B} \left [ \bigwedge _{b \in  S} b \wedge  \bigwedge _{b \notin  S} \neg  b \right ].]]></fr:tex> Consider the disjunctive clauses in here not equal to <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex> (which must exist unless <fr:tex
display="inline"><![CDATA[\top  = \bot ]]></fr:tex> which trivially satisfies the requirements). They must be atoms because any element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> strictly below them must be below all the conjunctive items, so either <fr:tex
display="inline"><![CDATA[x < x]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x < \neg  x]]></fr:tex>. The former is absurd and the latter implies <fr:tex
display="inline"><![CDATA[x = \bot ]]></fr:tex>.</fr:p>

  <fr:p>Taking the meet of the equation with an arbitrary element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> gives <fr:tex
display="block"><![CDATA[x = \bigvee _{S \subseteq  B} \left [x \wedge  \bigwedge _{b \in  S} b \wedge  \bigwedge _{b \notin  S} \neg  b \right ].]]></fr:tex> If there are no atoms <fr:tex
display="inline"><![CDATA[a \le  x]]></fr:tex>, then all the clauses must be <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex> meaning <fr:tex
display="inline"><![CDATA[x = \bot ]]></fr:tex>. This finishes the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3321</fr:anchor><fr:addr
type="user">ualg-000K</fr:addr><fr:route>ualg-000K.xml</fr:route><fr:title
text="Free completely distributive complete Boolean algebras">Free completely distributive complete Boolean algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An element of a free <fr:link
type="local"
href="ualg-000J.xml"
addr="ualg-000J"
title="Completely distributive complete Boolean algebra">CDCBA</fr:link> over the set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an expression made out of joins, meets and negation, with literals from <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. We can push the negation in and use distributivity to put the expression into <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">disjunctive normal form</fr:link>. The clauses can be represented by functions <fr:tex
display="inline"><![CDATA[X \to  \{\top , \bot , ?\}]]></fr:tex> representing a literal appearing positively, negatively or not appearing in the conjunction.</fr:p><fr:p>If a literal <fr:tex
display="inline"><![CDATA[b]]></fr:tex> does not appear in a clause, we can take its conjunction with <fr:tex
display="inline"><![CDATA[\top  = b \lor  \neg  b]]></fr:tex> and expand using distributivity. This ensures every literal appears either positively or negatively, so the expressions are now represented by a double powerset of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, where the inner powerset records which literals appear positively in a clause, and the outer powerset represents the set of clauses.</fr:p><fr:p>In fact, such a representation is unique. We just need to show that the double powerset forms a CDCBA. Disjunction is simply a union. Negation is given by the complement. Conjunction is given by an intersection. We can verify that the required identities all hold. Hence the monad for CDCBAs is the double powerset monad, corresponding to the adjunction <fr:tex
display="inline"><![CDATA[\mathcal {P}^{\textrm {op}} \dashv  \mathcal {P}]]></fr:tex> via <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3323</fr:anchor><fr:addr
type="user">ualg-000I</fr:addr><fr:route>ualg-000I.xml</fr:route><fr:title
text="Limits and colimits created by a monadic functor">Limits and colimits created by a monadic functor</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic functor</fr:link> <fr:link
type="local"
href="ualg-000G.xml"
addr="ualg-000G"
title="Preservation, lifting, reflection and creation of limits">creates</fr:link> all limits. It also creates all colimits preserved by the monad.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1369</fr:anchor><fr:addr
type="machine">#232</fr:addr><fr:route>unstable-232.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By definition, we just need to prove the functor <fr:tex
display="inline"><![CDATA[\mathcal {C}^M \to  \mathcal {C}]]></fr:tex> creates these limits and colimits. Given a diagram <fr:tex
display="inline"><![CDATA[(M X_i \xrightarrow {\alpha _i} X_i)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex>, we can simply define an <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-algebra structure on <fr:tex
display="inline"><![CDATA[\lim  X_i]]></fr:tex> by assigning <fr:tex
display="inline"><![CDATA[M(\lim  X_i) \to  \lim  X_i]]></fr:tex> the obvious map. This is the limit of the original diagram by a simple diagram chase, hence it is lifted. The cones over the diagram are determined by their image under the forgetful functor, so the lift is unique, which means the limit is trivially reflected.</fr:p>

  <fr:p>For colimits, if <fr:tex
display="inline"><![CDATA[M]]></fr:tex> preserves a colimit, then we can similarly define an algebra structure as <fr:tex
display="inline"><![CDATA[M(\operatorname *{colim} X_i) \cong  \operatorname *{colim} M X_i \to  \operatorname *{colim} X_i]]></fr:tex>. The lift is also unique, which means it is reflected.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3325</fr:anchor><fr:addr
type="user">ualg-000G</fr:addr><fr:route>ualg-000G.xml</fr:route><fr:title
text="Preservation, lifting, reflection and creation of limits">Preservation, lifting, reflection and creation of limits</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex>.</fr:p><fr:ul><fr:li>If a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is mapped to a limit cone in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, then the functor <fr:strong>preserves</fr:strong> the limit <fr:tex
display="inline"><![CDATA[I]]></fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> over <fr:tex
display="inline"><![CDATA[F \mathbin {\circ } D]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[D]]></fr:tex> can be extended to a limit cone in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> that maps to <fr:tex
display="inline"><![CDATA[L]]></fr:tex>, then the functor <fr:strong>lifts</fr:strong> the limit <fr:tex
display="inline"><![CDATA[L]]></fr:tex> to <fr:tex
display="inline"><![CDATA[D]]></fr:tex>.</fr:li>
  <fr:li>If all the cones that maps to a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> are limit cones in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, then the functor <fr:strong>reflects</fr:strong> the limit <fr:tex
display="inline"><![CDATA[L]]></fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> over <fr:tex
display="inline"><![CDATA[F \mathbin {\circ } D]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[L]]></fr:tex> is reflected and lifted to <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, then the limit of <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is <fr:strong>created</fr:strong>.</fr:li></fr:ul><fr:p>This can be easily generalized to cover a type of limits or all limits, and can be dualized to colimits. The definitions here are not agreed upon, and the literature may have slight variations. We consider univalent categories here, so that definitions are automatically adjusted to be equivalence-invariant.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3327</fr:anchor><fr:addr
type="user">ualg-000F</fr:addr><fr:route>ualg-000F.xml</fr:route><fr:title
text="Reflexive pair">Reflexive pair</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>reflexive pair</fr:strong> is the categorical translation of a reflexive relation. It is defined as a pair of arrows <fr:tex
display="inline"><![CDATA[\partial _0, \partial _1 : X \rightrightarrows  Y]]></fr:tex> with a common section <fr:tex
display="inline"><![CDATA[r : Y \to  X]]></fr:tex>, i.e. an arrow <fr:tex
display="inline"><![CDATA[r]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } r = \partial _1 \mathbin {\circ } r = \textrm {id}_Y]]></fr:tex>. A coequalizer of a reflexive pair is called a <fr:strong>reflexive coequalizer</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3329</fr:anchor><fr:addr
type="user">ualg-000E</fr:addr><fr:route>ualg-000E.xml</fr:route><fr:title
text="Crude monadicity theorem">Crude monadicity theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[G : \mathcal {D} \to  \mathcal {C}]]></fr:tex> be a functor with a left adjoint <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. <fr:tex
display="inline"><![CDATA[M = G \mathbin {\circ } F]]></fr:tex> is the corresponding monad on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. This gives a <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> <fr:tex
display="inline"><![CDATA[K : \mathcal {A} \to  \mathcal {C}^M]]></fr:tex>.</fr:p><fr:ol><fr:li>If <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> has all coequalizers (we can weaken this to <fr:link
type="local"
href="ualg-000F.xml"
addr="ualg-000F"
title="Reflexive pair">reflexive coequalizers</fr:link>), then <fr:tex
display="inline"><![CDATA[K]]></fr:tex> has a left adjoint.</fr:li>
  <fr:li>If moreover <fr:tex
display="inline"><![CDATA[G]]></fr:tex> preserves these reflexive coequalizers, the unit <fr:tex
display="inline"><![CDATA[\textrm {Id} \to  K \mathbin {\circ } L]]></fr:tex> is an isomorphism.</fr:li>
  <fr:li>Finally, if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms, then the counit <fr:tex
display="inline"><![CDATA[L \mathbin {\circ } K \to  \textrm {Id}]]></fr:tex> is also an isomorphism, making <fr:tex
display="inline"><![CDATA[G]]></fr:tex> <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic</fr:link>.</fr:li></fr:ol>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1389</fr:anchor><fr:addr
type="machine">#234</fr:addr><fr:route>unstable-234.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the first claim, we need a functor <fr:tex
display="inline"><![CDATA[L]]></fr:tex> such that arrows from <fr:tex
display="inline"><![CDATA[L(GFA \xrightarrow {\alpha } A)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is in bijection with commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7552ab0a1122c764613faeef0d30c0bc"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      GFA & GFGX \\
      A & GX
      \arrow [from=1-1, to=1-2]
      \arrow ["{\alpha }"', from=1-1, to=2-1]
      \arrow ["{G \epsilon }", from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    which are equivalent by <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> to the commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="742f273ba13897778c25fb9ad1150d18"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      FGFA & FGX \\
      FA & X
      \arrow ["FG\varphi ", from=1-1, to=1-2]
      \arrow ["F\alpha "', from=1-1, to=2-1]
      \arrow ["\epsilon ", from=1-2, to=2-2]
      \arrow ["\varphi ", from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Further notice that <fr:tex
display="inline"><![CDATA[\epsilon  \mathbin {\circ } FG\varphi  = \varphi  \mathbin {\circ } \epsilon ]]></fr:tex> by naturality. So it becomes obvious that <fr:tex
display="inline"><![CDATA[L]]></fr:tex> should be defined as the coequalizer of the pair <fr:tex
display="block"><![CDATA[F \alpha , \epsilon  : FGFA \rightrightarrows  FA.]]></fr:tex> This is reflexive by the common section <fr:tex
display="inline"><![CDATA[F\eta ]]></fr:tex>.</fr:p>

  <fr:p>For the second point, we unfold the unit as a natural family of commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="857909e7575ed30b312cefad4ffa82e3"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      GFA & {GFG\operatorname *{colim}(FGFA \rightrightarrows  FA)} \\
      A & {G\operatorname *{colim}(FGFA \rightrightarrows  FA)}
      \arrow [from=1-1, to=1-2]
      \arrow [from=1-1, to=2-1]
      \arrow [from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    and when <fr:tex
display="inline"><![CDATA[G]]></fr:tex> preserves the coequalizers in the diagram, the problem is reduced to showing that the coequalizer of <fr:tex
display="inline"><![CDATA[GF\alpha ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[G\epsilon  : GFGFA \rightrightarrows  GFA]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> via the bottom map, which is just the unit <fr:tex
display="inline"><![CDATA[\eta  : A \to  GFA]]></fr:tex> composed with the coequalizing map. This is a routine diagram chase.</fr:p>

  <fr:p>For the final point, we would like the coequalizer of <fr:tex
display="inline"><![CDATA[FG\epsilon , \epsilon  : FGFGX \rightrightarrows  FGX]]></fr:tex> to be isomorphic to <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. If we apply <fr:tex
display="inline"><![CDATA[G]]></fr:tex> to the diagram, we get an isomorphism to <fr:tex
display="inline"><![CDATA[GX]]></fr:tex> by the previous point. So if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms, we’re done.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3331</fr:anchor><fr:addr
type="user">ualg-000C</fr:addr><fr:route>ualg-000C.xml</fr:route><fr:title
text="Absolute (co)limit">Absolute (co)limit</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>absolute (co)limit</fr:strong> is a (co)limit that is preserved by any functor whatsoever.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3333</fr:anchor><fr:addr
type="user">ualg-000D</fr:addr><fr:route>ualg-000D.xml</fr:route><fr:title
text="Characterization of absolute coequalizers">Characterization of absolute coequalizers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a coequalizer diagram <fr:tex
display="inline"><![CDATA[X \rightrightarrows  Y \to  Z]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\partial _0, \partial _1 : X \to  Y]]></fr:tex> are the two parallel arrows and the coequalizing arrow is <fr:tex
display="inline"><![CDATA[e : Y \to  Z]]></fr:tex>, it is <fr:link
type="local"
href="ualg-000C.xml"
addr="ualg-000C"
title="Absolute (co)limit">absolute</fr:link>, if and only if the following conditions hold.</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[e]]></fr:tex> is split epimorphic, i.e. there is an arrow <fr:tex
display="inline"><![CDATA[r]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>.</fr:li>
  <fr:li>There is a list of <fr:tex
display="inline"><![CDATA[n]]></fr:tex> endomorphisms on <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> starting with <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } e]]></fr:tex> and ending with <fr:tex
display="inline"><![CDATA[\textrm {id}_Y]]></fr:tex>, such that for each pair of adjacent morphisms, there is an arrow <fr:tex
display="inline"><![CDATA[s]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _1 \mathbin {\circ } s]]></fr:tex> are equal to the two morphisms (in some order).</fr:li></fr:ul><fr:p>Note that for <fr:tex
display="inline"><![CDATA[n = 0]]></fr:tex> this is the trivial coequalizer where <fr:tex
display="inline"><![CDATA[\partial _0 = \partial _1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[e]]></fr:tex> is an isomorphism. For <fr:tex
display="inline"><![CDATA[n = 1]]></fr:tex> this results in the <fr:link
type="local"
href="ualg-000B.xml"
addr="ualg-000B"
title="Split coequalizer">split coequalizer</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1396</fr:anchor><fr:addr
type="machine">#235</fr:addr><fr:route>unstable-235.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the definition of an <fr:link
type="local"
href="ualg-000C.xml"
addr="ualg-000C"
title="Absolute (co)limit">absolute (co)limit</fr:link>, the coequalizer is preserved by every functor. Consider the functor <fr:tex
display="inline"><![CDATA[\hom (Z, -)]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[\hom (Z, e)]]></fr:tex> is a coequalizer map, and hence epimorphic. This means <fr:tex
display="inline"><![CDATA[e]]></fr:tex> itself is split epimorphic since <fr:tex
display="inline"><![CDATA[\textrm {id}_Z]]></fr:tex> is in the image, i.e. there is a morphism <fr:tex
display="inline"><![CDATA[r : Z \to  Y]]></fr:tex> with <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>.</fr:p>

  <fr:p>Next, we consider the functor <fr:tex
display="inline"><![CDATA[\hom (Y, -)]]></fr:tex>. Since this gives a coequalizer of sets, the quotient <fr:tex
display="inline"><![CDATA[\hom (Y, Y) \xrightarrow {e \mathbin {\circ } -} \hom (Y, Z)]]></fr:tex> is given by the equivalence relation generated by <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } f = \partial _1 \mathbin {\circ } f]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex>. There is a pair of elements mapped to the same element under <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } -]]></fr:tex> in this situation: one of them is obviously <fr:tex
display="inline"><![CDATA[\textrm {id}_Y]]></fr:tex>, and the other is <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } e]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } \textrm {id}_Y = e = e \mathbin {\circ } r \mathbin {\circ } e]]></fr:tex>. Hence we get the chain of morphisms related in the way stated in the theorem.</fr:p>

  <fr:p>Finally, we observe that these are enough to guarantee the given diagram is a coequalizer —— the diagram is a coequalizer simply by virtue of the shape of the diagram. Since any functor preserves the composition relation of morphisms, they must also give coequalizers, and therefore the coequalizer is absolute.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3335</fr:anchor><fr:addr
type="user">ualg-000B</fr:addr><fr:route>ualg-000B.xml</fr:route><fr:title
text="Split coequalizer">Split coequalizer</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a <fr:strong>split coequalizer</fr:strong> to be the following diagram:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="5ceb23e39cb73d22e2cb02c70866ddd9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    X & Y & Z
    \arrow ["{\partial _0}", shift left, curve={height=-6pt}, from=1-1, to=1-2]
    \arrow ["{\partial _1}"', shift right, curve={height=6pt}, from=1-1, to=1-2]
    \arrow ["s"{description}, from=1-2, to=1-1]
    \arrow ["q", from=1-2, to=1-3]
    \arrow ["r", curve={height=-6pt}, from=1-3, to=1-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that <fr:tex
display="inline"><![CDATA[q \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>, <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } q = \partial _0 \mathbin {\circ } s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _1 \mathbin {\circ } s = \textrm {id}_Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3337</fr:anchor><fr:addr
type="user">ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title
text="Monadic functor">Monadic functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functors <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> to <fr:tex
display="inline"><![CDATA[\mathcal {C}^{G \mathbin {\circ } F}]]></fr:tex> is an equivalence in <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">the bicategory of decompositions</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3339</fr:anchor><fr:addr
type="user">ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title
text="The Kleisli category induces the initial decomposition of a monad">The Kleisli category induces the initial decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3341</fr:anchor><fr:addr
type="user">ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title
text="The Eilenberg–Moore category induces the terminal decomposition of a monad">The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1459</fr:anchor><fr:addr
type="machine">#236</fr:addr><fr:route>unstable-236.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> with the corresponding monad <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex>, the comparison functor is defined as sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[GFGX \to  GX]]></fr:tex>, given by the counit <fr:tex
display="inline"><![CDATA[FGX \to  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3343</fr:anchor><fr:addr
type="user">ualg-0007</fr:addr><fr:route>ualg-0007.xml</fr:route><fr:title
text="Decomposition of a monad into adjoint functors">Decomposition of a monad into adjoint functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functor <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex> forms a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link>. As a converse, we can consider the adjunctions whose composition is a given monad <fr:tex
display="inline"><![CDATA[M]]></fr:tex>. These decompositions form a bicategory. The morphisms between two adjunctions are given by functors <fr:tex
display="inline"><![CDATA[L]]></fr:tex> that make the two triangles below commute.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="a39a5a66477c19047311c740a235210b"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    {\mathcal {D}_2} & {\mathcal {D}_1} & {\mathcal {C}}
    \arrow [shift right, from=1-2, to=1-3]
    \arrow [shift right, from=1-3, to=1-2]
    \arrow [shift right, curve={height=18pt}, from=1-1, to=1-3]
    \arrow [shift right, curve={height=18pt}, from=1-3, to=1-1]
    \arrow ["L"{description}, from=1-2, to=1-1]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  More precisely, the objects of this bicategory are given by adjunctions <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> together with a natural isomorphism <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F \cong  M]]></fr:tex>. A morphism from <fr:tex
display="inline"><![CDATA[F_1 \dashv  G_1]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F_2 \dashv  G_2]]></fr:tex> is given by a functor <fr:tex
display="inline"><![CDATA[L]]></fr:tex> together with two natural isomorphisms <fr:tex
display="inline"><![CDATA[L \mathbin {\circ } G_1 \cong  G_2]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F_1 \cong  F_2 \mathbin {\circ } L]]></fr:tex>. A <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-morphism is given by a natural transformation such that the relevant composition of natural transformations are equal.</fr:p><fr:p>This bicategory has initial and terminal objects.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1492</fr:anchor><fr:addr
type="user">ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title
text="The Kleisli category induces the initial decomposition of a monad">The Kleisli category induces the initial decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1494</fr:anchor><fr:addr
type="user">ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title
text="The Eilenberg–Moore category induces the terminal decomposition of a monad">The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1459</fr:anchor><fr:addr
type="machine">#236</fr:addr><fr:route>unstable-236.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> with the corresponding monad <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex>, the comparison functor is defined as sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[GFGX \to  GX]]></fr:tex>, given by the counit <fr:tex
display="inline"><![CDATA[FGX \to  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1496</fr:anchor><fr:addr
type="user">ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title
text="Monadic functor">Monadic functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functors <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> to <fr:tex
display="inline"><![CDATA[\mathcal {C}^{G \mathbin {\circ } F}]]></fr:tex> is an equivalence in <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">the bicategory of decompositions</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3345</fr:anchor><fr:addr
type="user">ualg-0006</fr:addr><fr:route>ualg-0006.xml</fr:route><fr:title
text="Objects of the Kleisli category">Objects of the Kleisli category</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An object of <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">the Kleisli category of a monad</fr:link> can be considered as a <fr:link
type="local"
href="ualg-0003.xml"
addr="ualg-0003"
title="Free monad algebras">free algebra</fr:link>, but <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">equipped with a canonical choice of generators</html:mark>. Hence although <fr:link
type="local"
href="ualg-0005.xml"
addr="ualg-0005"
title="The Kleisli category is equivalent to the category of free algebras">the Kleisli category is equivalent to the category of free algebras</fr:link>, the objects are essentially different. This manifests as the curious fact that the Kleisli category is not univalent, since an equality of Kleisli objects requires an isomorphism of the generators, but an isomorphism only requires the two free algebras to be isomorphic.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3347</fr:anchor><fr:addr
type="user">ualg-0005</fr:addr><fr:route>ualg-0005.xml</fr:route><fr:title
text="The Kleisli category is equivalent to the category of free algebras">The Kleisli category is equivalent to the category of free algebras</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">the Kleisli category of a monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> is equivalent to the full subcategory of the <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-<fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebras</fr:link> spanned by the <fr:link
type="local"
href="ualg-0003.xml"
addr="ualg-0003"
title="Free monad algebras">free algebras</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1533</fr:anchor><fr:addr
type="machine">#237</fr:addr><fr:route>unstable-237.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0005</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the functor from the Kleisli category to the category of free algebras, sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to the free algebra on <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. This is fully faithful and surjective on objects.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3349</fr:anchor><fr:addr
type="user">ualg-0004</fr:addr><fr:route>ualg-0004.xml</fr:route><fr:title
text="The Kleisli category of a monad">The Kleisli category of a monad</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> and two objects <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Kleisli arrow</fr:strong> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is simply any arrow <fr:tex
display="inline"><![CDATA[X \to  MY]]></fr:tex>. This represents an algebra homomorphism from the free algebra generated by <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to that of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p><fr:p>The identity Kleisli arrow is defined as <fr:tex
display="inline"><![CDATA[\eta  : X \to  MX]]></fr:tex>. The composition of <fr:tex
display="inline"><![CDATA[f : X \to  MY]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g : Y \to  MZ]]></fr:tex> is given by <fr:tex
display="block"><![CDATA[X \xrightarrow {f} MY \xrightarrow {Mg} M^2 Z \xrightarrow {\mu } MZ.]]></fr:tex> This forms a category whose objects are the objects of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, as a formal symbol standing for the free algebra generated by those objects, and morphisms are Kleisli arrows. This is the <fr:strong>Kleisli category</fr:strong> <fr:tex
display="inline"><![CDATA[\mathcal {C}_M]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3351</fr:anchor><fr:addr
type="user">ualg-0002</fr:addr><fr:route>ualg-0002.xml</fr:route><fr:title
text="Algebra of a monad">Algebra of a monad</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-<fr:strong>algebra</fr:strong> is defined as an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> equipped with a morphism <fr:tex
display="inline"><![CDATA[\alpha  : MX \to  X]]></fr:tex>, such that the following two diagrams commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8f5102f9cbc69c3d35325723042d2fd9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
  {M^2X} & MX & X & MX \\
  MX & X && X
  \arrow["\alpha"', from=2-1, to=2-2]
  \arrow["\alpha", from=1-2, to=2-2]
  \arrow["\mu"', from=1-1, to=2-1]
  \arrow["M\alpha", from=1-1, to=1-2]
  \arrow["\operatorname{id}"', from=1-3, to=2-4]
  \arrow["\eta", from=1-3, to=1-4]
  \arrow["\alpha", from=1-4, to=2-4]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>In an unbiased formulation, we require the natural transformation <fr:tex
display="inline"><![CDATA[M^n \to  M]]></fr:tex> of the monad evaluated at the object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> composed with <fr:tex
display="inline"><![CDATA[\alpha  : MX \to  X]]></fr:tex> to be equal to <fr:tex
display="block"><![CDATA[M^n X \xrightarrow {M^{n-1}\alpha } M^{n-1}X \to  \cdots  \xrightarrow {\alpha } X.]]></fr:tex></fr:p><fr:p>The algebras of a monad form a category <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex>, whose morphisms are commutative squares. This is also known as the <fr:strong>Eilenberg–Moore category</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3353</fr:anchor><fr:addr
type="user">ualg-0003</fr:addr><fr:route>ualg-0003.xml</fr:route><fr:title
text="Free monad algebras">Free monad algebras</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> on a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, there is a canonical adjunction between the <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">category of algebras</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. The <fr:strong>forgetful functor</fr:strong> <fr:tex
display="inline"><![CDATA[U_M]]></fr:tex> takes an <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebra</fr:link> and forgets the algebra structure. The <fr:strong>free functor</fr:strong> <fr:tex
display="inline"><![CDATA[F_M]]></fr:tex> takes an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and produces an algebra on <fr:tex
display="inline"><![CDATA[MX]]></fr:tex> given by the monad multiplication map <fr:tex
display="inline"><![CDATA[\mu  : M^2 X \to  MX]]></fr:tex>, called the <fr:strong>free algebra</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1556</fr:anchor><fr:addr
type="machine">#238</fr:addr><fr:route>unstable-238.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We verify that they form an adjunction. Algebra homomorphisms <fr:tex
display="inline"><![CDATA[\varphi  : F_M X \to  Y]]></fr:tex> are given by commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="a9a1e034dcfd39c0f1ae7665b6b057d4"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
      {M^2 X} & MY \\
      MX & Y
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    while morphisms <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> fits in the diagram as such: 
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cf98d9db6ddf55aa5c8f4220681e1f2e"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
      {M^2 X} & MY \\
      MX & Y \\
      X
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]
      \arrow["f"', from=3-1, to=2-2]
      \arrow["\eta", from=3-1, to=2-1]
      \arrow[from=2-1, to=1-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Given a homomorphism <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> of algebras, we can compute <fr:tex
display="inline"><![CDATA[f]]></fr:tex> by composing with <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex>. On the other hand, given <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we define <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } Mf]]></fr:tex>. This creates a commutative square because
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \alpha _Y \mathbin {\circ } M \varphi        &= \alpha _Y \mathbin {\circ } M\alpha _Y \mathbin {\circ } M^2 f \\       &= \alpha _Y \mathbin {\circ } \mu  \mathbin {\circ } M^2 f \\       &= \alpha _Y \mathbin {\circ } M f \mathbin {\circ } \mu  \\       &= \varphi  \mathbin {\circ } \mu .     \end {aligned}]]></fr:tex></fr:p>

  <fr:p>We just have to verify that the two conversions are mutual inverses. In one way, we need to verify <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M f \mathbin {\circ } \eta  = f]]></fr:tex>. This is true because by the naturality of <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> we get <fr:tex
display="inline"><![CDATA[M f \mathbin {\circ } \eta  = \eta  \mathbin {\circ } f]]></fr:tex>. Then by the definition of <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebra</fr:link> <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } \eta  = \textrm {id}]]></fr:tex>, proving the equality. On the other hand, we need to show <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M(\varphi  \mathbin {\circ } \eta ) = \varphi ]]></fr:tex>. This follows from the algebra identity <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M \alpha _Y = \alpha _Y \mathbin {\circ } \mu ]]></fr:tex> and the monad identity <fr:tex
display="inline"><![CDATA[\mu  \mathbin {\circ } M \eta  = \textrm {id}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3355</fr:anchor><fr:addr
type="user">ualg-0001</fr:addr><fr:route>ualg-0001.xml</fr:route><fr:title
text="Monad on a category">Monad on a category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>monad</fr:strong> on a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a functor <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> equipped with natural transformations <fr:tex
display="inline"><![CDATA[\eta  : \textrm {Id} \to  M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mu  : M \mathbin {\circ } M \to  M]]></fr:tex> satisfying identity and associativity laws. In an unbiased way, we have a family of natural transformations <fr:tex
display="inline"><![CDATA[M^n \to  M]]></fr:tex> with associativity.</fr:p><fr:p>In short, it is a monoid in the category of endofunctors equipped with composition as the monoidal product.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3357</fr:anchor><fr:addr
type="user">hmlg-001R</fr:addr><fr:route>hmlg-001R.xml</fr:route><fr:title
text="Chain reduction generated by a discrete vector field">Chain reduction generated by a discrete vector field</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible discrete vector field</fr:link> on an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> <fr:tex
display="inline"><![CDATA[(C_k, d)]]></fr:tex>, we can generate a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link>. It will be computable when the cellular complex is <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1222</fr:anchor><fr:addr
type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The DVF partitions the chain groups into a direct sum <fr:tex
display="inline"><![CDATA[C_k^{s} \oplus  C_k^t \oplus  C_k^c]]></fr:tex>, corresponding to source, target and critical cells. We would like to create a reduction to the critical cells only. To do this, we invoke <fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction">perturbation</fr:link> of the larger chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:link> and start with a simpler chain reduction.</fr:p>

  <fr:p>Consider the algebraic cellular complex whose chain groups are <fr:tex
display="inline"><![CDATA[C_k]]></fr:tex>, but the differential <fr:tex
display="inline"><![CDATA[d'(\sigma ) = \pm  \tau ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\overrightharpoon {\tau  \sigma }]]></fr:tex> is in the vector field, and zero otherwise. The sign is determined as the sign of <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> in <fr:tex
display="inline"><![CDATA[d(\sigma )]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[d' : C_{k+1}^{t} \to  C_k^s]]></fr:tex>, and is zero otherwise. Therefore using the <fr:link
type="local"
href="hmlg-001H.xml"
addr="hmlg-001H"
title="Characterization of chain reduction">characterization of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:link> as a direct sum with a split exact chain complex, we see that this complex can be reduced to the complex on <fr:tex
display="inline"><![CDATA[C_k^p]]></fr:tex> whose differential is identically zero.</fr:p>

  <fr:p>Next, we try to perturb <fr:tex
display="inline"><![CDATA[d']]></fr:tex> to <fr:tex
display="inline"><![CDATA[d]]></fr:tex>. We need <fr:tex
display="inline"><![CDATA[h_{\rho } \mathbin {\circ } (d' - d)]]></fr:tex> to be locally nilpotent, where <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> is the reduction constructed above. <fr:tex
display="inline"><![CDATA[h_{\rho }]]></fr:tex> can be viewed as the inverse of <fr:tex
display="inline"><![CDATA[d']]></fr:tex>, as it maps the source cell to the target cell. Expanding the definition, we see that this map transports cells down the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">discrete field line</fr:link>. Since the vector field is admissible, such a transportation eventually terminates and it becomes zero.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3359</fr:anchor><fr:addr
type="user">hmlg-001S</fr:addr><fr:route>hmlg-001S.xml</fr:route><fr:title
text="Discrete field lines can branch and merge">Discrete field lines can branch and merge</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although we make an analogy between a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> and a vector field, the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">field lines</fr:link> of a DVF may branch out. For instance, take a triangle <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> with three edges <fr:tex
display="inline"><![CDATA[\sigma _1, \sigma _2, \sigma _3]]></fr:tex>. We can have a vector <fr:tex
display="inline"><![CDATA[\overrightharpoon {\sigma _1 \tau }]]></fr:tex> pointing into the triangle, and <fr:tex
display="inline"><![CDATA[\sigma _2, \sigma _3]]></fr:tex> each having vectors pointing out. Similarly multiple field lines may join when they reach a lower-degree cell. Because of this, we need to take care in the phrasing of <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissibility</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3361</fr:anchor><fr:addr
type="user">hmlg-001P</fr:addr><fr:route>hmlg-001P.xml</fr:route><fr:title
text="Admissible discrete vector field">Admissible discrete vector field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link>, if is <fr:strong>admissible</fr:strong> if the lengths of the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">field lines</fr:link> starting from a cell are bounded. In other words, we can assign a natural number to every cell such that the field lines starting from this cell have length bounded by the number. The number can be different for each cell, and can be unbounded overall.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3363</fr:anchor><fr:addr
type="user">hmlg-001N</fr:addr><fr:route>hmlg-001N.xml</fr:route><fr:title
text="Discrete vector field">Discrete vector field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>discrete vector field</fr:strong> (DVF) of degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> on an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> is given by a collection of pairs of cells <fr:tex
display="inline"><![CDATA[(\sigma , \tau )]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> is a <fr:link
type="local"
href="hmlg-001O.xml"
addr="hmlg-001O"
title="Regular face in an algebraic cellular complex">regular face</fr:link> of the degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, standing for a vector pointing from <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, which we will write as <fr:tex
display="inline"><![CDATA[\overrightharpoon {\sigma  \tau }]]></fr:tex>. We require that every cell appears at most once in these vectors.</fr:p><fr:p>A DVF naturally partitions the cells into three kinds: the <fr:em>sources</fr:em>, the <fr:em>targets</fr:em>, and the rest of the cells are called <fr:em>critical cells</fr:em>. This name comes from the analogy to Morse theory. Indeed there is a notion of <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Discrete_Morse_theory">discrete Morse function</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3365</fr:anchor><fr:addr
type="user">hmlg-001Q</fr:addr><fr:route>hmlg-001Q.xml</fr:route><fr:title
text="Discrete field line">Discrete field line</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link>, the discrete version of <fr:strong>field lines</fr:strong> is defined as a sequence of cells alternating between degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> starting and ending with lower-degree cells, with a few requirements.</fr:p><fr:ul><fr:li>When the degree increases, the two cells must occur as a vector in the DVF.</fr:li>
  <fr:li>When the degree decreases, the degree <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> cell must be a (possible non-<fr:link
type="local"
href="hmlg-001O.xml"
addr="hmlg-001O"
title="Regular face in an algebraic cellular complex">regular</fr:link>) face of the degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell.</fr:li>
  <fr:li>Two degree <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> cells separated by a degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell must not be the same.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3367</fr:anchor><fr:addr
type="user">hmlg-001O</fr:addr><fr:route>hmlg-001O.xml</fr:route><fr:title
text="Regular face in an algebraic cellular complex">Regular face in an algebraic cellular complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> and a cell <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>, a <fr:strong>regular face</fr:strong> of <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> is a cell whose coefficient in <fr:tex
display="inline"><![CDATA[d\sigma ]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\pm  1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3369</fr:anchor><fr:addr
type="user">algm-001T</fr:addr><fr:route>algm-001T.xml</fr:route><fr:title
text="Slice of presheaf category">Slice of presheaf category</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have an equivalence of categories
  <fr:tex
display="block"><![CDATA[\mathsf {Psh}(\mathcal {C})/P \cong  \mathsf {Psh}\left (\int _{\mathcal {C}} P\right ).]]></fr:tex>
  In the special case that <fr:tex
display="inline"><![CDATA[P = \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex>, we have
  <fr:tex
display="block"><![CDATA[\mathsf {Psh}(\mathcal {C})/\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U) \cong  \mathsf {Psh}(\mathcal {C}/U).]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3371</fr:anchor><fr:addr
type="user">algm-001U</fr:addr><fr:route>algm-001U.xml</fr:route><fr:title
text="Slice of sheaf category">Slice of sheaf category</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> with a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link> <fr:tex
display="inline"><![CDATA[J]]></fr:tex> and a sheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, there is a Grothendieck coverage <fr:tex
display="inline"><![CDATA[J']]></fr:tex> on <fr:tex
display="inline"><![CDATA[\int _{\mathcal {C}} F]]></fr:tex> such that the equivalence in <fr:ref
addr="algm-001T"
href="algm-001T.xml"
taxon="Theorem" /> restricts to an equivalence
  <fr:tex
display="block"><![CDATA[\mathsf {Sh}(\mathcal {C}, J)/F \cong  \mathsf {Sh}\left (\int _{\mathcal {C}} F, J'\right ).]]></fr:tex></fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1664</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001U</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose we have a covering sieve <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, then an element <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, F)]]></fr:tex> uniquely corresponds to a matching family <fr:tex
display="inline"><![CDATA[s \in  \hom (S, F)]]></fr:tex>. In the category of elements <fr:tex
display="inline"><![CDATA[\int _{\mathcal {C}} F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s]]></fr:tex> corresponds to a sieve over <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is the required Grothendieck coverage.</fr:p>

  <fr:p>Another way to construct this is through the <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>. The subobject classifier of a slice category is simply <fr:tex
display="inline"><![CDATA[\Omega  \times  F \to  F]]></fr:tex>. Hence we can let <fr:tex
display="inline"><![CDATA[j]]></fr:tex> act on the <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3373</fr:anchor><fr:addr
type="user">algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title
text="Dense subobject of a Lawvere–Tierney operator">Dense subobject of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a subobject <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> is <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex
display="inline"><![CDATA[G \to  \Omega  \xrightarrow {j} \Omega ]]></fr:tex> is the constant true. In terms of the corresponding <fr:tex
display="inline"><![CDATA[J \hookrightarrow  \Omega ]]></fr:tex>, we need the pullback of it with <fr:tex
display="inline"><![CDATA[G \to  \Omega ]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[\textrm {id} : G \to  G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3375</fr:anchor><fr:addr
type="user">algm-001O</fr:addr><fr:route>algm-001O.xml</fr:route><fr:title
text="Exponentials of sheaves">Exponentials of sheaves</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The exponentials of sheaves coincide with those of presheaves. To see this, we assume <fr:tex
display="inline"><![CDATA[X^Y]]></fr:tex> is the exponential of sheaves and calculate
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \Gamma (U, X^Y)     &= \hom _{\mathsf {Psh}}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X^Y) \\     &= \hom _{\mathsf {Sh}}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X^Y) \\     &= \hom _{\mathsf {Sh}}(Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X) \\     &= \hom _{\mathsf {Sh}}(Y^{++} \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X) \\     &= \hom _{\mathsf {Sh}}((Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U))^{++}, X) \\     &= \hom _{\mathsf {Psh}}(Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X) \\   \end {aligned}]]></fr:tex>
  which is evidently <fr:tex
display="inline"><![CDATA[\Gamma (U, X^Y)]]></fr:tex> but this time the exponential is taken in the category of presheaves. We used the fact that <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">the plus construction preserves finite product</fr:link>. However, we still need to prove that this indeed forms a sheaf.</fr:p><fr:p>Expressing the <fr:link
type="local"
href="algm-001P.xml"
addr="algm-001P"
title="Sheaf condition using Lawvere–Tierney operators">sheaf condition using Lawvere–Tierney operators</fr:link>, we only need to show for <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator">dense subobjects</fr:link> <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> that <fr:tex
display="inline"><![CDATA[\hom (G, X^Y) \to  \hom (F, X^Y)]]></fr:tex> is a bijection. This is equivalent to <fr:tex
display="block"><![CDATA[\hom (Y \times  G, X) \to  \hom (Y \times  F, X).]]></fr:tex> Note that the subobject <fr:tex
display="inline"><![CDATA[Y \times  F \hookrightarrow  Y \times  G]]></fr:tex> corresponds to the characteristic function <fr:tex
display="inline"><![CDATA[Y \times  G \to  G \to  \Omega ]]></fr:tex>. Hence the denseness of <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> implies the denseness of <fr:tex
display="inline"><![CDATA[Y \times  F \hookrightarrow  Y \times  G]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a sheaf, we conclude that <fr:tex
display="inline"><![CDATA[X^Y]]></fr:tex> is also a sheaf.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3377</fr:anchor><fr:addr
type="user">algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title
text="Local object">Local object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a class of arrows <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[S]]></fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for every <fr:tex
display="inline"><![CDATA[f : A \to  B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, the composition map <fr:tex
display="block"><![CDATA[\hom (B, X) \to  \hom (A, X)]]></fr:tex> is an isomorphism.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3379</fr:anchor><fr:addr
type="user">algm-001P</fr:addr><fr:route>algm-001P.xml</fr:route><fr:title
text="Sheaf condition using Lawvere–Tierney operators">Sheaf condition using Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Knowing the <fr:link
type="local"
href="algm-001N.xml"
addr="algm-001N"
title="Grothendieck coverages and Lawvere–Tierney operators">correspondence</fr:link> of Grothendieck coverages on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and Lawvere–Tierney operators on <fr:tex
display="inline"><![CDATA[\mathsf {Psh}(\mathcal {C})]]></fr:tex>, we naturally want to rewrite the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> to use <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operators</fr:link> instead of <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverages</fr:link>.</fr:p><fr:p>Recall that the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> requires for every covering sieve <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> that the composition <fr:tex
display="inline"><![CDATA[\hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X) \to  \hom (S, X)]]></fr:tex> is an isomorphism. We can reify this to a definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:addr
type="user">algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title
text="Local object">Local object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a class of arrows <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[S]]></fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for every <fr:tex
display="inline"><![CDATA[f : A \to  B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, the composition map <fr:tex
display="block"><![CDATA[\hom (B, X) \to  \hom (A, X)]]></fr:tex> is an isomorphism.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Now we just need to pick out the class of morphisms <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> using the Lawvere–Tierney operator <fr:tex
display="inline"><![CDATA[j]]></fr:tex>. Note that this operator does not necessarily live in a presheaf topos, so we must find a way to generalize this class of arrows to not necessarily representable presheaves. Since every presheaf is a colimit of representables, we can look at the corresponding colimit of morphisms <fr:tex
display="inline"><![CDATA[\operatorname *{colim} S_i \hookrightarrow  \operatorname *{colim} \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i)]]></fr:tex>. A local object will satisfy
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \hom (\operatorname *{colim}\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i), X) \cong  \lim \hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i), X) \quad  \\     \xrightarrow {\sim } \lim \hom (S_i, X) \cong  \hom (\operatorname *{colim} S_i, X).   \end {aligned}]]></fr:tex>
  Hence we can safely include these arrows into the class and still get the same concept of local objects. Now it’s illuminating to look at the characteristic maps. A sieve <fr:tex
display="inline"><![CDATA[S \to  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> corresponds to a characteristic map in <fr:tex
display="inline"><![CDATA[\hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), \Omega ) \cong  \Gamma (U, \Omega )]]></fr:tex>. Generalizing to an arbitrary presheaf expressed (canonically) as a colimit of representables, we need the image of every section to be a covering sieve.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1738</fr:anchor><fr:addr
type="user">algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title
text="Dense subobject of a Lawvere–Tierney operator">Dense subobject of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a subobject <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> is <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex
display="inline"><![CDATA[G \to  \Omega  \xrightarrow {j} \Omega ]]></fr:tex> is the constant true. In terms of the corresponding <fr:tex
display="inline"><![CDATA[J \hookrightarrow  \Omega ]]></fr:tex>, we need the pullback of it with <fr:tex
display="inline"><![CDATA[G \to  \Omega ]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[\textrm {id} : G \to  G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In terms of sieves, for every section <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, G)]]></fr:tex>, the sieve of arrows on <fr:tex
display="inline"><![CDATA[U]]></fr:tex> along whom the restriction of <fr:tex
display="inline"><![CDATA[s]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[F]]></fr:tex> must be a covering sieve. We have arrived at the desired reformulation of the sheaf condition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1740</fr:anchor><fr:addr
type="user">algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title
text="Sheaf of a Lawvere–Tierney operator">Sheaf of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
type="local"
href="algm-001R.xml"
addr="algm-001R"
title="Local object">local object</fr:link> under the <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator"><fr:tex
display="inline"><![CDATA[j]]></fr:tex>-dense monomorphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3381</fr:anchor><fr:addr
type="user">algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title
text="Sheaf of a Lawvere–Tierney operator">Sheaf of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
type="local"
href="algm-001R.xml"
addr="algm-001R"
title="Local object">local object</fr:link> under the <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator"><fr:tex
display="inline"><![CDATA[j]]></fr:tex>-dense monomorphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3383</fr:anchor><fr:addr
type="user">algm-001N</fr:addr><fr:route>algm-001N.xml</fr:route><fr:title
text="Grothendieck coverages and Lawvere–Tierney operators">Grothendieck coverages and Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> on a presheaf category. Then we may calculate the subobject classifier as in <fr:ref
addr="algm-001M"
href="algm-001M.xml"
taxon="Construction" />.</fr:p><fr:p>By the definition of subobject classifiers, a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> can be equivalently expressed as a subobject <fr:tex
display="inline"><![CDATA[J \subseteq  \Omega ]]></fr:tex>. Translating the condition of preserving finite intersections, it needs to contain the improper sieve, be upwards closed and closed under finite intersections. And <fr:tex
display="inline"><![CDATA[j \mathbin {\circ } j = j]]></fr:tex> implies the following pullback square:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="d6485766ab43c0c3dfc20100a4403a1f"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
    J & J \\
    \Omega & \Omega
    \arrow[hook, from=1-2, to=2-2]
    \arrow["j"', from=2-1, to=2-2]
    \arrow[hook, from=1-1, to=2-1]
    \arrow[from=1-1, to=1-2]
    \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  In other words, a sieve is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> iff its image under <fr:tex
display="inline"><![CDATA[j]]></fr:tex> is also contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex>. Unfolding this, a sieve <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> iff the arrows <fr:tex
display="inline"><![CDATA[g]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> also form a sieve in <fr:tex
display="inline"><![CDATA[J]]></fr:tex>. Looking at the definition of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, we see that they are equivalent, if we regard <fr:tex
display="inline"><![CDATA[J]]></fr:tex> as picking out the covering sieves.</fr:p><fr:p>In the operator form <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, it takes in a sieve <fr:tex
display="inline"><![CDATA[S]]></fr:tex> and outputs the sieve <fr:tex
display="inline"><![CDATA[j(S)]]></fr:tex> consisting of all the subobjects <fr:tex
display="inline"><![CDATA[S]]></fr:tex> can cover, or equivalently it outputs the largest sieve that covers the “same portion” of the object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3385</fr:anchor><fr:addr
type="user">algm-001L</fr:addr><fr:route>algm-001L.xml</fr:route><fr:title
text="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Lawvere–Tierney operator</fr:strong> is a morphism <fr:tex
display="inline"><![CDATA[j : \Omega  \to  \Omega ]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is the subobject classifier, such that <fr:tex
display="inline"><![CDATA[j]]></fr:tex> preserves finite intersections, and <fr:tex
display="inline"><![CDATA[j \mathbin {\circ } j = j]]></fr:tex>.</fr:p><fr:p>We can equivalently express it as an enriched monad on the propositions. This allows for a form more akin to functional programming: we have an operator <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, equipped with maps <fr:tex
display="inline"><![CDATA[\eta  : \forall  (p : \Omega ), p \to  j(p)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\beta  : \forall  (p, q : \Omega ), j(p) \to  (p \to  j(q)) \to  j(q)]]></fr:tex>. No laws are required since propositions have at most one element.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3387</fr:anchor><fr:addr
type="user">algm-001M</fr:addr><fr:route>algm-001M.xml</fr:route><fr:title
text="Subobject classifier of presheaves">Subobject classifier of presheaves</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The subobject classifier <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> of presheaves can be given by a quick calculation.
  <fr:tex
display="block"><![CDATA[\Gamma (U, \Omega )   \cong  \hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), \Omega )   \cong  \operatorname {Sub}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U))]]></fr:tex>
  By definition, this is the set of <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieves</fr:link> on <fr:tex
display="inline"><![CDATA[U]]></fr:tex>, and the functorial action is the <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link>. For a monomorphism <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex>, an element <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, G)]]></fr:tex> is sent to the sieve consisting of arrows <fr:tex
display="inline"><![CDATA[f : V \to  U]]></fr:tex> such that the restriction along <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is included in <fr:tex
display="inline"><![CDATA[F]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3389</fr:anchor><fr:addr
type="user">algm-001K</fr:addr><fr:route>algm-001K.xml</fr:route><fr:title
text="Separation of presheaf">Separation of presheaf</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, the inclusion of <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated presheaves</fr:link> to presheaves has a left adjoint <fr:tex
display="inline"><![CDATA[(-)^{\operatorname {sep}}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001K</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We define <fr:tex
display="inline"><![CDATA[\Gamma (U, P^{\operatorname {sep}})]]></fr:tex> to be a quotient of <fr:tex
display="inline"><![CDATA[\Gamma (U, P)]]></fr:tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <fr:tex
display="inline"><![CDATA[P \to  Q]]></fr:tex> to a separated presheaf, if two sections of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3391</fr:anchor><fr:addr
type="user">algm-001I</fr:addr><fr:route>algm-001I.xml</fr:route><fr:title
text="Sheaf condition in terms of plus construction">Sheaf condition in terms of plus construction</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, the morphism <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex> to its <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link> is a monomorphism iff <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated</fr:link>, and it is an isomorphism iff <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3393</fr:anchor><fr:addr
type="user">algm-001J</fr:addr><fr:route>algm-001J.xml</fr:route><fr:title
text="Sheafification">Sheafification</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Sheafification</fr:strong> is defined as the left adjoint of the inclusion from <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaves</fr:link> to the category of presheaves. Hence it freely constructs a sheaf from a presheaf.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>484</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We construct sheafification as <fr:link
type="local"
href="algm-001G.xml"
addr="algm-001G"
title="Iterated plus construction produces a sheaf">an iterated plus construction</fr:link>. This produces a functor. By <fr:ref
addr="algm-001H"
href="algm-001H.xml"
taxon="Theorem" /> we have a natural bijection
    <fr:tex
display="block"><![CDATA[\hom (P^{++}, F) \cong  \hom (P^+, F) \cong  \hom (P, F).]]></fr:tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^+ \to  P^{++}]]></fr:tex>, we see that the unit of the adjunction is given by the composition <fr:tex
display="inline"><![CDATA[P \to  P^{++}]]></fr:tex>.</fr:p>

  <fr:p>Alternatively, using <fr:ref
addr="algm-001K"
href="algm-001K.xml"
taxon="Construction" />, we may compose two adjunctions to first <fr:link
type="local"
href="algm-001K.xml"
addr="algm-001K"
title="Separation of presheaf">separate</fr:link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3395</fr:anchor><fr:addr
type="user">algm-001H</fr:addr><fr:route>algm-001H.xml</fr:route><fr:title
text="Universal property of plus construction">Universal property of <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex> and sheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, there is a natural bijection <fr:tex
display="block"><![CDATA[\hom (P, F) \cong  \hom (P^+, F)]]></fr:tex> given by composition with <fr:tex
display="inline"><![CDATA[\eta _P : P \to  P^+]]></fr:tex>.</fr:p><fr:p>As a corollary of this and <fr:ref
addr="algm-001G"
href="algm-001G.xml"
taxon="Theorem" />, when restricted to separated presheaves, it is left adjoint to the forgetful functor from sheaves to separated presheaves.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1842</fr:anchor><fr:addr
type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For every morphism <fr:tex
display="inline"><![CDATA[P \to  F]]></fr:tex>, there is a unique way to extend the map to <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> using the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. A section of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> consists of a matching family <fr:tex
display="inline"><![CDATA[s_f]]></fr:tex>, and it is also the gluing of <fr:tex
display="inline"><![CDATA[\eta _P(s_f)]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3397</fr:anchor><fr:addr
type="user">algm-001A</fr:addr><fr:route>algm-001A.xml</fr:route><fr:title
text="Grothendieck coverage">Grothendieck coverage</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Grothendieck coverage</fr:strong> declares some <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieves</fr:link> to be coverings, such that the following holds.</fr:p><fr:ul><fr:li>The maximal sieve <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A) \subseteq  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex> is always a covering.</fr:li>
  <fr:li>Covering sieves are upwards closed, i.e. if <fr:tex
display="inline"><![CDATA[S \subseteq  S']]></fr:tex> and <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a covering sieve, then so is <fr:tex
display="inline"><![CDATA[S']]></fr:tex>.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a covering sieve of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex> is a morphism, then the <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link> <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is also a covering.</fr:li>
  <fr:li>Suppose <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a sieve, then the collection of arrows <fr:tex
display="inline"><![CDATA[g]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is a covering is a sieve itself. If this sieve is a covering, then <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is also a covering.</fr:li></fr:ul><fr:p>A Grothendieck coverage can be viewed as a <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">coverage</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3399</fr:anchor><fr:addr
type="user">algm-0019</fr:addr><fr:route>algm-0019.xml</fr:route><fr:title
text="Coverage">Coverage</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>coverage</fr:strong> on an arbitrary category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is given by a family of covers. A <fr:strong>cover</fr:strong> of some object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a family of maps with codomain <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Given a cover <fr:tex
display="inline"><![CDATA[f_i : U_i \to  A]]></fr:tex> and a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, there is a cover of <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that its composition with <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is a <fr:strong>refinement</fr:strong> of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>, in the sense that every map in the cover factors through one of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3401</fr:anchor><fr:addr
type="user">algm-001D</fr:addr><fr:route>algm-001D.xml</fr:route><fr:title
text="Descent data of presheaves">Descent data of presheaves</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> and a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>, a set of <fr:strong>descent data</fr:strong> or a <fr:strong>compatible family</fr:strong> is a morphism <fr:tex
display="inline"><![CDATA[S \to  P]]></fr:tex>. Expanding this, it is a family of <fr:em>local sections</fr:em> <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, P)]]></fr:tex> assigned for each morphism <fr:tex
display="inline"><![CDATA[U \to  A]]></fr:tex> in the sieve <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, such that the local sections are compatible on restriction. There is an obvious map from the sections <fr:tex
display="inline"><![CDATA[\Gamma (A, P)]]></fr:tex> to the descent data given by restriction.</fr:p><fr:p>More generally, given a general <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">cover</fr:link>, a set of descent data is a family of sections <fr:tex
display="inline"><![CDATA[s_i \in  \Gamma (U_i, P)]]></fr:tex> for each morphism <fr:tex
display="inline"><![CDATA[f_i : U_i \to  A]]></fr:tex> in the cover, such that in any common restriction of <fr:tex
display="inline"><![CDATA[U_i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[U_j]]></fr:tex>, the sections agree. This can be equivalently expressed as the descent data of the sieve generated by the cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3403</fr:anchor><fr:addr
type="user">algm-001G</fr:addr><fr:route>algm-001G.xml</fr:route><fr:title
text="Iterated plus construction produces a sheaf">Iterated <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link> produces a sheaf</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated presheaf</fr:link>, and if <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is already separated, <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf</fr:link>. Therefore <fr:tex
display="inline"><![CDATA[P^{++}]]></fr:tex> is always a sheaf.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1868</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first prove that <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is separated. Suppose there are two gluings of a set of descent data on a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">covering sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, then we have two sieves <fr:tex
display="inline"><![CDATA[S_1, S_2]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex> with compatible families <fr:tex
display="inline"><![CDATA[s_{1, f}, s_{2, f}]]></fr:tex>. Since they are gluings of the same descent data, the restriction along any morphism <fr:tex
display="inline"><![CDATA[g : U \to  A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex> would be equal. Hence there is a common refinement of <fr:tex
display="inline"><![CDATA[g^* S_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^* S_2]]></fr:tex> where the two families become equal. Expanding this, there is a covering sieve on <fr:tex
display="inline"><![CDATA[U]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h \in  S_1 \cap  S_2]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[h]]></fr:tex> in the sieve, and <fr:tex
display="inline"><![CDATA[s_{1, g \mathbin {\circ } h} = s_{2, g \mathbin {\circ } h}]]></fr:tex>. But then by the axioms of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[h]]></fr:tex> in the said sieve and <fr:tex
display="inline"><![CDATA[g \in  S]]></fr:tex> also generates a covering sieve. Hence <fr:tex
display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_2]]></fr:tex> are already equal on a covering subsieve, and so they are equal in <fr:tex
display="inline"><![CDATA[\Gamma (A, P^+)]]></fr:tex>.</fr:p>

  <fr:p>Let’s see why <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">compatible family</fr:link> of local sections of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a family of covering sieves <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex> over <fr:tex
display="inline"><![CDATA[U]]></fr:tex> for each morphism <fr:tex
display="inline"><![CDATA[f : U \to  A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, and for each <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex> a family of sections <fr:tex
display="inline"><![CDATA[s_{f, g} \in  \Gamma (V, P)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[g : V \to  U]]></fr:tex> lies in <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex>. By the axioms of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, the union <fr:tex
display="inline"><![CDATA[\bigcup _{f \in  S} f \mathbin {\circ } S_f]]></fr:tex> is a sieve, since <fr:tex
display="inline"><![CDATA[S_f \subseteq  f^* (f \mathbin {\circ } S_f)]]></fr:tex>. (Warning: <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } S_f]]></fr:tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <fr:tex
display="inline"><![CDATA[s']]></fr:tex> by <fr:tex
display="inline"><![CDATA[s'_{f \mathbin {\circ } g} = s_{f, g}]]></fr:tex>. Hence we need to prove <fr:tex
display="inline"><![CDATA[s_{f, g} = s_{f', g'}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g = f' \mathbin {\circ } g']]></fr:tex>.</fr:p>

  <fr:p>Since the families <fr:tex
display="inline"><![CDATA[s_{f}]]></fr:tex> are compatible, given any <fr:tex
display="inline"><![CDATA[g : V \to  U]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[s_{f, g \mathbin {\circ } r} = s_{f \mathbin {\circ } g, r}]]></fr:tex> for a family of arrows <fr:tex
display="inline"><![CDATA[r]]></fr:tex> that generates a covering sieve on <fr:tex
display="inline"><![CDATA[V]]></fr:tex>. However we cannot necessarily take <fr:tex
display="inline"><![CDATA[r = \textrm {id}]]></fr:tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <fr:tex
display="inline"><![CDATA[s_{f, g \mathbin {\circ } r} = s_{f \mathbin {\circ } g, r}]]></fr:tex> forms a compatible family over <fr:tex
display="inline"><![CDATA[V]]></fr:tex> as <fr:tex
display="inline"><![CDATA[r]]></fr:tex> ranges over the covering sieve. And therefore <fr:tex
display="inline"><![CDATA[s_{f, g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_{f \mathbin {\circ } g, \textrm {id}}]]></fr:tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3405</fr:anchor><fr:addr
type="user">algm-001E</fr:addr><fr:route>algm-001E.xml</fr:route><fr:title
text="Plus construction">Plus construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link> on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>, the <fr:strong>plus construction</fr:strong> produces a new presheaf <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> by taking a directed limit over all the <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">descent data</fr:link>. More precisely, we assign <fr:tex
display="block"><![CDATA[\Gamma (A, P^+) = \operatorname *{colim}_{S \text { covers } A} \hom (S, P).]]></fr:tex> This means the sections of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> are compatible families of sections of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, and two families are considered equal if they are equal on a common covering subsieve.</fr:p><fr:p>Given a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, we have a <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link> <fr:tex
display="inline"><![CDATA[\hom (S, P) \to  \hom (g^*S, P)]]></fr:tex>. This induces the functorial action of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex>. There is an obvious natural transformation <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3407</fr:anchor><fr:addr
type="user">algm-001C</fr:addr><fr:route>algm-001C.xml</fr:route><fr:title
text="Pullback of sieves">Pullback of sieves</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a morphism <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, the <fr:strong>pullback</fr:strong> <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is a sieve over <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. <fr:tex
display="inline"><![CDATA[h : C \to  B]]></fr:tex> is in this sieve iff <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. There is a natural map <fr:tex
display="inline"><![CDATA[g^* S \to  S]]></fr:tex> given by <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } -]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3409</fr:anchor><fr:addr
type="user">algm-001F</fr:addr><fr:route>algm-001F.xml</fr:route><fr:title
text="Sheaf">Sheaf</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> equipped with a <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">coverage</fr:link>, we define a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex> to be a <fr:strong>sheaf</fr:strong> if it satisfies the <fr:strong>sheaf condition</fr:strong>: for every cover of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the map from sections of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> to <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">descent data</fr:link> of the cover is a bijection. It is a <fr:strong>separated presheaf</fr:strong> if the map is an injection.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3411</fr:anchor><fr:addr
type="user">algm-001B</fr:addr><fr:route>algm-001B.xml</fr:route><fr:title
text="Sieve">Sieve</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>sieve</fr:strong> over an object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of an arbitrary category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a subfunctor of <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex>. More explicitly, it selects some arrows with codomain <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, such that the selected arrows absorbs composition (i.e. if <fr:tex
display="inline"><![CDATA[f : B \to  A]]></fr:tex> is selected and <fr:tex
display="inline"><![CDATA[g : C \to  B]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f]]></fr:tex> is also selected).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3413</fr:anchor><fr:addr
type="user">hmlg-001M</fr:addr><fr:route>hmlg-001M.xml</fr:route><fr:title
text="Chain reduction of mapping cones">Chain reduction of mapping cones</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reductions</fr:link> <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\rho ' : C' \Rightarrow \mkern {-14mu}\Rightarrow  D']]></fr:tex>, we can construct a reduction from the mapping cone <fr:tex
display="inline"><![CDATA[\operatorname {Cone}(f)]]></fr:tex> of a chain map <fr:tex
display="inline"><![CDATA[f : C \to  C']]></fr:tex> to (the action of <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> on <fr:tex
display="inline"><![CDATA[f]]></fr:tex>).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3415</fr:anchor><fr:addr
type="user">algm-0018</fr:addr><fr:route>algm-0018.xml</fr:route><fr:title
text="A space is noetherian iff hereditarily quasi-compact">A space is noetherian iff hereditarily quasi-compact</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian</fr:link> iff it is <fr:em>hereditarily</fr:em> <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, that is, if all its opens are quasi-compact.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2002</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.</fr:p>

  <fr:p>For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3417</fr:anchor><fr:addr
type="user">algm-0016</fr:addr><fr:route>algm-0016.xml</fr:route><fr:title
text="Nike’s trick">Nike’s trick</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The intersections of two <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link> subschemes <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_1), \operatorname {Spec}(R_2) \hookrightarrow  X]]></fr:tex> can be covered by affine schemes distinguished in both of them.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>815</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0016</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[R_1]]></fr:tex>. We can pick a distinguished open <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex> contained in the intersection and containing <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>, and a distinguished open <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_1)]]></fr:tex> contained in <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and containing <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>. Now we prove that <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>.</fr:p>

  <fr:p>It suffices to prove that <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>, since this would imply the existence of an element <fr:tex
display="inline"><![CDATA[g'/f^{n} \in  R_2[f^{-1}]]]></fr:tex>, and we can take <fr:tex
display="inline"><![CDATA[D(g') \cap  D(f) = D(g' f)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>. Now there is an inclusion map <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2[f^{-1}]) \to  \operatorname {Spec}(R_1)]]></fr:tex>, which amounts to a ring homomorphism <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem" />. In this case, <fr:tex
display="inline"><![CDATA[D(\varphi (g))]]></fr:tex> is the required distinguished open, since <fr:tex
display="inline"><![CDATA[\varphi ^{-1}D(u)]]></fr:tex> is equal to <fr:tex
display="inline"><![CDATA[D(\varphi (u))]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3419</fr:anchor><fr:addr
type="user">algm-0017</fr:addr><fr:route>algm-0017.xml</fr:route><fr:title
text="Affine local properties">Affine local properties</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose a property on affine subschemes <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex> is closed under taking distinguished subsets <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_f) \hookrightarrow  X]]></fr:tex>, and for <fr:tex
display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>, the property being true on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_{f_i}) \hookrightarrow  X]]></fr:tex> implies it being true on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex>. Then such a property is called <fr:strong>affine local</fr:strong>. We then say that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.</fr:p><fr:p>If the property <fr:tex
display="inline"><![CDATA[P]]></fr:tex> only depends on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> and not <fr:tex
display="inline"><![CDATA[X]]></fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex
display="inline"><![CDATA[P']]></fr:tex> on schemes, which we will usually refer to as <fr:strong>locally</fr:strong> <fr:tex
display="inline"><![CDATA[P]]></fr:tex>. Suppose the scheme is furthermore <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2014</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0017</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We prove that if some affine cover <fr:tex
display="inline"><![CDATA[\{\operatorname {Spec}(R_i) \hookrightarrow  X\}]]></fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex>, using <fr:link
type="local"
href="algm-0016.xml"
addr="algm-0016"
title="Nike’s trick">Nike’s trick</fr:link>, we see that the intersection with <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_i)]]></fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex> with the said property, and therefore itself also.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3421</fr:anchor><fr:addr
type="user">algm-0015</fr:addr><fr:route>algm-0015.xml</fr:route><fr:title
text="Irreducible space">Irreducible space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:strong>irreducible</fr:strong> iff finitely many non-empty opens always has non-empty intersection. In other words, iff it is non-empty and cannot be written as a union of two closed sets.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3423</fr:anchor><fr:addr
type="user">algm-0014</fr:addr><fr:route>algm-0014.xml</fr:route><fr:title
text="Adjunction of global section and {Spec}">Adjunction of global section and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have an adjunction of functors <fr:tex
display="block"><![CDATA[\mathsf {CRing}^\textrm {op} \xtofrom [\Gamma (\top , \mathscr {O}_{(-)})]{\operatorname {Spec}} \mathsf {Sch},]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> being the right adjoint (or <fr:tex
display="inline"><![CDATA[\operatorname {Spec} : \mathsf {CRing} \to  \mathsf {Sch}^\textrm {op}]]></fr:tex> being the left adjoint). In fact, we can replace <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> with the category of <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\mathsf {LRS}]]></fr:tex>, of whom <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> is a full subcategory.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>859</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0014</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We need to give a natural bijection
    <fr:tex
display="block"><![CDATA[\hom (X, \operatorname {Spec}(R)) \cong  \hom (R, \Gamma (\top , \mathscr {O}_X)).]]></fr:tex>
    In other words, maps <fr:tex
display="inline"><![CDATA[X \to  \operatorname {Spec}(R)]]></fr:tex> between locally ringed spaces are uniquely specified by the action of global sections.</fr:p>

  <fr:p>Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is glued from affine open subschemes, a map from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equivalent to a map from each open subscheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S_i)]]></fr:tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <fr:tex
display="inline"><![CDATA[R \to  S_i]]></fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem" />. The elements of <fr:tex
display="inline"><![CDATA[\Gamma (\top , \mathscr {O}_X)]]></fr:tex> are also given by a set of compatible elements from <fr:tex
display="inline"><![CDATA[S_i]]></fr:tex>. Hence these two sets are naturally bijective.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3425</fr:anchor><fr:addr
type="user">algm-0011</fr:addr><fr:route>algm-0011.xml</fr:route><fr:title
text="Characterization of the locale {Proj}(S)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens of the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> are in bijection with graded radical ideals with <fr:tex
display="inline"><![CDATA[\mathfrak {r}_0 = 0]]></fr:tex>. Hence we write <fr:tex
display="inline"><![CDATA[D_+ (\mathfrak {r})]]></fr:tex> for this open. The proof is exactly the same as <fr:ref
addr="algm-0008"
href="algm-0008.xml"
taxon="Theorem" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3427</fr:anchor><fr:addr
type="user">algm-000Z</fr:addr><fr:route>algm-000Z.xml</fr:route><fr:title
text="Geometry of graded rings">Geometry of graded rings</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>To define projective spaces, we start with an affine space, and restricts ourselves to regions invariant under dilation — or using the language of points, we consider lines through the origin as points. Hence we need to define how an element of a ring (which is geometrically a function on the affine space) behaves under dilation.</fr:p><fr:p>In polynomial rings, for example, the polynomial <fr:tex
display="inline"><![CDATA[x^2 + 2y + 7]]></fr:tex> becomes <fr:tex
display="inline"><![CDATA[\lambda ^2 x^2 + 2 \lambda  y + 7]]></fr:tex> under a dilation by <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>. Note how each term can be classified by the power of <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex> it obtains. Hence, what we need is a <fr:strong>grading</fr:strong> on the ring, which partitions <fr:tex
display="inline"><![CDATA[R = \bigoplus _d R_d]]></fr:tex> (as abelian groups). <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex> is intuitively the elements that get the factor <fr:tex
display="inline"><![CDATA[\lambda ^d]]></fr:tex> upon dilation. The multiplication of a degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> element with a degree <fr:tex
display="inline"><![CDATA[q]]></fr:tex> element should produce a degree <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex> element, since <fr:tex
display="inline"><![CDATA[\lambda ^p \lambda ^q = \lambda ^{p+q}]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2074</fr:anchor><fr:addr
type="user">hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title
text="Graded ring">Graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[d \in  D]]></fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block"><![CDATA[R_p \otimes  R_q \to  R_{p+q}]]></fr:tex> and a identity element <fr:tex
display="inline"><![CDATA[1 \in  R_0]]></fr:tex> satisfying the associativity and identity laws.</fr:p><fr:p>Usually, the grading is one of <fr:tex
display="inline"><![CDATA[\mathbb  Z]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex
display="inline"><![CDATA[D^2]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, whatever the context implies the grading is.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The opens of a projective space should come from the non-vanishing region of a homogeneous function, i.e. elements with a single degree. This ensures that dilation doesn’t change the opens. However, we would have multiple ways to represent the entire space: in a two-dimensional affine space, <fr:tex
display="inline"><![CDATA[D(x) \cup  D(y)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(1)]]></fr:tex> are both invariant under dilation, but the former excludes the origin, while the latter does not. In a projective setting, we don’t care about the origin at all, and considering that all homogeneous polynomials of positive degree vanish at the origin, we should make that mandatory. Hence, we only consider the opens corresponding to positively graded elements, which we write as <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex>. We can construct a space similar to the <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">localic spectrum of a commutative ring</fr:link>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2076</fr:anchor><fr:addr
type="user">algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title
text="Projective spectrum of a graded ring">Projective spectrum of a graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-graded ring <fr:tex
display="inline"><![CDATA[S_\bullet ]]></fr:tex>, we construct a locale analogous to <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> for each positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and impose the same relations: <fr:tex
display="inline"><![CDATA[D_+]]></fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex
display="inline"><![CDATA[D_+ (\sum _i f_i) \subseteq  \bigcup _i D_+(f_i)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As for the structure sheaf, we need to decide what the sections over <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> are. They should be functions defined on the affine space <fr:tex
display="inline"><![CDATA[D(f) \subseteq  \operatorname {Spec}(S)]]></fr:tex>, but invariant under dilation. Note that it is stronger than requiring vanishing region be invariant. We actually need the grade <fr:tex
display="inline"><![CDATA[0]]></fr:tex> elements here. Recalling from <fr:link
type="local"
href="algm-000I.xml"
addr="algm-000I"
title="Structure sheaf of a ring spectrum">structure sheaf of a ring spectrum</fr:link> that <fr:tex
display="inline"><![CDATA[\Gamma (D(f), \mathscr {O}_{\operatorname {Spec}(S)}) = S[f^{-1}]]]></fr:tex> (which can be given a canonical grading since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a graded element), we can make the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2078</fr:anchor><fr:addr
type="user">algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title
text="Structure sheaf of {Proj}(S)">Structure sheaf of <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Fix a <fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. For a positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have a graded ring localization <fr:tex
display="inline"><![CDATA[S[f^{-1}]_\bullet ]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D_+(f), \mathscr {O})]]></fr:tex> be the zeroth degree component <fr:tex
display="inline"><![CDATA[S[f^{-1}]_0]]></fr:tex>. This defines a sheaf over the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link>, and moreover gives a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2052</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> the affine scheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> (which is possible because the open subspace <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> is homeomorphic to <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> as a space). Given two positively graded elements <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, we have an isomorphism between <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D_+ (f g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D(g^{\deg  f}/f^{\deg  g})]]></fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3429</fr:anchor><fr:addr
type="user">hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title
text="Graded ring">Graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[d \in  D]]></fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block"><![CDATA[R_p \otimes  R_q \to  R_{p+q}]]></fr:tex> and a identity element <fr:tex
display="inline"><![CDATA[1 \in  R_0]]></fr:tex> satisfying the associativity and identity laws.</fr:p><fr:p>Usually, the grading is one of <fr:tex
display="inline"><![CDATA[\mathbb  Z]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex
display="inline"><![CDATA[D^2]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, whatever the context implies the grading is.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3431</fr:anchor><fr:addr
type="user">algm-0013</fr:addr><fr:route>algm-0013.xml</fr:route><fr:title
text="Irrelevant ideal">Irrelevant ideal</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-<fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, its <fr:strong>irrelevant ideal</fr:strong> <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex> is defined by the subset <fr:tex
display="inline"><![CDATA[S_+]]></fr:tex> of all positively graded elements.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3433</fr:anchor><fr:addr
type="user">algm-0012</fr:addr><fr:route>algm-0012.xml</fr:route><fr:title
text="Points of the projective spectrum">Points of the projective spectrum</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The points of the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> are given by prime ideals not dividing the <fr:link
type="local"
href="algm-0013.xml"
addr="algm-0013"
title="Irrelevant ideal">irrelevant ideal</fr:link> <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. This is in bijection with ideals with <fr:tex
display="inline"><![CDATA[\mathfrak {p}_0 = 0]]></fr:tex> (equivalently <fr:tex
display="inline"><![CDATA[\mathord {\odot } \nmid  \mathfrak {p}]]></fr:tex>), and the condition for prime ideals holds for positively graded elements, i.e. <fr:tex
display="block"><![CDATA[\mathfrak {p} \mid  x y \iff  (\mathfrak {p} \mid  x \lor  \mathfrak {p} \mid  y)]]></fr:tex> for positively graded <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2046</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>To specify a point <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, we need to specify which opens <fr:tex
display="inline"><![CDATA[D_+(f)]]></fr:tex> it belongs to, where <fr:tex
display="inline"><![CDATA[f]]></fr:tex> ranges over positively graded elements. Equivalently, we specify the closeds <fr:tex
display="inline"><![CDATA[V_+(f)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[V_+(f) \cap  V_+(g) \subseteq  V_+(f + g)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[P \in  V_+(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P \in  V_+(g)]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P \in  V_+(f + g)]]></fr:tex>. Similarly since <fr:tex
display="inline"><![CDATA[V_+(f) \subseteq  V_+(f g)]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P \in  V_+(f)]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[P \in  V_+(f g)]]></fr:tex>. Collecting all the elements whose distinguished closed contains <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, we get an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> whose zeroth degree vanishes.</fr:p>

  <fr:p>We have <fr:tex
display="inline"><![CDATA[V_+(f g) = V_+(f) \cup  V_+(g)]]></fr:tex>, so if <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f g]]></fr:tex>, then either <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  g]]></fr:tex>. This is almost the condition for prime ideals, but recall that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <fr:ref
addr="algm-0011"
href="algm-0011.xml"
taxon="Theorem" />.</fr:p>

  <fr:p>Next, we prove these ideals are in bijection with prime ideals not dividing <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. One direction of the correspondence is obvious: we take a prime ideal <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> and remove the zeroth degree, which amounts to taking <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {p}, \mathord {\odot })]]></fr:tex>.</fr:p>

  <fr:p>We prove injectivity. Suppose primes <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> satisfy <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {p}, \mathord {\odot }) = \operatorname {lcm}(\mathfrak {q}, \mathord {\odot })]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \operatorname {lcm}(\mathfrak {q}, \mathord {\odot }) \mid  \mathfrak {q} \cdot  \mathord {\odot }]]></fr:tex>, so either <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathord {\odot }]]></fr:tex> which is forbidden, or <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {q}]]></fr:tex>. Conversely we must have <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  \mathfrak {p}]]></fr:tex>, hence <fr:tex
display="inline"><![CDATA[\mathfrak {p} = \mathfrak {q}]]></fr:tex>.</fr:p>

  <fr:p>We prove surjectivity. Given an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex>, we need to supplement it with a zeroth degree component <fr:tex
display="inline"><![CDATA[\mathfrak {a}_0]]></fr:tex> so that together they make a prime ideal not divided by <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. We define <fr:tex
display="inline"><![CDATA[\mathfrak {a}_0 \mid  c]]></fr:tex> iff there exists some positively graded <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  cf]]></fr:tex>. The verification is routine element chasing.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3435</fr:anchor><fr:addr
type="user">algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title
text="Projective spectrum of a graded ring">Projective spectrum of a graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-graded ring <fr:tex
display="inline"><![CDATA[S_\bullet ]]></fr:tex>, we construct a locale analogous to <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> for each positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and impose the same relations: <fr:tex
display="inline"><![CDATA[D_+]]></fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex
display="inline"><![CDATA[D_+ (\sum _i f_i) \subseteq  \bigcup _i D_+(f_i)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3437</fr:anchor><fr:addr
type="user">algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title
text="Structure sheaf of {Proj}(S)">Structure sheaf of <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Fix a <fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. For a positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have a graded ring localization <fr:tex
display="inline"><![CDATA[S[f^{-1}]_\bullet ]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D_+(f), \mathscr {O})]]></fr:tex> be the zeroth degree component <fr:tex
display="inline"><![CDATA[S[f^{-1}]_0]]></fr:tex>. This defines a sheaf over the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link>, and moreover gives a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2052</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> the affine scheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> (which is possible because the open subspace <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> is homeomorphic to <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> as a space). Given two positively graded elements <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, we have an isomorphism between <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D_+ (f g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D(g^{\deg  f}/f^{\deg  g})]]></fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3439</fr:anchor><fr:addr
type="user">algm-000W</fr:addr><fr:route>algm-000W.xml</fr:route><fr:title
text="Action of morphisms on stalks of locally ringed spaces">Action of morphisms on stalks of locally ringed spaces</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000S.xml"
addr="algm-000S"
title="Morphism of ringed spaces">morphism of ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\varphi  : X \to  Y]]></fr:tex>, if it is <fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">local</fr:link>, a germ is invertible iff its <fr:link
type="local"
href="algm-000V.xml"
addr="algm-000V"
title="Terminology of pullbacks">pullback</fr:link> under <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is invertible. If the space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has enough points, then the inverse implication is also true.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2140</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Note that the stalk <fr:tex
display="inline"><![CDATA[(\varphi ^{-1}\mathscr {O}_{Y})_x = \mathscr {O}_{Y, \varphi (x)}]]></fr:tex>. A germ being invertible implies for some neighborhood <fr:tex
display="inline"><![CDATA[U]]></fr:tex> of <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, it comes from an invertible section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \varphi ^{-1}\mathscr {O}_Y)]]></fr:tex>, so the image in <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}_X)]]></fr:tex> is also invertible, and hence the image germ. The locality condition gives the converse.</fr:p>

  <fr:p>On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3441</fr:anchor><fr:addr
type="user">algm-000X</fr:addr><fr:route>algm-000X.xml</fr:route><fr:title
text="Morphisms of affine schemes">Morphisms of affine schemes</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">Morphism</fr:link> of <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine schemes</fr:link> are in natural bijection with ring homomorphisms in the opposite direction. In other words, there is a fully faithful embedding <fr:tex
display="inline"><![CDATA[\mathsf {CRing}^\textrm {op} \to  \mathsf {Sch}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1121</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given two rings <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, a ring homomorphism <fr:tex
display="inline"><![CDATA[\varphi  : S \to  R]]></fr:tex> naturally induces a map of <fr:link
type="local"
href="algm-0004.xml"
addr="algm-0004"
title="Distinguished opens of {Spec}(R)">distinguished opens</fr:link> <fr:tex
display="inline"><![CDATA[f \mapsto  \varphi (f)]]></fr:tex>. This is a continuous map <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \to  \operatorname {Spec}(S)]]></fr:tex>, because <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> preserves <fr:tex
display="inline"><![CDATA[\operatorname {lcm}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\gcd ]]></fr:tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <fr:tex
display="inline"><![CDATA[\Gamma (D(s), \mathscr {O}_{\operatorname {Spec}(S)}) \to  \Gamma (D(r), \mathscr {O}_{\operatorname {Spec}(R)})]]></fr:tex> whenever <fr:tex
display="inline"><![CDATA[D(r) \subseteq  \varphi ^{-1}D(s) = D(\varphi (s))]]></fr:tex>. This is just a homomorphism <fr:tex
display="inline"><![CDATA[S[s^{-1}] \to  R[r^{-1}]]]></fr:tex>, which is obvious because <fr:tex
display="inline"><![CDATA[\varphi (s)]]></fr:tex> must be invertible in <fr:tex
display="inline"><![CDATA[R[r^{-1}]]]></fr:tex>.</fr:p>

  <fr:p>We need to prove our map is <fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">local</fr:link>. Using the <fr:link
type="local"
href="algm-000W.xml"
addr="algm-000W"
title="Action of morphisms on stalks of locally ringed spaces">characterization on stalks</fr:link>, we just need to verify that <fr:tex
display="inline"><![CDATA[S_{\varphi ^{-1}(\mathfrak {p})} \to  R_{\mathfrak {p}}]]></fr:tex> reflects invertibility. This is true by construction. Hence we have a map <fr:tex
display="inline"><![CDATA[\hom _{\mathsf {CRing}}(S, R) \to  \hom _{\mathsf {Sch}}(\operatorname {Spec}(R), \operatorname {Spec}(S))]]></fr:tex>.</fr:p>

  <fr:p>In the reverse direction, given a morphism <fr:tex
display="inline"><![CDATA[\varphi  : \operatorname {Spec}(R) \to  \operatorname {Spec}(S)]]></fr:tex>, we can extract a ring homomorphism by looking at the global sections
    <fr:tex
display="block"><![CDATA[S \cong  \Gamma (\top , \varphi ^{-1}\mathscr {O}_{\operatorname {Spec}(S)}) \to  \Gamma (\top , \mathscr {O}_{\operatorname {Spec}(R)}) \cong  R.]]></fr:tex>
    We obviously have going from <fr:tex
display="inline"><![CDATA[\mathsf {CRing}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:

    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="c53e81307d06912948fdb79b10c12ad6"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      S & R \\
      {S_{\mathfrak {q}}} & {R_{\mathfrak {p}}}
      \arrow [from=1-1, to=1-2]
      \arrow [from=2-1, to=2-2]
      \arrow [two heads, from=1-1, to=2-1]
      \arrow [two heads, from=1-2, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


    where <fr:tex
display="inline"><![CDATA[\left [\mathfrak {q}\right ]]]></fr:tex> is the image of the point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> under the underlying continuous map of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex>. This fixes the action of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> on the stalks. Furthermore, the <fr:link
type="local"
href="algm-000W.xml"
addr="algm-000W"
title="Action of morphisms on stalks of locally ringed spaces">locality</fr:link> implies the preimage of <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> under the ring homomorphism divides <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and since <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> is maximal in the local ring <fr:tex
display="inline"><![CDATA[S_{\mathfrak {q}}]]></fr:tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3443</fr:anchor><fr:addr
type="user">algm-000V</fr:addr><fr:route>algm-000V.xml</fr:route><fr:title
text="Terminology of pullbacks">Terminology of pullbacks</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In general, a pullback is any contravariant functorial action. In other words, we have a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C}^\textrm {op} \to  \mathcal {D}]]></fr:tex>, and pulling back along a morphism <fr:tex
display="inline"><![CDATA[f]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> means the action of <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex>.</fr:p><fr:p>In differential geometry, we have a set of <fr:tex
display="inline"><![CDATA[k]]></fr:tex>-forms <fr:tex
display="inline"><![CDATA[\Omega ^k(M)]]></fr:tex>, which forms a functor <fr:tex
display="inline"><![CDATA[\mathsf {Mfd}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>. Pullbacks of differential forms is then the functorial action. In the special case of <fr:tex
display="inline"><![CDATA[k = 0]]></fr:tex>, this corresponds to composition, which is sometimes also referred to as pullbacks.</fr:p><fr:p>The categorical pullback can also be construed as a contravariant action, which forms the functor from <fr:tex
display="inline"><![CDATA[\mathcal {C}^\textrm {op}]]></fr:tex> to the <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-category <fr:tex
display="inline"><![CDATA[\mathsf {Cat}]]></fr:tex> given by taking slices.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3445</fr:anchor><fr:addr
type="user">algm-000U</fr:addr><fr:route>algm-000U.xml</fr:route><fr:title
text="Morphism of locally ringed spaces">Morphism of locally ringed spaces</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed spaces</fr:link>, a <fr:link
type="local"
href="algm-000S.xml"
addr="algm-000S"
title="Morphism of ringed spaces">morphism of ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> between them is <fr:strong>local</fr:strong> when sections of <fr:tex
display="inline"><![CDATA[\varphi ^{-1}\mathscr {O}_Y]]></fr:tex> are invertible iff their images in <fr:tex
display="inline"><![CDATA[\mathscr {O}_X]]></fr:tex> are invertible, i.e. the following diagram is a pullback:

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="10f8a1c26eaef8e9e0591acaaadc4d0d"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    {\varphi ^{-1}\mathscr {O}_Y^\times } & {\mathscr {O}_X^\times } \\
    {\varphi ^{-1}\mathscr {O}_Y} & {\mathscr {O}_X}
    \arrow [hook, from=1-1, to=2-1]
    \arrow [hook, from=1-2, to=2-2]
    \arrow [from=1-1, to=1-2]
    \arrow [from=2-1, to=2-2]
    \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  Note that the <fr:link
type="local"
href="algm-000T.xml"
addr="algm-000T"
title="Subsheaf of units">subsheaf of units</fr:link> is given by a finite limit, hence <fr:tex
display="inline"><![CDATA[\varphi ^{-1}]]></fr:tex> preserves it. Since the lower map map <fr:tex
display="inline"><![CDATA[\varphi ^{-1} \mathscr {O}_Y \to  \mathscr {O}_X]]></fr:tex> is a ring homomorphism on the sections, it maps units to units. Hence restriction to the upper map makes sense.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3447</fr:anchor><fr:addr
type="user">algm-000T</fr:addr><fr:route>algm-000T.xml</fr:route><fr:title
text="Subsheaf of units">Subsheaf of units</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a sheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex> of rings, we can define a subsheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}^\times ]]></fr:tex> consisting of the invertible elements, i.e. <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}^\times ) = \Gamma (U, \mathscr {O})^\times ]]></fr:tex>. This is the <fr:strong>subsheaf of units</fr:strong>.</fr:p><fr:p>This can be equivalently expressed as a pullback of <fr:tex
display="inline"><![CDATA[\mathscr {O} \times  \mathscr {O} \xrightarrow {(f,g) \mapsto  f g} \mathscr {O}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[1 \xrightarrow {1} \mathscr {O}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3449</fr:anchor><fr:addr
type="user">algm-000Q</fr:addr><fr:route>algm-000Q.xml</fr:route><fr:title
text="Affine scheme">Affine scheme</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>affine scheme</fr:strong> is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> of the form <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> for some commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3451</fr:anchor><fr:addr
type="user">algm-000O</fr:addr><fr:route>algm-000O.xml</fr:route><fr:title
text="Locally ringed space">Locally ringed space</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locality</fr:link> requirement for a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link> is to guarantee that the sections behave like functions valued in some field.</fr:p><fr:p>It is impossible in general to discuss the vanishing region of a section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \mathscr {O})]]></fr:tex>. For instance, the germs of continuous functions are non-zero on their support, which is the closure of the non-vanishing region. In algebraic geometry, such an overspill destroys most valuable information. We can talk about the maximal region on which the section is invertible, but this is different from being non-zero if sections don’t behave like functions. Similarly, it is also impossible to discuss the value of a section at some point in general. In locally ringed space, we have <fr:ref
addr="algm-000P"
href="algm-000P.xml"
taxon="Definition" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3453</fr:anchor><fr:addr
type="user">algm-000S</fr:addr><fr:route>algm-000S.xml</fr:route><fr:title
text="Morphism of ringed spaces">Morphism of ringed spaces</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex>, a morphism <fr:tex
display="inline"><![CDATA[\varphi  : X \to  Y]]></fr:tex> is given by a continuous map of the underlying spaces, and a sheaf morphism <fr:tex
display="inline"><![CDATA[\varphi ^{-1} \mathscr {O}_Y \to  \mathscr {O}_X]]></fr:tex>, equivalently <fr:tex
display="inline"><![CDATA[\mathscr {O}_Y \to  \varphi _* \mathscr {O}_X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3455</fr:anchor><fr:addr
type="user">algm-000R</fr:addr><fr:route>algm-000R.xml</fr:route><fr:title
text="Scheme">Scheme</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>scheme</fr:strong> is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> with an open covering on which the space is isomorphic to <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine schemes</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3457</fr:anchor><fr:addr
type="user">algm-000P</fr:addr><fr:route>algm-000P.xml</fr:route><fr:title
text="Value of section at a point">Value of section at a point</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> and a section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \mathscr {O})]]></fr:tex>, the germ of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at a point is an element of a local ring. The image of this element in the residue field, i.e. the quotient by the unique maximal ideal is called the <fr:strong>value</fr:strong> of this section at this point.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3459</fr:anchor><fr:addr
type="user">algm-000L</fr:addr><fr:route>algm-000L.xml</fr:route><fr:title
text="Locally ringed space">Locally ringed space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link>, i.e. a space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with a sheaf of rings <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex>, it is said to be <fr:strong>locally ringed</fr:strong> iff the following conditions hold.</fr:p><fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}) = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[U]]></fr:tex> is empty.</fr:li>
  <fr:li>Suppose <fr:tex
display="inline"><![CDATA[f + g \in  \Gamma (U, \mathscr {O})]]></fr:tex> is invertible, then we can cover <fr:tex
display="inline"><![CDATA[U]]></fr:tex> with two open sets such that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> are invertible when restricted respectively.</fr:li></fr:ul><fr:p>This can be unified as one condition: If a finite sum in <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O})]]></fr:tex> is invertible, then each summand is invertible when restricted to an open, which jointly covers <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3461</fr:anchor><fr:addr
type="user">algm-000M</fr:addr><fr:route>algm-000M.xml</fr:route><fr:title
text="Ringed space">Ringed space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>ringed space</fr:strong> is a space equipped with a sheaf of rings, called the <fr:strong>structure sheaf</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3463</fr:anchor><fr:addr
type="user">algm-000K</fr:addr><fr:route>algm-000K.xml</fr:route><fr:title
text="Sheaf and stalk from R-modules">Sheaf and stalk from <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The proofs in <fr:ref
addr="algm-000I"
href="algm-000I.xml"
taxon="Definition" /> and <fr:ref
addr="algm-000J"
href="algm-000J.xml"
taxon="Theorem" /> do not make use of the multiplication on the numerators. Therefore they immediately generalizes to modules. In particular, we have a sheaf corresponding to an <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-module <fr:tex
display="inline"><![CDATA[M]]></fr:tex>, whose sections over <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> form the <fr:tex
display="inline"><![CDATA[R[f^{-1}]]]></fr:tex>-module <fr:tex
display="inline"><![CDATA[M[f^{-1}]]]></fr:tex>. The stalk on <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[M_{\left [\mathfrak {p}\right ]}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3465</fr:anchor><fr:addr
type="user">algm-000J</fr:addr><fr:route>algm-000J.xml</fr:route><fr:title
text="Stalk of the structure sheaf on {Spec}(R)">Stalk of the structure sheaf on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \in  \operatorname {Spec}(R)]]></fr:tex>, the stalk at the point is the localization <fr:tex
display="inline"><![CDATA[R_{\mathfrak {p}}]]></fr:tex>. In particular, the ring spectrum is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> by <fr:ref
addr="algm-000N"
href="algm-000N.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2253</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We take a directed limit. The elements are from some <fr:tex
display="inline"><![CDATA[R[f^{-1}]]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  f]]></fr:tex>, i.e. the elements can be written as <fr:tex
display="inline"><![CDATA[g/f^n]]></fr:tex>. Two elements are equal iff their common restriction to some <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> is equal, i.e. <fr:tex
display="inline"><![CDATA[g_1/f_1^n = g_2/f_2^m]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[(g_1 f_2^m - g_2 f_1^n) f^k = 0]]></fr:tex>. These are exactly the definition of the localization away from <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3467</fr:anchor><fr:addr
type="user">algm-000N</fr:addr><fr:route>algm-000N.xml</fr:route><fr:title
text="Stalks of locally ringed topological space">Stalks of locally ringed topological space</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed</fr:link> topological space, it is <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed</fr:link> iff every stalk is a local ring.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2247</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000N</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.</fr:p>

  <fr:p>In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3469</fr:anchor><fr:addr
type="user">algm-000H</fr:addr><fr:route>algm-000H.xml</fr:route><fr:title
text="Irreducible closeds in a ring spectrum">Irreducible closeds in a ring spectrum</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A closed <fr:tex
display="inline"><![CDATA[V(\mathfrak {r})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is irreducible iff <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> is prime, and it is an irreducible component iff <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> is a minimal prime ideal, i.e. prime ideals that divide no other prime ideals.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2319</fr:anchor><fr:addr
type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Translating via <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />, we have a proper ideal <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> that cannot be written as <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {r}_1, \mathfrak {r}_2)]]></fr:tex> non-trivially. Suppose <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  f g]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  \sqrt {f g} \mid  \operatorname {lcm}(f, g)]]></fr:tex>. So
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \mathfrak {r} &= \gcd (\mathfrak {r}, \operatorname {lcm}(f, g)) \\       &= \operatorname {lcm}(\gcd (\mathfrak {r}, f), \gcd (\mathfrak {r}, g)).     \end {aligned}]]></fr:tex>
    Hence at least one of the two must be equal to <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex>. So <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  f]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  g]]></fr:tex>.</fr:p>

  <fr:p>An irreducible closed is an irreducible <fr:em>component</fr:em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3471</fr:anchor><fr:addr
type="user">algm-000G</fr:addr><fr:route>algm-000G.xml</fr:route><fr:title
text="Noetherian rings and noetherian spaces">Noetherian rings and <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian spaces</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">spectrum</fr:link> of a noetherian ring is always noetherian: the closeds corresponds to radical ideals. The converse does not hold. Consider a polynomial ring with infinitely many indeterminates <fr:tex
display="inline"><![CDATA[x_1, x_2, \dots ]]></fr:tex> quotiented by the relations <fr:tex
display="inline"><![CDATA[x_k^k = 0]]></fr:tex>. <fr:link
type="local"
href="algm-000E.xml"
addr="algm-000E"
title="Ideals under quotient and localization">The ideals in the quotient ring</fr:link> correspond to ideals in the polynomial ring dividing <fr:tex
display="inline"><![CDATA[x_k^k]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[k]]></fr:tex>. So there are only two radical ideals: the trivial one, and the one that divides all indeterminates, but not constants. Hence the spectrum must be a noetherian space, but the ring is obviously not noetherian since it is not finitely generated itself.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3473</fr:anchor><fr:addr
type="user">algm-000I</fr:addr><fr:route>algm-000I.xml</fr:route><fr:title
text="Structure sheaf of a ring spectrum">Structure sheaf of a ring spectrum</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a sheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex> of rings on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> called the <fr:strong>structure sheaf</fr:strong>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D(f), \mathscr {O}) = R[f^{-1}]]]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[D(f) \subseteq  D(g)]]></fr:tex> we define the restriction morphism to be the localization map <fr:tex
display="inline"><![CDATA[R[g^{-1}] \to  R[f^{-1}]]]></fr:tex>, since by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" /> the latter is a further localization of the former. This turns <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> into a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2082</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex
display="inline"><![CDATA[f_i \in  R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = D(f)]]></fr:tex>, we need to show that
    <fr:tex
display="block"><![CDATA[R[f^{-1}] \to  \prod _{i \in  I} R[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} R[(f_i f_j)^{-1}]]]></fr:tex>
    is an equalizer. Notice that <fr:tex
display="inline"><![CDATA[R[f_i^{-1}] \cong  R[f^{-1}][f_i^{-1}]]]></fr:tex>. So we may reassign <fr:tex
display="inline"><![CDATA[S = R[f^{-1}]]]></fr:tex>. This simplifies the problem to
    <fr:tex
display="block"><![CDATA[S \to  \prod _{i \in  I} S[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} S[(f_i f_j)^{-1}],]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[D(f_i)]]></fr:tex> covers the whole space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>.</fr:p>

  <fr:p>We first describe the intuition. Since we know <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex> is <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex
display="inline"><![CDATA[g_i/f_i^{d_i} \in  S[f_i^{-1}]]]></fr:tex> that are equal in their common domain. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^{d_i})]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^{d_i}]]></fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f &= \sum _{i \in  I} c_i f_i^{d_i} f \\       &= \sum  c_i f_i^{d_i} \frac {g_i}{f_i^{d_i}} \\       &= \sum  c_i g_i.     \end {aligned}]]></fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.</fr:p>

  <fr:p>Suppose there are elements <fr:tex
display="inline"><![CDATA[g_i/f_i^d \in  S[f_i^{-1}]]]></fr:tex>, where we are allowed to use a single exponent <fr:tex
display="inline"><![CDATA[d]]></fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block"><![CDATA[(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.]]></fr:tex> If there is a solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to the gluing problem, it would need to satisfy <fr:tex
display="inline"><![CDATA[(f f_i^d - g_i) f_i^M = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^R)]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^R]]></fr:tex> for large enough <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. Hence
    <fr:tex
display="block"><![CDATA[f = \sum _{i \in  I} c_i f f_i^R = \sum  c_i g_i f_i^{R-d}.]]></fr:tex> This uniquely determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex
display="inline"><![CDATA[D(f_j)]]></fr:tex>, we have
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f f_j^d \cdot  f_j^R &= \sum  c_i g_i f_i^{R-d} f_j^{R+d} \\       &= \sum  c_i g_j f_i^{R} f_j^{R} \\       &= g_j f_j^R \cdot  \sum  c_i f_i^R = g_j f_j^R.     \end {aligned}]]></fr:tex>
    This reasoning is valid as long as <fr:tex
display="inline"><![CDATA[R > N + 2d]]></fr:tex>.</fr:p>

  <fr:p>If there are infinitely many opens, we first use <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compactness</fr:link> to select a finite number <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> for <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex>. Then consider the solution on <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k), D(g)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[g]]></fr:tex>. This solution must be equal to <fr:tex
display="inline"><![CDATA[f]]></fr:tex> by uniqueness. Therefore <fr:tex
display="inline"><![CDATA[f]]></fr:tex> restrict to the correct function on each <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, showing that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the required solution.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3475</fr:anchor><fr:addr
type="user">trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title
text="Style of writing">Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I try to adhere to several principles when composing trees.</fr:p><fr:ul><fr:li>If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.</fr:li>
  <fr:li>Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.</fr:li>
  <fr:li>Apply <fr:link
type="external"
href="https://ncatlab.org/nlab/show/biased+definition">unbiased terminology</fr:link> and <fr:link
type="external"
href="https://ncatlab.org/nlab/show/negative+thinking">negative thinking</fr:link>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3477</fr:anchor><fr:addr
type="user">algm-0009</fr:addr><fr:route>algm-0009.xml</fr:route><fr:title
text="{Spec}{R} is disconnected iff R is a product of non-zero rings"><fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected iff <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a product of non-zero rings</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected iff <fr:tex
display="inline"><![CDATA[R \cong  R_1 \times  R_2]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[R_1, R_2]]></fr:tex> are non-zero commutative rings.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2359</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, if <fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected, we have two opens <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(\mathfrak {b})]]></fr:tex> whose intersection is empty and union is the entire space. In other words radical ideals <fr:tex
display="inline"><![CDATA[\mathfrak {a}, \mathfrak {b}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\sqrt {\gcd (\mathfrak {a}, \mathfrak {b})} = 1]]></fr:tex> (equivalent to <fr:tex
display="inline"><![CDATA[\gcd (\mathfrak {a}, \mathfrak {b}) = 1]]></fr:tex>) and <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {a}, \mathfrak {b}) = 0]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathfrak {b} \mid  b]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[a + b = 1]]></fr:tex>. But <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {a}, \mathfrak {b}) \mid  a b]]></fr:tex>, therefore <fr:tex
display="inline"><![CDATA[a b = 0]]></fr:tex>. This implies <fr:tex
display="inline"><![CDATA[a(1-a) = 0]]></fr:tex>, or <fr:tex
display="inline"><![CDATA[a^2 = a]]></fr:tex>. The same goes for <fr:tex
display="inline"><![CDATA[b]]></fr:tex>.</fr:p>

  <fr:p>Let <fr:tex
display="inline"><![CDATA[R_1]]></fr:tex> be the subset of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> consisting of multiples of <fr:tex
display="inline"><![CDATA[a]]></fr:tex>. It contains an identity <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[a \cdot  a x = a x]]></fr:tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <fr:tex
display="inline"><![CDATA[R_2]]></fr:tex>, the multiples of <fr:tex
display="inline"><![CDATA[b]]></fr:tex>. There is an obvious map <fr:tex
display="inline"><![CDATA[R_1 \times  R_2 \to  R]]></fr:tex>, given by <fr:tex
display="inline"><![CDATA[(ax, by) \mapsto  ax + by]]></fr:tex>. This is an injection since <fr:tex
display="inline"><![CDATA[z \mapsto  a z]]></fr:tex> recovers the first argument, and <fr:tex
display="inline"><![CDATA[z \mapsto  b z]]></fr:tex> recovers the second. It is also a surjection because <fr:tex
display="inline"><![CDATA[z = a z + b z]]></fr:tex> is the image of <fr:tex
display="inline"><![CDATA[(az, bz)]]></fr:tex>. Hence we found an isomorphism.</fr:p>

  <fr:p>In the other direction, suppose <fr:tex
display="inline"><![CDATA[R \cong  R_1 \times  R_2]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[D((1,0))]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D((0,1))]]></fr:tex> separates the spectrum into two disjoint parts.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3479</fr:anchor><fr:addr
type="user">algm-000F</fr:addr><fr:route>algm-000F.xml</fr:route><fr:title
text="Hilbert basis theorem">Hilbert basis theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is noetherian, then <fr:tex
display="inline"><![CDATA[R[x]]]></fr:tex> is also noetherian.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2365</fr:anchor><fr:addr
type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}R \subseteq  R]]></fr:tex>. We recursively produce a list of generators. Suppose we have already selected <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex>. If this doesn’t generate <fr:tex
display="inline"><![CDATA[\mathfrak {a}R]]></fr:tex>, then we select another one of the lowest degree. We prove that this procedure terminates.</fr:p>

  <fr:p>Consider the initial coefficient <fr:tex
display="inline"><![CDATA[c_i]]></fr:tex> of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>. The ideal <fr:tex
display="inline"><![CDATA[\mathfrak {c}_k]]></fr:tex> generated by the first <fr:tex
display="inline"><![CDATA[k]]></fr:tex> elements must eventually stabilize. Let’s say <fr:tex
display="inline"><![CDATA[c_{n+1} = \sum _{i=1}^n b_i c_i]]></fr:tex>. Then we can subtract <fr:tex
display="inline"><![CDATA[f_{n+1}]]></fr:tex> by suitable multiples of <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex> to cancel the leading term. This must not belong to ideal generated by <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex>, which contradicts our choice of generators, being of the lowest degree.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3481</fr:anchor><fr:addr
type="user">algm-000B</fr:addr><fr:route>algm-000B.xml</fr:route><fr:title
text="A ring spectrum is quasi-compact">A <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">ring spectrum</fr:link> is quasi-compact</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is always <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2349</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = \top ]]></fr:tex>, then there is a finite union equal to <fr:tex
display="inline"><![CDATA[\top ]]></fr:tex>. Algebraically this means <fr:tex
display="inline"><![CDATA[\sqrt {\gcd \{f_i\}} = 1]]></fr:tex>, equivalently <fr:tex
display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>. So we have a linear combination <fr:tex
display="inline"><![CDATA[\sum _k a_k f_k = 1]]></fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3483</fr:anchor><fr:addr
type="user">algm-000D</fr:addr><fr:route>algm-000D.xml</fr:route><fr:title
text="A closed in a noetherian space is uniquely a finite union of irreducible closeds">A closed in a noetherian space is uniquely a finite union of irreducible closeds</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian space</fr:link>, then a closed <fr:tex
display="inline"><![CDATA[Z \subseteq  X]]></fr:tex> can be written uniquely as the union of finitely many irreducible closeds.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2371</fr:anchor><fr:addr
type="machine">#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> can be written as a finite union. If <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is irreducible then we’re done. Otherwise <fr:tex
display="inline"><![CDATA[Z = Z_1 \cup  Z_2]]></fr:tex> is a non-trivial union of two closeds. By the induction hypothesis <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Z_2]]></fr:tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.</fr:p>

  <fr:p>We then prove uniqueness. Suppose
    <fr:tex
display="block"><![CDATA[Z_1 \cup  \cdots  \cup  Z_n = Z'_1 \cup  \cdots  \cup  Z'_m.]]></fr:tex>
    Consider the intersection with <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex>. The left hand side collapses to <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex>. The right hand side becomes <fr:tex
display="inline"><![CDATA[\bigcup _{i=1}^m (Z'_i \cap  Z_1)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> is irreducible, <fr:tex
display="inline"><![CDATA[Z'_i \cap  Z_1]]></fr:tex> must be either <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> or empty. In the former case, since <fr:tex
display="inline"><![CDATA[Z'_i]]></fr:tex> is also irreducible, <fr:tex
display="inline"><![CDATA[Z'_i = Z_1]]></fr:tex>. Therefore each <fr:tex
display="inline"><![CDATA[Z_j]]></fr:tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3485</fr:anchor><fr:addr
type="user">algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title
text="Characterization of the locale {Spec}(R)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens in <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the locale</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> bijectively corresponds to radical ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2070</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We can first put the opens in disjunctive normal form
    <fr:tex
display="block"><![CDATA[U = \bigcup _{i \in  I} \bigcap _{j=1}^{n_i} D(f_{i, j}).]]></fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex
display="inline"><![CDATA[f_i = \prod _j f_{i, j}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[U = \bigcup _i D(f_i)]]></fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex
display="inline"><![CDATA[U]]></fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> can be added, i.e. <fr:tex
display="inline"><![CDATA[D(f) \nsubseteq  U]]></fr:tex>. This would uniquely determine <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>

  <fr:p>Such a saturated set would have to be closed under addition since <fr:tex
display="inline"><![CDATA[D(f+g) \subseteq  D(f) \cup  D(g)]]></fr:tex>, and for the nullary case it must include <fr:tex
display="inline"><![CDATA[D(0) = \bot ]]></fr:tex>. It also has to absorb multiplication, because <fr:tex
display="inline"><![CDATA[D(f \cdot  g) \subseteq  D(f)]]></fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for the union <fr:tex
display="inline"><![CDATA[\bigcup _{\mathfrak {a} \mid  f} D(f)]]></fr:tex>.</fr:p>

  <fr:p>There is one last requirement we haven’t dealt with, i.e. <fr:tex
display="inline"><![CDATA[D(f \cdot  g)]]></fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex
display="inline"><![CDATA[D(f^n) = D(f)]]></fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex
display="inline"><![CDATA[f \cdot  g]]></fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3487</fr:anchor><fr:addr
type="user">algm-0004</fr:addr><fr:route>algm-0004.xml</fr:route><fr:title
text="Distinguished opens of {Spec}(R)">Distinguished opens of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a basis of opens on <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring"><fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:link> by <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for every element <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>. These are called <fr:strong>distinguished opens</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2169</fr:anchor><fr:addr
type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0004</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="block"><![CDATA[D(\mathfrak {a}) = \bigcup _{\mathfrak {a} \mid  f} D(f).]]></fr:tex> Alternatively, <fr:tex
display="inline"><![CDATA[V(\mathfrak {a}) = \bigcap _{\mathfrak {a} \mid  f} V(f)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[V(\mathfrak {a}) \subseteq  V(f)]]></fr:tex>, we have the forward inclusion. For the backwards inclusion, suppose <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \notin  V(\mathfrak {a})]]></fr:tex>, i.e. <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  \mathfrak {a}]]></fr:tex>, then by definition there is an element <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  f]]></fr:tex>, meaning that <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \notin  V(f)]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3489</fr:anchor><fr:addr
type="user">algm-000E</fr:addr><fr:route>algm-000E.xml</fr:route><fr:title
text="Ideals under quotient and localization">Ideals under quotient and localization</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the ideals of <fr:tex
display="inline"><![CDATA[R/\mathfrak {a}]]></fr:tex> bijectively corresponds to the ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> that divides <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex>. The ideals of <fr:tex
display="inline"><![CDATA[R[S^{-1}]]]></fr:tex> are generated by images of ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> under the localization map, written as <fr:tex
display="inline"><![CDATA[\mathfrak {b}[S^{-1}]]]></fr:tex>, isomorphic to <fr:tex
display="inline"><![CDATA[\mathfrak {b} \otimes _R R[S^{-1}]]]></fr:tex>.</fr:p><fr:p>The prime ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> that doesn’t intersect <fr:tex
display="inline"><![CDATA[S]]></fr:tex> bijectively correspond to prime ideals in <fr:tex
display="inline"><![CDATA[R[S^{-1}]]]></fr:tex> via the localization map.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3491</fr:anchor><fr:addr
type="user">algm-0005</fr:addr><fr:route>algm-0005.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <fr:tex
display="inline"><![CDATA[f/g]]></fr:tex>, so the domain should be the non-vanishing part of <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which we denote as <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2411</fr:anchor><fr:addr
type="user">algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title
text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p><fr:p>For example, on the space given by <fr:tex
display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex
display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex
display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex
display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Recognizing this, we can try to freely generate a locale using <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2413</fr:anchor><fr:addr
type="user">algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a frame generated by the symbols <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>, subject to the following relations:
  <fr:tex
display="block"><![CDATA[\begin {aligned}     D(0) &= \bot  \\     D(1) &= \top  \\     D(f \cdot  g) &= D(f) \cap  D(g) \\     D(f + g) &\subseteq  D(f) \cup  D(g)   \end {aligned}]]></fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2415</fr:anchor><fr:addr
type="user">algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title
text="Characterization of the locale {Spec}(R)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens in <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the locale</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> bijectively corresponds to radical ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2070</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We can first put the opens in disjunctive normal form
    <fr:tex
display="block"><![CDATA[U = \bigcup _{i \in  I} \bigcap _{j=1}^{n_i} D(f_{i, j}).]]></fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex
display="inline"><![CDATA[f_i = \prod _j f_{i, j}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[U = \bigcup _i D(f_i)]]></fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex
display="inline"><![CDATA[U]]></fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> can be added, i.e. <fr:tex
display="inline"><![CDATA[D(f) \nsubseteq  U]]></fr:tex>. This would uniquely determine <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>

  <fr:p>Such a saturated set would have to be closed under addition since <fr:tex
display="inline"><![CDATA[D(f+g) \subseteq  D(f) \cup  D(g)]]></fr:tex>, and for the nullary case it must include <fr:tex
display="inline"><![CDATA[D(0) = \bot ]]></fr:tex>. It also has to absorb multiplication, because <fr:tex
display="inline"><![CDATA[D(f \cdot  g) \subseteq  D(f)]]></fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for the union <fr:tex
display="inline"><![CDATA[\bigcup _{\mathfrak {a} \mid  f} D(f)]]></fr:tex>.</fr:p>

  <fr:p>There is one last requirement we haven’t dealt with, i.e. <fr:tex
display="inline"><![CDATA[D(f \cdot  g)]]></fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex
display="inline"><![CDATA[D(f^n) = D(f)]]></fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex
display="inline"><![CDATA[f \cdot  g]]></fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3493</fr:anchor><fr:addr
type="user">algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a frame generated by the symbols <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>, subject to the following relations:
  <fr:tex
display="block"><![CDATA[\begin {aligned}     D(0) &= \bot  \\     D(1) &= \top  \\     D(f \cdot  g) &= D(f) \cap  D(g) \\     D(f + g) &\subseteq  D(f) \cup  D(g)   \end {aligned}]]></fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3495</fr:anchor><fr:addr
type="user">algm-000C</fr:addr><fr:route>algm-000C.xml</fr:route><fr:title
text="Noetherian space">Noetherian space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:strong>noetherian</fr:strong> if every descending chain of closeds, or equivalently every ascending chain of opens stabilizes. In other words, the partial order of closeds is well-founded.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3497</fr:anchor><fr:addr
type="user">algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title
text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p><fr:p>For example, on the space given by <fr:tex
display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex
display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex
display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex
display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3499</fr:anchor><fr:addr
type="user">algm-000A</fr:addr><fr:route>algm-000A.xml</fr:route><fr:title
text="Terminology of compactness in algebraic geometry">Terminology of compactness in algebraic geometry</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3501</fr:anchor><fr:addr
type="user">algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title
text="The radical ideal is the lcm of prime ideal divisors">The radical ideal is the lcm of prime ideal divisors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> of a commutative ring, the radical <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}}]]></fr:tex> is the lowest common multiple of the prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2329</fr:anchor><fr:addr
type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>On one hand, if <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f^n]]></fr:tex> for some natural number <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This means for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f^n]]></fr:tex>, which by being a prime ideal implies <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, we construct a prime ideal divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> that is not a divisor of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Consider the set of all ideals not a divisor of <fr:tex
display="inline"><![CDATA[f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> still in this set, since <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Zorn's_lemma">Zorn’s lemma</fr:link>, the set contains some <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex
display="inline"><![CDATA[\mathfrak {q} \nmid  x, y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {q}' = \gcd (\mathfrak {q}, x y)]]></fr:tex> is a proper divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x y \mid  f^n]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y \mid  f^n]]></fr:tex>, contradiction.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3503</fr:anchor><fr:addr
type="user">algm-0002</fr:addr><fr:route>algm-0002.xml</fr:route><fr:title
text="Radical ideals bijectively correspond to open sets">Radical ideals bijectively correspond to open sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an arbitrary <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link>, we have <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) = D(\sqrt {\mathfrak {a}})]]></fr:tex>. There is a containment of opens <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) \subseteq  D(\mathfrak {b})]]></fr:tex> — equivalently <fr:tex
display="inline"><![CDATA[V(\mathfrak {b}) \subseteq  V(\mathfrak {a})]]></fr:tex> — iff <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {b}} \mid  \sqrt {\mathfrak {a}}]]></fr:tex>, and the points contained in an open set completely determines the radical ideal.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2325</fr:anchor><fr:addr
type="machine">#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0002</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {p}} \mid  \sqrt {\mathfrak {a}}]]></fr:tex>, but <fr:tex
display="inline"><![CDATA[\mathfrak {p} = \sqrt {\mathfrak {p}}]]></fr:tex>, we see that <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) = D(\sqrt {\mathfrak {a}})]]></fr:tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {b} \implies  \mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>. We need to prove that <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f \implies  \sqrt {\mathfrak {b}} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>Given <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex> for all prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \sqrt {\mathfrak {a}}]]></fr:tex> (which is equivalent to <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>). So we know that for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {b}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>. This is now purely a condition on <fr:tex
display="inline"><![CDATA[\mathfrak {b}]]></fr:tex>. The next lemma finishes the proof.</fr:p>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2327</fr:anchor><fr:addr
type="user">algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title
text="The radical ideal is the lcm of prime ideal divisors">The radical ideal is the lcm of prime ideal divisors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> of a commutative ring, the radical <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}}]]></fr:tex> is the lowest common multiple of the prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2329</fr:anchor><fr:addr
type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>On one hand, if <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f^n]]></fr:tex> for some natural number <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This means for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f^n]]></fr:tex>, which by being a prime ideal implies <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, we construct a prime ideal divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> that is not a divisor of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Consider the set of all ideals not a divisor of <fr:tex
display="inline"><![CDATA[f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> still in this set, since <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Zorn's_lemma">Zorn’s lemma</fr:link>, the set contains some <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex
display="inline"><![CDATA[\mathfrak {q} \nmid  x, y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {q}' = \gcd (\mathfrak {q}, x y)]]></fr:tex> is a proper divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x y \mid  f^n]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y \mid  f^n]]></fr:tex>, contradiction.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3505</fr:anchor><fr:addr
type="user">algm-0001</fr:addr><fr:route>algm-0001.xml</fr:route><fr:title
text="Topological spectrum of a commutative ring">Topological spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The topological <fr:strong>spectrum</fr:strong> of a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>, is a topological space whose points are given by prime ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. We denote the point corresponding to <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex>. We define an open <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for each ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> which contains the point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> when <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  \mathfrak {a}]]></fr:tex>. The corresponding closed is written as <fr:tex
display="inline"><![CDATA[V(\mathfrak {a})]]></fr:tex>.</fr:p><fr:p>We abuse the notation and write <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for the case where <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> is generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Similar notations apply to <fr:tex
display="inline"><![CDATA[V]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3507</fr:anchor><fr:addr
type="user">hmlg-001J</fr:addr><fr:route>hmlg-001J.xml</fr:route><fr:title
text="Effective homology">Effective homology</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a mathematical object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> canonically associated with an <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link> chain complex <fr:tex
display="inline"><![CDATA[C_\bullet  (X)]]></fr:tex> (e.g. the <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">normalized chain complex</fr:link> of a <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">simplicial set</fr:link>), it is said to be equipped with the structure of <fr:strong>effective homology</fr:strong>, if we have a <fr:link
type="local"
href="hmlg-001I.xml"
addr="hmlg-001I"
title="Strong homology equivalence">strong homology equivalence</fr:link> <fr:tex
display="inline"><![CDATA[C_\bullet  (X) \mathbin {\Leftarrow  \mkern {-13mu} \Leftrightarrow  \mkern {-13mu} \Rightarrow } E_\bullet ]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex> is <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective of finite type</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3509</fr:anchor><fr:addr
type="user">hmlg-001K</fr:addr><fr:route>hmlg-001K.xml</fr:route><fr:title
text="Effective homology">Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes on effective homology and algebraic topology. Main references are <fr:link
type="local"
href="constructive-homological-algebra.xml"
addr="constructive-homological-algebra"
title="Constructive Homological Algebra and Applications">Constructive Homological Algebra and Applications</fr:link> and <fr:link
type="local"
href="discrete-vector-fields.xml"
addr="discrete-vector-fields"
title="Discrete Vector Fields and Fundamental Algebraic Topology">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. We assume basic familiarity with the classical aspects of the theory, although there will also be links within this forest to the relevant concepts.</fr:p><fr:ul><fr:li><fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>, simplicial principal bundles, twisted products by <fr:link
type="local"
href="simplicial-objects.xml"
addr="simplicial-objects"
title="Simplicial objects in algebraic topology">Simplicial objects in algebraic topology</fr:link></fr:li>
  <fr:li>classifying space, loop space</fr:li>
  <fr:li>composition of <fr:link
type="local"
href="hmlg-001I.xml"
addr="hmlg-001I"
title="Strong homology equivalence">strong homology equivalence</fr:link>, tensor product, cone, bicomplex</fr:li>
  <fr:li>simplicial group, Kan complex</fr:li>
  <fr:li>organize into notes</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3511</fr:anchor><fr:addr
type="user">hmlg-001I</fr:addr><fr:route>hmlg-001I.xml</fr:route><fr:title
text="Strong homology equivalence">Strong homology equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>strong homology equivalence</fr:strong> between chain complexes <fr:tex
display="inline"><![CDATA[C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is a span of chain reductions, i.e. a third chain complex <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with <fr:tex
display="inline"><![CDATA[X \Rightarrow \mkern {-14mu}\Rightarrow  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>. We denote a strong homology equivalence with <fr:tex
display="inline"><![CDATA[C \mathbin {\Leftarrow  \mkern {-13mu} \Leftrightarrow  \mkern {-13mu} \Rightarrow } D]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3513</fr:anchor><fr:addr
type="user">hmlg-001G</fr:addr><fr:route>hmlg-001G.xml</fr:route><fr:title
text="Perturbation of the larger chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction">Perturbation</fr:link> of the larger chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a reduction <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and a perturbation <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex> for <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, we assume that <fr:tex
display="inline"><![CDATA[h_{\rho } \mathbin {\circ } \delta _C]]></fr:tex> is pointwise nilpotent, i.e. <fr:tex
display="block"><![CDATA[\forall  c \in  C_k, \exists  n \in  \mathbb {N}, \; (h_{\rho }\delta _C)^n (c) = 0.]]></fr:tex> We can construct a new chain reduction <fr:tex
display="inline"><![CDATA[\rho ' : C' \Rightarrow \mkern {-14mu}\Rightarrow  D']]></fr:tex>, where <fr:tex
display="inline"><![CDATA[C']]></fr:tex> is <fr:tex
display="inline"><![CDATA[C]]></fr:tex> perturbed by <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex>.</fr:p><fr:p>Note that this situation is much harder compared to <fr:ref
addr="hmlg-001E"
href="hmlg-001E.xml"
taxon="Construction" />, as it is generally impossible without the added condition.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1638</fr:anchor><fr:addr
type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For this construction using the third equivalent definition of a chain reduction in <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem" />, i.e. a homotopy operator on <fr:tex
display="inline"><![CDATA[C]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } d_C \mathbin {\circ } h = h]]></fr:tex>.</fr:p>

  <fr:p>We need to construct a new homotopy operator such that <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } h' = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } (d_C + \delta _C) \mathbin {\circ } h' = h']]></fr:tex>. We approach this through a “perturbative” mindset. Starting with <fr:tex
display="inline"><![CDATA[h_0 = h]]></fr:tex>, the second equation is off by a difference of <fr:tex
display="inline"><![CDATA[h_0 \delta _C h_0]]></fr:tex>. We simply add this as a correction term, <fr:tex
display="inline"><![CDATA[h_1 = h_0 + \alpha  h_0 \delta _C h_0]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <fr:tex
display="inline"><![CDATA[h_0 \delta _C h_0 \delta _C \cdots  h_0]]></fr:tex>, since nothing else has the same type.) We still have <fr:tex
display="inline"><![CDATA[h_1 \mathbin {\circ } h_1 = 0]]></fr:tex>, and for the second equation this creates a new error term
    <fr:tex
display="block"><![CDATA[\begin {aligned}       &\quad  h_1 (d_C + \delta _C) h_1 - h_1 \\       &= (1 + \alpha ) h_0 \delta _C h_0 + 2 (\alpha  + \alpha ^2) h_0 \delta _C h_0 \delta _C h_0 + \alpha ^2 h_0 \delta _C h_0 \delta _C h_0 \delta _C h_0     \end {aligned}]]></fr:tex>
    and we can eliminate the first and second order part by setting <fr:tex
display="inline"><![CDATA[\alpha  = -1]]></fr:tex>. The natural next step would be to add a further correction <fr:tex
display="inline"><![CDATA[h_2 = h_1 + \beta  h_0 \delta _C h_0 \delta _C h_0]]></fr:tex>. This turns out to require <fr:tex
display="inline"><![CDATA[\beta  = +1]]></fr:tex>, and so on.</fr:p>

  <fr:p>From the informal discussion above, we can conjecture the formula
    <fr:tex
display="block"><![CDATA[h' = \sum _{k=0}^\infty  (-1)^k (h \delta _C)^k h.]]></fr:tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } h' = 0]]></fr:tex> from <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex>, and the second equation follows from a nice telescopic sum
    <fr:tex
display="block"><![CDATA[\begin {aligned}       h' \mathbin {\circ } (d_C + \delta _C) \mathbin {\circ } h'       &= \sum _{i, j} (-1)^{i + j} (h \delta _C)^i h (d_C + \delta _C) (h \delta _C)^j h \\       &= \sum _{i, j} (-1)^{i + j} \left [(h \delta _C)^{i + j + 1} h + (h \delta _C)^{i + j} h\right ] \\       &= \sum _{k} (k+1) (-1)^k \left [(h \delta _C)^{k + 1} h + (h \delta _C)^k h\right ] \\       &= \sum _k (-1)^k (h \delta _C)^k h = h'.     \end {aligned}]]></fr:tex></fr:p>

  <fr:p>We can reconstruct the other two components of the reduction <fr:tex
display="inline"><![CDATA[\iota _{\rho '}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{\rho '}]]></fr:tex> through <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem" />. In particular, <fr:tex
display="inline"><![CDATA[D']]></fr:tex> is given by a perturbation of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>. We only write down the results below for easy reference.
    <fr:tex
display="block"><![CDATA[\begin {aligned}     \pi _{\rho '} &= \sum _{k=0}^\infty  (-1)^k \pi _{\rho } (\delta _C h_{\rho })^k \\     \iota _{\rho '} &= \sum _{k=0}^\infty  (-1)^k (h_{\rho } \delta _C)^k \iota _{\rho } \\     \delta _D &= \sum _{k=0}^\infty  (-1)^k \pi _{\rho } \delta _C (h_{\rho } \delta _C)^k \iota _{\rho }.     \end {aligned}]]></fr:tex></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3515</fr:anchor><fr:addr
type="user">hmlg-001H</fr:addr><fr:route>hmlg-001H.xml</fr:route><fr:title
text="Characterization of chain reduction">Characterization of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The following data are equivalent.</fr:p><fr:ul><fr:li>A <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>.</fr:li>
  <fr:li>A splitting <fr:tex
display="inline"><![CDATA[C \cong  D \oplus  E]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>.</fr:li>
  <fr:li>A <fr:link
type="local"
href="hmlg-0016.xml"
addr="hmlg-0016"
title="Chain homotopy">chain homotopy</fr:link> <fr:tex
display="inline"><![CDATA[h : C \to  C]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } d_C \mathbin {\circ } h = h]]></fr:tex>.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1642</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A chain reduction consists of maps <fr:tex
display="inline"><![CDATA[C_k \mathrel {\smash {\xtofrom [g_k]{f_k}}} D_k]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f_k \mathbin {\circ } g_k = \textrm {id}]]></fr:tex>. Therefore <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">splits</fr:link> as <fr:tex
display="inline"><![CDATA[D_\bullet  \oplus  E_\bullet ]]></fr:tex>, and the boundary maps are preserved since <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> are chain maps. We have a homotopy <fr:tex
display="inline"><![CDATA[h_k : D_k \oplus  E_k \to  D_{k+1} \oplus  E_{k+1}]]></fr:tex>, which we may write as a <fr:tex
display="inline"><![CDATA[(2 \times  2)]]></fr:tex>-matrix. <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } h = 0]]></fr:tex> demands the first row to be zero, and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } g = 0]]></fr:tex> requires the first column to vanish. This leaves us with
    <fr:tex
display="block"><![CDATA[\begin {bmatrix}       0 & 0 \\       0 & r_k     \end {bmatrix}]]></fr:tex>
    such that <fr:tex
display="inline"><![CDATA[r_{k+1} \mathbin {\circ } r_k = 0]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex>.</fr:p>

  <fr:p>Substituting the requirement that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a homotopy <fr:tex
display="inline"><![CDATA[\textrm {id} \to  g \mathbin {\circ } f]]></fr:tex>, we get the equation <fr:tex
display="block"><![CDATA[d_{k+1} \mathbin {\circ } r_k + r_{k-1} \mathbin {\circ } d_k = \textrm {id},]]></fr:tex> where <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is the boundary operator on <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex>. In other words, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is a null-homotopy of <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex>, rendering it <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>. Conversely, given <fr:tex
display="inline"><![CDATA[C \cong  D \oplus  E]]></fr:tex>, we can reconstruct <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as the projection and inclusion maps, with <fr:tex
display="inline"><![CDATA[h]]></fr:tex> obtained out of <fr:tex
display="inline"><![CDATA[r]]></fr:tex> in the manner depicted above.</fr:p>

  <fr:p>On the other hand, given only the homotopy operator, we expect to have <fr:tex
display="inline"><![CDATA[d \mathbin {\circ } h + h \mathbin {\circ } d = \textrm {id} - g \mathbin {\circ } f]]></fr:tex>. And since <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f]]></fr:tex> should be the projector of <fr:tex
display="inline"><![CDATA[C]]></fr:tex> onto the subspace <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\textrm {id} - g \mathbin {\circ } f]]></fr:tex> should be the projector onto <fr:tex
display="inline"><![CDATA[E]]></fr:tex>. We are thus led to proving <fr:tex
display="inline"><![CDATA[p = d \mathbin {\circ } h + h \mathbin {\circ } d]]></fr:tex> is indeed a projector.
    <fr:tex
display="block"><![CDATA[\begin {aligned}       p_k \mathbin {\circ } p_k &= (d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k) \mathbin {\circ } (d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k) \\       &= d_{k+1} \mathbin {\circ } \overbrace {h_k \mathbin {\circ } d_{k+1} \mathbin {\circ } h_k}^{h_k} + d_{k+1} \mathbin {\circ } \overbrace {h_k \mathbin {\circ } h_{k-1}}^{0} \mathbin {\circ } d_k \\       &\qquad  + h_{k-1} \mathbin {\circ } \underbrace {d_k \mathbin {\circ } d_{k+1}}_{0} \mathbin {\circ } h_k + \underbrace {h_{k-1} \mathbin {\circ } d_k \mathbin {\circ } h_{k-1}}_{h_{k-1}} \mathbin {\circ } d_k \\       &= d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k = p_k.     \end {aligned}]]></fr:tex>
    Therefore we conclude that <fr:tex
display="inline"><![CDATA[p_k]]></fr:tex> splits <fr:tex
display="inline"><![CDATA[C_k \cong  D_k \oplus  E_k]]></fr:tex>. More over, <fr:tex
display="inline"><![CDATA[p \mathbin {\circ } d = d \mathbin {\circ } h \mathbin {\circ } d = d \mathbin {\circ } p]]></fr:tex>, meaning <fr:tex
display="inline"><![CDATA[p]]></fr:tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } p = p \mathbin {\circ } h = h \mathbin {\circ } d \mathbin {\circ } h = h]]></fr:tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <fr:tex
display="inline"><![CDATA[E_k]]></fr:tex> to get a homotopy from <fr:tex
display="inline"><![CDATA[\textrm {id}_E]]></fr:tex> to <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>

  <fr:p>Finally, restricting <fr:tex
display="inline"><![CDATA[h]]></fr:tex> onto <fr:tex
display="inline"><![CDATA[D_k]]></fr:tex> we see that it must be zero, since <fr:tex
display="inline"><![CDATA[h(\textrm {id} - p) = h - h \mathbin {\circ } d \mathbin {\circ } h = 0]]></fr:tex>. This means that all the information of <fr:tex
display="inline"><![CDATA[h]]></fr:tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3517</fr:anchor><fr:addr
type="user">hmlg-001E</fr:addr><fr:route>hmlg-001E.xml</fr:route><fr:title
text="Perturbation of the smaller chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001C.xml"
addr="hmlg-001C"
title="Perturbation of chain complex">Perturbation</fr:link> of the smaller chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a reduction <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and a perturbation <fr:tex
display="inline"><![CDATA[\delta _D]]></fr:tex> for <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, we can construct a perturbation <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex> for <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, such that the same <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> can serve as a reduction of the perturbed chain complexes.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2545</fr:anchor><fr:addr
type="machine">#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Let the reduction <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> be made out of the three maps <fr:tex
display="inline"><![CDATA[\pi _{\rho } : C \to  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\iota _{\rho } : D \to  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h_{\rho } : C \to  C]]></fr:tex>. Then since <fr:tex
display="inline"><![CDATA[C]]></fr:tex> splits as the direct sum of <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and an <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">acyclic</fr:link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <fr:tex
display="inline"><![CDATA[\delta _C = \iota _{\rho } \mathbin {\circ } \delta _D \mathbin {\circ } \pi _{\rho }]]></fr:tex>. A quick computation shows that <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> is still a reduction of the perturbed chain complexes.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3519</fr:anchor><fr:addr
type="user">hmlg-001B</fr:addr><fr:route>hmlg-001B.xml</fr:route><fr:title
text="Terminology of effective algebraic cellular complex">Terminology of <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:link></fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The terminology chosen here differs from that in <fr:link
type="local"
href="kenzo.xml"
addr="kenzo"
title="Kenzo">Kenzo</fr:link>. What we call effective is named <fr:em>locally effective</fr:em>; and what we call effective of finite type is named <fr:em>effective</fr:em> instead.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3521</fr:anchor><fr:addr
type="user">hmlg-001D</fr:addr><fr:route>hmlg-001D.xml</fr:route><fr:title
text="Geometric interpretation of algebraic cellular complex">Geometric interpretation of <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An ACC can be viewed as the algebraic distillation of a <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complex</fr:link>. The generators in dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are regarded as <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-cells. However, we only record a formal sum of the boundaries, and forget the exact configuration. Hence, ACC is a suitable middle ground for both geometric transformations and algebraic operations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3523</fr:anchor><fr:addr
type="user">hmlg-001F</fr:addr><fr:route>hmlg-001F.xml</fr:route><fr:title
text="Geometric interpretation of perturbations">Geometric interpretation of <fr:link
type="local"
href="hmlg-001C.xml"
addr="hmlg-001C"
title="Perturbation of chain complex">perturbations</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">ACCs</fr:link>, the effect of a perturbation is to “reconnect” the cells. But it may not create or delete cells, since the abelian groups are unchanged.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3525</fr:anchor><fr:addr
type="user">hmlg-001C</fr:addr><fr:route>hmlg-001C.xml</fr:route><fr:title
text="Perturbation of chain complex">Perturbation of chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>perturbation</fr:strong> of a chain complex with boundary operator <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is an operator <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> of degree <fr:tex
display="inline"><![CDATA[(-1)]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[d + \delta ]]></fr:tex> also forms a boundary operator.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3527</fr:anchor><fr:addr
type="user">hmlg-001A</fr:addr><fr:route>hmlg-001A.xml</fr:route><fr:title
text="Effective algebraic cellular complex">Effective <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link>, suppose we can encode the basis sets <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> such that they have <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">decidable equality</fr:link>, and the maps <fr:tex
display="inline"><![CDATA[C_k \to  \mathbb {Z}[C_{k-1}]]]></fr:tex> are computable, then we say the ACC is <fr:strong>effective</fr:strong>. Suppose further that <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> are (computably) finite sets, then we say it is <fr:strong>effective of finite type</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3529</fr:anchor><fr:addr
type="user">hmlg-0018</fr:addr><fr:route>hmlg-0018.xml</fr:route><fr:title
text="An additive functor is exact iff it preserves quasi-isomorphisms">An additive functor is exact iff it preserves quasi-isomorphisms</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian categories</fr:link>, it is <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link> iff it sends <fr:link
type="local"
href="hmlg-000C.xml"
addr="hmlg-000C"
title="Quasi-isomorphism">quasi-isomorphisms</fr:link> to quasi-isomorphisms.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2625</fr:anchor><fr:addr
type="machine">#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.</fr:p>

  <fr:p>On the other hand, <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex
display="inline"><![CDATA[f : C_\bullet  \to  D_\bullet ]]></fr:tex> is a quasi-isomorphism, <fr:tex
display="inline"><![CDATA[H_n (f)]]></fr:tex> are all isomorphisms. Therefore <fr:tex
display="inline"><![CDATA[H_n (F(f)) = F(H_n(f))]]></fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3531</fr:anchor><fr:addr
type="user">hmlg-0016</fr:addr><fr:route>hmlg-0016.xml</fr:route><fr:title
text="Chain homotopy">Chain homotopy</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D_\bullet ]]></fr:tex> with two <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain maps</fr:link> <fr:tex
display="inline"><![CDATA[f, g : C \to  D]]></fr:tex> between them, a <fr:strong>chain homotopy</fr:strong> from <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is given by a family of maps <fr:tex
display="inline"><![CDATA[h_n : C_n \to  D_{n+1}]]></fr:tex>, such that
  <fr:tex
display="block"><![CDATA[d_{n+1} \mathbin {\circ } h_n + h_{n-1} \mathbin {\circ } d_n = f_n - g_n.]]></fr:tex>
  Note that the two <fr:tex
display="inline"><![CDATA[d]]></fr:tex>’s denote the boundary map of different chain complexes.</fr:p><fr:p>The chain homotopy can be written as <fr:tex
display="inline"><![CDATA[h : f \to  g]]></fr:tex> or as <fr:tex
display="inline"><![CDATA[h : C \to  D]]></fr:tex>. This causes no confusion, and the latter is convenient in situations where the maps <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> matter less than their difference <fr:tex
display="inline"><![CDATA[f - g]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3533</fr:anchor><fr:addr
type="user">hmlg-0017</fr:addr><fr:route>hmlg-0017.xml</fr:route><fr:title
text="Chain reduction">Chain reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C, D]]></fr:tex>, a <fr:strong>chain reduction</fr:strong> consists of a chain map <fr:tex
display="inline"><![CDATA[\pi  : C \to  D]]></fr:tex>, a chain map <fr:tex
display="inline"><![CDATA[\iota  : D \to  C]]></fr:tex> and a <fr:link
type="local"
href="hmlg-0016.xml"
addr="hmlg-0016"
title="Chain homotopy">chain homotopy</fr:link> <fr:tex
display="inline"><![CDATA[h : \textrm {id} \to  g \mathbin {\circ } f]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\pi  \mathbin {\circ } \iota  = \textrm {id}]]></fr:tex>, and <fr:tex
display="block"><![CDATA[\pi  \mathbin {\circ } h = h \mathbin {\circ } \iota  = h \mathbin {\circ } h = 0.]]></fr:tex> Here the compositions are understood to have the appropriate subscript so the degrees match.</fr:p><fr:p>We write the reduction as <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>. The three components are denoted <fr:tex
display="inline"><![CDATA[\pi _{\rho } : C \to  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\iota _{\rho } : D \to  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h_{\rho } : C \to  C]]></fr:tex>, respectively.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3535</fr:anchor><fr:addr
type="user">hmlg-0019</fr:addr><fr:route>hmlg-0019.xml</fr:route><fr:title
text="Chain reduction">Chain reduction</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is embedded as a subcomplex of <fr:tex
display="inline"><![CDATA[C]]></fr:tex>. It is cleanly separated, indicating that <fr:link
type="local"
href="hmlg-001H.xml"
addr="hmlg-001H"
title="Characterization of chain reduction">it is split</fr:link>. The other part of <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>, and so its homology component is drawn as empty, with the components separated.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="70dedd655193094be204fbef08bd4044"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  %tex
  \begin{scope}
    \clip (-1.9, -1.4) rectangle (5.9, 1.7);
    \tikzset{every path/.style={thick}}

    \draw (-3.6,0) -- (-0.4,0) arc (0:180:1.6);
    \draw (-1.6,0) -- (1.6,0) arc (0:180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4,0) -- (3.6,0) arc (0:180:1.6);
    \draw (2.4,0) -- (5.6,0) arc (0:180:1.6);
    \draw (4.4,0) -- (7.6,0) arc (0:180:1.6);

    % arccos(1/1.6) = 51.318deg
    \draw (-1.6, -0.1) -- (-0.4, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4, -0.1) -- (1.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (2.4, -0.1) -- (3.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \draw (4.4, -0.1) -- (5.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
  \end{scope}
  \node at (2, -1.6) {\(C_n\)};
  \node at (2, 1.1) {\(H_n\)};
  \draw[thick, decoration={brace, mirror}, decorate] (-2.1, 1.6) -- node[left] {\(C_\bullet\)} (-2.1, -1.35);
  \draw[thick, decoration={brace}, decorate] (6.1, 1.6) -- node[right] {\(D_\bullet\)} (6.1, 0);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3537</fr:anchor><fr:addr
type="user">hmlg-0013</fr:addr><fr:route>hmlg-0013.xml</fr:route><fr:title
text="Algebraic cellular complex">Algebraic cellular complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>algebraic cellular complex</fr:strong> (or ACC) is a <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complex</fr:link> of free abelian groups. The generators are called <fr:strong>cells</fr:strong>, and the boundary maps can be expressed using the generators as a basis, yielding the <fr:strong>incidence matrices</fr:strong>.</fr:p><fr:p>More precisely, we may define an ACC as a sequence of sets <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex>, with a sequence of functions <fr:tex
display="inline"><![CDATA[d : C_k \to  \mathbb {Z}[C_{k-1}]]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is satisfied. When a generator has non-zero coefficient in some <fr:tex
display="inline"><![CDATA[d\sigma ]]></fr:tex>, the generator is called a <fr:strong>face</fr:strong> of <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>.</fr:p><fr:p>Note that the generators of these chain groups are <fr:link
type="local"
href="ualg-0006.xml"
addr="ualg-0006"
title="Objects of the Kleisli category">canonically chosen</fr:link> as part of the data. So a more accurate definition is a chain complex in the <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> of abelian groups.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3539</fr:anchor><fr:addr
type="user">hmlg-0014</fr:addr><fr:route>hmlg-0014.xml</fr:route><fr:title
text="Filtered object">Filtered object</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can visualize a filtered object <fr:tex
display="inline"><![CDATA[F_1 A \subseteq  F_2 A \subseteq  F_3 A \subseteq  A]]></fr:tex> as nested rectangles. The graded components of this filtration are the individual rectangular regions.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="3c05fffcc0c2aff9060e6b53726e0007"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  \tikzset {every path/.style={thick, fill = blue!80!yellow, fill opacity = 0.1}}
  \filldraw  (0,-1) rectangle (4,1);
  \filldraw  (0,-1) rectangle (3,1);
  \filldraw  (0,-1) rectangle (2,1);
  \filldraw  (0,-1) rectangle (1,1);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3541</fr:anchor><fr:addr
type="user">hmlg-0015</fr:addr><fr:route>hmlg-0015.xml</fr:route><fr:title
text="Filtered chain complex">Filtered chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Combining <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization" /> and <fr:ref
addr="hmlg-0014"
href="hmlg-0014.xml"
taxon="Visualization" />, we arrive at the following picture. Each family of colors corresponds to the filtration <fr:tex
display="inline"><![CDATA[F_\bullet  C_n]]></fr:tex> in one dimension, and the different shades corresponds to the degree in the filtration.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="b55e54a19c8b33ac97aac70df87d7ce3"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  \tikzset {every path/.style={thick, fill opacity = 0.2, line join = round}}
  \foreach  \depth  in {4,3,2,1} {
    \fill [blue!80!yellow] (-4,4) -- (0,0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
    \fill [green!80!purple] (0,0) -- (4,4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
    \fill [yellow!80!red] (4,4) -- (8,0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
  }

  \foreach  \depth  in {4,3,2,1} {
    \draw  ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
    \draw  ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
    \draw  ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
  }
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>Note that we arranged so that only the higher degree (i.e. the lighter color) components may touch the lower degree components in the next dimension. So the intersection is a triangle shape instead of a complete diamond grid. This corresponds to the requirement that the boundary map sends <fr:tex
display="inline"><![CDATA[F_i C_j]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F_i C_{j+1}]]></fr:tex>.</fr:p><fr:p>We can see the associated spectral sequences directly from the visualization. We start with the graded components, which form strands of chain complexes. Here the second degree is highlighted.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="503f03422a46aab9e25b88aafcb49af9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \tikzset {every path/.style={thick, fill opacity = 0.4, line join = round}}
    \foreach  \depth  in {2} {
      \fill [blue!80!yellow] ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
      \fill [green!80!purple] ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
      \fill [yellow!80!red] ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
    }

    \foreach  \depth  in {4,3,2,1} {
      \draw  ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
      \draw  ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
      \draw  ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
    }
  \end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  The homology chops off the intersections, and so we enter the first page of the spectral sequence, consisting of strands with the top and bottom part cut off. Repeatedly taking homology, we are finally left with the rectangular part in the middle, which is the graded components of the desired homology group of the entire complex.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3543</fr:anchor><fr:addr
type="user">hmlg-0012</fr:addr><fr:route>hmlg-0012.xml</fr:route><fr:title
text="Long exact sequence of homologies">Long exact sequence of homologies</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a short exact sequence of chain complexes
  <fr:tex
display="block"><![CDATA[0 \to  A_\bullet  \to  B_\bullet  \to  C_\bullet  \to  0,]]></fr:tex>
  there is a long exact sequence of homology groups
  <fr:tex
display="block"><![CDATA[\cdots  \to  H_{n+1}(C) \xrightarrow {\partial } H_n(A) \to  H_n (B) \to  H_n (C) \xrightarrow {\partial } H_{n-1} (A) \to  \cdots ]]></fr:tex>
  The map <fr:tex
display="inline"><![CDATA[\partial ]]></fr:tex> here is, after unpacking some quotients, simply the boundary map <fr:tex
display="inline"><![CDATA[B_n \to  B_{n-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3545</fr:anchor><fr:addr
type="user">hmlg-0010</fr:addr><fr:route>hmlg-0010.xml</fr:route><fr:title
text="Snake lemma">Snake lemma</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, given the middle two rows of the diagram
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8ab3a474de427cef2dbcc4a25ff72149"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    & {\ker  f} & {\ker  g} & {\ker  h} \\
    {\ker  i} & \bullet  & \bullet  & \bullet  & 0 \\
    0 & \bullet  & \bullet  & \bullet  & {\operatorname {coker} j} \\
    & {\operatorname {coker} f} & {\operatorname {coker} g} & {\operatorname {coker} h}
    \arrow ["f", from=2-2, to=3-2]
    \arrow ["g", from=2-3, to=3-3]
    \arrow ["h", from=2-4, to=3-4]
    \arrow [from=1-2, to=2-2]
    \arrow [from=1-3, to=2-3]
    \arrow [from=1-4, to=2-4]
    \arrow [blue, >->, out=90, in=180, from=2-1, to=1-2]
    \arrow [from=2-1, to=2-2]
    \arrow ["i", from=2-2, to=2-3]
    \arrow [from=2-3, to=2-4]
    \arrow [from=3-2, to=3-3]
    \arrow ["j", from=3-3, to=3-4]
    \arrow [from=3-4, to=3-5]
    \arrow [blue, ->>, out=0, in=-90, from=4-4, to=3-5]
    \arrow [from=3-2, to=4-2]
    \arrow [from=3-3, to=4-3]
    \arrow [from=3-4, to=4-4]
    \arrow [blue, from=1-2, to=1-3]
    \arrow [blue, from=1-3, to=1-4]
    \arrow [blue, from=4-2, to=4-3]
    \arrow [blue, from=4-3, to=4-4]
    \arrow [blue, dashed, out=0, in=180, from=1-4, to=4-2]
    \arrow [from=2-4, to=2-5]
    \arrow [from=3-1, to=3-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <fr:tex
display="inline"><![CDATA[0 \to  \ker  i \to  \ker  f \to  \ker  g \to  \ker  h \xrightarrow {\partial } \operatorname {coker} f \to  \operatorname {coker} g \to  \operatorname {coker} h \to  \operatorname {coker} j \to  0]]></fr:tex>. In particular, if <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is monic and <fr:tex
display="inline"><![CDATA[j]]></fr:tex> is epic, this leads to a six-term exact sequence.</fr:p><fr:p>There are multiple ways to prove this claim. We can first <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">prove it in categories of modules</fr:link>, and <fr:link
type="local"
href="hmlg-0011.xml"
addr="hmlg-0011"
title="Using the Freyd–Mitchell embedding to prove theorems">use the Freyd–Mitchell embedding</fr:link>. We can also use <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">pseudo-elements</fr:link> to <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">perform diagram chases</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3547</fr:anchor><fr:addr
type="user">hmlg-0011</fr:addr><fr:route>hmlg-0011.xml</fr:route><fr:title
text="Using the Freyd–Mitchell embedding to prove theorems">Using the <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">Freyd–Mitchell embedding</fr:link> to prove theorems</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We use the <fr:link
type="local"
href="hmlg-0010.xml"
addr="hmlg-0010"
title="Snake lemma">snake lemma</fr:link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.</fr:p><fr:p>Suppose we have already <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">proved</fr:link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, which we can embed in a module category <fr:tex
display="inline"><![CDATA[R\text {-}\mathsf {Mod}]]></fr:tex>.</fr:p><fr:p>Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> is a full abelian subcategory of <fr:tex
display="inline"><![CDATA[R\text {-}\mathsf {Mod}]]></fr:tex>, these morphisms are contained in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, and the sequence is still exact. And since <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> is a full abelian subcategory of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the sequence is again exact in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3549</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3551</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1024</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1026</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1028</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1030</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1032</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1034</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>877</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1036</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1038</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1040</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1042</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1044</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1046</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1049</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3553</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1042</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3555</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3557</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3559</fr:anchor><fr:addr
type="user">hmlg-000Z</fr:addr><fr:route>hmlg-000Z.xml</fr:route><fr:title
text="Monomorphisms can be expressed using finite limits">Monomorphisms can be expressed using finite limits</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> in an arbitrary category, we can express the condition of being monic using finite limits.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2746</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> being monic is equivalent to the following square being a pullback square:
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b498bc7c8e96729df8b9019499c15b06"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      X & X \\
      X & Y
      \arrow ["f"', from=2-1, to=2-2]
      \arrow ["f", from=1-2, to=2-2]
      \arrow ["\textrm {id}"', from=1-1, to=2-1]
      \arrow ["\textrm {id}", from=1-1, to=1-2]
      \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span></fr:p>

  <fr:p>For the forward implication, we consider the diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="e425743d109ca2729ae73915d30e7362"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      Z \\
      & X & X \\
      & X & Y
      \arrow ["f"', from=3-2, to=3-3]
      \arrow ["f", from=2-3, to=3-3]
      \arrow ["\textrm {id}"', from=2-2, to=3-2]
      \arrow ["\textrm {id}", from=2-2, to=2-3]
      \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
      \arrow [dashed, from=1-1, to=2-2]
      \arrow ["g"', curve={height=6pt}, from=1-1, to=3-2]
      \arrow ["h", curve={height=-6pt}, from=1-1, to=2-3]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is mono, this diagram commutes iff <fr:tex
display="inline"><![CDATA[g = h]]></fr:tex>, in which case there is a unique way to fill in the dashed arrow, which is <fr:tex
display="inline"><![CDATA[g]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, if the diagram is a pullback, then for every pair of morphisms <fr:tex
display="inline"><![CDATA[g, h : Z \rightrightarrows  X]]></fr:tex>, we can draw the diagram above, and obtain the dashed arrow <fr:tex
display="inline"><![CDATA[k : Z \to  X]]></fr:tex>. The diagram commuting implies <fr:tex
display="inline"><![CDATA[g = \textrm {id} \mathbin {\circ } k = h]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3561</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3563</fr:anchor><fr:addr
type="user">hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title
text="Freyd–Mitchell embedding theorem">Freyd–Mitchell embedding theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules for some ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1765</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>(TODO)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3565</fr:anchor><fr:addr
type="user">hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1011</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1013</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1015</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1017</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1019</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1022</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1024</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1026</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1028</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1030</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1032</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1034</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>877</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1036</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1038</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1040</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1042</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1044</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1046</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1049</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1051</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>973</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>974</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>975</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>977</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>979</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>981</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3567</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3569</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1028</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3571</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>877</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3573</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1038</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3575</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1032</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3577</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3579</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3581</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3583</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1013</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1015</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1017</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1019</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3585</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3587</fr:anchor><fr:addr
type="user">hmlg-000N</fr:addr><fr:route>hmlg-000N.xml</fr:route><fr:title
text="Signs in bicomplexes">Signs in bicomplexes</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Some sources require a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> to have anti-commuting squares. In this way, the <fr:link
type="local"
href="hmlg-000M.xml"
addr="hmlg-000M"
title="Total complex">total complex</fr:link> has the simpler differential <fr:tex
display="inline"><![CDATA[\partial  = d + \delta ]]></fr:tex>. These two definitions are convertible by flipping the signs of the horizontal boundary maps in every other row.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3589</fr:anchor><fr:addr
type="user">hmlg-000M</fr:addr><fr:route>hmlg-000M.xml</fr:route><fr:title
text="Total complex">Total complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> <fr:tex
display="inline"><![CDATA[C_{\bullet , \bullet }]]></fr:tex>, we can collapse it into a chain complex in two ways. In either way, <fr:tex
display="inline"><![CDATA[C_{p, q}]]></fr:tex> is contained in the total complex at degree <fr:tex
display="inline"><![CDATA[(m+n)]]></fr:tex>. We can use the direct sum to combine them: <fr:tex
display="block"><![CDATA[\operatorname {Tot}^\oplus (C)_n = \bigoplus _{n = p+q} C_{p, q},]]></fr:tex> or the direct product: <fr:tex
display="block"><![CDATA[\operatorname {Tot}^\Pi (C)_n = \prod _{n=p+q} C_{p,q}.]]></fr:tex></fr:p><fr:p>The total differential acts on elements in <fr:tex
display="inline"><![CDATA[C_{p, q}]]></fr:tex> by <fr:tex
display="block"><![CDATA[\partial (x) = d(x) + (-1)^q \delta (x),]]></fr:tex> where <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is the vertical map, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> the horizontal map. The <fr:link
type="local"
href="hmlg-000N.xml"
addr="hmlg-000N"
title="Signs in bicomplexes">sign</fr:link> here is to ensure that <fr:tex
display="inline"><![CDATA[\partial ^2 = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3591</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3593</fr:anchor><fr:addr
type="user">hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title
text="Chain complexes">Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> freely generated by cells of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The critical feature of the operator is <fr:tex
display="block"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0,]]></fr:tex> simply written as <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2845</fr:anchor><fr:addr
type="user">hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title
text="Chain complex of abelian groups">Chain complex of abelian groups</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex
display="inline"><![CDATA[G_\bullet ]]></fr:tex> together with homomorphisms <fr:tex
display="inline"><![CDATA[d_n : G_n \to  G_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2846</fr:anchor><fr:addr
type="user">hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title
text="Chain complex of R-modules">Chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors /><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is given by a sequence of modules <fr:tex
display="inline"><![CDATA[M_\bullet ]]></fr:tex> together with <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-linear maps <fr:tex
display="inline"><![CDATA[d_n : R_n \to  R_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2847</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2849</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2851</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2853</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2855</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2857</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2859</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2861</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2863</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3595</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3597</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3599</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2855</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3601</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3603</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3605</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3607</fr:anchor><fr:addr
type="user">hmlg-0001</fr:addr><fr:route>hmlg-0001.xml</fr:route><fr:title
text="Homological Algebra">Homological Algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes primarily based on <fr:link
type="local"
href="homological-algebra.xml"
addr="homological-algebra"
title="An Introduction to Homological Algebra">Weibel</fr:link> and <fr:link
type="local"
href="wwli.xml"
addr="wwli"
title="Wen-Wei Li">Wen-Wei Li</fr:link>’s <fr:link
type="local"
href="methods-of-algebra-2.xml"
addr="methods-of-algebra-2"
title="代数学方法 卷二: 线性代数">unpublished book</fr:link>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2842</fr:anchor><fr:addr
type="user">hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title
text="Chain complexes">Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> freely generated by cells of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The critical feature of the operator is <fr:tex
display="block"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0,]]></fr:tex> simply written as <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2845</fr:anchor><fr:addr
type="user">hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title
text="Chain complex of abelian groups">Chain complex of abelian groups</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex
display="inline"><![CDATA[G_\bullet ]]></fr:tex> together with homomorphisms <fr:tex
display="inline"><![CDATA[d_n : G_n \to  G_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2846</fr:anchor><fr:addr
type="user">hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title
text="Chain complex of R-modules">Chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors /><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is given by a sequence of modules <fr:tex
display="inline"><![CDATA[M_\bullet ]]></fr:tex> together with <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-linear maps <fr:tex
display="inline"><![CDATA[d_n : R_n \to  R_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2847</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2849</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2851</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2853</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2855</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2857</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2859</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2861</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2863</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2865</fr:anchor><fr:addr
type="user">hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1011</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1013</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1015</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1017</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1019</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1022</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1024</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1026</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1028</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1030</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1032</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1034</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>877</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1036</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1038</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1040</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1042</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1044</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1046</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1049</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1051</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>973</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>974</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>975</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>977</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>979</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>981</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="true"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3609</fr:anchor><fr:addr
type="user">trebor-0001</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Trebor’s forest">Trebor’s forest</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is my forest. Forests are <fr:link
type="external"
href="https://www.jonmsterling.com/jms-005P.xml">a way of organizing notes</fr:link>, and here is <fr:link
type="external"
href="https://www.jonmsterling.com/jms-009H.xml">a list of other websites organized as forests</fr:link>. Some of the contents here:</fr:p><fr:ul><fr:li><fr:link
type="local"
href="hmlg-0001.xml"
addr="hmlg-0001"
title="Homological Algebra">Notes on homological algebra</fr:link></fr:li>
  <fr:li><fr:link
type="local"
href="hmlg-001K.xml"
addr="hmlg-001K"
title="Effective homology">Effective homology</fr:link></fr:li>
  <fr:li>Algebraic geometry (Under namespace <fr:code>algm</fr:code>, not organized)</fr:li>
  <fr:li><fr:link
type="local"
href="ualg-000H.xml"
addr="ualg-000H"
title="Beck monadicity theorem">Beck monadicity theorem</fr:link></fr:li></fr:ul><fr:p>On a computer, you can press Ctrl–K to search for trees. You can also visit my <fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">contributor page</fr:link> to see a list of my trees.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1381</fr:anchor><fr:addr
type="user">trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title
text="Style of writing">Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I try to adhere to several principles when composing trees.</fr:p><fr:ul><fr:li>If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.</fr:li>
  <fr:li>Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.</fr:li>
  <fr:li>Apply <fr:link
type="external"
href="https://ncatlab.org/nlab/show/biased+definition">unbiased terminology</fr:link> and <fr:link
type="external"
href="https://ncatlab.org/nlab/show/negative+thinking">negative thinking</fr:link>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>