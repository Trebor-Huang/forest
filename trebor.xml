<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2528</fr:anchor><fr:addr
type="user">trebor</fr:addr><fr:route>trebor.xml</fr:route><fr:title
text="Trebor">Trebor</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="institution">Tsinghua University</fr:meta><fr:meta
name="position">Bachelor Student</fr:meta><fr:meta
name="external">https://github.com/Trebor-Huang</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>My name is 黄栩 (<fr:em>Huang Xu</fr:em>), but I go by the name <fr:em>Trebor</fr:em> online. I’m interested in (homotopy) type theory, category theory and jazz.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Contributions">Contributions</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2529</fr:anchor><fr:addr
type="user">hmlg-002X</fr:addr><fr:route>hmlg-002X.xml</fr:route><fr:title
text="Commutativity of H {Z}-modules">Commutativity of <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Connective spectra can be thought of as <fr:tex
display="inline"><![CDATA[\infty ]]></fr:tex>-groups that are maximally commutative, within the confines of operadic algebras. This manifests as the little cubes operad, being able to freely move around in high dimensional space.</fr:p><fr:p>However, <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules can be seen as even more commutative. Consider the equation <fr:tex
display="inline"><![CDATA[x + x = x + x]]></fr:tex> swapping the two arguments. It is impossible to talk about the behavior of this path because in operads variables cannot repeat. Hence this might not be homotopic to the trivial path, and indeed it is not in the sphere spectrum <fr:tex
display="inline"><![CDATA[\mathbb {S}]]></fr:tex> — this path is given by the non-trivial element in the second stable homotopy group <fr:tex
display="inline"><![CDATA[\mathbb  Z / 2 \mathbb  Z]]></fr:tex>. <fr:tex
display="inline"><![CDATA[H \mathbb {Z}]]></fr:tex>-modules requires further that given <fr:tex
display="inline"><![CDATA[n]]></fr:tex> identical elements, the space of different possible sums is contractible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2531</fr:anchor><fr:addr
type="user">hmlg-002W</fr:addr><fr:route>hmlg-002W.xml</fr:route><fr:title
text="Additive functor is faithful iff it reflects exactness">Additive functor is faithful iff it reflects exactness</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> is faithful iff it reflects exactness.</fr:p><fr:p>This implies that faithful additive functors reflects kernels, cokernels, etc. Note that faithful functors need not preserve kernels or cokernels. This is because we can take the direct sum of a faithful functor with an arbitrary additive functor and the result is still faithful. The second summand can behave badly.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>295</fr:anchor><fr:addr
type="machine">#239</fr:addr><fr:route>unstable-239.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first prove the forward implication. Given a sequence
    <fr:tex
display="block"><![CDATA[X \xrightarrow {f} Y \xrightarrow {g} Z]]></fr:tex>
    whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact, by faithfulness <fr:tex
display="inline"><![CDATA[F(g \mathbin {\circ } f) = 0]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f = 0]]></fr:tex>. Now we wish to prove the composite <fr:tex
display="inline"><![CDATA[\ker  g \to  Y \to  \operatorname {coker} f]]></fr:tex> is zero. We can decompose its image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> as
    <fr:tex
display="block"><![CDATA[F(\ker  g) \to  \ker  Fg \to  FY \to  \operatorname {coker} Ff \to  F(\operatorname {coker} f).]]></fr:tex>
    But the inner two morphisms compose to zero, so by faithfulness we get our result.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[F]]></fr:tex> reflects exactness. Given a morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex>, suppose <fr:tex
display="inline"><![CDATA[Ff = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[FX \xrightarrow {\textrm {id}} FX \xrightarrow {Ff} FY]]></fr:tex> is exact. Hence <fr:tex
display="inline"><![CDATA[X \xrightarrow {\textrm {id}} X \xrightarrow {f} Y]]></fr:tex> is also exact, so <fr:tex
display="inline"><![CDATA[f = 0]]></fr:tex> too.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2533</fr:anchor><fr:addr
type="user">hmlg-002V</fr:addr><fr:route>hmlg-002V.xml</fr:route><fr:title
text="Homology is a universal -functor">Homology is a universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Homology <fr:tex
display="inline"><![CDATA[H_\bullet ]]></fr:tex> as a functor from the category of chain complexes (bounded from below) of <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> is a homological <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>. Dually, cohomology is a cohomological <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>307</fr:anchor><fr:addr
type="machine">#240</fr:addr><fr:route>unstable-240.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002V</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Every chain complex injects into its cone, whose cohomology is zero. So cohomology is <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceable</fr:link>. Dually every chain complex is a quotient of its cocone, hence homology is coeffaceable. Therefore by <fr:ref
addr="hmlg-002T"
href="hmlg-002T.xml"
taxon="Theorem" /> we finish the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2535</fr:anchor><fr:addr
type="user">hmlg-002T</fr:addr><fr:route>hmlg-002T.xml</fr:route><fr:title
text="Criterion for universality of -functors">Criterion for universality of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a cohomological <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[T^\bullet ]]></fr:tex>, if each <fr:tex
display="inline"><![CDATA[T^n]]></fr:tex> for <fr:tex
display="inline"><![CDATA[n > 0]]></fr:tex> is <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceable</fr:link>, then it is a <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link>. Dually, if a homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor is coeffaceable, then it is universal.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>313</fr:anchor><fr:addr
type="machine">#241</fr:addr><fr:route>unstable-241.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002T</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, consider the exact sequence given by <fr:link
type="local"
href="hmlg-002S.xml"
addr="hmlg-002S"
title="Effaceable functor">effaceability</fr:link>
    <fr:tex
display="block"><![CDATA[0 \longrightarrow  X \longrightarrow  I \longrightarrow  Y \longrightarrow  0.]]></fr:tex>
    Then we have a long exact sequence
    <fr:tex
display="block"><![CDATA[0 \to  T^0 X \to  T^0 I \to  T^0 Y \xrightarrow {\delta } T^1 X \xrightarrow {0} T^1 I.]]></fr:tex>
    and the rest breaks into infinitely many short exact sequences
    <fr:tex
display="block"><![CDATA[0 \to  T^{n+1} I \to  T^{n+1} Y \to  T^{n+2} X \to  0.]]></fr:tex></fr:p>

  <fr:p>Consider another <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[S^\bullet ]]></fr:tex> with a natural transformation <fr:tex
display="inline"><![CDATA[f : T^0 \to  S^0]]></fr:tex>. We now have a diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="2e2344ae59b281a1ee0aa10523116655"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      {T^0 I} & {T^0 Y} & {T^1 X} \\
      {S^0 I} & {S^0 Y} & {S^1 X}
      \arrow [from=1-1, to=1-2]
      \arrow [from=1-1, to=2-1]
      \arrow ["\delta ", two heads, from=1-2, to=1-3]
      \arrow [from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
      \arrow ["\delta "', from=2-2, to=2-3]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    where we can fill the vertical map on the right, because the composite of the lower left route is zero on the kernel of <fr:tex
display="inline"><![CDATA[\delta  : T^0 Y \to  T^1 X]]></fr:tex>, and uniqueness follows from epimorphism. This then yields a transformation <fr:tex
display="inline"><![CDATA[T^1 \to  S^1]]></fr:tex>, we need to prove it's natural and does not depend on the chosen <fr:tex
display="inline"><![CDATA[I]]></fr:tex>. Then we can repeat the move to extend to arbitrary degrees.</fr:p>

  <fr:p>Given a morphism <fr:tex
display="inline"><![CDATA[\varphi  : X \to  X']]></fr:tex> and the corresponding monomorphisms <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X' \to  I']]></fr:tex>, we can replace <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex> with <fr:tex
display="inline"><![CDATA[X \to  I \times  I']]></fr:tex> since both components of the map are sent to <fr:tex
display="inline"><![CDATA[0]]></fr:tex> by <fr:tex
display="inline"><![CDATA[T^0]]></fr:tex>, an additive functor. This together with the projection map <fr:tex
display="inline"><![CDATA[I \times  I' \to  I]]></fr:tex> forms a commutative square. Taking the cokernel we also have an induced map <fr:tex
display="inline"><![CDATA[\psi  : Y \to  Y']]></fr:tex>.


    This leads to a 3-dimensional diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="50b1237f178df03f2363f27efc3c1cc7"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      {T^0 Y} && {T^1 X} \\
      & {T^0 Y'} && {T^1 X'} \\
      {S^0 Y} && {S^1 X} \\
      & {S^0 Y'} && {S^1 X'}
      \arrow ["\delta ", two heads, from=1-1, to=1-3]
      \arrow ["{T^0 \psi }"', from=1-1, to=2-2]
      \arrow ["f"', from=1-1, to=3-1]
      \arrow ["{T^1 \varphi }", from=1-3, to=2-4]
      \arrow [from=1-3, to=3-3]
      \arrow ["\delta "{pos=0.3}, two heads, from=2-2, to=2-4]
      \arrow ["f"'{pos=0.3}, from=2-2, to=4-2]
      \arrow [from=2-4, to=4-4]
      \arrow [from=3-1, to=3-3]
      \arrow ["{S^0 \psi }"', from=3-1, to=4-2]
      \arrow ["{S^1 \varphi }", from=3-3, to=4-4]
      \arrow ["\delta "', from=4-2, to=4-4]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    where all but the right face commutes. After composing with <fr:tex
display="inline"><![CDATA[\delta  : T^0 Y \to  T^1 X]]></fr:tex>, we can use all five commutative squares to prove that the two compositions are equal. And since the morphism is epimorphic, the right square commutes as expected.</fr:p>

  <fr:p>For independence, we first prove that if two effacements <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X \to  I']]></fr:tex> are connected by a morphism <fr:tex
display="inline"><![CDATA[I \to  I']]></fr:tex>, then the resulting transformations are equal. This is essentially the same as the proof of naturality, except <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is replaced with <fr:tex
display="inline"><![CDATA[\textrm {id}]]></fr:tex>. Now any two effacements are connected by a zigzag, since we can take the diagonal <fr:tex
display="inline"><![CDATA[X \to  I \times  I']]></fr:tex> and project out.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2537</fr:anchor><fr:addr
type="user">hmlg-002S</fr:addr><fr:route>hmlg-002S.xml</fr:route><fr:title
text="Effaceable functor">Effaceable functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> is <fr:strong>effaceable</fr:strong> iff for each object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex>, there exists a monomorphism <fr:tex
display="inline"><![CDATA[X \to  I]]></fr:tex> whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is zero. Dually, it is <fr:strong>coeffaceable</fr:strong> iff for each object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> there exists an epimorphism <fr:tex
display="inline"><![CDATA[P \to  X]]></fr:tex> whose image under <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is zero.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2539</fr:anchor><fr:addr
type="user">hmlg-002U</fr:addr><fr:route>hmlg-002U.xml</fr:route><fr:title
text="Enough injectives">Enough injectives</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> has enough <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injectives</fr:link> if every object has a monomorphism into an injective. Dually, it has enough <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projectives</fr:link> if every object is a quotient of a projective.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2541</fr:anchor><fr:addr
type="user">hmlg-002R</fr:addr><fr:route>hmlg-002R.xml</fr:route><fr:title
text="James construction">James construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pointed space <fr:tex
display="inline"><![CDATA[(X, x_0)]]></fr:tex>, the <fr:strong>James construction</fr:strong> <fr:tex
display="inline"><![CDATA[J X]]></fr:tex> is the homotopy coherent version of a free monoid (a.k.a. the type of lists or strings), such that the point acts as the neutral element. The space is constructed inductively from a point <fr:tex
display="inline"><![CDATA[[] \in  JX]]></fr:tex>. For each point <fr:tex
display="inline"><![CDATA[y \in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex>, we have another point <fr:tex
display="inline"><![CDATA[y \mathbin {::} \vec {x} \in  JX]]></fr:tex>. And finally for <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex> we adjoin a path from <fr:tex
display="inline"><![CDATA[x_0 \mathbin {::} \vec {x}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex>.</fr:p><fr:p>There is a map <fr:tex
display="inline"><![CDATA[X \to  JX]]></fr:tex> given by <fr:tex
display="inline"><![CDATA[x \mapsto  x \mathbin {::} []]]></fr:tex>, written as <fr:tex
display="inline"><![CDATA[[x]]]></fr:tex> for short.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2543</fr:anchor><fr:addr
type="user">hmlg-002Q</fr:addr><fr:route>hmlg-002Q.xml</fr:route><fr:title
text="Synthetic characterization of the James construction">Synthetic characterization of the James construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002R.xml"
addr="hmlg-002R"
title="James construction">James construction</fr:link> <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> of a connected pointed space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equivalent to the space <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex>, which is very intriguing considering that <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex> actually has a group structure up to homotopy. Its synthetic proof is enlightening.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>354</fr:anchor><fr:addr
type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002Q</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is connected, for each <fr:tex
display="inline"><![CDATA[x]]></fr:tex> there exists a path back to the point <fr:tex
display="inline"><![CDATA[x_0]]></fr:tex>. <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -) = \textrm {id}]]></fr:tex> is an auto-equivalence on <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>, so noting that being an equivalence is a proposition, <fr:tex
display="inline"><![CDATA[(x \mathbin {::} -)]]></fr:tex> is too, for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:p>

  <fr:p>Now consider a family of spaces indexed by <fr:tex
display="inline"><![CDATA[\Sigma  X]]></fr:tex>. For the north and south pole we assign the space <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>, and for each path between the poles induced by an element <fr:tex
display="inline"><![CDATA[x \in  X]]></fr:tex>, we assign the equivalence <fr:tex
display="inline"><![CDATA[(x \mathbin {::} -)]]></fr:tex>, which by univalence induces a path.
    The total space of this kind of families is characterized by the flattening lemma, in Section 6.12 of the <fr:link
type="local"
href="hott-book.xml"
addr="hott-book"
title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT book</fr:link>. In this case, we have two copies of <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> such that for each <fr:tex
display="inline"><![CDATA[x \in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\vec {x} \in  JX]]></fr:tex> we connect <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex> in the former copy to <fr:tex
display="inline"><![CDATA[x \mathbin {::} \vec {x}]]></fr:tex> in the latter with a path.</fr:p>

  <fr:p>The total space is in fact contractible. Take the center to be <fr:tex
display="inline"><![CDATA[[]]]></fr:tex> in the north copy of <fr:tex
display="inline"><![CDATA[JX]]></fr:tex>. For any other point <fr:tex
display="inline"><![CDATA[\vec {x}]]></fr:tex> in the north copy, we can move to the south copy via the neutral element <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -)]]></fr:tex>, go along the path <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -) = \textrm {id}]]></fr:tex> in the south copy, and go back to the north copy removing the first entry. This allows us to recursively reach the empty list. For an element in the south copy, we can similarly move through <fr:tex
display="inline"><![CDATA[(x_0 \mathbin {::} -)]]></fr:tex> to the north copy and continue there.</fr:p>

  <fr:p>We still need to arrange for the contraction of the paths. This can be easily seen by drawing a diagram of all the boundaries, though tedious to completely write down. This then establishes that we have a fiber sequence <fr:tex
display="inline"><![CDATA[JX \to  1 \to  \Sigma  X]]></fr:tex>, where the middle term is the total space constructed above, and <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> is the fiber on top of the north pole of <fr:tex
display="inline"><![CDATA[\Sigma  X]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[JX]]></fr:tex> must be equivalent to the loop space <fr:tex
display="inline"><![CDATA[\Omega  \Sigma  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2545</fr:anchor><fr:addr
type="user">hmlg-002P</fr:addr><fr:route>hmlg-002P.xml</fr:route><fr:title
text="Right adjoint of exact functor preserves injectives">Right adjoint of exact functor preserves injectives</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[F \dashv  R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact and <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is an <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link>, then <fr:tex
display="inline"><![CDATA[R(I)]]></fr:tex> is also an injective. Dually, if <fr:tex
display="inline"><![CDATA[L \dashv  F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is exact and <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective</fr:link>, then <fr:tex
display="inline"><![CDATA[L(P)]]></fr:tex> is also a projective.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>374</fr:anchor><fr:addr
type="machine">#242</fr:addr><fr:route>unstable-242.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that the right adjoint preserves products, and so is <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive</fr:link>. We need to show that <fr:tex
display="inline"><![CDATA[\hom (-, R(I))]]></fr:tex> is <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, which amounts to saying the composition of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is exact, which is true because both are exact.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2547</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr
type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2549</fr:anchor><fr:addr
type="user">hmlg-002K</fr:addr><fr:route>hmlg-002K.xml</fr:route><fr:title
text="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:strong> is a sequence of <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functors</fr:link> <fr:tex
display="inline"><![CDATA[T_n : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian categories</fr:link>, with the convention that <fr:tex
display="inline"><![CDATA[T_n = 0]]></fr:tex> for <fr:tex
display="inline"><![CDATA[n < 0]]></fr:tex>. For every <fr:link
type="local"
href="hmlg-000H.xml"
addr="hmlg-000H"
title="Short exact sequence">short exact sequence</fr:link> <fr:tex
display="inline"><![CDATA[0 \to  X \to  Y \to  Z \to  0]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex>, we have a connecting map <fr:tex
display="inline"><![CDATA[\delta _n : T_n(Z) \to  T_{n-1}(X)]]></fr:tex>, such that this assignment is natural in the exact sequence.</fr:p><fr:p>Similarly, a <fr:strong>cohomological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:strong> can be defined with <fr:tex
display="inline"><![CDATA[\delta ^n : T^n(Z) \to  T^{n+1}(X)]]></fr:tex>. Notice that cohomology does not imply contravariance here. These also have contravariant versions, by replacing <fr:tex
display="inline"><![CDATA[\mathcal {A}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathcal {A}^\textrm {op}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2551</fr:anchor><fr:addr
type="user">hmlg-002M</fr:addr><fr:route>hmlg-002M.xml</fr:route><fr:title
text="Displayed category of -functors">Displayed category of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link> between two <fr:link
type="local"
href="hmlg-000G.xml"
addr="hmlg-000G"
title="Abelian categories">abelian categories</fr:link> form a displayed category over the category of <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functors</fr:link> (or we can restrict it to <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">right exact functors</fr:link> for homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors). Under this setup, the definition of a <fr:link
type="local"
href="hmlg-002N.xml"
addr="hmlg-002N"
title="Universal -functor">universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> can be expressed abstractly as a “relative” kind of terminal object or initial object. It is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> displayed over <fr:tex
display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\hom _f (Y, X) = 1]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2553</fr:anchor><fr:addr
type="user">hmlg-002L</fr:addr><fr:route>hmlg-002L.xml</fr:route><fr:title
text="Morphism of -functors">Morphism of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor"><fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link>, a morphism between them is given by a sequence of natural transformations <fr:tex
display="inline"><![CDATA[f_n : T_n \to  S_n]]></fr:tex> that additionally commutes with <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2555</fr:anchor><fr:addr
type="user">hmlg-002N</fr:addr><fr:route>hmlg-002N.xml</fr:route><fr:title
text="Universal -functor">Universal <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-002K.xml"
addr="hmlg-002K"
title="-Functor">homological <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor</fr:link> <fr:tex
display="inline"><![CDATA[T_n]]></fr:tex>, it is <fr:strong>universal</fr:strong> if given any other <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor <fr:tex
display="inline"><![CDATA[S_n]]></fr:tex> and a natural transformation <fr:tex
display="inline"><![CDATA[S_0 \to  T_0]]></fr:tex> at degree 0, it can be uniquely extended to a <fr:link
type="local"
href="hmlg-002L.xml"
addr="hmlg-002L"
title="Morphism of -functors">morphism of <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functors</fr:link>. Dually, we can reverse the arrows to get the definition of a universal <fr:em>cohomological</fr:em> <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex>-functor.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2557</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2559</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2561</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>398</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr
type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2563</fr:anchor><fr:addr
type="user">algm-001X</fr:addr><fr:route>algm-001X.xml</fr:route><fr:title
text="Ring grading as {G}_{m}-action">Ring grading as <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex>-action</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex>-<fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">grading</fr:link> on <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is the same as a <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex>-action on <fr:tex
display="inline"><![CDATA[\operatorname {Spec} R]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex> is <fr:link
type="local"
href="algm-001V.xml"
addr="algm-001V"
title="The scheme of invertible elements">the scheme of invertible elements</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>531</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001X</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>A morphism <fr:tex
display="inline"><![CDATA[\rho  : \mathbf {G}_{m} \times  \operatorname {Spec} R \to  \operatorname {Spec} R]]></fr:tex> is given by a ring homomorphism <fr:tex
display="inline"><![CDATA[R \to  \mathbb {Z}[x, x^{-1}] \otimes  R \cong  R[x, x^{-1}]]]></fr:tex>. Composing with the identity <fr:tex
display="inline"><![CDATA[1 \to  \mathbf {G}_{m}]]></fr:tex>, we are required that
    <fr:tex
display="block"><![CDATA[R \xrightarrow {\rho } R[x, x^{-1}] \xrightarrow {x \mapsto  1} R]]></fr:tex>
    is the identity.</fr:p>

  <fr:p>We can regard <fr:tex
display="inline"><![CDATA[R[x, x^{-1}]]]></fr:tex> as generated by <fr:tex
display="inline"><![CDATA[(n, r) \in  \mathbb {Z} \times  R]]></fr:tex>, where the first number is the degree of <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and the second number is the coefficient. So they are under the relations <fr:tex
display="inline"><![CDATA[(n, r) + (n, r') = (n, r + r')]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[(n, r) \cdot  (m, r') = (n + m, r r')]]></fr:tex>. <fr:tex
display="inline"><![CDATA[\rho (r)]]></fr:tex> is a sum of finitely many <fr:tex
display="inline"><![CDATA[(n, r_n)]]></fr:tex>, and the identity law requires the sum of <fr:tex
display="inline"><![CDATA[r_n]]></fr:tex> is <fr:tex
display="inline"><![CDATA[r]]></fr:tex> again. This decomposes <fr:tex
display="inline"><![CDATA[r]]></fr:tex> into its components in each degree.</fr:p>

  <fr:p>Next, the associativity law essentially requires that, if <fr:tex
display="inline"><![CDATA[(n, r_n)]]></fr:tex> is a summand of some <fr:tex
display="inline"><![CDATA[\rho (r)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\rho (r_n) = (n, r_n)]]></fr:tex>. So this is indeed a well-defined decomposition. Furthermore, <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> being a ring homomorphism guarantees that the grading respects multiplication and addition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2565</fr:anchor><fr:addr
type="user">algm-001V</fr:addr><fr:route>algm-001V.xml</fr:route><fr:title
text="The scheme of invertible elements">The scheme of invertible elements</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define the scheme <fr:tex
display="inline"><![CDATA[\mathbf {G}_{m}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\operatorname {Spec} \mathbb {Z}[x, x^{-1}]]]></fr:tex>. It can be characterized by the points <fr:tex
display="inline"><![CDATA[\hom (\mathbf {G}_{m}, \operatorname {Spec} R) = R^\times ]]></fr:tex> being the units of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. This scheme has a group structure. Since it is <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link>, <fr:tex
display="inline"><![CDATA[1 \to  \mathbf {G}_{m}]]></fr:tex> is <fr:link
type="local"
href="algm-000X.xml"
addr="algm-000X"
title="Morphisms of affine schemes">given</fr:link> by the ring homomorphism <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \to  \mathbb  Z]]></fr:tex> sending <fr:tex
display="inline"><![CDATA[x]]></fr:tex> to <fr:tex
display="inline"><![CDATA[1]]></fr:tex>. The product map is given by a ring homomorphism <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \otimes  \mathbb {Z}[y, y^{-1}] \to  \mathbb {Z}[z, z^{-1}]]]></fr:tex> (where we renamed the variables for clarity) sending <fr:tex
display="inline"><![CDATA[x \otimes  y]]></fr:tex> to <fr:tex
display="inline"><![CDATA[z]]></fr:tex>. The inverse map <fr:tex
display="inline"><![CDATA[\mathbb {Z}[x, x^{-1}] \to  \mathbb {Z}[x, x^{-1}]]]></fr:tex> sends <fr:tex
display="inline"><![CDATA[x]]></fr:tex> to <fr:tex
display="inline"><![CDATA[x^{-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2567</fr:anchor><fr:addr
type="user">hmlg-002G</fr:addr><fr:route>hmlg-002G.xml</fr:route><fr:title
text="Coalgebra structure on algebraic cellular complexes">Coalgebra structure on algebraic cellular complexes</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There is a natural (differential graded) coalgebra structure on <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complexes</fr:link>. Recall that the tensor unit is <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> concentrated at degree 0. The counit map sends every 0-dimensional cell to <fr:tex
display="inline"><![CDATA[1]]></fr:tex>, and everything else to zero. The comultiplication is induced by the composition (... need simplicial?)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2569</fr:anchor><fr:addr
type="user">hmlg-002E</fr:addr><fr:route>hmlg-002E.xml</fr:route><fr:title
text="Abelian group structure on the W-bar construction">Abelian group structure on the W-bar construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose the simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is abelian, then the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link> still has an abelian group structure, by multiplication element-wise.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2571</fr:anchor><fr:addr
type="user">hmlg-002F</fr:addr><fr:route>hmlg-002F.xml</fr:route><fr:title
text="Twisted tensor product">Twisted tensor product</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>(...)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2573</fr:anchor><fr:addr
type="user">hmlg-002D</fr:addr><fr:route>hmlg-002D.xml</fr:route><fr:title
text="Associated twisted product">Associated twisted product</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-002C.xml"
addr="hmlg-002C"
title="Associated simplicial fiber bundle">associated simplicial fiber bundle</fr:link> of <fr:link
type="local"
href="hmlg-002B.xml"
addr="hmlg-002B"
title="Twisted product of simplicial sets">twisted products</fr:link> admits a simpler description. Suppose we have simplicial sets <fr:tex
display="inline"><![CDATA[F, B]]></fr:tex>, a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with an action <fr:tex
display="inline"><![CDATA[G \times  F \to  F]]></fr:tex> and a <fr:link
type="local"
href="hmlg-002A.xml"
addr="hmlg-002A"
title="Twisting function">twisting function</fr:link> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> on <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. The <fr:strong>associated twisted product</fr:strong> <fr:tex
display="inline"><![CDATA[B \times _\tau  F]]></fr:tex> is defined exactly the same as twisted products, except we replace the factor <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. This still makes sense, because we can interpret the multiplication <fr:tex
display="inline"><![CDATA[\tau (b) \cdot  \partial _n f]]></fr:tex> as the <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action.</fr:p><fr:p>In particular, if we consider <fr:tex
display="inline"><![CDATA[G]]></fr:tex> as a simplicial set with a <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action on the left via multiplication, then the associated twisted product <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> is exactly the same as the twisted product <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex>, which explains our identical notation.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2575</fr:anchor><fr:addr
type="user">hmlg-002C</fr:addr><fr:route>hmlg-002C.xml</fr:route><fr:title
text="Associated simplicial fiber bundle">Associated simplicial fiber bundle</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> with simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, and a simplicial set <fr:tex
display="inline"><![CDATA[F]]></fr:tex> with a group action <fr:tex
display="inline"><![CDATA[G \times  F \to  F]]></fr:tex>, we can construct a fiber bundle with fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, such that the twisting behaviour is described by the <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">principal bundle</fr:link> <fr:tex
display="inline"><![CDATA[p]]></fr:tex>.</fr:p><fr:p>We consider a group action on <fr:tex
display="inline"><![CDATA[E \times  F]]></fr:tex>, by <fr:tex
display="inline"><![CDATA[g \cdot  (e, f) = (e \cdot  g^{-1}, g \cdot  f)]]></fr:tex>. This action is clearly free. Suppose the quotient simplicial set is <fr:tex
display="inline"><![CDATA[E']]></fr:tex>, then we have a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">simplicial fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p' : E' \to  B]]></fr:tex> induced from <fr:tex
display="inline"><![CDATA[p]]></fr:tex>. There is a <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action on the fibers, by acting on the <fr:tex
display="inline"><![CDATA[F]]></fr:tex> factor.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2577</fr:anchor><fr:addr
type="user">hmlg-002B</fr:addr><fr:route>hmlg-002B.xml</fr:route><fr:title
text="Twisted product of simplicial sets">Twisted product of simplicial sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial set <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> with a <fr:link
type="local"
href="hmlg-002A.xml"
addr="hmlg-002A"
title="Twisting function">twisting function</fr:link> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, the <fr:strong>twisted product</fr:strong> is the pullback <fr:tex
display="inline"><![CDATA[B \times _{\bar {W} G} W G]]></fr:tex> with the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>. We write <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> so as to make explicit the twisting function. This is a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link>.</fr:p><fr:p>More explicitly, we define <fr:tex
display="inline"><![CDATA[B \times _\tau  G]]></fr:tex> to be the same as the Cartesian product <fr:tex
display="inline"><![CDATA[B \times  G]]></fr:tex>, but with one face map altered. The pair <fr:tex
display="inline"><![CDATA[(b, g)]]></fr:tex> represents the element in <fr:tex
display="inline"><![CDATA[B \times _{\bar {W} G} W G]]></fr:tex> whose first component is <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex>, and the second component is <fr:tex
display="inline"><![CDATA[(g_0, \dots , g_n) \in  W G]]></fr:tex>, where each element is an iterated product
  <fr:tex
display="block"><![CDATA[\begin {aligned}     g_n &= g \\     g_{k-1} &= \tau (\partial _{k+1} \cdots  \partial _n b) \cdot  (\partial _{k} g_{k}).   \end {aligned}]]></fr:tex>
  This forces the last face map to be
  <fr:tex
display="block"><![CDATA[\partial _n (b, g) = (\partial _n b, \tau (b) \cdot  \partial _n g),]]></fr:tex>
  and the other face and degeneracy maps are unchanged.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2579</fr:anchor><fr:addr
type="user">hmlg-002A</fr:addr><fr:route>hmlg-002A.xml</fr:route><fr:title
text="Twisting function">Twisting function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, a twisting function on a simplicial set <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is a simplicial map <fr:tex
display="inline"><![CDATA[B \to  \bar {W} G]]></fr:tex> to the <fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>. It represents a cocycle valued in <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. Recall that <fr:tex
display="inline"><![CDATA[(\bar {W} G)_n = G_0 \times  \cdots  \times  G_{n-1}]]></fr:tex>. Taking the face map <fr:tex
display="inline"><![CDATA[\partial _{n}]]></fr:tex> reveals that all but the last component of the map <fr:tex
display="inline"><![CDATA[B_n \to  (\bar {W} G)_n]]></fr:tex> are determined by the lower dimension maps. Hence we can obtain a more minimalistic combinatorial description.</fr:p><fr:p>A <fr:strong>twisting function</fr:strong> <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> is a family of maps <fr:tex
display="inline"><![CDATA[\tau _n : B_n \to  G_{n-1}]]></fr:tex> such that
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \tau (\partial _k b) &= \partial _k \tau (b) && (k < n-1)\\     \tau (\partial _{n-1} b) &= \partial _{n-1} \tau (b) \cdot  \tau (\partial _n b) \\     \tau (\sigma _k b) &= \sigma _k \tau (b) && (k < n)\\     \tau (\sigma _n b) &= 1   \end {aligned}]]></fr:tex>
  The corresponding simplicial map <fr:tex
display="inline"><![CDATA[B_n \to  (\bar {W} G)_n]]></fr:tex> is then computed by discarding the last <fr:tex
display="inline"><![CDATA[k]]></fr:tex> vertices of the input <fr:tex
display="inline"><![CDATA[b \in  B_n]]></fr:tex> for <fr:tex
display="inline"><![CDATA[1 \le  k \le  n]]></fr:tex>, apply them to <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> and placing them at the correct components.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2581</fr:anchor><fr:addr
type="user">hmlg-0029</fr:addr><fr:route>hmlg-0029.xml</fr:route><fr:title
text="Kan fiber bundle">Kan fiber bundle</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">simplicial fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex>, it is a Kan fibration iff the fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is a Kan complex. Hence we call it a <fr:strong>Kan fiber bundle</fr:strong>. The proof yields an <fr:link
type="local"
href="hmlg-0027.xml"
addr="hmlg-0027"
title="Effective Kan fibration">effective Kan fibration</fr:link> if all the inputs are effective.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0029</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given a horn <fr:tex
display="inline"><![CDATA[\Lambda ^n_k \to  E]]></fr:tex> and a compatible simplex <fr:tex
display="inline"><![CDATA[\Delta ^n \to  B]]></fr:tex>, by the definition of simplicial fiber bundles, we may trivialize the bundle on the simplex locally. But since <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is Kan, obviously <fr:tex
display="inline"><![CDATA[F \times  \Delta ^n \to  \Delta ^n]]></fr:tex> is also Kan. Hence we may select the required filling.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2583</fr:anchor><fr:addr
type="user">hmlg-0027</fr:addr><fr:route>hmlg-0027.xml</fr:route><fr:title
text="Effective Kan fibration">Effective Kan fibration</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>effective Kan fibration</fr:strong> is a Kan fibration of <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective simplicial sets</fr:link> equipped with a computable choice of horn-filling. Note that it is different from <fr:em>algebraic</fr:em> Kan fibrations, because morphisms are not required to preserve the choice.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2585</fr:anchor><fr:addr
type="user">hmlg-0026</fr:addr><fr:route>hmlg-0026.xml</fr:route><fr:title
text="Simplicial fiber bundle">Simplicial fiber bundle</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A (strict) <fr:strong>simplicial fiber bundle</fr:strong> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> with fiber <fr:tex
display="inline"><![CDATA[F]]></fr:tex> is a simplicial map <fr:tex
display="inline"><![CDATA[p]]></fr:tex> such that for every simplex <fr:tex
display="inline"><![CDATA[\Delta ^n \to  B]]></fr:tex>, the pullback of <fr:tex
display="inline"><![CDATA[p]]></fr:tex> along the simplex is isomorphic to <fr:tex
display="inline"><![CDATA[\Delta ^n \times  F \to  \Delta ^n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2587</fr:anchor><fr:addr
type="user">hmlg-0028</fr:addr><fr:route>hmlg-0028.xml</fr:route><fr:title
text="Simplicial principal fiber bundle">Simplicial principal fiber bundle</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, a <fr:link
type="local"
href="hmlg-0026.xml"
addr="hmlg-0026"
title="Simplicial fiber bundle">fiber bundle</fr:link> <fr:tex
display="inline"><![CDATA[p : E \to  B]]></fr:tex> is <fr:strong>principal</fr:strong> if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> acts on the fibers freely and transitively <fr:em>on the right</fr:em>. This condition can be checked in each dimension separately.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2589</fr:anchor><fr:addr
type="user">hmlg-0023</fr:addr><fr:route>hmlg-0023.xml</fr:route><fr:title
text="Eilenberg–Zilber theorem">Eilenberg–Zilber theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link>
  <fr:tex
display="block"><![CDATA[C_* (X \times  Y) \Rightarrow \mkern {-14mu}\Rightarrow  C_* (X) \otimes  C_* (Y).]]></fr:tex></fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>634</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0023</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For every product of simplices <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex>, we put on the <fr:link
type="local"
href="hmlg-0022.xml"
addr="hmlg-0022"
title="Discrete vector field on ^p  ^q">discrete vector field on <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:link>. This DVF is <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible</fr:link> because the time a path stays in <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> is bounded by a function of <fr:tex
display="inline"><![CDATA[p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[q]]></fr:tex>. Then it is sent to a boundary cell.</fr:p>

  <fr:p>Using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction" />, we get the required chain reduction. This is identical to the Eilenberg–Zilber reduction in literature, but the proof requires some combinatorics, and can be seen in Section 5.13 of <fr:link
type="local"
href="discrete-vector-fields.xml"
addr="discrete-vector-fields"
title="Discrete Vector Fields and Fundamental Algebraic Topology">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. However, this formulation gives a much better computational performance.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2591</fr:anchor><fr:addr
type="user">hmlg-0021</fr:addr><fr:route>hmlg-0021.xml</fr:route><fr:title
text="W-bar construction">W-bar construction</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a simplicial group, we can define a model of its universal principal bundle <fr:tex
display="inline"><![CDATA[\mathbf {E} G \to  \mathbf {B} G]]></fr:tex> as simplicial sets <fr:tex
display="inline"><![CDATA[W G \to  \bar {W} G]]></fr:tex>. This is a generalization of the <fr:link
type="local"
href="hmlg-001W.xml"
addr="hmlg-001W"
title="Bar construction">bar construction</fr:link>, if we consider a group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> as a discrete simplicial set. It classifies principal <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-bundles in the sense of Theorem 21.13 in <fr:link
type="local"
href="simplicial-objects.xml"
addr="simplicial-objects"
title="Simplicial objects in algebraic topology">Simplicial objects in algebraic topology</fr:link>.</fr:p><fr:p>We define the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices of <fr:tex
display="inline"><![CDATA[W G]]></fr:tex> to be
  <fr:tex
display="block"><![CDATA[(W G)_n = G_0 \times  G_1 \times  \cdots  \times  G_n]]></fr:tex>
  so that <fr:tex
display="inline"><![CDATA[G_n]]></fr:tex> acts on <fr:tex
display="inline"><![CDATA[(W G)_n]]></fr:tex> by taking the face map that discards the last <fr:tex
display="inline"><![CDATA[k]]></fr:tex> vertices for each <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, and then acting on the appropriate factor on the right. This forces the face maps and degeneracy maps to be
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \partial _k (g_0, \dots , g_n) &=       (g_0, \dots , g_{k-1}, \partial _k g_{k+1}, \dots , \partial _k g_n), \\     \sigma _k (g_0, \dots , g_n) &=       (g_0, \dots , g_{k}, \sigma _k g_{k}, \dots , \sigma _k g_n).   \end {aligned}]]></fr:tex>
  We define <fr:tex
display="inline"><![CDATA[\bar {W} G]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[W G]]></fr:tex> quotiented by the action of <fr:tex
display="inline"><![CDATA[G]]></fr:tex>. This can be represented as <fr:tex
display="inline"><![CDATA[(\bar {W} G)_n = G_0 \times  \cdots  \times  G_{n-1}]]></fr:tex>,
  with the quotient map <fr:tex
display="inline"><![CDATA[(W G)_n \twoheadrightarrow  (\bar {W} G)_n]]></fr:tex> given by
  <fr:tex
display="block"><![CDATA[(g_0, \dots , g_n) \mapsto  (g_0 (\partial _1 g_1)^{-1}, \dots , g_{n-1} (\partial _n g_n)^{-1}).]]></fr:tex>
  The face and degeneracy maps can then be computed to be
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \partial _k (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{k-1} \cdot  \partial _k g_k, \partial _k g_{k+1}, \dots , \partial _k g_{n-1}), \\     \partial _n (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{n-2}) \\     \sigma _k (g_0, \dots , g_{n-1}) &=       (g_0, g_1, \dots , g_{k-1}, 1, \sigma _k g_{k}, \dots , \sigma _k g_{n-1}).   \end {aligned}]]></fr:tex>
  A quick computation shows that this indeed produces a <fr:link
type="local"
href="hmlg-0028.xml"
addr="hmlg-0028"
title="Simplicial principal fiber bundle">simplicial principal fiber bundle</fr:link> with fiber <fr:tex
display="inline"><![CDATA[G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2593</fr:anchor><fr:addr
type="user">hmlg-0025</fr:addr><fr:route>hmlg-0025.xml</fr:route><fr:title
text="Degeneracy maps">Degeneracy maps</fr:title><fr:taxon>Notation</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given the monotone surjection <fr:tex
display="inline"><![CDATA[\{0, \dots , n+1\} \to  \{0, \dots , n\}]]></fr:tex> with multiplicity at <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, we write the corresponding degeneracy map of a simplicial set as <fr:tex
display="inline"><![CDATA[s_k]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2595</fr:anchor><fr:addr
type="user">hmlg-0022</fr:addr><fr:route>hmlg-0022.xml</fr:route><fr:title
text="Discrete vector field on ^p  ^q">Discrete vector field on <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We construct a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> on the <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">reduced ACC</fr:link> of <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> whose critical cells are given by its boundary and one additional cell
  <fr:tex
display="block"><![CDATA[(0,0) < (1,0) < \cdots  < (p,0) < (p,1) < \cdots  < (p,q),]]></fr:tex>
  in the representation scheme of <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem" />. In particular, this <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">gives rise</fr:link> to a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[C_*(\Delta ^p \times  \Delta ^q) \Rightarrow \mkern {-14mu}\Rightarrow  C_*(\Delta ^p) \otimes  C_*(\Delta ^q)]]></fr:tex>.</fr:p><fr:p>Regarding the geometric simplices as paths in a <fr:tex
display="inline"><![CDATA[p \times  q]]></fr:tex> grid as specified in <fr:ref
addr="hmlg-0020"
href="hmlg-0020.xml"
taxon="Theorem" />, we assign a <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex>-simplex as a target cell if it contains a shape <fr:tex
display="inline"><![CDATA[\Rsh ]]></fr:tex>. (The shape must go exactly one step up and one step to the right, since it is not possible otherwise in a geometric <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex>-simplex.) To get its source cell, replace the <fr:em>last occurrence</fr:em> of this shape with <fr:tex
display="inline"><![CDATA[\nearrow ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2597</fr:anchor><fr:addr
type="user">hmlg-0024</fr:addr><fr:route>hmlg-0024.xml</fr:route><fr:title
text="Naturality of the Eilenberg–Zilber reduction">Naturality of the Eilenberg–Zilber reduction</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The naturality of the reduction in <fr:link
type="local"
href="hmlg-0023.xml"
addr="hmlg-0023"
title="Eilenberg–Zilber theorem">Eilenberg–Zilber theorem</fr:link> is not obvious. This is because maps sending geometric simplices to degenerate ones does not respect the vector field. We would need additional properties on the maps to guarantee naturality.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2599</fr:anchor><fr:addr
type="user">hmlg-0020</fr:addr><fr:route>hmlg-0020.xml</fr:route><fr:title
text="Simplices of ^p  ^q">Simplices of <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The geometric <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices of the product simplicial set <fr:tex
display="inline"><![CDATA[\Delta ^p \times  \Delta ^q]]></fr:tex> are given by a sequence <fr:tex
display="inline"><![CDATA[(u_0, v_0) < (u_1, v_1) < \dots  < (u_n, v_n)]]></fr:tex> of elements in <fr:tex
display="inline"><![CDATA[\{0, \dots , p\} \times  \{0, \dots , q\}]]></fr:tex> endowed with the product partial order. Among these, the interior simplices, i.e. non-boundary simplices are given by sequences such that <fr:tex
display="inline"><![CDATA[u_i]]></fr:tex> ranges over all <fr:tex
display="inline"><![CDATA[\{0, \dots , p\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[v_i]]></fr:tex> ranges over <fr:tex
display="inline"><![CDATA[\{0, \dots , q\}]]></fr:tex>.</fr:p><fr:p>We can graphically represent this as a path that only travels upwards and/or rightwards every step in a <fr:tex
display="inline"><![CDATA[p \times  q]]></fr:tex> grid. Face maps are given by removing the corresponding vertex in the path, and directly connecting the surrounding two. But notice that a segment can skip through a grid point, such as going from <fr:tex
display="inline"><![CDATA[(0,0)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[(2,2)]]></fr:tex>, skipping through <fr:tex
display="inline"><![CDATA[(1,1)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2601</fr:anchor><fr:addr
type="user">hmlg-001Z</fr:addr><fr:route>hmlg-001Z.xml</fr:route><fr:title
text="Chain reduction generated by a discrete vector field">Chain reduction generated by a discrete vector field</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">chain reduction generated by a discrete vector field</fr:link> reduces an ACC <fr:tex
display="inline"><![CDATA[(C_k, d)]]></fr:tex> to a smaller one, which can be explicitly described. Its cells are the critical cells in <fr:tex
display="inline"><![CDATA[C_k]]></fr:tex>. For the faces of a cell <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>, we start with the faces <fr:tex
display="inline"><![CDATA[d(\sigma )]]></fr:tex> in the original ACC. Then we move every non-critical cell down along the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">discrete field lines</fr:link>, up to some sign flips, until we get to a critical cell.</fr:p><fr:p>Note that the field lines alternate between <fr:tex
display="inline"><![CDATA[n]]></fr:tex>- and <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex>-dimensional cells, and we count the movement <fr:tex
display="inline"><![CDATA[n]]></fr:tex> – <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex> – <fr:tex
display="inline"><![CDATA[n]]></fr:tex> as a single step. Also, <fr:link
type="local"
href="hmlg-001S.xml"
addr="hmlg-001S"
title="Discrete field lines can branch and merge">discrete field lines can branch and merge</fr:link>, and the cells need to duplicate and move down every branch.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2603</fr:anchor><fr:addr
type="user">hmlg-001Y</fr:addr><fr:route>hmlg-001Y.xml</fr:route><fr:title
text="Sphere">Sphere</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>sphere</fr:strong> <fr:tex
display="inline"><![CDATA[\mathbb {S}^n]]></fr:tex> can be constructed as an <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective simplicial set</fr:link> with exactly two geometric simplices: a zero-dimensional point, and an <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-dimensional surface. All the faces of the surface are degenerate and comes from the point.</fr:p><fr:p>The <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">associated reduced ACC</fr:link> is <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> at degree <fr:tex
display="inline"><![CDATA[0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and zero elsewhere. The map <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is constant zero.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2605</fr:anchor><fr:addr
type="user">hmlg-001W</fr:addr><fr:route>hmlg-001W.xml</fr:route><fr:title
text="Bar construction">Bar construction</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any group <fr:tex
display="inline"><![CDATA[G]]></fr:tex>, we can construct a model of the first Eilenberg–MacLane space <fr:tex
display="inline"><![CDATA[K(G, 1)]]></fr:tex> as a simplicial set <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex>. Consider the contractible simplicial set <fr:tex
display="inline"><![CDATA[W(G)]]></fr:tex> whose set of <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices is given by <fr:tex
display="inline"><![CDATA[G^{n+1}]]></fr:tex>. This has a natural free <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action given by multiplying every entry on the left. <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex> is constructed by the quotient of the <fr:tex
display="inline"><![CDATA[G]]></fr:tex>-action.</fr:p><fr:p>More concretely, the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-simplices are given by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-tuples, representing the quotient of consecutive elements in the <fr:tex
display="inline"><![CDATA[(n+1)]]></fr:tex>-tuple in the unquotiented simplicial set above. This is traditionally written as a bracketed sequence of elements separated by <fr:em>bars</fr:em>, <fr:tex
display="inline"><![CDATA[[g_1 \mid  g_2 \mid  \dots  \mid  g_n]]]></fr:tex>, hence we name it the <fr:strong>bar construction</fr:strong>. Face maps are given by removing the corresponding bars so the elements multiply together. Degeneracy maps are given by inserting the identity elements.</fr:p><fr:p>If the group has decidable equality and multiplication, then the simplicial set is also <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">effective</fr:link>. If further more the group is computably finite, then it is of finite type.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2607</fr:anchor><fr:addr
type="user">hmlg-001X</fr:addr><fr:route>hmlg-001X.xml</fr:route><fr:title
text="Reduction from K({Z}, 1) to the circle">Reduction from <fr:tex
display="inline"><![CDATA[K(\mathbb {Z}, 1)]]></fr:tex> to the circle</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There is a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> from the <fr:link
type="local"
href="hmlg-001W.xml"
addr="hmlg-001W"
title="Bar construction">bar construction</fr:link> <fr:tex
display="inline"><![CDATA[\bar {W}(G)]]></fr:tex> of a group regarded as its <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">reduced algebraic cellular complex</fr:link>, to the <fr:link
type="local"
href="hmlg-001Y.xml"
addr="hmlg-001Y"
title="Sphere">circle</fr:link> <fr:tex
display="inline"><![CDATA[\mathbb {S}^1]]></fr:tex>.</fr:p><fr:p>By construction, the geometric simplices of <fr:tex
display="inline"><![CDATA[K(\mathbb {Z}, 1)]]></fr:tex> are lists <fr:tex
display="inline"><![CDATA[[a_1 \mid  a_2 \mid  \cdots  \mid  a_n]]]></fr:tex> of non-zero integers. We construct an <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible discrete vector field</fr:link> and use <fr:link
type="local"
href="hmlg-001R.xml"
addr="hmlg-001R"
title="Chain reduction generated by a discrete vector field">the reduction it generates</fr:link>. We assign a cell <fr:tex
display="inline"><![CDATA[[a_1 \mid  \cdots ]]]></fr:tex> as a source if <fr:tex
display="inline"><![CDATA[a_1 \ne  1]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[a_1 \le  0]]></fr:tex>, then we assign its target cell to be <fr:tex
display="inline"><![CDATA[[1 \mid  a_1 \mid  \cdots ]]]></fr:tex>; otherwise we assign <fr:tex
display="inline"><![CDATA[[1 \mid  a_1 - 1 \mid  \cdots ]]]></fr:tex>. Hence, the critical cells are <fr:tex
display="inline"><![CDATA[[]]]></fr:tex> and <fr:tex
display="inline"><![CDATA[[1]]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2609</fr:anchor><fr:addr
type="user">hmlg-001U</fr:addr><fr:route>hmlg-001U.xml</fr:route><fr:title
text="Algebraic cellular complexes associated with a simplicial set">Algebraic cellular complexes associated with a simplicial set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">(effective) simplicial set</fr:link> <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, there are two major <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complexes</fr:link> (or <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complexes</fr:link>) we can associate to it. We can consider the free abelian group generated by <fr:tex
display="inline"><![CDATA[\Gamma (\Delta ^n, X)]]></fr:tex> at degree <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, where the boundary map is given by an alternating sum of face maps: <fr:tex
display="block"><![CDATA[d_n = \sum _{i=0}^n (-1)^{i} \partial _i.]]></fr:tex> This satisfies <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> by the simplicial identities. ALternatively, we can consider only the geometric simplices, regarding degenerate ones are zero. More formally, we quotient out the previous chain complex by the subgroups generated by degenerate simplicies. They are both obviously <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link> by construction.</fr:p><fr:p>The first chain complex is called the <fr:strong>non-reduced</fr:strong> complex, while the second one is the <fr:strong>reduced</fr:strong> complex. By <fr:ref
addr="hmlg-001V"
href="hmlg-001V.xml"
taxon="Construction" /> the two chain complexes are related by a chain reduction. So we will write <fr:tex
display="inline"><![CDATA[C_* X]]></fr:tex> for the reduced complex, leaving no notation for the non-reduced one unless otherwise stated.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2611</fr:anchor><fr:addr
type="user">hmlg-001T</fr:addr><fr:route>hmlg-001T.xml</fr:route><fr:title
text="Effective simplicial set">Effective simplicial set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>effective</fr:strong> simplicial set consists of a sequence of types <fr:tex
display="inline"><![CDATA[\operatorname {Geom}_n(X)]]></fr:tex> with decidable equality, representing the <fr:strong>geometric</fr:strong>, a.k.a. non-degenerate, simplices. The full set of simplices, written <fr:tex
display="inline"><![CDATA[\Gamma (\Delta ^n, X)]]></fr:tex> or more simply <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex>, is given by a geometric simplex <fr:tex
display="inline"><![CDATA[g \in  \operatorname {Geom}_k(X)]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[k]]></fr:tex> together with a <fr:strong>degeneracy symbol</fr:strong>, defined as a surjection <fr:tex
display="inline"><![CDATA[\eta  : [n+1] \twoheadrightarrow  [k+1]]]></fr:tex>, formally representing the degeneracy map that brought <fr:tex
display="inline"><![CDATA[g]]></fr:tex> up to dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, written as <fr:tex
display="inline"><![CDATA[\eta ^* g]]></fr:tex>. The effective simplicial set is also required to have computable <fr:strong>face maps</fr:strong> <fr:tex
display="inline"><![CDATA[\partial _i : \operatorname {Geom}_{n+1}(X) \to  \Gamma (\Delta ^n, X)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[0 \le  i \le  n+1]]></fr:tex>, so that the usual simplicial identities hold. The simplicial set is <fr:strong>of finite type</fr:strong> if each <fr:tex
display="inline"><![CDATA[\operatorname {Geom}_n(X)]]></fr:tex> is computably finite.</fr:p><fr:p>Alternatively, we can make a definition that more closely follows the traditional one, requiring a sequence of types with decidable equality representing <fr:em>all</fr:em> simplices instead of geometric ones. We then need to impose an additional requirement that the degeneracy of a simplex is decidable. The equivalence of the two definitions is given by the Eilenberg–Zilber lemma.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2613</fr:anchor><fr:addr
type="user">hmlg-001V</fr:addr><fr:route>hmlg-001V.xml</fr:route><fr:title
text="Reduction from the non-reduced chain complex to the reduced chain complex">Reduction from the non-reduced chain complex to the reduced chain complex</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We construct a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> from the non-reduced chain complex to the reduced chain complex in <fr:ref
addr="hmlg-001U"
href="hmlg-001U.xml"
taxon="Definition" />, by constructing a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> and using <fr:ref
addr="hmlg-001R"
href="hmlg-001R.xml"
taxon="Construction" />.</fr:p><fr:p>We consider placing vectors on degenerate simplicies, so that all degenerate simplices are sources or targets. For each non-trivial degeneracy symbol, if the first degeneration has even multiplicity, we assign it to be a source, with the corresponding target to have one more multiplicity at the place, and vice versa. For example, the degeneracy symbol <fr:tex
display="inline"><![CDATA[[6] \twoheadrightarrow  [4]]]></fr:tex> given by the table of values <fr:tex
display="inline"><![CDATA[(0, 1, 1, 2, 3, 3, 4)]]></fr:tex> is a source, whose target is <fr:tex
display="inline"><![CDATA[(0, 1, 1, 1, 2, 3, 3, 4) : [7] \twoheadrightarrow  [4]]]></fr:tex>.</fr:p><fr:p>To verify this indeed gives a discrete vector field, we need to show that the source is a regular face of the target. This is true since an odd consective sum of <fr:tex
display="inline"><![CDATA[(-1)^{i}]]></fr:tex> gives <fr:tex
display="inline"><![CDATA[\pm  1]]></fr:tex>. Furthermore, we need to show the admissibility of the vector field. I claim that length of the field lines originating from one cell is bounded by two times the geometric dimension (i.e. the dimension of the associated geometric simplex). On one hand, the geometric dimensions of the target and the source are the same. On the other hand, moving from the target to the next source cell requires us to pick a regular face that does not point back to the target. This is equivalent to picking a place in the degeneracy symbol with no multiplicity. Hence the geometric dimension will decrease by one.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2615</fr:anchor><fr:addr
type="user">ualg-000H</fr:addr><fr:route>ualg-000H.xml</fr:route><fr:title
text="Beck monadicity theorem">Beck monadicity theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[G : \mathcal {D} \to  \mathcal {C}]]></fr:tex> be a functor with a left adjoint <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic</fr:link> iff <fr:tex
display="inline"><![CDATA[G]]></fr:tex> <fr:link
type="local"
href="ualg-000G.xml"
addr="ualg-000G"
title="Preservation, lifting, reflection and creation of limits">creates</fr:link> coequalizers whose image under <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="ualg-000B.xml"
addr="ualg-000B"
title="Split coequalizer">split</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>799</fr:anchor><fr:addr
type="machine">#233</fr:addr><fr:route>unstable-233.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For necessity, using <fr:ref
addr="ualg-000I"
href="ualg-000I.xml"
taxon="Theorem" />, we only need to verify that a monad <fr:tex
display="inline"><![CDATA[M]]></fr:tex> preserves the relevant coequalizers, which is true since <fr:link
type="local"
href="ualg-000D.xml"
addr="ualg-000D"
title="Characterization of absolute coequalizers">they are absolute</fr:link>.</fr:p>

  <fr:p>For sufficiency, we observe the proof of <fr:ref
addr="ualg-000E"
href="ualg-000E.xml"
taxon="Theorem" />. Notice that the coequalizers involved are of the form <fr:tex
display="inline"><![CDATA[F\alpha , \epsilon  : FGFA \rightrightarrows  FA]]></fr:tex>. The images of these under <fr:tex
display="inline"><![CDATA[G]]></fr:tex> are indeed split by <fr:tex
display="inline"><![CDATA[\eta  : GFA \to  GFGFA]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\eta  : A \to  GFA]]></fr:tex>. Therefore we just have to show <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms. Given an isomorphism <fr:tex
display="inline"><![CDATA[Gf : GA \cong  GB]]></fr:tex>, we have a split coequalizer <fr:tex
display="inline"><![CDATA[GA \rightrightarrows  GB \to  GA]]></fr:tex> where the two maps on the left are <fr:tex
display="inline"><![CDATA[Gf]]></fr:tex>, and the map on the right is its inverse. This creates a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex> which is the coequalizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with itself. So this map must be an isomorphism. We then consider the coequalizer <fr:tex
display="inline"><![CDATA[GB \rightrightarrows  GA \to  GB]]></fr:tex>, where the two maps on the left are <fr:tex
display="inline"><![CDATA[Gg]]></fr:tex> and the map on the right is <fr:tex
display="inline"><![CDATA[Gf]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects this limit, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> must also be an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2617</fr:anchor><fr:addr
type="user">ualg-000M</fr:addr><fr:route>ualg-000M.xml</fr:route><fr:title
text="Complete Boolean algebra not isomorphic to a powerset">Complete Boolean algebra not isomorphic to a powerset</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider the Lebesgue measurable sets on the interval <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex> quotiented by measure-zero sets. This is a complete Boolean algebra, but it is not a powerset, showing the necessity of complete distributivity in <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>781</fr:anchor><fr:addr
type="machine">#230</fr:addr><fr:route>unstable-230.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000M</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>This is indeed a Boolean algebra since measure-zero sets form a Boolean ideal of the Lebesgue <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra. So we just need to show the existence of arbitrary joins. Given a family <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex> of measurable sets, we inductively construct a countable union. On each step, consider the area of each set outside of the current union. Select a set such that this excess area is within <fr:tex
display="inline"><![CDATA[\frac 12]]></fr:tex> of the supremum. Since <fr:tex
display="inline"><![CDATA[\mu ([0,1]) = 1]]></fr:tex>, such a process must lead to an excess area converging to zero.</fr:p>

  <fr:p>By construction, every set <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex> has zero area outside of this countable union, so they are under the union in the Boolean algebra. And the countable union <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^\infty  X_{\alpha _k}]]></fr:tex> is the join of <fr:tex
display="inline"><![CDATA[X_{\alpha _k}]]></fr:tex> in the algebra, since a countable union of neglegible set is still neglegible. Hence by chasing elements, it must be the join of the entire family <fr:tex
display="inline"><![CDATA[X_\alpha ]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2619</fr:anchor><fr:addr
type="user">ualg-000J</fr:addr><fr:route>ualg-000J.xml</fr:route><fr:title
text="Completely distributive complete Boolean algebra">Completely distributive complete Boolean algebra</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>completely distributive complete Boolean algebra</fr:strong> is a Boolean algebra with arbitrary join and meet that distribute over each other.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2621</fr:anchor><fr:addr
type="user">ualg-000L</fr:addr><fr:route>ualg-000L.xml</fr:route><fr:title
text="Completely distributive complete Boolean algebras are powersets">Completely distributive complete Boolean algebras are powersets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Every <fr:link
type="local"
href="ualg-000J.xml"
addr="ualg-000J"
title="Completely distributive complete Boolean algebra">completely distributive complete Boolean algebra</fr:link> is isomorphic to the set algebra of a powerset, and homomorphisms are given by inverse image map. In other words, the category of CDCBA is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Set}^{\textrm {op}}]]></fr:tex> and the forgetful functor is given by the powerset <fr:tex
display="inline"><![CDATA[\mathcal {P}(X) = 2^X]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>787</fr:anchor><fr:addr
type="machine">#231</fr:addr><fr:route>unstable-231.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000L</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the set of <fr:em>atoms</fr:em> <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, defined as minimal non-bottom elements. It suffices to prove the algebra is <fr:em>atomic</fr:em>, i.e. every non-bottom element has an atom below it. This is because we can remove all the atoms that an element contains, and the result must be <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex>. So every element is given by a join of atoms. Such a join must be unique, since the intersection of different atoms is empty, so given two ways to write an element as a join of atoms, we take the intersection and see that they must agree. This shows that the elements are in bijection with <fr:tex
display="inline"><![CDATA[\mathcal {P}(A)]]></fr:tex>, with joins, meets and complements given by unions, intersections and complements, respectively.</fr:p>

  <fr:p>To show atomicity, consider <fr:tex
display="block"><![CDATA[\top  = \bigwedge _{b \in  B} (b \lor  \neg  b) = \bigvee _{S \subseteq  B} \left [ \bigwedge _{b \in  S} b \wedge  \bigwedge _{b \notin  S} \neg  b \right ].]]></fr:tex> Consider the disjunctive clauses in here not equal to <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex> (which must exist unless <fr:tex
display="inline"><![CDATA[\top  = \bot ]]></fr:tex> which trivially satisfies the requirements). They must be atoms because any element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> strictly below them must be below all the conjunctive items, so either <fr:tex
display="inline"><![CDATA[x < x]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x < \neg  x]]></fr:tex>. The former is absurd and the latter implies <fr:tex
display="inline"><![CDATA[x = \bot ]]></fr:tex>.</fr:p>

  <fr:p>Taking the meet of the equation with an arbitrary element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> gives <fr:tex
display="block"><![CDATA[x = \bigvee _{S \subseteq  B} \left [x \wedge  \bigwedge _{b \in  S} b \wedge  \bigwedge _{b \notin  S} \neg  b \right ].]]></fr:tex> If there are no atoms <fr:tex
display="inline"><![CDATA[a \le  x]]></fr:tex>, then all the clauses must be <fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex> meaning <fr:tex
display="inline"><![CDATA[x = \bot ]]></fr:tex>. This finishes the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2623</fr:anchor><fr:addr
type="user">ualg-000K</fr:addr><fr:route>ualg-000K.xml</fr:route><fr:title
text="Free completely distributive complete Boolean algebras">Free completely distributive complete Boolean algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An element of a free <fr:link
type="local"
href="ualg-000J.xml"
addr="ualg-000J"
title="Completely distributive complete Boolean algebra">CDCBA</fr:link> over the set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an expression made out of joins, meets and negation, with literals from <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. We can push the negation in and use distributivity to put the expression into <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">disjunctive normal form</fr:link>. The clauses can be represented by functions <fr:tex
display="inline"><![CDATA[X \to  \{\top , \bot , ?\}]]></fr:tex> representing a literal appearing positively, negatively or not appearing in the conjunction.</fr:p><fr:p>If a literal <fr:tex
display="inline"><![CDATA[b]]></fr:tex> does not appear in a clause, we can take its conjunction with <fr:tex
display="inline"><![CDATA[\top  = b \lor  \neg  b]]></fr:tex> and expand using distributivity. This ensures every literal appears either positively or negatively, so the expressions are now represented by a double powerset of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, where the inner powerset records which literals appear positively in a clause, and the outer powerset represents the set of clauses.</fr:p><fr:p>In fact, such a representation is unique. We just need to show that the double powerset forms a CDCBA. Disjunction is simply a union. Negation is given by the complement. Conjunction is given by an intersection. We can verify that the required identities all hold. Hence the monad for CDCBAs is the double powerset monad, corresponding to the adjunction <fr:tex
display="inline"><![CDATA[\mathcal {P}^{\textrm {op}} \dashv  \mathcal {P}]]></fr:tex> via <fr:ref
addr="ualg-000L"
href="ualg-000L.xml"
taxon="Theorem" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2625</fr:anchor><fr:addr
type="user">ualg-000I</fr:addr><fr:route>ualg-000I.xml</fr:route><fr:title
text="Limits and colimits created by a monadic functor">Limits and colimits created by a monadic functor</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic functor</fr:link> <fr:link
type="local"
href="ualg-000G.xml"
addr="ualg-000G"
title="Preservation, lifting, reflection and creation of limits">creates</fr:link> all limits. It also creates all colimits preserved by the monad.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>793</fr:anchor><fr:addr
type="machine">#232</fr:addr><fr:route>unstable-232.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By definition, we just need to prove the functor <fr:tex
display="inline"><![CDATA[\mathcal {C}^M \to  \mathcal {C}]]></fr:tex> creates these limits and colimits. Given a diagram <fr:tex
display="inline"><![CDATA[(M X_i \xrightarrow {\alpha _i} X_i)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex>, we can simply define an <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-algebra structure on <fr:tex
display="inline"><![CDATA[\lim  X_i]]></fr:tex> by assigning <fr:tex
display="inline"><![CDATA[M(\lim  X_i) \to  \lim  X_i]]></fr:tex> the obvious map. This is the limit of the original diagram by a simple diagram chase, hence it is lifted. The cones over the diagram are determined by their image under the forgetful functor, so the lift is unique, which means the limit is trivially reflected.</fr:p>

  <fr:p>For colimits, if <fr:tex
display="inline"><![CDATA[M]]></fr:tex> preserves a colimit, then we can similarly define an algebra structure as <fr:tex
display="inline"><![CDATA[M(\operatorname *{colim} X_i) \cong  \operatorname *{colim} M X_i \to  \operatorname *{colim} X_i]]></fr:tex>. The lift is also unique, which means it is reflected.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2627</fr:anchor><fr:addr
type="user">ualg-000G</fr:addr><fr:route>ualg-000G.xml</fr:route><fr:title
text="Preservation, lifting, reflection and creation of limits">Preservation, lifting, reflection and creation of limits</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex>.</fr:p><fr:ul><fr:li>If a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is mapped to a limit cone in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, then the functor <fr:strong>preserves</fr:strong> the limit <fr:tex
display="inline"><![CDATA[I]]></fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> over <fr:tex
display="inline"><![CDATA[F \mathbin {\circ } D]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[D]]></fr:tex> can be extended to a limit cone in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> that maps to <fr:tex
display="inline"><![CDATA[L]]></fr:tex>, then the functor <fr:strong>lifts</fr:strong> the limit <fr:tex
display="inline"><![CDATA[L]]></fr:tex> to <fr:tex
display="inline"><![CDATA[D]]></fr:tex>.</fr:li>
  <fr:li>If all the cones that maps to a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> are limit cones in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, then the functor <fr:strong>reflects</fr:strong> the limit <fr:tex
display="inline"><![CDATA[L]]></fr:tex>.</fr:li>
  <fr:li>If given a diagram <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and a limit cone <fr:tex
display="inline"><![CDATA[L]]></fr:tex> over <fr:tex
display="inline"><![CDATA[F \mathbin {\circ } D]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[L]]></fr:tex> is reflected and lifted to <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, then the limit of <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is <fr:strong>created</fr:strong>.</fr:li></fr:ul><fr:p>This can be easily generalized to cover a type of limits or all limits, and can be dualized to colimits. The definitions here are not agreed upon, and the literature may have slight variations. We consider univalent categories here, so that definitions are automatically adjusted to be equivalence-invariant.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2629</fr:anchor><fr:addr
type="user">ualg-000F</fr:addr><fr:route>ualg-000F.xml</fr:route><fr:title
text="Reflexive pair">Reflexive pair</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>reflexive pair</fr:strong> is the categorical translation of a reflexive relation. It is defined as a pair of arrows <fr:tex
display="inline"><![CDATA[\partial _0, \partial _1 : X \rightrightarrows  Y]]></fr:tex> with a common section <fr:tex
display="inline"><![CDATA[r : Y \to  X]]></fr:tex>, i.e. an arrow <fr:tex
display="inline"><![CDATA[r]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } r = \partial _1 \mathbin {\circ } r = \textrm {id}_Y]]></fr:tex>. A coequalizer of a reflexive pair is called a <fr:strong>reflexive coequalizer</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2631</fr:anchor><fr:addr
type="user">ualg-000E</fr:addr><fr:route>ualg-000E.xml</fr:route><fr:title
text="Crude monadicity theorem">Crude monadicity theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[G : \mathcal {D} \to  \mathcal {C}]]></fr:tex> be a functor with a left adjoint <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. <fr:tex
display="inline"><![CDATA[M = G \mathbin {\circ } F]]></fr:tex> is the corresponding monad on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. This gives a <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> <fr:tex
display="inline"><![CDATA[K : \mathcal {A} \to  \mathcal {C}^M]]></fr:tex>.</fr:p><fr:ol><fr:li>If <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> has all coequalizers (we can weaken this to <fr:link
type="local"
href="ualg-000F.xml"
addr="ualg-000F"
title="Reflexive pair">reflexive coequalizers</fr:link>), then <fr:tex
display="inline"><![CDATA[K]]></fr:tex> has a left adjoint.</fr:li>
  <fr:li>If moreover <fr:tex
display="inline"><![CDATA[G]]></fr:tex> preserves these reflexive coequalizers, the unit <fr:tex
display="inline"><![CDATA[\textrm {Id} \to  K \mathbin {\circ } L]]></fr:tex> is an isomorphism.</fr:li>
  <fr:li>Finally, if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms, then the counit <fr:tex
display="inline"><![CDATA[L \mathbin {\circ } K \to  \textrm {Id}]]></fr:tex> is also an isomorphism, making <fr:tex
display="inline"><![CDATA[G]]></fr:tex> <fr:link
type="local"
href="ualg-000A.xml"
addr="ualg-000A"
title="Monadic functor">monadic</fr:link>.</fr:li></fr:ol>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>813</fr:anchor><fr:addr
type="machine">#234</fr:addr><fr:route>unstable-234.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the first claim, we need a functor <fr:tex
display="inline"><![CDATA[L]]></fr:tex> such that arrows from <fr:tex
display="inline"><![CDATA[L(GFA \xrightarrow {\alpha } A)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is in bijection with commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7552ab0a1122c764613faeef0d30c0bc"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      GFA & GFGX \\
      A & GX
      \arrow [from=1-1, to=1-2]
      \arrow ["{\alpha }"', from=1-1, to=2-1]
      \arrow ["{G \epsilon }", from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    which are equivalent by <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> to the commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="742f273ba13897778c25fb9ad1150d18"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      FGFA & FGX \\
      FA & X
      \arrow ["FG\varphi ", from=1-1, to=1-2]
      \arrow ["F\alpha "', from=1-1, to=2-1]
      \arrow ["\epsilon ", from=1-2, to=2-2]
      \arrow ["\varphi ", from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Further notice that <fr:tex
display="inline"><![CDATA[\epsilon  \mathbin {\circ } FG\varphi  = \varphi  \mathbin {\circ } \epsilon ]]></fr:tex> by naturality. So it becomes obvious that <fr:tex
display="inline"><![CDATA[L]]></fr:tex> should be defined as the coequalizer of the pair <fr:tex
display="block"><![CDATA[F \alpha , \epsilon  : FGFA \rightrightarrows  FA.]]></fr:tex> This is reflexive by the common section <fr:tex
display="inline"><![CDATA[F\eta ]]></fr:tex>.</fr:p>

  <fr:p>For the second point, we unfold the unit as a natural family of commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="857909e7575ed30b312cefad4ffa82e3"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      GFA & {GFG\operatorname *{colim}(FGFA \rightrightarrows  FA)} \\
      A & {G\operatorname *{colim}(FGFA \rightrightarrows  FA)}
      \arrow [from=1-1, to=1-2]
      \arrow [from=1-1, to=2-1]
      \arrow [from=1-2, to=2-2]
      \arrow [from=2-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    and when <fr:tex
display="inline"><![CDATA[G]]></fr:tex> preserves the coequalizers in the diagram, the problem is reduced to showing that the coequalizer of <fr:tex
display="inline"><![CDATA[GF\alpha ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[G\epsilon  : GFGFA \rightrightarrows  GFA]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> via the bottom map, which is just the unit <fr:tex
display="inline"><![CDATA[\eta  : A \to  GFA]]></fr:tex> composed with the coequalizing map. This is a routine diagram chase.</fr:p>

  <fr:p>For the final point, we would like the coequalizer of <fr:tex
display="inline"><![CDATA[FG\epsilon , \epsilon  : FGFGX \rightrightarrows  FGX]]></fr:tex> to be isomorphic to <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. If we apply <fr:tex
display="inline"><![CDATA[G]]></fr:tex> to the diagram, we get an isomorphism to <fr:tex
display="inline"><![CDATA[GX]]></fr:tex> by the previous point. So if <fr:tex
display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms, we’re done.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2633</fr:anchor><fr:addr
type="user">ualg-000C</fr:addr><fr:route>ualg-000C.xml</fr:route><fr:title
text="Absolute (co)limit">Absolute (co)limit</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>absolute (co)limit</fr:strong> is a (co)limit that is preserved by any functor whatsoever.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2635</fr:anchor><fr:addr
type="user">ualg-000D</fr:addr><fr:route>ualg-000D.xml</fr:route><fr:title
text="Characterization of absolute coequalizers">Characterization of absolute coequalizers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a coequalizer diagram <fr:tex
display="inline"><![CDATA[X \rightrightarrows  Y \to  Z]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\partial _0, \partial _1 : X \to  Y]]></fr:tex> are the two parallel arrows and the coequalizing arrow is <fr:tex
display="inline"><![CDATA[e : Y \to  Z]]></fr:tex>, it is <fr:link
type="local"
href="ualg-000C.xml"
addr="ualg-000C"
title="Absolute (co)limit">absolute</fr:link>, if and only if the following conditions hold.</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[e]]></fr:tex> is split epimorphic, i.e. there is an arrow <fr:tex
display="inline"><![CDATA[r]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>.</fr:li>
  <fr:li>There is a list of <fr:tex
display="inline"><![CDATA[n]]></fr:tex> endomorphisms on <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> starting with <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } e]]></fr:tex> and ending with <fr:tex
display="inline"><![CDATA[\textrm {id}_Y]]></fr:tex>, such that for each pair of adjacent morphisms, there is an arrow <fr:tex
display="inline"><![CDATA[s]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _1 \mathbin {\circ } s]]></fr:tex> are equal to the two morphisms (in some order).</fr:li></fr:ul><fr:p>Note that for <fr:tex
display="inline"><![CDATA[n = 0]]></fr:tex> this is the trivial coequalizer where <fr:tex
display="inline"><![CDATA[\partial _0 = \partial _1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[e]]></fr:tex> is an isomorphism. For <fr:tex
display="inline"><![CDATA[n = 1]]></fr:tex> this results in the <fr:link
type="local"
href="ualg-000B.xml"
addr="ualg-000B"
title="Split coequalizer">split coequalizer</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>820</fr:anchor><fr:addr
type="machine">#235</fr:addr><fr:route>unstable-235.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the definition of an <fr:link
type="local"
href="ualg-000C.xml"
addr="ualg-000C"
title="Absolute (co)limit">absolute (co)limit</fr:link>, the coequalizer is preserved by every functor. Consider the functor <fr:tex
display="inline"><![CDATA[\hom (Z, -)]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[\hom (Z, e)]]></fr:tex> is a coequalizer map, and hence epimorphic. This means <fr:tex
display="inline"><![CDATA[e]]></fr:tex> itself is split epimorphic since <fr:tex
display="inline"><![CDATA[\textrm {id}_Z]]></fr:tex> is in the image, i.e. there is a morphism <fr:tex
display="inline"><![CDATA[r : Z \to  Y]]></fr:tex> with <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>.</fr:p>

  <fr:p>Next, we consider the functor <fr:tex
display="inline"><![CDATA[\hom (Y, -)]]></fr:tex>. Since this gives a coequalizer of sets, the quotient <fr:tex
display="inline"><![CDATA[\hom (Y, Y) \xrightarrow {e \mathbin {\circ } -} \hom (Y, Z)]]></fr:tex> is given by the equivalence relation generated by <fr:tex
display="inline"><![CDATA[\partial _0 \mathbin {\circ } f = \partial _1 \mathbin {\circ } f]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex>. There is a pair of elements mapped to the same element under <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } -]]></fr:tex> in this situation: one of them is obviously <fr:tex
display="inline"><![CDATA[\textrm {id}_Y]]></fr:tex>, and the other is <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } e]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[e \mathbin {\circ } \textrm {id}_Y = e = e \mathbin {\circ } r \mathbin {\circ } e]]></fr:tex>. Hence we get the chain of morphisms related in the way stated in the theorem.</fr:p>

  <fr:p>Finally, we observe that these are enough to guarantee the given diagram is a coequalizer —— the diagram is a coequalizer simply by virtue of the shape of the diagram. Since any functor preserves the composition relation of morphisms, they must also give coequalizers, and therefore the coequalizer is absolute.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2637</fr:anchor><fr:addr
type="user">ualg-000B</fr:addr><fr:route>ualg-000B.xml</fr:route><fr:title
text="Split coequalizer">Split coequalizer</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a <fr:strong>split coequalizer</fr:strong> to be the following diagram:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="5ceb23e39cb73d22e2cb02c70866ddd9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    X & Y & Z
    \arrow ["{\partial _0}", shift left, curve={height=-6pt}, from=1-1, to=1-2]
    \arrow ["{\partial _1}"', shift right, curve={height=6pt}, from=1-1, to=1-2]
    \arrow ["s"{description}, from=1-2, to=1-1]
    \arrow ["q", from=1-2, to=1-3]
    \arrow ["r", curve={height=-6pt}, from=1-3, to=1-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that <fr:tex
display="inline"><![CDATA[q \mathbin {\circ } r = \textrm {id}_Z]]></fr:tex>, <fr:tex
display="inline"><![CDATA[r \mathbin {\circ } q = \partial _0 \mathbin {\circ } s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\partial _1 \mathbin {\circ } s = \textrm {id}_Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2639</fr:anchor><fr:addr
type="user">ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title
text="Monadic functor">Monadic functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functors <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> to <fr:tex
display="inline"><![CDATA[\mathcal {C}^{G \mathbin {\circ } F}]]></fr:tex> is an equivalence in <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">the bicategory of decompositions</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2641</fr:anchor><fr:addr
type="user">ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title
text="The Kleisli category induces the initial decomposition of a monad">The Kleisli category induces the initial decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2643</fr:anchor><fr:addr
type="user">ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title
text="The Eilenberg–Moore category induces the terminal decomposition of a monad">The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>883</fr:anchor><fr:addr
type="machine">#236</fr:addr><fr:route>unstable-236.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> with the corresponding monad <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex>, the comparison functor is defined as sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[GFGX \to  GX]]></fr:tex>, given by the counit <fr:tex
display="inline"><![CDATA[FGX \to  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2645</fr:anchor><fr:addr
type="user">ualg-0007</fr:addr><fr:route>ualg-0007.xml</fr:route><fr:title
text="Decomposition of a monad into adjoint functors">Decomposition of a monad into adjoint functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functor <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex> forms a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link>. As a converse, we can consider the adjunctions whose composition is a given monad <fr:tex
display="inline"><![CDATA[M]]></fr:tex>. These decompositions form a bicategory. The morphisms between two adjunctions are given by functors <fr:tex
display="inline"><![CDATA[L]]></fr:tex> that make the two triangles below commute.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="a39a5a66477c19047311c740a235210b"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    {\mathcal {D}_2} & {\mathcal {D}_1} & {\mathcal {C}}
    \arrow [shift right, from=1-2, to=1-3]
    \arrow [shift right, from=1-3, to=1-2]
    \arrow [shift right, curve={height=18pt}, from=1-1, to=1-3]
    \arrow [shift right, curve={height=18pt}, from=1-3, to=1-1]
    \arrow ["L"{description}, from=1-2, to=1-1]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  More precisely, the objects of this bicategory are given by adjunctions <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> together with a natural isomorphism <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F \cong  M]]></fr:tex>. A morphism from <fr:tex
display="inline"><![CDATA[F_1 \dashv  G_1]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F_2 \dashv  G_2]]></fr:tex> is given by a functor <fr:tex
display="inline"><![CDATA[L]]></fr:tex> together with two natural isomorphisms <fr:tex
display="inline"><![CDATA[L \mathbin {\circ } G_1 \cong  G_2]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F_1 \cong  F_2 \mathbin {\circ } L]]></fr:tex>. A <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-morphism is given by a natural transformation such that the relevant composition of natural transformations are equal.</fr:p><fr:p>This bicategory has initial and terminal objects.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>916</fr:anchor><fr:addr
type="user">ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title
text="The Kleisli category induces the initial decomposition of a monad">The Kleisli category induces the initial decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>918</fr:anchor><fr:addr
type="user">ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title
text="The Eilenberg–Moore category induces the terminal decomposition of a monad">The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>883</fr:anchor><fr:addr
type="machine">#236</fr:addr><fr:route>unstable-236.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex> with the corresponding monad <fr:tex
display="inline"><![CDATA[G \mathbin {\circ } F]]></fr:tex>, the comparison functor is defined as sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[GFGX \to  GX]]></fr:tex>, given by the counit <fr:tex
display="inline"><![CDATA[FGX \to  X]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>920</fr:anchor><fr:addr
type="user">ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title
text="Monadic functor">Monadic functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of adjoint functors <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
type="local"
href="ualg-0009.xml"
addr="ualg-0009"
title="The Eilenberg–Moore category induces the terminal decomposition of a monad">comparison functor</fr:link> to <fr:tex
display="inline"><![CDATA[\mathcal {C}^{G \mathbin {\circ } F}]]></fr:tex> is an equivalence in <fr:link
type="local"
href="ualg-0007.xml"
addr="ualg-0007"
title="Decomposition of a monad into adjoint functors">the bicategory of decompositions</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2647</fr:anchor><fr:addr
type="user">ualg-0006</fr:addr><fr:route>ualg-0006.xml</fr:route><fr:title
text="Objects of the Kleisli category">Objects of the Kleisli category</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An object of <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">the Kleisli category of a monad</fr:link> can be considered as a <fr:link
type="local"
href="ualg-0003.xml"
addr="ualg-0003"
title="Free monad algebras">free algebra</fr:link>, but <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">equipped with a canonical choice of generators</html:mark>. Hence although <fr:link
type="local"
href="ualg-0005.xml"
addr="ualg-0005"
title="The Kleisli category is equivalent to the category of free algebras">the Kleisli category is equivalent to the category of free algebras</fr:link>, the objects are essentially different. This manifests as the curious fact that the Kleisli category is not univalent, since an equality of Kleisli objects requires an isomorphism of the generators, but an isomorphism only requires the two free algebras to be isomorphic.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2649</fr:anchor><fr:addr
type="user">ualg-0005</fr:addr><fr:route>ualg-0005.xml</fr:route><fr:title
text="The Kleisli category is equivalent to the category of free algebras">The Kleisli category is equivalent to the category of free algebras</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">the Kleisli category of a monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> is equivalent to the full subcategory of the <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-<fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebras</fr:link> spanned by the <fr:link
type="local"
href="ualg-0003.xml"
addr="ualg-0003"
title="Free monad algebras">free algebras</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>957</fr:anchor><fr:addr
type="machine">#237</fr:addr><fr:route>unstable-237.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0005</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the functor from the Kleisli category to the category of free algebras, sending <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to the free algebra on <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. This is fully faithful and surjective on objects.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2651</fr:anchor><fr:addr
type="user">ualg-0004</fr:addr><fr:route>ualg-0004.xml</fr:route><fr:title
text="The Kleisli category of a monad">The Kleisli category of a monad</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> and two objects <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Kleisli arrow</fr:strong> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is simply any arrow <fr:tex
display="inline"><![CDATA[X \to  MY]]></fr:tex>. This represents an algebra homomorphism from the free algebra generated by <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to that of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p><fr:p>The identity Kleisli arrow is defined as <fr:tex
display="inline"><![CDATA[\eta  : X \to  MX]]></fr:tex>. The composition of <fr:tex
display="inline"><![CDATA[f : X \to  MY]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g : Y \to  MZ]]></fr:tex> is given by <fr:tex
display="block"><![CDATA[X \xrightarrow {f} MY \xrightarrow {Mg} M^2 Z \xrightarrow {\mu } MZ.]]></fr:tex> This forms a category whose objects are the objects of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, as a formal symbol standing for the free algebra generated by those objects, and morphisms are Kleisli arrows. This is the <fr:strong>Kleisli category</fr:strong> <fr:tex
display="inline"><![CDATA[\mathcal {C}_M]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2653</fr:anchor><fr:addr
type="user">ualg-0002</fr:addr><fr:route>ualg-0002.xml</fr:route><fr:title
text="Algebra of a monad">Algebra of a monad</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[M]]></fr:tex>-<fr:strong>algebra</fr:strong> is defined as an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> equipped with a morphism <fr:tex
display="inline"><![CDATA[\alpha  : MX \to  X]]></fr:tex>, such that the following two diagrams commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8f5102f9cbc69c3d35325723042d2fd9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
  {M^2X} & MX & X & MX \\
  MX & X && X
  \arrow["\alpha"', from=2-1, to=2-2]
  \arrow["\alpha", from=1-2, to=2-2]
  \arrow["\mu"', from=1-1, to=2-1]
  \arrow["M\alpha", from=1-1, to=1-2]
  \arrow["\operatorname{id}"', from=1-3, to=2-4]
  \arrow["\eta", from=1-3, to=1-4]
  \arrow["\alpha", from=1-4, to=2-4]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>In an unbiased formulation, we require the natural transformation <fr:tex
display="inline"><![CDATA[M^n \to  M]]></fr:tex> of the monad evaluated at the object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> composed with <fr:tex
display="inline"><![CDATA[\alpha  : MX \to  X]]></fr:tex> to be equal to <fr:tex
display="block"><![CDATA[M^n X \xrightarrow {M^{n-1}\alpha } M^{n-1}X \to  \cdots  \xrightarrow {\alpha } X.]]></fr:tex></fr:p><fr:p>The algebras of a monad form a category <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex>, whose morphisms are commutative squares. This is also known as the <fr:strong>Eilenberg–Moore category</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2655</fr:anchor><fr:addr
type="user">ualg-0003</fr:addr><fr:route>ualg-0003.xml</fr:route><fr:title
text="Free monad algebras">Free monad algebras</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="ualg-0001.xml"
addr="ualg-0001"
title="Monad on a category">monad</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> on a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, there is a canonical adjunction between the <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">category of algebras</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}^M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. The <fr:strong>forgetful functor</fr:strong> <fr:tex
display="inline"><![CDATA[U_M]]></fr:tex> takes an <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebra</fr:link> and forgets the algebra structure. The <fr:strong>free functor</fr:strong> <fr:tex
display="inline"><![CDATA[F_M]]></fr:tex> takes an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and produces an algebra on <fr:tex
display="inline"><![CDATA[MX]]></fr:tex> given by the monad multiplication map <fr:tex
display="inline"><![CDATA[\mu  : M^2 X \to  MX]]></fr:tex>, called the <fr:strong>free algebra</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>980</fr:anchor><fr:addr
type="machine">#238</fr:addr><fr:route>unstable-238.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We verify that they form an adjunction. Algebra homomorphisms <fr:tex
display="inline"><![CDATA[\varphi  : F_M X \to  Y]]></fr:tex> are given by commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="a9a1e034dcfd39c0f1ae7665b6b057d4"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
      {M^2 X} & MY \\
      MX & Y
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    while morphisms <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> fits in the diagram as such: 
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cf98d9db6ddf55aa5c8f4220681e1f2e"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
      {M^2 X} & MY \\
      MX & Y \\
      X
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]
      \arrow["f"', from=3-1, to=2-2]
      \arrow["\eta", from=3-1, to=2-1]
      \arrow[from=2-1, to=1-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Given a homomorphism <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> of algebras, we can compute <fr:tex
display="inline"><![CDATA[f]]></fr:tex> by composing with <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex>. On the other hand, given <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we define <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } Mf]]></fr:tex>. This creates a commutative square because
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \alpha _Y \mathbin {\circ } M \varphi        &= \alpha _Y \mathbin {\circ } M\alpha _Y \mathbin {\circ } M^2 f \\       &= \alpha _Y \mathbin {\circ } \mu  \mathbin {\circ } M^2 f \\       &= \alpha _Y \mathbin {\circ } M f \mathbin {\circ } \mu  \\       &= \varphi  \mathbin {\circ } \mu .     \end {aligned}]]></fr:tex></fr:p>

  <fr:p>We just have to verify that the two conversions are mutual inverses. In one way, we need to verify <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M f \mathbin {\circ } \eta  = f]]></fr:tex>. This is true because by the naturality of <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> we get <fr:tex
display="inline"><![CDATA[M f \mathbin {\circ } \eta  = \eta  \mathbin {\circ } f]]></fr:tex>. Then by the definition of <fr:link
type="local"
href="ualg-0002.xml"
addr="ualg-0002"
title="Algebra of a monad">algebra</fr:link> <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } \eta  = \textrm {id}]]></fr:tex>, proving the equality. On the other hand, we need to show <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M(\varphi  \mathbin {\circ } \eta ) = \varphi ]]></fr:tex>. This follows from the algebra identity <fr:tex
display="inline"><![CDATA[\alpha _Y \mathbin {\circ } M \alpha _Y = \alpha _Y \mathbin {\circ } \mu ]]></fr:tex> and the monad identity <fr:tex
display="inline"><![CDATA[\mu  \mathbin {\circ } M \eta  = \textrm {id}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2657</fr:anchor><fr:addr
type="user">ualg-0001</fr:addr><fr:route>ualg-0001.xml</fr:route><fr:title
text="Monad on a category">Monad on a category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>monad</fr:strong> on a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a functor <fr:tex
display="inline"><![CDATA[M : \mathcal {C} \to  \mathcal {C}]]></fr:tex> equipped with natural transformations <fr:tex
display="inline"><![CDATA[\eta  : \textrm {Id} \to  M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mu  : M \mathbin {\circ } M \to  M]]></fr:tex> satisfying identity and associativity laws. In an unbiased way, we have a family of natural transformations <fr:tex
display="inline"><![CDATA[M^n \to  M]]></fr:tex> with associativity.</fr:p><fr:p>In short, it is a monoid in the category of endofunctors equipped with composition as the monoidal product.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2659</fr:anchor><fr:addr
type="user">hmlg-001R</fr:addr><fr:route>hmlg-001R.xml</fr:route><fr:title
text="Chain reduction generated by a discrete vector field">Chain reduction generated by a discrete vector field</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissible discrete vector field</fr:link> on an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> <fr:tex
display="inline"><![CDATA[(C_k, d)]]></fr:tex>, we can generate a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link>. It will be computable when the cellular complex is <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>646</fr:anchor><fr:addr
type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>The DVF partitions the chain groups into a direct sum <fr:tex
display="inline"><![CDATA[C_k^{s} \oplus  C_k^t \oplus  C_k^c]]></fr:tex>, corresponding to source, target and critical cells. We would like to create a reduction to the critical cells only. To do this, we invoke <fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction">perturbation</fr:link> of the larger chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:link> and start with a simpler chain reduction.</fr:p>

  <fr:p>Consider the algebraic cellular complex whose chain groups are <fr:tex
display="inline"><![CDATA[C_k]]></fr:tex>, but the differential <fr:tex
display="inline"><![CDATA[d'(\sigma ) = \pm  \tau ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\overrightharpoon {\tau  \sigma }]]></fr:tex> is in the vector field, and zero otherwise. The sign is determined as the sign of <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> in <fr:tex
display="inline"><![CDATA[d(\sigma )]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[d' : C_{k+1}^{t} \to  C_k^s]]></fr:tex>, and is zero otherwise. Therefore using the <fr:link
type="local"
href="hmlg-001H.xml"
addr="hmlg-001H"
title="Characterization of chain reduction">characterization of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:link> as a direct sum with a split exact chain complex, we see that this complex can be reduced to the complex on <fr:tex
display="inline"><![CDATA[C_k^p]]></fr:tex> whose differential is identically zero.</fr:p>

  <fr:p>Next, we try to perturb <fr:tex
display="inline"><![CDATA[d']]></fr:tex> to <fr:tex
display="inline"><![CDATA[d]]></fr:tex>. We need <fr:tex
display="inline"><![CDATA[h_{\rho } \mathbin {\circ } (d' - d)]]></fr:tex> to be locally nilpotent, where <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> is the reduction constructed above. <fr:tex
display="inline"><![CDATA[h_{\rho }]]></fr:tex> can be viewed as the inverse of <fr:tex
display="inline"><![CDATA[d']]></fr:tex>, as it maps the source cell to the target cell. Expanding the definition, we see that this map transports cells down the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">discrete field line</fr:link>. Since the vector field is admissible, such a transportation eventually terminates and it becomes zero.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2661</fr:anchor><fr:addr
type="user">hmlg-001S</fr:addr><fr:route>hmlg-001S.xml</fr:route><fr:title
text="Discrete field lines can branch and merge">Discrete field lines can branch and merge</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although we make an analogy between a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link> and a vector field, the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">field lines</fr:link> of a DVF may branch out. For instance, take a triangle <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex> with three edges <fr:tex
display="inline"><![CDATA[\sigma _1, \sigma _2, \sigma _3]]></fr:tex>. We can have a vector <fr:tex
display="inline"><![CDATA[\overrightharpoon {\sigma _1 \tau }]]></fr:tex> pointing into the triangle, and <fr:tex
display="inline"><![CDATA[\sigma _2, \sigma _3]]></fr:tex> each having vectors pointing out. Similarly multiple field lines may join when they reach a lower-degree cell. Because of this, we need to take care in the phrasing of <fr:link
type="local"
href="hmlg-001P.xml"
addr="hmlg-001P"
title="Admissible discrete vector field">admissibility</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2663</fr:anchor><fr:addr
type="user">hmlg-001P</fr:addr><fr:route>hmlg-001P.xml</fr:route><fr:title
text="Admissible discrete vector field">Admissible discrete vector field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link>, if is <fr:strong>admissible</fr:strong> if the lengths of the <fr:link
type="local"
href="hmlg-001Q.xml"
addr="hmlg-001Q"
title="Discrete field line">field lines</fr:link> starting from a cell are bounded. In other words, we can assign a natural number to every cell such that the field lines starting from this cell have length bounded by the number. The number can be different for each cell, and can be unbounded overall.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2665</fr:anchor><fr:addr
type="user">hmlg-001N</fr:addr><fr:route>hmlg-001N.xml</fr:route><fr:title
text="Discrete vector field">Discrete vector field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>discrete vector field</fr:strong> (DVF) of degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> on an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> is given by a collection of pairs of cells <fr:tex
display="inline"><![CDATA[(\sigma , \tau )]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> is a <fr:link
type="local"
href="hmlg-001O.xml"
addr="hmlg-001O"
title="Regular face in an algebraic cellular complex">regular face</fr:link> of the degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, standing for a vector pointing from <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\tau ]]></fr:tex>, which we will write as <fr:tex
display="inline"><![CDATA[\overrightharpoon {\sigma  \tau }]]></fr:tex>. We require that every cell appears at most once in these vectors.</fr:p><fr:p>A DVF naturally partitions the cells into three kinds: the <fr:em>sources</fr:em>, the <fr:em>targets</fr:em>, and the rest of the cells are called <fr:em>critical cells</fr:em>. This name comes from the analogy to Morse theory. Indeed there is a notion of <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Discrete_Morse_theory">discrete Morse function</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2667</fr:anchor><fr:addr
type="user">hmlg-001Q</fr:addr><fr:route>hmlg-001Q.xml</fr:route><fr:title
text="Discrete field line">Discrete field line</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-001N.xml"
addr="hmlg-001N"
title="Discrete vector field">discrete vector field</fr:link>, the discrete version of <fr:strong>field lines</fr:strong> is defined as a sequence of cells alternating between degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> starting and ending with lower-degree cells, with a few requirements.</fr:p><fr:ul><fr:li>When the degree increases, the two cells must occur as a vector in the DVF.</fr:li>
  <fr:li>When the degree decreases, the degree <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> cell must be a (possible non-<fr:link
type="local"
href="hmlg-001O.xml"
addr="hmlg-001O"
title="Regular face in an algebraic cellular complex">regular</fr:link>) face of the degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell.</fr:li>
  <fr:li>Two degree <fr:tex
display="inline"><![CDATA[(p-1)]]></fr:tex> cells separated by a degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> cell must not be the same.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2669</fr:anchor><fr:addr
type="user">hmlg-001O</fr:addr><fr:route>hmlg-001O.xml</fr:route><fr:title
text="Regular face in an algebraic cellular complex">Regular face in an algebraic cellular complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link> and a cell <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>, a <fr:strong>regular face</fr:strong> of <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex> is a cell whose coefficient in <fr:tex
display="inline"><![CDATA[d\sigma ]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\pm  1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2671</fr:anchor><fr:addr
type="user">algm-001T</fr:addr><fr:route>algm-001T.xml</fr:route><fr:title
text="Slice of presheaf category">Slice of presheaf category</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have an equivalence of categories
  <fr:tex
display="block"><![CDATA[\mathsf {Psh}(\mathcal {C})/P \cong  \mathsf {Psh}\left (\int _{\mathcal {C}} P\right ).]]></fr:tex>
  In the special case that <fr:tex
display="inline"><![CDATA[P = \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex>, we have
  <fr:tex
display="block"><![CDATA[\mathsf {Psh}(\mathcal {C})/\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U) \cong  \mathsf {Psh}(\mathcal {C}/U).]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2673</fr:anchor><fr:addr
type="user">algm-001U</fr:addr><fr:route>algm-001U.xml</fr:route><fr:title
text="Slice of sheaf category">Slice of sheaf category</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> with a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link> <fr:tex
display="inline"><![CDATA[J]]></fr:tex> and a sheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, there is a Grothendieck coverage <fr:tex
display="inline"><![CDATA[J']]></fr:tex> on <fr:tex
display="inline"><![CDATA[\int _{\mathcal {C}} F]]></fr:tex> such that the equivalence in <fr:ref
addr="algm-001T"
href="algm-001T.xml"
taxon="Theorem" /> restricts to an equivalence
  <fr:tex
display="block"><![CDATA[\mathsf {Sh}(\mathcal {C}, J)/F \cong  \mathsf {Sh}\left (\int _{\mathcal {C}} F, J'\right ).]]></fr:tex></fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1088</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001U</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose we have a covering sieve <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, then an element <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, F)]]></fr:tex> uniquely corresponds to a matching family <fr:tex
display="inline"><![CDATA[s \in  \hom (S, F)]]></fr:tex>. In the category of elements <fr:tex
display="inline"><![CDATA[\int _{\mathcal {C}} F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s]]></fr:tex> corresponds to a sieve over <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is the required Grothendieck coverage.</fr:p>

  <fr:p>Another way to construct this is through the <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>. The subobject classifier of a slice category is simply <fr:tex
display="inline"><![CDATA[\Omega  \times  F \to  F]]></fr:tex>. Hence we can let <fr:tex
display="inline"><![CDATA[j]]></fr:tex> act on the <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2675</fr:anchor><fr:addr
type="user">algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title
text="Dense subobject of a Lawvere–Tierney operator">Dense subobject of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a subobject <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> is <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex
display="inline"><![CDATA[G \to  \Omega  \xrightarrow {j} \Omega ]]></fr:tex> is the constant true. In terms of the corresponding <fr:tex
display="inline"><![CDATA[J \hookrightarrow  \Omega ]]></fr:tex>, we need the pullback of it with <fr:tex
display="inline"><![CDATA[G \to  \Omega ]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[\textrm {id} : G \to  G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2677</fr:anchor><fr:addr
type="user">algm-001O</fr:addr><fr:route>algm-001O.xml</fr:route><fr:title
text="Exponentials of sheaves">Exponentials of sheaves</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The exponentials of sheaves coincide with those of presheaves. To see this, we assume <fr:tex
display="inline"><![CDATA[X^Y]]></fr:tex> is the exponential of sheaves and calculate
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \Gamma (U, X^Y)     &= \hom _{\mathsf {Psh}}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X^Y) \\     &= \hom _{\mathsf {Sh}}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X^Y) \\     &= \hom _{\mathsf {Sh}}(Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X) \\     &= \hom _{\mathsf {Sh}}(Y^{++} \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)^{++}, X) \\     &= \hom _{\mathsf {Sh}}((Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U))^{++}, X) \\     &= \hom _{\mathsf {Psh}}(Y \times  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X) \\   \end {aligned}]]></fr:tex>
  which is evidently <fr:tex
display="inline"><![CDATA[\Gamma (U, X^Y)]]></fr:tex> but this time the exponential is taken in the category of presheaves. We used the fact that <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">the plus construction preserves finite product</fr:link>. However, we still need to prove that this indeed forms a sheaf.</fr:p><fr:p>Expressing the <fr:link
type="local"
href="algm-001P.xml"
addr="algm-001P"
title="Sheaf condition using Lawvere–Tierney operators">sheaf condition using Lawvere–Tierney operators</fr:link>, we only need to show for <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator">dense subobjects</fr:link> <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> that <fr:tex
display="inline"><![CDATA[\hom (G, X^Y) \to  \hom (F, X^Y)]]></fr:tex> is a bijection. This is equivalent to <fr:tex
display="block"><![CDATA[\hom (Y \times  G, X) \to  \hom (Y \times  F, X).]]></fr:tex> Note that the subobject <fr:tex
display="inline"><![CDATA[Y \times  F \hookrightarrow  Y \times  G]]></fr:tex> corresponds to the characteristic function <fr:tex
display="inline"><![CDATA[Y \times  G \to  G \to  \Omega ]]></fr:tex>. Hence the denseness of <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> implies the denseness of <fr:tex
display="inline"><![CDATA[Y \times  F \hookrightarrow  Y \times  G]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a sheaf, we conclude that <fr:tex
display="inline"><![CDATA[X^Y]]></fr:tex> is also a sheaf.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2679</fr:anchor><fr:addr
type="user">algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title
text="Local object">Local object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a class of arrows <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[S]]></fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for every <fr:tex
display="inline"><![CDATA[f : A \to  B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, the composition map <fr:tex
display="block"><![CDATA[\hom (B, X) \to  \hom (A, X)]]></fr:tex> is an isomorphism.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2681</fr:anchor><fr:addr
type="user">algm-001P</fr:addr><fr:route>algm-001P.xml</fr:route><fr:title
text="Sheaf condition using Lawvere–Tierney operators">Sheaf condition using Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Knowing the <fr:link
type="local"
href="algm-001N.xml"
addr="algm-001N"
title="Grothendieck coverages and Lawvere–Tierney operators">correspondence</fr:link> of Grothendieck coverages on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and Lawvere–Tierney operators on <fr:tex
display="inline"><![CDATA[\mathsf {Psh}(\mathcal {C})]]></fr:tex>, we naturally want to rewrite the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> to use <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operators</fr:link> instead of <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverages</fr:link>.</fr:p><fr:p>Recall that the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> requires for every covering sieve <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> that the composition <fr:tex
display="inline"><![CDATA[\hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), X) \to  \hom (S, X)]]></fr:tex> is an isomorphism. We can reify this to a definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1160</fr:anchor><fr:addr
type="user">algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title
text="Local object">Local object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a class of arrows <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[S]]></fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for every <fr:tex
display="inline"><![CDATA[f : A \to  B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, the composition map <fr:tex
display="block"><![CDATA[\hom (B, X) \to  \hom (A, X)]]></fr:tex> is an isomorphism.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Now we just need to pick out the class of morphisms <fr:tex
display="inline"><![CDATA[S \hookrightarrow  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> using the Lawvere–Tierney operator <fr:tex
display="inline"><![CDATA[j]]></fr:tex>. Note that this operator does not necessarily live in a presheaf topos, so we must find a way to generalize this class of arrows to not necessarily representable presheaves. Since every presheaf is a colimit of representables, we can look at the corresponding colimit of morphisms <fr:tex
display="inline"><![CDATA[\operatorname *{colim} S_i \hookrightarrow  \operatorname *{colim} \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i)]]></fr:tex>. A local object will satisfy
  <fr:tex
display="block"><![CDATA[\begin {aligned}     \hom (\operatorname *{colim}\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i), X) \cong  \lim \hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U_i), X) \quad  \\     \xrightarrow {\sim } \lim \hom (S_i, X) \cong  \hom (\operatorname *{colim} S_i, X).   \end {aligned}]]></fr:tex>
  Hence we can safely include these arrows into the class and still get the same concept of local objects. Now it’s illuminating to look at the characteristic maps. A sieve <fr:tex
display="inline"><![CDATA[S \to  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U)]]></fr:tex> corresponds to a characteristic map in <fr:tex
display="inline"><![CDATA[\hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), \Omega ) \cong  \Gamma (U, \Omega )]]></fr:tex>. Generalizing to an arbitrary presheaf expressed (canonically) as a colimit of representables, we need the image of every section to be a covering sieve.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1162</fr:anchor><fr:addr
type="user">algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title
text="Dense subobject of a Lawvere–Tierney operator">Dense subobject of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a subobject <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex> is <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex
display="inline"><![CDATA[G \to  \Omega  \xrightarrow {j} \Omega ]]></fr:tex> is the constant true. In terms of the corresponding <fr:tex
display="inline"><![CDATA[J \hookrightarrow  \Omega ]]></fr:tex>, we need the pullback of it with <fr:tex
display="inline"><![CDATA[G \to  \Omega ]]></fr:tex> to be <fr:tex
display="inline"><![CDATA[\textrm {id} : G \to  G]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In terms of sieves, for every section <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, G)]]></fr:tex>, the sieve of arrows on <fr:tex
display="inline"><![CDATA[U]]></fr:tex> along whom the restriction of <fr:tex
display="inline"><![CDATA[s]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[F]]></fr:tex> must be a covering sieve. We have arrived at the desired reformulation of the sheaf condition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1164</fr:anchor><fr:addr
type="user">algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title
text="Sheaf of a Lawvere–Tierney operator">Sheaf of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
type="local"
href="algm-001R.xml"
addr="algm-001R"
title="Local object">local object</fr:link> under the <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator"><fr:tex
display="inline"><![CDATA[j]]></fr:tex>-dense monomorphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2683</fr:anchor><fr:addr
type="user">algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title
text="Sheaf of a Lawvere–Tierney operator">Sheaf of a Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex
display="inline"><![CDATA[j]]></fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
type="local"
href="algm-001R.xml"
addr="algm-001R"
title="Local object">local object</fr:link> under the <fr:link
type="local"
href="algm-001Q.xml"
addr="algm-001Q"
title="Dense subobject of a Lawvere–Tierney operator"><fr:tex
display="inline"><![CDATA[j]]></fr:tex>-dense monomorphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2685</fr:anchor><fr:addr
type="user">algm-001N</fr:addr><fr:route>algm-001N.xml</fr:route><fr:title
text="Grothendieck coverages and Lawvere–Tierney operators">Grothendieck coverages and Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> on a presheaf category. Then we may calculate the subobject classifier as in <fr:ref
addr="algm-001M"
href="algm-001M.xml"
taxon="Construction" />.</fr:p><fr:p>By the definition of subobject classifiers, a <fr:link
type="local"
href="algm-001L.xml"
addr="algm-001L"
title="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:link> can be equivalently expressed as a subobject <fr:tex
display="inline"><![CDATA[J \subseteq  \Omega ]]></fr:tex>. Translating the condition of preserving finite intersections, it needs to contain the improper sieve, be upwards closed and closed under finite intersections. And <fr:tex
display="inline"><![CDATA[j \mathbin {\circ } j = j]]></fr:tex> implies the following pullback square:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="d6485766ab43c0c3dfc20100a4403a1f"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}%tex
    J & J \\
    \Omega & \Omega
    \arrow[hook, from=1-2, to=2-2]
    \arrow["j"', from=2-1, to=2-2]
    \arrow[hook, from=1-1, to=2-1]
    \arrow[from=1-1, to=1-2]
    \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  In other words, a sieve is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> iff its image under <fr:tex
display="inline"><![CDATA[j]]></fr:tex> is also contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex>. Unfolding this, a sieve <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> iff the arrows <fr:tex
display="inline"><![CDATA[g]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[J]]></fr:tex> also form a sieve in <fr:tex
display="inline"><![CDATA[J]]></fr:tex>. Looking at the definition of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, we see that they are equivalent, if we regard <fr:tex
display="inline"><![CDATA[J]]></fr:tex> as picking out the covering sieves.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2687</fr:anchor><fr:addr
type="user">algm-001L</fr:addr><fr:route>algm-001L.xml</fr:route><fr:title
text="Lawvere–Tierney operator">Lawvere–Tierney operator</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Lawvere–Tierney operator</fr:strong> is a morphism <fr:tex
display="inline"><![CDATA[j : \Omega  \to  \Omega ]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is the subobject classifier, such that <fr:tex
display="inline"><![CDATA[j]]></fr:tex> preserves finite intersections, and <fr:tex
display="inline"><![CDATA[j \mathbin {\circ } j = j]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2689</fr:anchor><fr:addr
type="user">algm-001M</fr:addr><fr:route>algm-001M.xml</fr:route><fr:title
text="Subobject classifier of presheaves">Subobject classifier of presheaves</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The subobject classifier <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> of presheaves can be given by a quick calculation.
  <fr:tex
display="block"><![CDATA[\Gamma (U, \Omega )   \cong  \hom (\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U), \Omega )   \cong  \operatorname {Sub}(\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(U))]]></fr:tex>
  By definition, this is the set of <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieves</fr:link> on <fr:tex
display="inline"><![CDATA[U]]></fr:tex>, and the functorial action is the <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link>. For a monomorphism <fr:tex
display="inline"><![CDATA[F \hookrightarrow  G]]></fr:tex>, an element <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, G)]]></fr:tex> is sent to the sieve consisting of arrows <fr:tex
display="inline"><![CDATA[f : V \to  U]]></fr:tex> such that the restriction along <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is included in <fr:tex
display="inline"><![CDATA[F]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2691</fr:anchor><fr:addr
type="user">algm-001K</fr:addr><fr:route>algm-001K.xml</fr:route><fr:title
text="Separation of presheaf">Separation of presheaf</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, the inclusion of <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated presheaves</fr:link> to presheaves has a left adjoint <fr:tex
display="inline"><![CDATA[(-)^{\operatorname {sep}}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1254</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001K</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We define <fr:tex
display="inline"><![CDATA[\Gamma (U, P^{\operatorname {sep}})]]></fr:tex> to be a quotient of <fr:tex
display="inline"><![CDATA[\Gamma (U, P)]]></fr:tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <fr:tex
display="inline"><![CDATA[P \to  Q]]></fr:tex> to a separated presheaf, if two sections of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2693</fr:anchor><fr:addr
type="user">algm-001I</fr:addr><fr:route>algm-001I.xml</fr:route><fr:title
text="Sheaf condition in terms of plus construction">Sheaf condition in terms of plus construction</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, the morphism <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex> to its <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link> is a monomorphism iff <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated</fr:link>, and it is an isomorphism iff <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2695</fr:anchor><fr:addr
type="user">algm-001J</fr:addr><fr:route>algm-001J.xml</fr:route><fr:title
text="Sheafification">Sheafification</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Sheafification</fr:strong> is defined as the left adjoint of the inclusion from <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaves</fr:link> to the category of presheaves. Hence it freely constructs a sheaf from a presheaf.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1260</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We construct sheafification as <fr:link
type="local"
href="algm-001G.xml"
addr="algm-001G"
title="Iterated plus construction produces a sheaf">an iterated plus construction</fr:link>. This produces a functor. By <fr:ref
addr="algm-001H"
href="algm-001H.xml"
taxon="Theorem" /> we have a natural bijection
    <fr:tex
display="block"><![CDATA[\hom (P^{++}, F) \cong  \hom (P^+, F) \cong  \hom (P, F).]]></fr:tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^+ \to  P^{++}]]></fr:tex>, we see that the unit of the adjunction is given by the composition <fr:tex
display="inline"><![CDATA[P \to  P^{++}]]></fr:tex>.</fr:p>

  <fr:p>Alternatively, using <fr:ref
addr="algm-001K"
href="algm-001K.xml"
taxon="Construction" />, we may compose two adjunctions to first <fr:link
type="local"
href="algm-001K.xml"
addr="algm-001K"
title="Separation of presheaf">separate</fr:link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2697</fr:anchor><fr:addr
type="user">algm-001H</fr:addr><fr:route>algm-001H.xml</fr:route><fr:title
text="Universal property of plus construction">Universal property of <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex> and sheaf <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, there is a natural bijection <fr:tex
display="block"><![CDATA[\hom (P, F) \cong  \hom (P^+, F)]]></fr:tex> given by composition with <fr:tex
display="inline"><![CDATA[\eta _P : P \to  P^+]]></fr:tex>.</fr:p><fr:p>As a corollary of this and <fr:ref
addr="algm-001G"
href="algm-001G.xml"
taxon="Theorem" />, when restricted to separated presheaves, it is left adjoint to the forgetful functor from sheaves to separated presheaves.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1266</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For every morphism <fr:tex
display="inline"><![CDATA[P \to  F]]></fr:tex>, there is a unique way to extend the map to <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> using the <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf condition</fr:link> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>. A section of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> consists of a matching family <fr:tex
display="inline"><![CDATA[s_f]]></fr:tex>, and it is also the gluing of <fr:tex
display="inline"><![CDATA[\eta _P(s_f)]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2699</fr:anchor><fr:addr
type="user">algm-001A</fr:addr><fr:route>algm-001A.xml</fr:route><fr:title
text="Grothendieck coverage">Grothendieck coverage</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:strong>Grothendieck coverage</fr:strong> declares some <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieves</fr:link> to be coverings, such that the following holds.</fr:p><fr:ul><fr:li>The maximal sieve <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A) \subseteq  \mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex> is always a covering.</fr:li>
  <fr:li>Covering sieves are upwards closed, i.e. if <fr:tex
display="inline"><![CDATA[S \subseteq  S']]></fr:tex> and <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a covering sieve, then so is <fr:tex
display="inline"><![CDATA[S']]></fr:tex>.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a covering sieve of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex> is a morphism, then the <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link> <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is also a covering.</fr:li>
  <fr:li>Suppose <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is a sieve, then the collection of arrows <fr:tex
display="inline"><![CDATA[g]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is a covering is a sieve itself. If this sieve is a covering, then <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is also a covering.</fr:li></fr:ul><fr:p>A Grothendieck coverage can be viewed as a <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">coverage</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2701</fr:anchor><fr:addr
type="user">algm-0019</fr:addr><fr:route>algm-0019.xml</fr:route><fr:title
text="Coverage">Coverage</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>coverage</fr:strong> on an arbitrary category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is given by a family of covers. A <fr:strong>cover</fr:strong> of some object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a family of maps with codomain <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Given a cover <fr:tex
display="inline"><![CDATA[f_i : U_i \to  A]]></fr:tex> and a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, there is a cover of <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that its composition with <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is a <fr:strong>refinement</fr:strong> of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>, in the sense that every map in the cover factors through one of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2703</fr:anchor><fr:addr
type="user">algm-001D</fr:addr><fr:route>algm-001D.xml</fr:route><fr:title
text="Descent data of presheaves">Descent data of presheaves</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> and a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>, a set of <fr:strong>descent data</fr:strong> or a <fr:strong>compatible family</fr:strong> is a morphism <fr:tex
display="inline"><![CDATA[S \to  P]]></fr:tex>. Expanding this, it is a family of <fr:em>local sections</fr:em> <fr:tex
display="inline"><![CDATA[s \in  \Gamma (U, P)]]></fr:tex> assigned for each morphism <fr:tex
display="inline"><![CDATA[U \to  A]]></fr:tex> in the sieve <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, such that the local sections are compatible on restriction. There is an obvious map from the sections <fr:tex
display="inline"><![CDATA[\Gamma (A, P)]]></fr:tex> to the descent data given by restriction.</fr:p><fr:p>More generally, given a general <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">cover</fr:link>, a set of descent data is a family of sections <fr:tex
display="inline"><![CDATA[s_i \in  \Gamma (U_i, P)]]></fr:tex> for each morphism <fr:tex
display="inline"><![CDATA[f_i : U_i \to  A]]></fr:tex> in the cover, such that in any common restriction of <fr:tex
display="inline"><![CDATA[U_i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[U_j]]></fr:tex>, the sections agree. This can be equivalently expressed as the descent data of the sieve generated by the cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2705</fr:anchor><fr:addr
type="user">algm-001G</fr:addr><fr:route>algm-001G.xml</fr:route><fr:title
text="Iterated plus construction produces a sheaf">Iterated <fr:link
type="local"
href="algm-001E.xml"
addr="algm-001E"
title="Plus construction">plus construction</fr:link> produces a sheaf</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any presheaf <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">separated presheaf</fr:link>, and if <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is already separated, <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a <fr:link
type="local"
href="algm-001F.xml"
addr="algm-001F"
title="Sheaf">sheaf</fr:link>. Therefore <fr:tex
display="inline"><![CDATA[P^{++}]]></fr:tex> is always a sheaf.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1290</fr:anchor><fr:addr
type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first prove that <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is separated. Suppose there are two gluings of a set of descent data on a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">covering sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, then we have two sieves <fr:tex
display="inline"><![CDATA[S_1, S_2]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex> with compatible families <fr:tex
display="inline"><![CDATA[s_{1, f}, s_{2, f}]]></fr:tex>. Since they are gluings of the same descent data, the restriction along any morphism <fr:tex
display="inline"><![CDATA[g : U \to  A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex> would be equal. Hence there is a common refinement of <fr:tex
display="inline"><![CDATA[g^* S_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^* S_2]]></fr:tex> where the two families become equal. Expanding this, there is a covering sieve on <fr:tex
display="inline"><![CDATA[U]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h \in  S_1 \cap  S_2]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[h]]></fr:tex> in the sieve, and <fr:tex
display="inline"><![CDATA[s_{1, g \mathbin {\circ } h} = s_{2, g \mathbin {\circ } h}]]></fr:tex>. But then by the axioms of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[h]]></fr:tex> in the said sieve and <fr:tex
display="inline"><![CDATA[g \in  S]]></fr:tex> also generates a covering sieve. Hence <fr:tex
display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_2]]></fr:tex> are already equal on a covering subsieve, and so they are equal in <fr:tex
display="inline"><![CDATA[\Gamma (A, P^+)]]></fr:tex>.</fr:p>

  <fr:p>Let’s see why <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">compatible family</fr:link> of local sections of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> is a family of covering sieves <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex> over <fr:tex
display="inline"><![CDATA[U]]></fr:tex> for each morphism <fr:tex
display="inline"><![CDATA[f : U \to  A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, and for each <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex> a family of sections <fr:tex
display="inline"><![CDATA[s_{f, g} \in  \Gamma (V, P)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[g : V \to  U]]></fr:tex> lies in <fr:tex
display="inline"><![CDATA[S_f]]></fr:tex>. By the axioms of a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link>, the union <fr:tex
display="inline"><![CDATA[\bigcup _{f \in  S} f \mathbin {\circ } S_f]]></fr:tex> is a sieve, since <fr:tex
display="inline"><![CDATA[S_f \subseteq  f^* (f \mathbin {\circ } S_f)]]></fr:tex>. (Warning: <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } S_f]]></fr:tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <fr:tex
display="inline"><![CDATA[s']]></fr:tex> by <fr:tex
display="inline"><![CDATA[s'_{f \mathbin {\circ } g} = s_{f, g}]]></fr:tex>. Hence we need to prove <fr:tex
display="inline"><![CDATA[s_{f, g} = s_{f', g'}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g = f' \mathbin {\circ } g']]></fr:tex>.</fr:p>

  <fr:p>Since the families <fr:tex
display="inline"><![CDATA[s_{f}]]></fr:tex> are compatible, given any <fr:tex
display="inline"><![CDATA[g : V \to  U]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[s_{f, g \mathbin {\circ } r} = s_{f \mathbin {\circ } g, r}]]></fr:tex> for a family of arrows <fr:tex
display="inline"><![CDATA[r]]></fr:tex> that generates a covering sieve on <fr:tex
display="inline"><![CDATA[V]]></fr:tex>. However we cannot necessarily take <fr:tex
display="inline"><![CDATA[r = \textrm {id}]]></fr:tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <fr:tex
display="inline"><![CDATA[s_{f, g \mathbin {\circ } r} = s_{f \mathbin {\circ } g, r}]]></fr:tex> forms a compatible family over <fr:tex
display="inline"><![CDATA[V]]></fr:tex> as <fr:tex
display="inline"><![CDATA[r]]></fr:tex> ranges over the covering sieve. And therefore <fr:tex
display="inline"><![CDATA[s_{f, g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_{f \mathbin {\circ } g, \textrm {id}}]]></fr:tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2707</fr:anchor><fr:addr
type="user">algm-001E</fr:addr><fr:route>algm-001E.xml</fr:route><fr:title
text="Plus construction">Plus construction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001A.xml"
addr="algm-001A"
title="Grothendieck coverage">Grothendieck coverage</fr:link> on <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>, the <fr:strong>plus construction</fr:strong> produces a new presheaf <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> by taking a directed limit over all the <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">descent data</fr:link>. More precisely, we assign <fr:tex
display="block"><![CDATA[\Gamma (A, P^+) = \operatorname *{colim}_{S \text { covers } A} \hom (S, P).]]></fr:tex> This means the sections of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex> are compatible families of sections of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, and two families are considered equal if they are equal on a common covering subsieve.</fr:p><fr:p>Given a map <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, we have a <fr:link
type="local"
href="algm-001C.xml"
addr="algm-001C"
title="Pullback of sieves">pullback</fr:link> <fr:tex
display="inline"><![CDATA[\hom (S, P) \to  \hom (g^*S, P)]]></fr:tex>. This induces the functorial action of <fr:tex
display="inline"><![CDATA[P^+]]></fr:tex>. There is an obvious natural transformation <fr:tex
display="inline"><![CDATA[P \to  P^+]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2709</fr:anchor><fr:addr
type="user">algm-001C</fr:addr><fr:route>algm-001C.xml</fr:route><fr:title
text="Pullback of sieves">Pullback of sieves</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-001B.xml"
addr="algm-001B"
title="Sieve">sieve</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex> over <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a morphism <fr:tex
display="inline"><![CDATA[g : B \to  A]]></fr:tex>, the <fr:strong>pullback</fr:strong> <fr:tex
display="inline"><![CDATA[g^* S]]></fr:tex> is a sieve over <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. <fr:tex
display="inline"><![CDATA[h : C \to  B]]></fr:tex> is in this sieve iff <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } h]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. There is a natural map <fr:tex
display="inline"><![CDATA[g^* S \to  S]]></fr:tex> given by <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } -]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2711</fr:anchor><fr:addr
type="user">algm-001F</fr:addr><fr:route>algm-001F.xml</fr:route><fr:title
text="Sheaf">Sheaf</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> equipped with a <fr:link
type="local"
href="algm-0019.xml"
addr="algm-0019"
title="Coverage">coverage</fr:link>, we define a presheaf <fr:tex
display="inline"><![CDATA[P : \mathcal {C}^\textrm {op} \to  \mathsf {Set}]]></fr:tex> to be a <fr:strong>sheaf</fr:strong> if it satisfies the <fr:strong>sheaf condition</fr:strong>: for every cover of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the map from sections of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> to <fr:link
type="local"
href="algm-001D.xml"
addr="algm-001D"
title="Descent data of presheaves">descent data</fr:link> of the cover is a bijection. It is a <fr:strong>separated presheaf</fr:strong> if the map is an injection.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2713</fr:anchor><fr:addr
type="user">algm-001B</fr:addr><fr:route>algm-001B.xml</fr:route><fr:title
text="Sieve">Sieve</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>sieve</fr:strong> over an object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of an arbitrary category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a subfunctor of <fr:tex
display="inline"><![CDATA[\mathop {\mkern {-2mu}\text {よ}\mkern {-2mu}}(A)]]></fr:tex>. More explicitly, it selects some arrows with codomain <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, such that the selected arrows absorbs composition (i.e. if <fr:tex
display="inline"><![CDATA[f : B \to  A]]></fr:tex> is selected and <fr:tex
display="inline"><![CDATA[g : C \to  B]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f]]></fr:tex> is also selected).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2715</fr:anchor><fr:addr
type="user">hmlg-001M</fr:addr><fr:route>hmlg-001M.xml</fr:route><fr:title
text="Chain reduction of mapping cones">Chain reduction of mapping cones</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reductions</fr:link> <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\rho ' : C' \Rightarrow \mkern {-14mu}\Rightarrow  D']]></fr:tex>, we can construct a reduction from the mapping cone <fr:tex
display="inline"><![CDATA[\operatorname {Cone}(f)]]></fr:tex> of a chain map <fr:tex
display="inline"><![CDATA[f : C \to  C']]></fr:tex> to (the action of <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> on <fr:tex
display="inline"><![CDATA[f]]></fr:tex>).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2717</fr:anchor><fr:addr
type="user">algm-0018</fr:addr><fr:route>algm-0018.xml</fr:route><fr:title
text="A space is noetherian iff hereditarily quasi-compact">A space is noetherian iff hereditarily quasi-compact</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian</fr:link> iff it is <fr:em>hereditarily</fr:em> <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, that is, if all its opens are quasi-compact.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1422</fr:anchor><fr:addr
type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.</fr:p>

  <fr:p>For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2719</fr:anchor><fr:addr
type="user">algm-0016</fr:addr><fr:route>algm-0016.xml</fr:route><fr:title
text="Nike’s trick">Nike’s trick</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The intersections of two <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine</fr:link> subschemes <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_1), \operatorname {Spec}(R_2) \hookrightarrow  X]]></fr:tex> can be covered by affine schemes distinguished in both of them.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1440</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0016</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[R_1]]></fr:tex>. We can pick a distinguished open <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex> contained in the intersection and containing <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>, and a distinguished open <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_1)]]></fr:tex> contained in <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and containing <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>. Now we prove that <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>.</fr:p>

  <fr:p>It suffices to prove that <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>, since this would imply the existence of an element <fr:tex
display="inline"><![CDATA[g'/f^{n} \in  R_2[f^{-1}]]]></fr:tex>, and we can take <fr:tex
display="inline"><![CDATA[D(g') \cap  D(f) = D(g' f)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>. Now there is an inclusion map <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2[f^{-1}]) \to  \operatorname {Spec}(R_1)]]></fr:tex>, which amounts to a ring homomorphism <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem" />. In this case, <fr:tex
display="inline"><![CDATA[D(\varphi (g))]]></fr:tex> is the required distinguished open, since <fr:tex
display="inline"><![CDATA[\varphi ^{-1}D(u)]]></fr:tex> is equal to <fr:tex
display="inline"><![CDATA[D(\varphi (u))]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2721</fr:anchor><fr:addr
type="user">algm-0017</fr:addr><fr:route>algm-0017.xml</fr:route><fr:title
text="Affine local properties">Affine local properties</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose a property on affine subschemes <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex> is closed under taking distinguished subsets <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_f) \hookrightarrow  X]]></fr:tex>, and for <fr:tex
display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>, the property being true on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_{f_i}) \hookrightarrow  X]]></fr:tex> implies it being true on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex>. Then such a property is called <fr:strong>affine local</fr:strong>. We then say that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.</fr:p><fr:p>If the property <fr:tex
display="inline"><![CDATA[P]]></fr:tex> only depends on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> and not <fr:tex
display="inline"><![CDATA[X]]></fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex
display="inline"><![CDATA[P']]></fr:tex> on schemes, which we will usually refer to as <fr:strong>locally</fr:strong> <fr:tex
display="inline"><![CDATA[P]]></fr:tex>. Suppose the scheme is furthermore <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1434</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0017</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We prove that if some affine cover <fr:tex
display="inline"><![CDATA[\{\operatorname {Spec}(R_i) \hookrightarrow  X\}]]></fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex>, using <fr:link
type="local"
href="algm-0016.xml"
addr="algm-0016"
title="Nike’s trick">Nike’s trick</fr:link>, we see that the intersection with <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R_i)]]></fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex> with the said property, and therefore itself also.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2723</fr:anchor><fr:addr
type="user">algm-0015</fr:addr><fr:route>algm-0015.xml</fr:route><fr:title
text="Irreducible space">Irreducible space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:strong>irreducible</fr:strong> iff finitely many non-empty opens always has non-empty intersection. In other words, iff it is non-empty and cannot be written as a union of two closed sets.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2725</fr:anchor><fr:addr
type="user">algm-0014</fr:addr><fr:route>algm-0014.xml</fr:route><fr:title
text="Adjunction of global section and {Spec}">Adjunction of global section and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have an adjunction of functors <fr:tex
display="block"><![CDATA[\mathsf {CRing}^\textrm {op} \xtofrom [\Gamma (\top , \mathscr {O}_{(-)})]{\operatorname {Spec}} \mathsf {Sch},]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> being the right adjoint (or <fr:tex
display="inline"><![CDATA[\operatorname {Spec} : \mathsf {CRing} \to  \mathsf {Sch}^\textrm {op}]]></fr:tex> being the left adjoint). In fact, we can replace <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> with the category of <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\mathsf {LRS}]]></fr:tex>, of whom <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> is a full subcategory.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1462</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0014</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We need to give a natural bijection
    <fr:tex
display="block"><![CDATA[\hom (X, \operatorname {Spec}(R)) \cong  \hom (R, \Gamma (\top , \mathscr {O}_X)).]]></fr:tex>
    In other words, maps <fr:tex
display="inline"><![CDATA[X \to  \operatorname {Spec}(R)]]></fr:tex> between locally ringed spaces are uniquely specified by the action of global sections.</fr:p>

  <fr:p>Since <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is glued from affine open subschemes, a map from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equivalent to a map from each open subscheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S_i)]]></fr:tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <fr:tex
display="inline"><![CDATA[R \to  S_i]]></fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem" />. The elements of <fr:tex
display="inline"><![CDATA[\Gamma (\top , \mathscr {O}_X)]]></fr:tex> are also given by a set of compatible elements from <fr:tex
display="inline"><![CDATA[S_i]]></fr:tex>. Hence these two sets are naturally bijective.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2727</fr:anchor><fr:addr
type="user">algm-0011</fr:addr><fr:route>algm-0011.xml</fr:route><fr:title
text="Characterization of the locale {Proj}(S)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens of the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> are in bijection with graded radical ideals with <fr:tex
display="inline"><![CDATA[\mathfrak {r}_0 = 0]]></fr:tex>. Hence we write <fr:tex
display="inline"><![CDATA[D_+ (\mathfrak {r})]]></fr:tex> for this open. The proof is exactly the same as <fr:ref
addr="algm-0008"
href="algm-0008.xml"
taxon="Theorem" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2729</fr:anchor><fr:addr
type="user">algm-000Z</fr:addr><fr:route>algm-000Z.xml</fr:route><fr:title
text="Geometry of graded rings">Geometry of graded rings</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>To define projective spaces, we start with an affine space, and restricts ourselves to regions invariant under dilation — or using the language of points, we consider lines through the origin as points. Hence we need to define how an element of a ring (which is geometrically a function on the affine space) behaves under dilation.</fr:p><fr:p>In polynomial rings, for example, the polynomial <fr:tex
display="inline"><![CDATA[x^2 + 2y + 7]]></fr:tex> becomes <fr:tex
display="inline"><![CDATA[\lambda ^2 x^2 + 2 \lambda  y + 7]]></fr:tex> under a dilation by <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>. Note how each term can be classified by the power of <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex> it obtains. Hence, what we need is a <fr:strong>grading</fr:strong> on the ring, which partitions <fr:tex
display="inline"><![CDATA[R = \bigoplus _d R_d]]></fr:tex> (as abelian groups). <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex> is intuitively the elements that get the factor <fr:tex
display="inline"><![CDATA[\lambda ^d]]></fr:tex> upon dilation. The multiplication of a degree <fr:tex
display="inline"><![CDATA[p]]></fr:tex> element with a degree <fr:tex
display="inline"><![CDATA[q]]></fr:tex> element should produce a degree <fr:tex
display="inline"><![CDATA[(p+q)]]></fr:tex> element, since <fr:tex
display="inline"><![CDATA[\lambda ^p \lambda ^q = \lambda ^{p+q}]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1494</fr:anchor><fr:addr
type="user">hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title
text="Graded ring">Graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[d \in  D]]></fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block"><![CDATA[R_p \otimes  R_q \to  R_{p+q}]]></fr:tex> and a identity element <fr:tex
display="inline"><![CDATA[1 \in  R_0]]></fr:tex> satisfying the associativity and identity laws.</fr:p><fr:p>Usually, the grading is one of <fr:tex
display="inline"><![CDATA[\mathbb  Z]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex
display="inline"><![CDATA[D^2]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, whatever the context implies the grading is.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The opens of a projective space should come from the non-vanishing region of a homogeneous function, i.e. elements with a single degree. This ensures that dilation doesn’t change the opens. However, we would have multiple ways to represent the entire space: in a two-dimensional affine space, <fr:tex
display="inline"><![CDATA[D(x) \cup  D(y)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(1)]]></fr:tex> are both invariant under dilation, but the former excludes the origin, while the latter does not. In a projective setting, we don’t care about the origin at all, and considering that all homogeneous polynomials of positive degree vanish at the origin, we should make that mandatory. Hence, we only consider the opens corresponding to positively graded elements, which we write as <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex>. We can construct a space similar to the <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">localic spectrum of a commutative ring</fr:link>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1496</fr:anchor><fr:addr
type="user">algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title
text="Projective spectrum of a graded ring">Projective spectrum of a graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-graded ring <fr:tex
display="inline"><![CDATA[S_\bullet ]]></fr:tex>, we construct a locale analogous to <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> for each positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and impose the same relations: <fr:tex
display="inline"><![CDATA[D_+]]></fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex
display="inline"><![CDATA[D_+ (\sum _i f_i) \subseteq  \bigcup _i D_+(f_i)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As for the structure sheaf, we need to decide what the sections over <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> are. They should be functions defined on the affine space <fr:tex
display="inline"><![CDATA[D(f) \subseteq  \operatorname {Spec}(S)]]></fr:tex>, but invariant under dilation. Note that it is stronger than requiring vanishing region be invariant. We actually need the grade <fr:tex
display="inline"><![CDATA[0]]></fr:tex> elements here. Recalling from <fr:link
type="local"
href="algm-000I.xml"
addr="algm-000I"
title="Structure sheaf of a ring spectrum">structure sheaf of a ring spectrum</fr:link> that <fr:tex
display="inline"><![CDATA[\Gamma (D(f), \mathscr {O}_{\operatorname {Spec}(S)}) = S[f^{-1}]]]></fr:tex> (which can be given a canonical grading since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a graded element), we can make the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1498</fr:anchor><fr:addr
type="user">algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title
text="Structure sheaf of {Proj}(S)">Structure sheaf of <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Fix a <fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. For a positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have a graded ring localization <fr:tex
display="inline"><![CDATA[S[f^{-1}]_\bullet ]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D_+(f), \mathscr {O})]]></fr:tex> be the zeroth degree component <fr:tex
display="inline"><![CDATA[S[f^{-1}]_0]]></fr:tex>. This defines a sheaf over the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link>, and moreover gives a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1474</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> the affine scheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> (which is possible because the open subspace <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> is homeomorphic to <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> as a space). Given two positively graded elements <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, we have an isomorphism between <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D_+ (f g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D(g^{\deg  f}/f^{\deg  g})]]></fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2731</fr:anchor><fr:addr
type="user">hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title
text="Graded ring">Graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex
display="inline"><![CDATA[R_d]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[d \in  D]]></fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block"><![CDATA[R_p \otimes  R_q \to  R_{p+q}]]></fr:tex> and a identity element <fr:tex
display="inline"><![CDATA[1 \in  R_0]]></fr:tex> satisfying the associativity and identity laws.</fr:p><fr:p>Usually, the grading is one of <fr:tex
display="inline"><![CDATA[\mathbb  Z]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex
display="inline"><![CDATA[D^2]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, whatever the context implies the grading is.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2733</fr:anchor><fr:addr
type="user">algm-0013</fr:addr><fr:route>algm-0013.xml</fr:route><fr:title
text="Irrelevant ideal">Irrelevant ideal</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-<fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, its <fr:strong>irrelevant ideal</fr:strong> <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex> is defined by the subset <fr:tex
display="inline"><![CDATA[S_+]]></fr:tex> of all positively graded elements.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2735</fr:anchor><fr:addr
type="user">algm-0012</fr:addr><fr:route>algm-0012.xml</fr:route><fr:title
text="Points of the projective spectrum">Points of the projective spectrum</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The points of the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> are given by prime ideals not dividing the <fr:link
type="local"
href="algm-0013.xml"
addr="algm-0013"
title="Irrelevant ideal">irrelevant ideal</fr:link> <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. This is in bijection with ideals with <fr:tex
display="inline"><![CDATA[\mathfrak {p}_0 = 0]]></fr:tex> (equivalently <fr:tex
display="inline"><![CDATA[\mathord {\odot } \nmid  \mathfrak {p}]]></fr:tex>), and the condition for prime ideals holds for positively graded elements, i.e. <fr:tex
display="block"><![CDATA[\mathfrak {p} \mid  x y \iff  (\mathfrak {p} \mid  x \lor  \mathfrak {p} \mid  y)]]></fr:tex> for positively graded <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1468</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>To specify a point <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, we need to specify which opens <fr:tex
display="inline"><![CDATA[D_+(f)]]></fr:tex> it belongs to, where <fr:tex
display="inline"><![CDATA[f]]></fr:tex> ranges over positively graded elements. Equivalently, we specify the closeds <fr:tex
display="inline"><![CDATA[V_+(f)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[V_+(f) \cap  V_+(g) \subseteq  V_+(f + g)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[P \in  V_+(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P \in  V_+(g)]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P \in  V_+(f + g)]]></fr:tex>. Similarly since <fr:tex
display="inline"><![CDATA[V_+(f) \subseteq  V_+(f g)]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P \in  V_+(f)]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[P \in  V_+(f g)]]></fr:tex>. Collecting all the elements whose distinguished closed contains <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, we get an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> whose zeroth degree vanishes.</fr:p>

  <fr:p>We have <fr:tex
display="inline"><![CDATA[V_+(f g) = V_+(f) \cup  V_+(g)]]></fr:tex>, so if <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f g]]></fr:tex>, then either <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  g]]></fr:tex>. This is almost the condition for prime ideals, but recall that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <fr:ref
addr="algm-0011"
href="algm-0011.xml"
taxon="Theorem" />.</fr:p>

  <fr:p>Next, we prove these ideals are in bijection with prime ideals not dividing <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. One direction of the correspondence is obvious: we take a prime ideal <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> and remove the zeroth degree, which amounts to taking <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {p}, \mathord {\odot })]]></fr:tex>.</fr:p>

  <fr:p>We prove injectivity. Suppose primes <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> satisfy <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {p}, \mathord {\odot }) = \operatorname {lcm}(\mathfrak {q}, \mathord {\odot })]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \operatorname {lcm}(\mathfrak {q}, \mathord {\odot }) \mid  \mathfrak {q} \cdot  \mathord {\odot }]]></fr:tex>, so either <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathord {\odot }]]></fr:tex> which is forbidden, or <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {q}]]></fr:tex>. Conversely we must have <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  \mathfrak {p}]]></fr:tex>, hence <fr:tex
display="inline"><![CDATA[\mathfrak {p} = \mathfrak {q}]]></fr:tex>.</fr:p>

  <fr:p>We prove surjectivity. Given an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex>, we need to supplement it with a zeroth degree component <fr:tex
display="inline"><![CDATA[\mathfrak {a}_0]]></fr:tex> so that together they make a prime ideal not divided by <fr:tex
display="inline"><![CDATA[\mathord {\odot }]]></fr:tex>. We define <fr:tex
display="inline"><![CDATA[\mathfrak {a}_0 \mid  c]]></fr:tex> iff there exists some positively graded <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  cf]]></fr:tex>. The verification is routine element chasing.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2737</fr:anchor><fr:addr
type="user">algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title
text="Projective spectrum of a graded ring">Projective spectrum of a graded ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:tex
display="inline"><![CDATA[\mathbb  N]]></fr:tex>-graded ring <fr:tex
display="inline"><![CDATA[S_\bullet ]]></fr:tex>, we construct a locale analogous to <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the <fr:tex
display="inline"><![CDATA[\operatorname {Spec}]]></fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> for each positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and impose the same relations: <fr:tex
display="inline"><![CDATA[D_+]]></fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex
display="inline"><![CDATA[D_+ (\sum _i f_i) \subseteq  \bigcup _i D_+(f_i)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2739</fr:anchor><fr:addr
type="user">algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title
text="Structure sheaf of {Proj}(S)">Structure sheaf of <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Fix a <fr:link
type="local"
href="hmlg-001L.xml"
addr="hmlg-001L"
title="Graded ring">graded ring</fr:link> <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. For a positively graded element <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, we have a graded ring localization <fr:tex
display="inline"><![CDATA[S[f^{-1}]_\bullet ]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D_+(f), \mathscr {O})]]></fr:tex> be the zeroth degree component <fr:tex
display="inline"><![CDATA[S[f^{-1}]_0]]></fr:tex>. This defines a sheaf over the <fr:link
type="local"
href="algm-000Y.xml"
addr="algm-000Y"
title="Projective spectrum of a graded ring">projective spectrum</fr:link>, and moreover gives a <fr:link
type="local"
href="algm-000R.xml"
addr="algm-000R"
title="Scheme">scheme</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1474</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> the affine scheme <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> (which is possible because the open subspace <fr:tex
display="inline"><![CDATA[D_+ (f)]]></fr:tex> is homeomorphic to <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> as a space). Given two positively graded elements <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, we have an isomorphism between <fr:tex
display="inline"><![CDATA[\operatorname {Proj}(S)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D_+ (f g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S[f^{-1}]_0)]]></fr:tex> restricted to <fr:tex
display="inline"><![CDATA[D(g^{\deg  f}/f^{\deg  g})]]></fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2741</fr:anchor><fr:addr
type="user">algm-000W</fr:addr><fr:route>algm-000W.xml</fr:route><fr:title
text="Action of morphisms on stalks of locally ringed spaces">Action of morphisms on stalks of locally ringed spaces</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000S.xml"
addr="algm-000S"
title="Morphism of ringed spaces">morphism of ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\varphi  : X \to  Y]]></fr:tex>, if it is <fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">local</fr:link>, a germ is invertible iff its <fr:link
type="local"
href="algm-000V.xml"
addr="algm-000V"
title="Terminology of pullbacks">pullback</fr:link> under <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is invertible. If the space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has enough points, then the inverse implication is also true.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1560</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Note that the stalk <fr:tex
display="inline"><![CDATA[(\varphi ^{-1}\mathscr {O}_{Y})_x = \mathscr {O}_{Y, \varphi (x)}]]></fr:tex>. A germ being invertible implies for some neighborhood <fr:tex
display="inline"><![CDATA[U]]></fr:tex> of <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, it comes from an invertible section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \varphi ^{-1}\mathscr {O}_Y)]]></fr:tex>, so the image in <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}_X)]]></fr:tex> is also invertible, and hence the image germ. The locality condition gives the converse.</fr:p>

  <fr:p>On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2743</fr:anchor><fr:addr
type="user">algm-000X</fr:addr><fr:route>algm-000X.xml</fr:route><fr:title
text="Morphisms of affine schemes">Morphisms of affine schemes</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">Morphism</fr:link> of <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine schemes</fr:link> are in natural bijection with ring homomorphisms in the opposite direction. In other words, there is a fully faithful embedding <fr:tex
display="inline"><![CDATA[\mathsf {CRing}^\textrm {op} \to  \mathsf {Sch}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr
type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Given two rings <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, a ring homomorphism <fr:tex
display="inline"><![CDATA[\varphi  : S \to  R]]></fr:tex> naturally induces a map of <fr:link
type="local"
href="algm-0004.xml"
addr="algm-0004"
title="Distinguished opens of {Spec}(R)">distinguished opens</fr:link> <fr:tex
display="inline"><![CDATA[f \mapsto  \varphi (f)]]></fr:tex>. This is a continuous map <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R) \to  \operatorname {Spec}(S)]]></fr:tex>, because <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> preserves <fr:tex
display="inline"><![CDATA[\operatorname {lcm}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\gcd ]]></fr:tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <fr:tex
display="inline"><![CDATA[\Gamma (D(s), \mathscr {O}_{\operatorname {Spec}(S)}) \to  \Gamma (D(r), \mathscr {O}_{\operatorname {Spec}(R)})]]></fr:tex> whenever <fr:tex
display="inline"><![CDATA[D(r) \subseteq  \varphi ^{-1}D(s) = D(\varphi (s))]]></fr:tex>. This is just a homomorphism <fr:tex
display="inline"><![CDATA[S[s^{-1}] \to  R[r^{-1}]]]></fr:tex>, which is obvious because <fr:tex
display="inline"><![CDATA[\varphi (s)]]></fr:tex> must be invertible in <fr:tex
display="inline"><![CDATA[R[r^{-1}]]]></fr:tex>.</fr:p>

  <fr:p>We need to prove our map is <fr:link
type="local"
href="algm-000U.xml"
addr="algm-000U"
title="Morphism of locally ringed spaces">local</fr:link>. Using the <fr:link
type="local"
href="algm-000W.xml"
addr="algm-000W"
title="Action of morphisms on stalks of locally ringed spaces">characterization on stalks</fr:link>, we just need to verify that <fr:tex
display="inline"><![CDATA[S_{\varphi ^{-1}(\mathfrak {p})} \to  R_{\mathfrak {p}}]]></fr:tex> reflects invertibility. This is true by construction. Hence we have a map <fr:tex
display="inline"><![CDATA[\hom _{\mathsf {CRing}}(S, R) \to  \hom _{\mathsf {Sch}}(\operatorname {Spec}(R), \operatorname {Spec}(S))]]></fr:tex>.</fr:p>

  <fr:p>In the reverse direction, given a morphism <fr:tex
display="inline"><![CDATA[\varphi  : \operatorname {Spec}(R) \to  \operatorname {Spec}(S)]]></fr:tex>, we can extract a ring homomorphism by looking at the global sections
    <fr:tex
display="block"><![CDATA[S \cong  \Gamma (\top , \varphi ^{-1}\mathscr {O}_{\operatorname {Spec}(S)}) \to  \Gamma (\top , \mathscr {O}_{\operatorname {Spec}(R)}) \cong  R.]]></fr:tex>
    We obviously have going from <fr:tex
display="inline"><![CDATA[\mathsf {CRing}]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathsf {Sch}]]></fr:tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:

    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="c53e81307d06912948fdb79b10c12ad6"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      S & R \\
      {S_{\mathfrak {q}}} & {R_{\mathfrak {p}}}
      \arrow [from=1-1, to=1-2]
      \arrow [from=2-1, to=2-2]
      \arrow [two heads, from=1-1, to=2-1]
      \arrow [two heads, from=1-2, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


    where <fr:tex
display="inline"><![CDATA[\left [\mathfrak {q}\right ]]]></fr:tex> is the image of the point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> under the underlying continuous map of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex>. This fixes the action of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> on the stalks. Furthermore, the <fr:link
type="local"
href="algm-000W.xml"
addr="algm-000W"
title="Action of morphisms on stalks of locally ringed spaces">locality</fr:link> implies the preimage of <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> under the ring homomorphism divides <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and since <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> is maximal in the local ring <fr:tex
display="inline"><![CDATA[S_{\mathfrak {q}}]]></fr:tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2745</fr:anchor><fr:addr
type="user">algm-000V</fr:addr><fr:route>algm-000V.xml</fr:route><fr:title
text="Terminology of pullbacks">Terminology of pullbacks</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In general, a pullback is any contravariant functorial action. In other words, we have a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C}^\textrm {op} \to  \mathcal {D}]]></fr:tex>, and pulling back along a morphism <fr:tex
display="inline"><![CDATA[f]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> means the action of <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex>.</fr:p><fr:p>In differential geometry, we have a set of <fr:tex
display="inline"><![CDATA[k]]></fr:tex>-forms <fr:tex
display="inline"><![CDATA[\Omega ^k(M)]]></fr:tex>, which forms a functor <fr:tex
display="inline"><![CDATA[\mathsf {Mfd}^\textrm {op} \to  \mathsf {Set}]]></fr:tex>. Pullbacks of differential forms is then the functorial action. In the special case of <fr:tex
display="inline"><![CDATA[k = 0]]></fr:tex>, this corresponds to composition, which is sometimes also referred to as pullbacks.</fr:p><fr:p>The categorical pullback can also be construed as a contravariant action, which forms the functor from <fr:tex
display="inline"><![CDATA[\mathcal {C}^\textrm {op}]]></fr:tex> to the <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-category <fr:tex
display="inline"><![CDATA[\mathsf {Cat}]]></fr:tex> given by taking slices.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2747</fr:anchor><fr:addr
type="user">algm-000U</fr:addr><fr:route>algm-000U.xml</fr:route><fr:title
text="Morphism of locally ringed spaces">Morphism of locally ringed spaces</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed spaces</fr:link>, a <fr:link
type="local"
href="algm-000S.xml"
addr="algm-000S"
title="Morphism of ringed spaces">morphism of ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> between them is <fr:strong>local</fr:strong> when sections of <fr:tex
display="inline"><![CDATA[\varphi ^{-1}\mathscr {O}_Y]]></fr:tex> are invertible iff their images in <fr:tex
display="inline"><![CDATA[\mathscr {O}_X]]></fr:tex> are invertible, i.e. the following diagram is a pullback:

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="10f8a1c26eaef8e9e0591acaaadc4d0d"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    {\varphi ^{-1}\mathscr {O}_Y^\times } & {\mathscr {O}_X^\times } \\
    {\varphi ^{-1}\mathscr {O}_Y} & {\mathscr {O}_X}
    \arrow [hook, from=1-1, to=2-1]
    \arrow [hook, from=1-2, to=2-2]
    \arrow [from=1-1, to=1-2]
    \arrow [from=2-1, to=2-2]
    \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  Note that the <fr:link
type="local"
href="algm-000T.xml"
addr="algm-000T"
title="Subsheaf of units">subsheaf of units</fr:link> is given by a finite limit, hence <fr:tex
display="inline"><![CDATA[\varphi ^{-1}]]></fr:tex> preserves it. Since the lower map map <fr:tex
display="inline"><![CDATA[\varphi ^{-1} \mathscr {O}_Y \to  \mathscr {O}_X]]></fr:tex> is a ring homomorphism on the sections, it maps units to units. Hence restriction to the upper map makes sense.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2749</fr:anchor><fr:addr
type="user">algm-000T</fr:addr><fr:route>algm-000T.xml</fr:route><fr:title
text="Subsheaf of units">Subsheaf of units</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a sheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex> of rings, we can define a subsheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}^\times ]]></fr:tex> consisting of the invertible elements, i.e. <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}^\times ) = \Gamma (U, \mathscr {O})^\times ]]></fr:tex>. This is the <fr:strong>subsheaf of units</fr:strong>.</fr:p><fr:p>This can be equivalently expressed as a pullback of <fr:tex
display="inline"><![CDATA[\mathscr {O} \times  \mathscr {O} \xrightarrow {(f,g) \mapsto  f g} \mathscr {O}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[1 \xrightarrow {1} \mathscr {O}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2751</fr:anchor><fr:addr
type="user">algm-000Q</fr:addr><fr:route>algm-000Q.xml</fr:route><fr:title
text="Affine scheme">Affine scheme</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>affine scheme</fr:strong> is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> of the form <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> for some commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2753</fr:anchor><fr:addr
type="user">algm-000O</fr:addr><fr:route>algm-000O.xml</fr:route><fr:title
text="Locally ringed space">Locally ringed space</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locality</fr:link> requirement for a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link> is to guarantee that the sections behave like functions valued in some field.</fr:p><fr:p>It is impossible in general to discuss the vanishing region of a section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \mathscr {O})]]></fr:tex>. For instance, the germs of continuous functions are non-zero on their support, which is the closure of the non-vanishing region. In algebraic geometry, such an overspill destroys most valuable information. We can talk about the maximal region on which the section is invertible, but this is different from being non-zero if sections don’t behave like functions. Similarly, it is also impossible to discuss the value of a section at some point in general. In locally ringed space, we have <fr:ref
addr="algm-000P"
href="algm-000P.xml"
taxon="Definition" />.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2755</fr:anchor><fr:addr
type="user">algm-000S</fr:addr><fr:route>algm-000S.xml</fr:route><fr:title
text="Morphism of ringed spaces">Morphism of ringed spaces</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed spaces</fr:link> <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex>, a morphism <fr:tex
display="inline"><![CDATA[\varphi  : X \to  Y]]></fr:tex> is given by a continuous map of the underlying spaces, and a sheaf morphism <fr:tex
display="inline"><![CDATA[\varphi ^{-1} \mathscr {O}_Y \to  \mathscr {O}_X]]></fr:tex>, equivalently <fr:tex
display="inline"><![CDATA[\mathscr {O}_Y \to  \varphi _* \mathscr {O}_X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2757</fr:anchor><fr:addr
type="user">algm-000R</fr:addr><fr:route>algm-000R.xml</fr:route><fr:title
text="Scheme">Scheme</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>scheme</fr:strong> is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> with an open covering on which the space is isomorphic to <fr:link
type="local"
href="algm-000Q.xml"
addr="algm-000Q"
title="Affine scheme">affine schemes</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2759</fr:anchor><fr:addr
type="user">algm-000P</fr:addr><fr:route>algm-000P.xml</fr:route><fr:title
text="Value of section at a point">Value of section at a point</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> and a section <fr:tex
display="inline"><![CDATA[f \in  \Gamma (U, \mathscr {O})]]></fr:tex>, the germ of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at a point is an element of a local ring. The image of this element in the residue field, i.e. the quotient by the unique maximal ideal is called the <fr:strong>value</fr:strong> of this section at this point.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2761</fr:anchor><fr:addr
type="user">algm-000L</fr:addr><fr:route>algm-000L.xml</fr:route><fr:title
text="Locally ringed space">Locally ringed space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link>, i.e. a space <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with a sheaf of rings <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex>, it is said to be <fr:strong>locally ringed</fr:strong> iff the following conditions hold.</fr:p><fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O}) = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[U]]></fr:tex> is empty.</fr:li>
  <fr:li>Suppose <fr:tex
display="inline"><![CDATA[f + g \in  \Gamma (U, \mathscr {O})]]></fr:tex> is invertible, then we can cover <fr:tex
display="inline"><![CDATA[U]]></fr:tex> with two open sets such that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> are invertible when restricted respectively.</fr:li></fr:ul><fr:p>This can be unified as one condition: If a finite sum in <fr:tex
display="inline"><![CDATA[\Gamma (U, \mathscr {O})]]></fr:tex> is invertible, then each summand is invertible when restricted to an open, which jointly covers <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2763</fr:anchor><fr:addr
type="user">algm-000M</fr:addr><fr:route>algm-000M.xml</fr:route><fr:title
text="Ringed space">Ringed space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>ringed space</fr:strong> is a space equipped with a sheaf of rings, called the <fr:strong>structure sheaf</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2765</fr:anchor><fr:addr
type="user">algm-000K</fr:addr><fr:route>algm-000K.xml</fr:route><fr:title
text="Sheaf and stalk from R-modules">Sheaf and stalk from <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The proofs in <fr:ref
addr="algm-000I"
href="algm-000I.xml"
taxon="Definition" /> and <fr:ref
addr="algm-000J"
href="algm-000J.xml"
taxon="Theorem" /> do not make use of the multiplication on the numerators. Therefore they immediately generalizes to modules. In particular, we have a sheaf corresponding to an <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-module <fr:tex
display="inline"><![CDATA[M]]></fr:tex>, whose sections over <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> form the <fr:tex
display="inline"><![CDATA[R[f^{-1}]]]></fr:tex>-module <fr:tex
display="inline"><![CDATA[M[f^{-1}]]]></fr:tex>. The stalk on <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[M_{\left [\mathfrak {p}\right ]}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2767</fr:anchor><fr:addr
type="user">algm-000J</fr:addr><fr:route>algm-000J.xml</fr:route><fr:title
text="Stalk of the structure sheaf on {Spec}(R)">Stalk of the structure sheaf on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \in  \operatorname {Spec}(R)]]></fr:tex>, the stalk at the point is the localization <fr:tex
display="inline"><![CDATA[R_{\mathfrak {p}}]]></fr:tex>. In particular, the ring spectrum is a <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed space</fr:link> by <fr:ref
addr="algm-000N"
href="algm-000N.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1663</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We take a directed limit. The elements are from some <fr:tex
display="inline"><![CDATA[R[f^{-1}]]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  f]]></fr:tex>, i.e. the elements can be written as <fr:tex
display="inline"><![CDATA[g/f^n]]></fr:tex>. Two elements are equal iff their common restriction to some <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> is equal, i.e. <fr:tex
display="inline"><![CDATA[g_1/f_1^n = g_2/f_2^m]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[(g_1 f_2^m - g_2 f_1^n) f^k = 0]]></fr:tex>. These are exactly the definition of the localization away from <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2769</fr:anchor><fr:addr
type="user">algm-000N</fr:addr><fr:route>algm-000N.xml</fr:route><fr:title
text="Stalks of locally ringed topological space">Stalks of locally ringed topological space</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed</fr:link> topological space, it is <fr:link
type="local"
href="algm-000L.xml"
addr="algm-000L"
title="Locally ringed space">locally ringed</fr:link> iff every stalk is a local ring.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1657</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000N</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.</fr:p>

  <fr:p>In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2771</fr:anchor><fr:addr
type="user">algm-000H</fr:addr><fr:route>algm-000H.xml</fr:route><fr:title
text="Irreducible closeds in a ring spectrum">Irreducible closeds in a ring spectrum</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A closed <fr:tex
display="inline"><![CDATA[V(\mathfrak {r})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is irreducible iff <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> is prime, and it is an irreducible component iff <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> is a minimal prime ideal, i.e. prime ideals that divide no other prime ideals.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1727</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Translating via <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />, we have a proper ideal <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex> that cannot be written as <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {r}_1, \mathfrak {r}_2)]]></fr:tex> non-trivially. Suppose <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  f g]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  \sqrt {f g} \mid  \operatorname {lcm}(f, g)]]></fr:tex>. So
    <fr:tex
display="block"><![CDATA[\begin {aligned}       \mathfrak {r} &= \gcd (\mathfrak {r}, \operatorname {lcm}(f, g)) \\       &= \operatorname {lcm}(\gcd (\mathfrak {r}, f), \gcd (\mathfrak {r}, g)).     \end {aligned}]]></fr:tex>
    Hence at least one of the two must be equal to <fr:tex
display="inline"><![CDATA[\mathfrak {r}]]></fr:tex>. So <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  f]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathfrak {r} \mid  g]]></fr:tex>.</fr:p>

  <fr:p>An irreducible closed is an irreducible <fr:em>component</fr:em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2773</fr:anchor><fr:addr
type="user">algm-000G</fr:addr><fr:route>algm-000G.xml</fr:route><fr:title
text="Noetherian rings and noetherian spaces">Noetherian rings and <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian spaces</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">spectrum</fr:link> of a noetherian ring is always noetherian: the closeds corresponds to radical ideals. The converse does not hold. Consider a polynomial ring with infinitely many indeterminates <fr:tex
display="inline"><![CDATA[x_1, x_2, \dots ]]></fr:tex> quotiented by the relations <fr:tex
display="inline"><![CDATA[x_k^k = 0]]></fr:tex>. <fr:link
type="local"
href="algm-000E.xml"
addr="algm-000E"
title="Ideals under quotient and localization">The ideals in the quotient ring</fr:link> correspond to ideals in the polynomial ring dividing <fr:tex
display="inline"><![CDATA[x_k^k]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[k]]></fr:tex>. So there are only two radical ideals: the trivial one, and the one that divides all indeterminates, but not constants. Hence the spectrum must be a noetherian space, but the ring is obviously not noetherian since it is not finitely generated itself.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2775</fr:anchor><fr:addr
type="user">algm-000I</fr:addr><fr:route>algm-000I.xml</fr:route><fr:title
text="Structure sheaf of a ring spectrum">Structure sheaf of a ring spectrum</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a sheaf <fr:tex
display="inline"><![CDATA[\mathscr {O}]]></fr:tex> of rings on <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> called the <fr:strong>structure sheaf</fr:strong>. Let <fr:tex
display="inline"><![CDATA[\Gamma (D(f), \mathscr {O}) = R[f^{-1}]]]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[D(f) \subseteq  D(g)]]></fr:tex> we define the restriction morphism to be the localization map <fr:tex
display="inline"><![CDATA[R[g^{-1}] \to  R[f^{-1}]]]></fr:tex>, since by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" /> the latter is a further localization of the former. This turns <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> into a <fr:link
type="local"
href="algm-000M.xml"
addr="algm-000M"
title="Ringed space">ringed space</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1502</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex
display="inline"><![CDATA[f_i \in  R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = D(f)]]></fr:tex>, we need to show that
    <fr:tex
display="block"><![CDATA[R[f^{-1}] \to  \prod _{i \in  I} R[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} R[(f_i f_j)^{-1}]]]></fr:tex>
    is an equalizer. Notice that <fr:tex
display="inline"><![CDATA[R[f_i^{-1}] \cong  R[f^{-1}][f_i^{-1}]]]></fr:tex>. So we may reassign <fr:tex
display="inline"><![CDATA[S = R[f^{-1}]]]></fr:tex>. This simplifies the problem to
    <fr:tex
display="block"><![CDATA[S \to  \prod _{i \in  I} S[f_i^{-1}] \rightrightarrows  \prod _{i \ne  j} S[(f_i f_j)^{-1}],]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[D(f_i)]]></fr:tex> covers the whole space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>.</fr:p>

  <fr:p>We first describe the intuition. Since we know <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex> is <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex
display="inline"><![CDATA[g_i/f_i^{d_i} \in  S[f_i^{-1}]]]></fr:tex> that are equal in their common domain. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^{d_i})]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^{d_i}]]></fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f &= \sum _{i \in  I} c_i f_i^{d_i} f \\       &= \sum  c_i f_i^{d_i} \frac {g_i}{f_i^{d_i}} \\       &= \sum  c_i g_i.     \end {aligned}]]></fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.</fr:p>

  <fr:p>Suppose there are elements <fr:tex
display="inline"><![CDATA[g_i/f_i^d \in  S[f_i^{-1}]]]></fr:tex>, where we are allowed to use a single exponent <fr:tex
display="inline"><![CDATA[d]]></fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block"><![CDATA[(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.]]></fr:tex> If there is a solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to the gluing problem, it would need to satisfy <fr:tex
display="inline"><![CDATA[(f f_i^d - g_i) f_i^M = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[D(f_i) = D(f_i^R)]]></fr:tex> covers <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(S)]]></fr:tex>, we have a linear combination <fr:tex
display="inline"><![CDATA[1 = \sum _i c_i f_i^R]]></fr:tex> for large enough <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. Hence
    <fr:tex
display="block"><![CDATA[f = \sum _{i \in  I} c_i f f_i^R = \sum  c_i g_i f_i^{R-d}.]]></fr:tex> This uniquely determines <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex
display="inline"><![CDATA[D(f_j)]]></fr:tex>, we have
    <fr:tex
display="block"><![CDATA[\begin {aligned}       f f_j^d \cdot  f_j^R &= \sum  c_i g_i f_i^{R-d} f_j^{R+d} \\       &= \sum  c_i g_j f_i^{R} f_j^{R} \\       &= g_j f_j^R \cdot  \sum  c_i f_i^R = g_j f_j^R.     \end {aligned}]]></fr:tex>
    This reasoning is valid as long as <fr:tex
display="inline"><![CDATA[R > N + 2d]]></fr:tex>.</fr:p>

  <fr:p>If there are infinitely many opens, we first use <fr:link
type="local"
href="algm-000B.xml"
addr="algm-000B"
title="A ring spectrum is quasi-compact">quasi-compactness</fr:link> to select a finite number <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex
display="inline"><![CDATA[f]]></fr:tex> for <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k)]]></fr:tex>. Then consider the solution on <fr:tex
display="inline"><![CDATA[D(f_1), \dots , D(f_k), D(g)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[g]]></fr:tex>. This solution must be equal to <fr:tex
display="inline"><![CDATA[f]]></fr:tex> by uniqueness. Therefore <fr:tex
display="inline"><![CDATA[f]]></fr:tex> restrict to the correct function on each <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, showing that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the required solution.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2777</fr:anchor><fr:addr
type="user">trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title
text="Style of writing">Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I try to adhere to several principles when composing trees.</fr:p><fr:ul><fr:li>If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.</fr:li>
  <fr:li>Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.</fr:li>
  <fr:li>Apply <fr:link
type="external"
href="https://ncatlab.org/nlab/show/biased+definition">unbiased terminology</fr:link> and <fr:link
type="external"
href="https://ncatlab.org/nlab/show/negative+thinking">negative thinking</fr:link>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2779</fr:anchor><fr:addr
type="user">algm-0009</fr:addr><fr:route>algm-0009.xml</fr:route><fr:title
text="{Spec}{R} is disconnected iff R is a product of non-zero rings"><fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected iff <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a product of non-zero rings</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected iff <fr:tex
display="inline"><![CDATA[R \cong  R_1 \times  R_2]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[R_1, R_2]]></fr:tex> are non-zero commutative rings.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1767</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, if <fr:tex
display="inline"><![CDATA[\operatorname {Spec}{R}]]></fr:tex> is disconnected, we have two opens <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(\mathfrak {b})]]></fr:tex> whose intersection is empty and union is the entire space. In other words radical ideals <fr:tex
display="inline"><![CDATA[\mathfrak {a}, \mathfrak {b}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\sqrt {\gcd (\mathfrak {a}, \mathfrak {b})} = 1]]></fr:tex> (equivalent to <fr:tex
display="inline"><![CDATA[\gcd (\mathfrak {a}, \mathfrak {b}) = 1]]></fr:tex>) and <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {a}, \mathfrak {b}) = 0]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathfrak {b} \mid  b]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[a + b = 1]]></fr:tex>. But <fr:tex
display="inline"><![CDATA[\operatorname {lcm}(\mathfrak {a}, \mathfrak {b}) \mid  a b]]></fr:tex>, therefore <fr:tex
display="inline"><![CDATA[a b = 0]]></fr:tex>. This implies <fr:tex
display="inline"><![CDATA[a(1-a) = 0]]></fr:tex>, or <fr:tex
display="inline"><![CDATA[a^2 = a]]></fr:tex>. The same goes for <fr:tex
display="inline"><![CDATA[b]]></fr:tex>.</fr:p>

  <fr:p>Let <fr:tex
display="inline"><![CDATA[R_1]]></fr:tex> be the subset of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> consisting of multiples of <fr:tex
display="inline"><![CDATA[a]]></fr:tex>. It contains an identity <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[a \cdot  a x = a x]]></fr:tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <fr:tex
display="inline"><![CDATA[R_2]]></fr:tex>, the multiples of <fr:tex
display="inline"><![CDATA[b]]></fr:tex>. There is an obvious map <fr:tex
display="inline"><![CDATA[R_1 \times  R_2 \to  R]]></fr:tex>, given by <fr:tex
display="inline"><![CDATA[(ax, by) \mapsto  ax + by]]></fr:tex>. This is an injection since <fr:tex
display="inline"><![CDATA[z \mapsto  a z]]></fr:tex> recovers the first argument, and <fr:tex
display="inline"><![CDATA[z \mapsto  b z]]></fr:tex> recovers the second. It is also a surjection because <fr:tex
display="inline"><![CDATA[z = a z + b z]]></fr:tex> is the image of <fr:tex
display="inline"><![CDATA[(az, bz)]]></fr:tex>. Hence we found an isomorphism.</fr:p>

  <fr:p>In the other direction, suppose <fr:tex
display="inline"><![CDATA[R \cong  R_1 \times  R_2]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[D((1,0))]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D((0,1))]]></fr:tex> separates the spectrum into two disjoint parts.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2781</fr:anchor><fr:addr
type="user">algm-000F</fr:addr><fr:route>algm-000F.xml</fr:route><fr:title
text="Hilbert basis theorem">Hilbert basis theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is noetherian, then <fr:tex
display="inline"><![CDATA[R[x]]]></fr:tex> is also noetherian.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1773</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}R \subseteq  R]]></fr:tex>. We recursively produce a list of generators. Suppose we have already selected <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex>. If this doesn’t generate <fr:tex
display="inline"><![CDATA[\mathfrak {a}R]]></fr:tex>, then we select another one of the lowest degree. We prove that this procedure terminates.</fr:p>

  <fr:p>Consider the initial coefficient <fr:tex
display="inline"><![CDATA[c_i]]></fr:tex> of <fr:tex
display="inline"><![CDATA[f_i]]></fr:tex>. The ideal <fr:tex
display="inline"><![CDATA[\mathfrak {c}_k]]></fr:tex> generated by the first <fr:tex
display="inline"><![CDATA[k]]></fr:tex> elements must eventually stabilize. Let’s say <fr:tex
display="inline"><![CDATA[c_{n+1} = \sum _{i=1}^n b_i c_i]]></fr:tex>. Then we can subtract <fr:tex
display="inline"><![CDATA[f_{n+1}]]></fr:tex> by suitable multiples of <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex> to cancel the leading term. This must not belong to ideal generated by <fr:tex
display="inline"><![CDATA[f_1, \dots , f_n]]></fr:tex>, which contradicts our choice of generators, being of the lowest degree.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2783</fr:anchor><fr:addr
type="user">algm-000B</fr:addr><fr:route>algm-000B.xml</fr:route><fr:title
text="A ring spectrum is quasi-compact">A <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">ring spectrum</fr:link> is quasi-compact</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The space <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> is always <fr:link
type="local"
href="algm-000A.xml"
addr="algm-000A"
title="Terminology of compactness in algebraic geometry">quasi-compact</fr:link>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1757</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex
display="inline"><![CDATA[\bigcup _i D(f_i) = \top ]]></fr:tex>, then there is a finite union equal to <fr:tex
display="inline"><![CDATA[\top ]]></fr:tex>. Algebraically this means <fr:tex
display="inline"><![CDATA[\sqrt {\gcd \{f_i\}} = 1]]></fr:tex>, equivalently <fr:tex
display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>. So we have a linear combination <fr:tex
display="inline"><![CDATA[\sum _k a_k f_k = 1]]></fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2785</fr:anchor><fr:addr
type="user">algm-000D</fr:addr><fr:route>algm-000D.xml</fr:route><fr:title
text="A closed in a noetherian space is uniquely a finite union of irreducible closeds">A closed in a noetherian space is uniquely a finite union of irreducible closeds</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a <fr:link
type="local"
href="algm-000C.xml"
addr="algm-000C"
title="Noetherian space">noetherian space</fr:link>, then a closed <fr:tex
display="inline"><![CDATA[Z \subseteq  X]]></fr:tex> can be written uniquely as the union of finitely many irreducible closeds.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1779</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> can be written as a finite union. If <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is irreducible then we’re done. Otherwise <fr:tex
display="inline"><![CDATA[Z = Z_1 \cup  Z_2]]></fr:tex> is a non-trivial union of two closeds. By the induction hypothesis <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Z_2]]></fr:tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.</fr:p>

  <fr:p>We then prove uniqueness. Suppose
    <fr:tex
display="block"><![CDATA[Z_1 \cup  \cdots  \cup  Z_n = Z'_1 \cup  \cdots  \cup  Z'_m.]]></fr:tex>
    Consider the intersection with <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex>. The left hand side collapses to <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex>. The right hand side becomes <fr:tex
display="inline"><![CDATA[\bigcup _{i=1}^m (Z'_i \cap  Z_1)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> is irreducible, <fr:tex
display="inline"><![CDATA[Z'_i \cap  Z_1]]></fr:tex> must be either <fr:tex
display="inline"><![CDATA[Z_1]]></fr:tex> or empty. In the former case, since <fr:tex
display="inline"><![CDATA[Z'_i]]></fr:tex> is also irreducible, <fr:tex
display="inline"><![CDATA[Z'_i = Z_1]]></fr:tex>. Therefore each <fr:tex
display="inline"><![CDATA[Z_j]]></fr:tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2787</fr:anchor><fr:addr
type="user">algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title
text="Characterization of the locale {Spec}(R)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens in <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the locale</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> bijectively corresponds to radical ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1490</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We can first put the opens in disjunctive normal form
    <fr:tex
display="block"><![CDATA[U = \bigcup _{i \in  I} \bigcap _{j=1}^{n_i} D(f_{i, j}).]]></fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex
display="inline"><![CDATA[f_i = \prod _j f_{i, j}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[U = \bigcup _i D(f_i)]]></fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex
display="inline"><![CDATA[U]]></fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> can be added, i.e. <fr:tex
display="inline"><![CDATA[D(f) \nsubseteq  U]]></fr:tex>. This would uniquely determine <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>

  <fr:p>Such a saturated set would have to be closed under addition since <fr:tex
display="inline"><![CDATA[D(f+g) \subseteq  D(f) \cup  D(g)]]></fr:tex>, and for the nullary case it must include <fr:tex
display="inline"><![CDATA[D(0) = \bot ]]></fr:tex>. It also has to absorb multiplication, because <fr:tex
display="inline"><![CDATA[D(f \cdot  g) \subseteq  D(f)]]></fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for the union <fr:tex
display="inline"><![CDATA[\bigcup _{\mathfrak {a} \mid  f} D(f)]]></fr:tex>.</fr:p>

  <fr:p>There is one last requirement we haven’t dealt with, i.e. <fr:tex
display="inline"><![CDATA[D(f \cdot  g)]]></fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex
display="inline"><![CDATA[D(f^n) = D(f)]]></fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex
display="inline"><![CDATA[f \cdot  g]]></fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2789</fr:anchor><fr:addr
type="user">algm-0004</fr:addr><fr:route>algm-0004.xml</fr:route><fr:title
text="Distinguished opens of {Spec}(R)">Distinguished opens of <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a basis of opens on <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring"><fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:link> by <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for every element <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>. These are called <fr:strong>distinguished opens</fr:strong>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1589</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0004</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="block"><![CDATA[D(\mathfrak {a}) = \bigcup _{\mathfrak {a} \mid  f} D(f).]]></fr:tex> Alternatively, <fr:tex
display="inline"><![CDATA[V(\mathfrak {a}) = \bigcap _{\mathfrak {a} \mid  f} V(f)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[V(\mathfrak {a}) \subseteq  V(f)]]></fr:tex>, we have the forward inclusion. For the backwards inclusion, suppose <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \notin  V(\mathfrak {a})]]></fr:tex>, i.e. <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  \mathfrak {a}]]></fr:tex>, then by definition there is an element <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  f]]></fr:tex>, meaning that <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ] \notin  V(f)]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2791</fr:anchor><fr:addr
type="user">algm-000E</fr:addr><fr:route>algm-000E.xml</fr:route><fr:title
text="Ideals under quotient and localization">Ideals under quotient and localization</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the ideals of <fr:tex
display="inline"><![CDATA[R/\mathfrak {a}]]></fr:tex> bijectively corresponds to the ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> that divides <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex>. The ideals of <fr:tex
display="inline"><![CDATA[R[S^{-1}]]]></fr:tex> are generated by images of ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> under the localization map, written as <fr:tex
display="inline"><![CDATA[\mathfrak {b}[S^{-1}]]]></fr:tex>, isomorphic to <fr:tex
display="inline"><![CDATA[\mathfrak {b} \otimes _R R[S^{-1}]]]></fr:tex>.</fr:p><fr:p>The prime ideals in <fr:tex
display="inline"><![CDATA[R]]></fr:tex> that doesn’t intersect <fr:tex
display="inline"><![CDATA[S]]></fr:tex> bijectively correspond to prime ideals in <fr:tex
display="inline"><![CDATA[R[S^{-1}]]]></fr:tex> via the localization map.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2793</fr:anchor><fr:addr
type="user">algm-0005</fr:addr><fr:route>algm-0005.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <fr:tex
display="inline"><![CDATA[f/g]]></fr:tex>, so the domain should be the non-vanishing part of <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which we denote as <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1819</fr:anchor><fr:addr
type="user">algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title
text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p><fr:p>For example, on the space given by <fr:tex
display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex
display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex
display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex
display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Recognizing this, we can try to freely generate a locale using <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1821</fr:anchor><fr:addr
type="user">algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a frame generated by the symbols <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>, subject to the following relations:
  <fr:tex
display="block"><![CDATA[\begin {aligned}     D(0) &= \bot  \\     D(1) &= \top  \\     D(f \cdot  g) &= D(f) \cap  D(g) \\     D(f + g) &\subseteq  D(f) \cup  D(g)   \end {aligned}]]></fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1823</fr:anchor><fr:addr
type="user">algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title
text="Characterization of the locale {Spec}(R)">Characterization of the locale <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The opens in <fr:link
type="local"
href="algm-0007.xml"
addr="algm-0007"
title="Localic spectrum of a commutative ring">the locale</fr:link> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> bijectively corresponds to radical ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem" />.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1490</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We can first put the opens in disjunctive normal form
    <fr:tex
display="block"><![CDATA[U = \bigcup _{i \in  I} \bigcap _{j=1}^{n_i} D(f_{i, j}).]]></fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex
display="inline"><![CDATA[f_i = \prod _j f_{i, j}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[U = \bigcup _i D(f_i)]]></fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex
display="inline"><![CDATA[U]]></fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> can be added, i.e. <fr:tex
display="inline"><![CDATA[D(f) \nsubseteq  U]]></fr:tex>. This would uniquely determine <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>

  <fr:p>Such a saturated set would have to be closed under addition since <fr:tex
display="inline"><![CDATA[D(f+g) \subseteq  D(f) \cup  D(g)]]></fr:tex>, and for the nullary case it must include <fr:tex
display="inline"><![CDATA[D(0) = \bot ]]></fr:tex>. It also has to absorb multiplication, because <fr:tex
display="inline"><![CDATA[D(f \cdot  g) \subseteq  D(f)]]></fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for the union <fr:tex
display="inline"><![CDATA[\bigcup _{\mathfrak {a} \mid  f} D(f)]]></fr:tex>.</fr:p>

  <fr:p>There is one last requirement we haven’t dealt with, i.e. <fr:tex
display="inline"><![CDATA[D(f \cdot  g)]]></fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D(g)]]></fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex
display="inline"><![CDATA[D(f^n) = D(f)]]></fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex
display="inline"><![CDATA[f \cdot  g]]></fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2795</fr:anchor><fr:addr
type="user">algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title
text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, we define a frame generated by the symbols <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[f \in  R]]></fr:tex>, subject to the following relations:
  <fr:tex
display="block"><![CDATA[\begin {aligned}     D(0) &= \bot  \\     D(1) &= \top  \\     D(f \cdot  g) &= D(f) \cap  D(g) \\     D(f + g) &\subseteq  D(f) \cup  D(g)   \end {aligned}]]></fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2797</fr:anchor><fr:addr
type="user">algm-000C</fr:addr><fr:route>algm-000C.xml</fr:route><fr:title
text="Noetherian space">Noetherian space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A space is <fr:strong>noetherian</fr:strong> if every descending chain of closeds, or equivalently every ascending chain of opens stabilizes. In other words, the partial order of closeds is well-founded.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2799</fr:anchor><fr:addr
type="user">algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title
text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p><fr:p>For example, on the space given by <fr:tex
display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex
display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex
display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex
display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2801</fr:anchor><fr:addr
type="user">algm-000A</fr:addr><fr:route>algm-000A.xml</fr:route><fr:title
text="Terminology of compactness in algebraic geometry">Terminology of compactness in algebraic geometry</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2803</fr:anchor><fr:addr
type="user">algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title
text="The radical ideal is the lcm of prime ideal divisors">The radical ideal is the lcm of prime ideal divisors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> of a commutative ring, the radical <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}}]]></fr:tex> is the lowest common multiple of the prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1737</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>On one hand, if <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f^n]]></fr:tex> for some natural number <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This means for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f^n]]></fr:tex>, which by being a prime ideal implies <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, we construct a prime ideal divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> that is not a divisor of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Consider the set of all ideals not a divisor of <fr:tex
display="inline"><![CDATA[f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> still in this set, since <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Zorn's_lemma">Zorn’s lemma</fr:link>, the set contains some <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex
display="inline"><![CDATA[\mathfrak {q} \nmid  x, y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {q}' = \gcd (\mathfrak {q}, x y)]]></fr:tex> is a proper divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x y \mid  f^n]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y \mid  f^n]]></fr:tex>, contradiction.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2805</fr:anchor><fr:addr
type="user">algm-0002</fr:addr><fr:route>algm-0002.xml</fr:route><fr:title
text="Radical ideals bijectively correspond to open sets">Radical ideals bijectively correspond to open sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an arbitrary <fr:link
type="local"
href="algm-0001.xml"
addr="algm-0001"
title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</fr:link>, we have <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) = D(\sqrt {\mathfrak {a}})]]></fr:tex>. There is a containment of opens <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) \subseteq  D(\mathfrak {b})]]></fr:tex> — equivalently <fr:tex
display="inline"><![CDATA[V(\mathfrak {b}) \subseteq  V(\mathfrak {a})]]></fr:tex> — iff <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {b}} \mid  \sqrt {\mathfrak {a}}]]></fr:tex>, and the points contained in an open set completely determines the radical ideal.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1733</fr:anchor><fr:addr
type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0002</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {p}} \mid  \sqrt {\mathfrak {a}}]]></fr:tex>, but <fr:tex
display="inline"><![CDATA[\mathfrak {p} = \sqrt {\mathfrak {p}}]]></fr:tex>, we see that <fr:tex
display="inline"><![CDATA[D(\mathfrak {a}) = D(\sqrt {\mathfrak {a}})]]></fr:tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {b} \implies  \mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>. We need to prove that <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f \implies  \sqrt {\mathfrak {b}} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>Given <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex> for all prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \sqrt {\mathfrak {a}}]]></fr:tex> (which is equivalent to <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>). So we know that for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {b}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>. This is now purely a condition on <fr:tex
display="inline"><![CDATA[\mathfrak {b}]]></fr:tex>. The next lemma finishes the proof.</fr:p>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1735</fr:anchor><fr:addr
type="user">algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title
text="The radical ideal is the lcm of prime ideal divisors">The radical ideal is the lcm of prime ideal divisors</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For any ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> of a commutative ring, the radical <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}}]]></fr:tex> is the lowest common multiple of the prime ideals <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1737</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>On one hand, if <fr:tex
display="inline"><![CDATA[\sqrt {\mathfrak {a}} \mid  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  f^n]]></fr:tex> for some natural number <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This means for all <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  \mathfrak {a}]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f^n]]></fr:tex>, which by being a prime ideal implies <fr:tex
display="inline"><![CDATA[\mathfrak {p} \mid  f]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[\mathfrak {a} \nmid  f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, we construct a prime ideal divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> that is not a divisor of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Consider the set of all ideals not a divisor of <fr:tex
display="inline"><![CDATA[f^n]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> still in this set, since <fr:tex
display="inline"><![CDATA[\mathfrak {d}]]></fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Zorn's_lemma">Zorn’s lemma</fr:link>, the set contains some <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex
display="inline"><![CDATA[\mathfrak {q} \nmid  x, y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathfrak {q}' = \gcd (\mathfrak {q}, x y)]]></fr:tex> is a proper divisor of <fr:tex
display="inline"><![CDATA[\mathfrak {q}]]></fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x y \mid  f^n]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\mathfrak {q} \mid  x y \mid  f^n]]></fr:tex>, contradiction.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2807</fr:anchor><fr:addr
type="user">algm-0001</fr:addr><fr:route>algm-0001.xml</fr:route><fr:title
text="Topological spectrum of a commutative ring">Topological spectrum of a commutative ring</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The topological <fr:strong>spectrum</fr:strong> of a commutative ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>, is a topological space whose points are given by prime ideals of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. We denote the point corresponding to <fr:tex
display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex>. We define an open <fr:tex
display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for each ideal <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> which contains the point <fr:tex
display="inline"><![CDATA[\left [\mathfrak {p}\right ]]]></fr:tex> when <fr:tex
display="inline"><![CDATA[\mathfrak {p} \nmid  \mathfrak {a}]]></fr:tex>. The corresponding closed is written as <fr:tex
display="inline"><![CDATA[V(\mathfrak {a})]]></fr:tex>.</fr:p><fr:p>We abuse the notation and write <fr:tex
display="inline"><![CDATA[D(f)]]></fr:tex> for the case where <fr:tex
display="inline"><![CDATA[\mathfrak {a}]]></fr:tex> is generated by <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Similar notations apply to <fr:tex
display="inline"><![CDATA[V]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2809</fr:anchor><fr:addr
type="user">hmlg-001J</fr:addr><fr:route>hmlg-001J.xml</fr:route><fr:title
text="Effective homology">Effective homology</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a mathematical object <fr:tex
display="inline"><![CDATA[X]]></fr:tex> canonically associated with an <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective</fr:link> chain complex <fr:tex
display="inline"><![CDATA[C_\bullet  (X)]]></fr:tex> (e.g. the <fr:link
type="local"
href="hmlg-001U.xml"
addr="hmlg-001U"
title="Algebraic cellular complexes associated with a simplicial set">normalized chain complex</fr:link> of a <fr:link
type="local"
href="hmlg-001T.xml"
addr="hmlg-001T"
title="Effective simplicial set">simplicial set</fr:link>), it is said to be equipped with the structure of <fr:strong>effective homology</fr:strong>, if we have a <fr:link
type="local"
href="hmlg-001I.xml"
addr="hmlg-001I"
title="Strong homology equivalence">strong homology equivalence</fr:link> <fr:tex
display="inline"><![CDATA[C_\bullet  (X) \mathbin {\Leftarrow  \mkern {-13mu} \Leftrightarrow  \mkern {-13mu} \Rightarrow } E_\bullet ]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex> is <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective of finite type</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2811</fr:anchor><fr:addr
type="user">hmlg-001K</fr:addr><fr:route>hmlg-001K.xml</fr:route><fr:title
text="Effective homology">Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes on effective homology and algebraic topology. Main references are <fr:link
type="local"
href="constructive-homological-algebra.xml"
addr="constructive-homological-algebra"
title="Constructive Homological Algebra and Applications">Constructive Homological Algebra and Applications</fr:link> and <fr:link
type="local"
href="discrete-vector-fields.xml"
addr="discrete-vector-fields"
title="Discrete Vector Fields and Fundamental Algebraic Topology">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. We assume basic familiarity with the classical aspects of the theory, although there will also be links within this forest to the relevant concepts.</fr:p><fr:ul><fr:li><fr:link
type="local"
href="hmlg-0021.xml"
addr="hmlg-0021"
title="W-bar construction">W-bar construction</fr:link>, simplicial principal bundles, twisted products by <fr:link
type="local"
href="simplicial-objects.xml"
addr="simplicial-objects"
title="Simplicial objects in algebraic topology">Simplicial objects in algebraic topology</fr:link></fr:li>
  <fr:li>classifying space, loop space</fr:li>
  <fr:li>composition of <fr:link
type="local"
href="hmlg-001I.xml"
addr="hmlg-001I"
title="Strong homology equivalence">strong homology equivalence</fr:link>, tensor product, cone, bicomplex</fr:li>
  <fr:li>simplicial group, Kan complex</fr:li>
  <fr:li>organize into notes</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2813</fr:anchor><fr:addr
type="user">hmlg-001I</fr:addr><fr:route>hmlg-001I.xml</fr:route><fr:title
text="Strong homology equivalence">Strong homology equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>strong homology equivalence</fr:strong> between chain complexes <fr:tex
display="inline"><![CDATA[C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is a span of chain reductions, i.e. a third chain complex <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with <fr:tex
display="inline"><![CDATA[X \Rightarrow \mkern {-14mu}\Rightarrow  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>. We denote a strong homology equivalence with <fr:tex
display="inline"><![CDATA[C \mathbin {\Leftarrow  \mkern {-13mu} \Leftrightarrow  \mkern {-13mu} \Rightarrow } D]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2815</fr:anchor><fr:addr
type="user">hmlg-001G</fr:addr><fr:route>hmlg-001G.xml</fr:route><fr:title
text="Perturbation of the larger chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001G.xml"
addr="hmlg-001G"
title="Perturbation of the larger chain complex in a chain reduction">Perturbation</fr:link> of the larger chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a reduction <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and a perturbation <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex> for <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, we assume that <fr:tex
display="inline"><![CDATA[h_{\rho } \mathbin {\circ } \delta _C]]></fr:tex> is pointwise nilpotent, i.e. <fr:tex
display="block"><![CDATA[\forall  c \in  C_k, \exists  n \in  \mathbb {N}, \; (h_{\rho }\delta _C)^n (c) = 0.]]></fr:tex> We can construct a new chain reduction <fr:tex
display="inline"><![CDATA[\rho ' : C' \Rightarrow \mkern {-14mu}\Rightarrow  D']]></fr:tex>, where <fr:tex
display="inline"><![CDATA[C']]></fr:tex> is <fr:tex
display="inline"><![CDATA[C]]></fr:tex> perturbed by <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex>.</fr:p><fr:p>Note that this situation is much harder compared to <fr:ref
addr="hmlg-001E"
href="hmlg-001E.xml"
taxon="Construction" />, as it is generally impossible without the added condition.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1062</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For this construction using the third equivalent definition of a chain reduction in <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem" />, i.e. a homotopy operator on <fr:tex
display="inline"><![CDATA[C]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } d_C \mathbin {\circ } h = h]]></fr:tex>.</fr:p>

  <fr:p>We need to construct a new homotopy operator such that <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } h' = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } (d_C + \delta _C) \mathbin {\circ } h' = h']]></fr:tex>. We approach this through a “perturbative” mindset. Starting with <fr:tex
display="inline"><![CDATA[h_0 = h]]></fr:tex>, the second equation is off by a difference of <fr:tex
display="inline"><![CDATA[h_0 \delta _C h_0]]></fr:tex>. We simply add this as a correction term, <fr:tex
display="inline"><![CDATA[h_1 = h_0 + \alpha  h_0 \delta _C h_0]]></fr:tex> where <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <fr:tex
display="inline"><![CDATA[h_0 \delta _C h_0 \delta _C \cdots  h_0]]></fr:tex>, since nothing else has the same type.) We still have <fr:tex
display="inline"><![CDATA[h_1 \mathbin {\circ } h_1 = 0]]></fr:tex>, and for the second equation this creates a new error term
    <fr:tex
display="block"><![CDATA[\begin {aligned}       &\quad  h_1 (d_C + \delta _C) h_1 - h_1 \\       &= (1 + \alpha ) h_0 \delta _C h_0 + 2 (\alpha  + \alpha ^2) h_0 \delta _C h_0 \delta _C h_0 + \alpha ^2 h_0 \delta _C h_0 \delta _C h_0 \delta _C h_0     \end {aligned}]]></fr:tex>
    and we can eliminate the first and second order part by setting <fr:tex
display="inline"><![CDATA[\alpha  = -1]]></fr:tex>. The natural next step would be to add a further correction <fr:tex
display="inline"><![CDATA[h_2 = h_1 + \beta  h_0 \delta _C h_0 \delta _C h_0]]></fr:tex>. This turns out to require <fr:tex
display="inline"><![CDATA[\beta  = +1]]></fr:tex>, and so on.</fr:p>

  <fr:p>From the informal discussion above, we can conjecture the formula
    <fr:tex
display="block"><![CDATA[h' = \sum _{k=0}^\infty  (-1)^k (h \delta _C)^k h.]]></fr:tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <fr:tex
display="inline"><![CDATA[h' \mathbin {\circ } h' = 0]]></fr:tex> from <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex>, and the second equation follows from a nice telescopic sum
    <fr:tex
display="block"><![CDATA[\begin {aligned}       h' \mathbin {\circ } (d_C + \delta _C) \mathbin {\circ } h'       &= \sum _{i, j} (-1)^{i + j} (h \delta _C)^i h (d_C + \delta _C) (h \delta _C)^j h \\       &= \sum _{i, j} (-1)^{i + j} \left [(h \delta _C)^{i + j + 1} h + (h \delta _C)^{i + j} h\right ] \\       &= \sum _{k} (k+1) (-1)^k \left [(h \delta _C)^{k + 1} h + (h \delta _C)^k h\right ] \\       &= \sum _k (-1)^k (h \delta _C)^k h = h'.     \end {aligned}]]></fr:tex></fr:p>

  <fr:p>We can reconstruct the other two components of the reduction <fr:tex
display="inline"><![CDATA[\iota _{\rho '}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{\rho '}]]></fr:tex> through <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem" />. In particular, <fr:tex
display="inline"><![CDATA[D']]></fr:tex> is given by a perturbation of <fr:tex
display="inline"><![CDATA[D]]></fr:tex>. We only write down the results below for easy reference.
    <fr:tex
display="block"><![CDATA[\begin {aligned}     \pi _{\rho '} &= \sum _{k=0}^\infty  (-1)^k \pi _{\rho } (\delta _C h_{\rho })^k \\     \iota _{\rho '} &= \sum _{k=0}^\infty  (-1)^k (h_{\rho } \delta _C)^k \iota _{\rho } \\     \delta _D &= \sum _{k=0}^\infty  (-1)^k \pi _{\rho } \delta _C (h_{\rho } \delta _C)^k \iota _{\rho }.     \end {aligned}]]></fr:tex></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2817</fr:anchor><fr:addr
type="user">hmlg-001H</fr:addr><fr:route>hmlg-001H.xml</fr:route><fr:title
text="Characterization of chain reduction">Characterization of <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The following data are equivalent.</fr:p><fr:ul><fr:li>A <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>.</fr:li>
  <fr:li>A splitting <fr:tex
display="inline"><![CDATA[C \cong  D \oplus  E]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>.</fr:li>
  <fr:li>A <fr:link
type="local"
href="hmlg-0016.xml"
addr="hmlg-0016"
title="Chain homotopy">chain homotopy</fr:link> <fr:tex
display="inline"><![CDATA[h : C \to  C]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } d_C \mathbin {\circ } h = h]]></fr:tex>.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1066</fr:anchor><fr:addr
type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A chain reduction consists of maps <fr:tex
display="inline"><![CDATA[C_k \mathrel {\smash {\xtofrom [g_k]{f_k}}} D_k]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f_k \mathbin {\circ } g_k = \textrm {id}]]></fr:tex>. Therefore <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">splits</fr:link> as <fr:tex
display="inline"><![CDATA[D_\bullet  \oplus  E_\bullet ]]></fr:tex>, and the boundary maps are preserved since <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> are chain maps. We have a homotopy <fr:tex
display="inline"><![CDATA[h_k : D_k \oplus  E_k \to  D_{k+1} \oplus  E_{k+1}]]></fr:tex>, which we may write as a <fr:tex
display="inline"><![CDATA[(2 \times  2)]]></fr:tex>-matrix. <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } h = 0]]></fr:tex> demands the first row to be zero, and <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } g = 0]]></fr:tex> requires the first column to vanish. This leaves us with
    <fr:tex
display="block"><![CDATA[\begin {bmatrix}       0 & 0 \\       0 & r_k     \end {bmatrix}]]></fr:tex>
    such that <fr:tex
display="inline"><![CDATA[r_{k+1} \mathbin {\circ } r_k = 0]]></fr:tex>, since <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } h = 0]]></fr:tex>.</fr:p>

  <fr:p>Substituting the requirement that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a homotopy <fr:tex
display="inline"><![CDATA[\textrm {id} \to  g \mathbin {\circ } f]]></fr:tex>, we get the equation <fr:tex
display="block"><![CDATA[d_{k+1} \mathbin {\circ } r_k + r_{k-1} \mathbin {\circ } d_k = \textrm {id},]]></fr:tex> where <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is the boundary operator on <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex>. In other words, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is a null-homotopy of <fr:tex
display="inline"><![CDATA[E_\bullet ]]></fr:tex>, rendering it <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>. Conversely, given <fr:tex
display="inline"><![CDATA[C \cong  D \oplus  E]]></fr:tex>, we can reconstruct <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as the projection and inclusion maps, with <fr:tex
display="inline"><![CDATA[h]]></fr:tex> obtained out of <fr:tex
display="inline"><![CDATA[r]]></fr:tex> in the manner depicted above.</fr:p>

  <fr:p>On the other hand, given only the homotopy operator, we expect to have <fr:tex
display="inline"><![CDATA[d \mathbin {\circ } h + h \mathbin {\circ } d = \textrm {id} - g \mathbin {\circ } f]]></fr:tex>. And since <fr:tex
display="inline"><![CDATA[g \mathbin {\circ } f]]></fr:tex> should be the projector of <fr:tex
display="inline"><![CDATA[C]]></fr:tex> onto the subspace <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\textrm {id} - g \mathbin {\circ } f]]></fr:tex> should be the projector onto <fr:tex
display="inline"><![CDATA[E]]></fr:tex>. We are thus led to proving <fr:tex
display="inline"><![CDATA[p = d \mathbin {\circ } h + h \mathbin {\circ } d]]></fr:tex> is indeed a projector.
    <fr:tex
display="block"><![CDATA[\begin {aligned}       p_k \mathbin {\circ } p_k &= (d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k) \mathbin {\circ } (d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k) \\       &= d_{k+1} \mathbin {\circ } \overbrace {h_k \mathbin {\circ } d_{k+1} \mathbin {\circ } h_k}^{h_k} + d_{k+1} \mathbin {\circ } \overbrace {h_k \mathbin {\circ } h_{k-1}}^{0} \mathbin {\circ } d_k \\       &\qquad  + h_{k-1} \mathbin {\circ } \underbrace {d_k \mathbin {\circ } d_{k+1}}_{0} \mathbin {\circ } h_k + \underbrace {h_{k-1} \mathbin {\circ } d_k \mathbin {\circ } h_{k-1}}_{h_{k-1}} \mathbin {\circ } d_k \\       &= d_{k+1} \mathbin {\circ } h_k + h_{k-1} \mathbin {\circ } d_k = p_k.     \end {aligned}]]></fr:tex>
    Therefore we conclude that <fr:tex
display="inline"><![CDATA[p_k]]></fr:tex> splits <fr:tex
display="inline"><![CDATA[C_k \cong  D_k \oplus  E_k]]></fr:tex>. More over, <fr:tex
display="inline"><![CDATA[p \mathbin {\circ } d = d \mathbin {\circ } h \mathbin {\circ } d = d \mathbin {\circ } p]]></fr:tex>, meaning <fr:tex
display="inline"><![CDATA[p]]></fr:tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <fr:tex
display="inline"><![CDATA[h \mathbin {\circ } p = p \mathbin {\circ } h = h \mathbin {\circ } d \mathbin {\circ } h = h]]></fr:tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <fr:tex
display="inline"><![CDATA[E_k]]></fr:tex> to get a homotopy from <fr:tex
display="inline"><![CDATA[\textrm {id}_E]]></fr:tex> to <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>

  <fr:p>Finally, restricting <fr:tex
display="inline"><![CDATA[h]]></fr:tex> onto <fr:tex
display="inline"><![CDATA[D_k]]></fr:tex> we see that it must be zero, since <fr:tex
display="inline"><![CDATA[h(\textrm {id} - p) = h - h \mathbin {\circ } d \mathbin {\circ } h = 0]]></fr:tex>. This means that all the information of <fr:tex
display="inline"><![CDATA[h]]></fr:tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2819</fr:anchor><fr:addr
type="user">hmlg-001E</fr:addr><fr:route>hmlg-001E.xml</fr:route><fr:title
text="Perturbation of the smaller chain complex in a chain reduction"><fr:link
type="local"
href="hmlg-001C.xml"
addr="hmlg-001C"
title="Perturbation of chain complex">Perturbation</fr:link> of the smaller chain complex in a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a reduction <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex> and a perturbation <fr:tex
display="inline"><![CDATA[\delta _D]]></fr:tex> for <fr:tex
display="inline"><![CDATA[D]]></fr:tex>, we can construct a perturbation <fr:tex
display="inline"><![CDATA[\delta _C]]></fr:tex> for <fr:tex
display="inline"><![CDATA[C]]></fr:tex>, such that the same <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> can serve as a reduction of the perturbed chain complexes.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1949</fr:anchor><fr:addr
type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Let the reduction <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> be made out of the three maps <fr:tex
display="inline"><![CDATA[\pi _{\rho } : C \to  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\iota _{\rho } : D \to  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h_{\rho } : C \to  C]]></fr:tex>. Then since <fr:tex
display="inline"><![CDATA[C]]></fr:tex> splits as the direct sum of <fr:tex
display="inline"><![CDATA[D]]></fr:tex> and an <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">acyclic</fr:link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <fr:tex
display="inline"><![CDATA[\delta _C = \iota _{\rho } \mathbin {\circ } \delta _D \mathbin {\circ } \pi _{\rho }]]></fr:tex>. A quick computation shows that <fr:tex
display="inline"><![CDATA[\rho ]]></fr:tex> is still a reduction of the perturbed chain complexes.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2821</fr:anchor><fr:addr
type="user">hmlg-001B</fr:addr><fr:route>hmlg-001B.xml</fr:route><fr:title
text="Terminology of effective algebraic cellular complex">Terminology of <fr:link
type="local"
href="hmlg-001A.xml"
addr="hmlg-001A"
title="Effective algebraic cellular complex">effective <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:link></fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The terminology chosen here differs from that in <fr:link
type="local"
href="kenzo.xml"
addr="kenzo"
title="Kenzo">Kenzo</fr:link>. What we call effective is named <fr:em>locally effective</fr:em>; and what we call effective of finite type is named <fr:em>effective</fr:em> instead.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2823</fr:anchor><fr:addr
type="user">hmlg-001D</fr:addr><fr:route>hmlg-001D.xml</fr:route><fr:title
text="Geometric interpretation of algebraic cellular complex">Geometric interpretation of <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An ACC can be viewed as the algebraic distillation of a <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complex</fr:link>. The generators in dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are regarded as <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-cells. However, we only record a formal sum of the boundaries, and forget the exact configuration. Hence, ACC is a suitable middle ground for both geometric transformations and algebraic operations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2825</fr:anchor><fr:addr
type="user">hmlg-001F</fr:addr><fr:route>hmlg-001F.xml</fr:route><fr:title
text="Geometric interpretation of perturbations">Geometric interpretation of <fr:link
type="local"
href="hmlg-001C.xml"
addr="hmlg-001C"
title="Perturbation of chain complex">perturbations</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">ACCs</fr:link>, the effect of a perturbation is to “reconnect” the cells. But it may not create or delete cells, since the abelian groups are unchanged.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2827</fr:anchor><fr:addr
type="user">hmlg-001C</fr:addr><fr:route>hmlg-001C.xml</fr:route><fr:title
text="Perturbation of chain complex">Perturbation of chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>perturbation</fr:strong> of a chain complex with boundary operator <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is an operator <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> of degree <fr:tex
display="inline"><![CDATA[(-1)]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[d + \delta ]]></fr:tex> also forms a boundary operator.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2829</fr:anchor><fr:addr
type="user">hmlg-001A</fr:addr><fr:route>hmlg-001A.xml</fr:route><fr:title
text="Effective algebraic cellular complex">Effective <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-0013.xml"
addr="hmlg-0013"
title="Algebraic cellular complex">algebraic cellular complex</fr:link>, suppose we can encode the basis sets <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> such that they have <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">decidable equality</fr:link>, and the maps <fr:tex
display="inline"><![CDATA[C_k \to  \mathbb {Z}[C_{k-1}]]]></fr:tex> are computable, then we say the ACC is <fr:strong>effective</fr:strong>. Suppose further that <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> are (computably) finite sets, then we say it is <fr:strong>effective of finite type</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2831</fr:anchor><fr:addr
type="user">hmlg-0018</fr:addr><fr:route>hmlg-0018.xml</fr:route><fr:title
text="An additive functor is exact iff it preserves quasi-isomorphisms">An additive functor is exact iff it preserves quasi-isomorphisms</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian categories</fr:link>, it is <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link> iff it sends <fr:link
type="local"
href="hmlg-000C.xml"
addr="hmlg-000C"
title="Quasi-isomorphism">quasi-isomorphisms</fr:link> to quasi-isomorphisms.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2029</fr:anchor><fr:addr
type="machine">#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.</fr:p>

  <fr:p>On the other hand, <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex
display="inline"><![CDATA[f : C_\bullet  \to  D_\bullet ]]></fr:tex> is a quasi-isomorphism, <fr:tex
display="inline"><![CDATA[H_n (f)]]></fr:tex> are all isomorphisms. Therefore <fr:tex
display="inline"><![CDATA[H_n (F(f)) = F(H_n(f))]]></fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2833</fr:anchor><fr:addr
type="user">hmlg-0016</fr:addr><fr:route>hmlg-0016.xml</fr:route><fr:title
text="Chain homotopy">Chain homotopy</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[D_\bullet ]]></fr:tex> with two <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain maps</fr:link> <fr:tex
display="inline"><![CDATA[f, g : C \to  D]]></fr:tex> between them, a <fr:strong>chain homotopy</fr:strong> from <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is given by a family of maps <fr:tex
display="inline"><![CDATA[h_n : C_n \to  D_{n+1}]]></fr:tex>, such that
  <fr:tex
display="block"><![CDATA[d_{n+1} \mathbin {\circ } h_n + h_{n-1} \mathbin {\circ } d_n = f_n - g_n.]]></fr:tex>
  Note that the two <fr:tex
display="inline"><![CDATA[d]]></fr:tex>’s denote the boundary map of different chain complexes.</fr:p><fr:p>The chain homotopy can be written as <fr:tex
display="inline"><![CDATA[h : f \to  g]]></fr:tex> or as <fr:tex
display="inline"><![CDATA[h : C \to  D]]></fr:tex>. This causes no confusion, and the latter is convenient in situations where the maps <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> matter less than their difference <fr:tex
display="inline"><![CDATA[f - g]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2835</fr:anchor><fr:addr
type="user">hmlg-0017</fr:addr><fr:route>hmlg-0017.xml</fr:route><fr:title
text="Chain reduction">Chain reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C, D]]></fr:tex>, a <fr:strong>chain reduction</fr:strong> consists of a chain map <fr:tex
display="inline"><![CDATA[\pi  : C \to  D]]></fr:tex>, a chain map <fr:tex
display="inline"><![CDATA[\iota  : D \to  C]]></fr:tex> and a <fr:link
type="local"
href="hmlg-0016.xml"
addr="hmlg-0016"
title="Chain homotopy">chain homotopy</fr:link> <fr:tex
display="inline"><![CDATA[h : \textrm {id} \to  g \mathbin {\circ } f]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\pi  \mathbin {\circ } \iota  = \textrm {id}]]></fr:tex>, and <fr:tex
display="block"><![CDATA[\pi  \mathbin {\circ } h = h \mathbin {\circ } \iota  = h \mathbin {\circ } h = 0.]]></fr:tex> Here the compositions are understood to have the appropriate subscript so the degrees match.</fr:p><fr:p>We write the reduction as <fr:tex
display="inline"><![CDATA[\rho  : C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>. The three components are denoted <fr:tex
display="inline"><![CDATA[\pi _{\rho } : C \to  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\iota _{\rho } : D \to  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h_{\rho } : C \to  C]]></fr:tex>, respectively.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2837</fr:anchor><fr:addr
type="user">hmlg-0019</fr:addr><fr:route>hmlg-0019.xml</fr:route><fr:title
text="Chain reduction">Chain reduction</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For a <fr:link
type="local"
href="hmlg-0017.xml"
addr="hmlg-0017"
title="Chain reduction">chain reduction</fr:link> <fr:tex
display="inline"><![CDATA[C \Rightarrow \mkern {-14mu}\Rightarrow  D]]></fr:tex>, <fr:tex
display="inline"><![CDATA[D]]></fr:tex> is embedded as a subcomplex of <fr:tex
display="inline"><![CDATA[C]]></fr:tex>. It is cleanly separated, indicating that <fr:link
type="local"
href="hmlg-001H.xml"
addr="hmlg-001H"
title="Characterization of chain reduction">it is split</fr:link>. The other part of <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">split exact</fr:link>, and so its homology component is drawn as empty, with the components separated.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="70dedd655193094be204fbef08bd4044"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  %tex
  \begin{scope}
    \clip (-1.9, -1.4) rectangle (5.9, 1.7);
    \tikzset{every path/.style={thick}}

    \draw (-3.6,0) -- (-0.4,0) arc (0:180:1.6);
    \draw (-1.6,0) -- (1.6,0) arc (0:180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4,0) -- (3.6,0) arc (0:180:1.6);
    \draw (2.4,0) -- (5.6,0) arc (0:180:1.6);
    \draw (4.4,0) -- (7.6,0) arc (0:180:1.6);

    % arccos(1/1.6) = 51.318deg
    \draw (-1.6, -0.1) -- (-0.4, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4, -0.1) -- (1.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (2.4, -0.1) -- (3.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \draw (4.4, -0.1) -- (5.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
  \end{scope}
  \node at (2, -1.6) {\(C_n\)};
  \node at (2, 1.1) {\(H_n\)};
  \draw[thick, decoration={brace, mirror}, decorate] (-2.1, 1.6) -- node[left] {\(C_\bullet\)} (-2.1, -1.35);
  \draw[thick, decoration={brace}, decorate] (6.1, 1.6) -- node[right] {\(D_\bullet\)} (6.1, 0);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2839</fr:anchor><fr:addr
type="user">hmlg-0013</fr:addr><fr:route>hmlg-0013.xml</fr:route><fr:title
text="Algebraic cellular complex">Algebraic cellular complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>algebraic cellular complex</fr:strong> (or ACC) is a <fr:link
type="local"
href="hmlg-0002.xml"
addr="hmlg-0002"
title="Chain complex of abelian groups">chain complex</fr:link> of free abelian groups. The generators are called <fr:strong>cells</fr:strong>, and the boundary maps can be expressed using the generators as a basis, yielding the <fr:strong>incidence matrices</fr:strong>.</fr:p><fr:p>More precisely, we may define an ACC as a sequence of sets <fr:tex
display="inline"><![CDATA[C_\bullet ]]></fr:tex>, with a sequence of functions <fr:tex
display="inline"><![CDATA[d : C_k \to  \mathbb {Z}[C_{k-1}]]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is satisfied. When a generator has non-zero coefficient in some <fr:tex
display="inline"><![CDATA[d\sigma ]]></fr:tex>, the generator is called a <fr:strong>face</fr:strong> of <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>.</fr:p><fr:p>Note that the generators of these chain groups are <fr:link
type="local"
href="ualg-0006.xml"
addr="ualg-0006"
title="Objects of the Kleisli category">canonically chosen</fr:link> as part of the data. So a more accurate definition is a chain complex in the <fr:link
type="local"
href="ualg-0004.xml"
addr="ualg-0004"
title="The Kleisli category of a monad">Kleisli category</fr:link> of abelian groups.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2841</fr:anchor><fr:addr
type="user">hmlg-0014</fr:addr><fr:route>hmlg-0014.xml</fr:route><fr:title
text="Filtered object">Filtered object</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can visualize a filtered object <fr:tex
display="inline"><![CDATA[F_1 A \subseteq  F_2 A \subseteq  F_3 A \subseteq  A]]></fr:tex> as nested rectangles. The graded components of this filtration are the individual rectangular regions.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="3c05fffcc0c2aff9060e6b53726e0007"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  \tikzset {every path/.style={thick, fill = blue!80!yellow, fill opacity = 0.1}}
  \filldraw  (0,-1) rectangle (4,1);
  \filldraw  (0,-1) rectangle (3,1);
  \filldraw  (0,-1) rectangle (2,1);
  \filldraw  (0,-1) rectangle (1,1);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2843</fr:anchor><fr:addr
type="user">hmlg-0015</fr:addr><fr:route>hmlg-0015.xml</fr:route><fr:title
text="Filtered chain complex">Filtered chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Combining <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization" /> and <fr:ref
addr="hmlg-0014"
href="hmlg-0014.xml"
taxon="Visualization" />, we arrive at the following picture. Each family of colors corresponds to the filtration <fr:tex
display="inline"><![CDATA[F_\bullet  C_n]]></fr:tex> in one dimension, and the different shades corresponds to the degree in the filtration.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="b55e54a19c8b33ac97aac70df87d7ce3"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
  \tikzset {every path/.style={thick, fill opacity = 0.2, line join = round}}
  \foreach  \depth  in {4,3,2,1} {
    \fill [blue!80!yellow] (-4,4) -- (0,0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
    \fill [green!80!purple] (0,0) -- (4,4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
    \fill [yellow!80!red] (4,4) -- (8,0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
  }

  \foreach  \depth  in {4,3,2,1} {
    \draw  ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
    \draw  ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
    \draw  ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
  }
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>Note that we arranged so that only the higher degree (i.e. the lighter color) components may touch the lower degree components in the next dimension. So the intersection is a triangle shape instead of a complete diamond grid. This corresponds to the requirement that the boundary map sends <fr:tex
display="inline"><![CDATA[F_i C_j]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F_i C_{j+1}]]></fr:tex>.</fr:p><fr:p>We can see the associated spectral sequences directly from the visualization. We start with the graded components, which form strands of chain complexes. Here the second degree is highlighted.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="503f03422a46aab9e25b88aafcb49af9"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \tikzset {every path/.style={thick, fill opacity = 0.4, line join = round}}
    \foreach  \depth  in {2} {
      \fill [blue!80!yellow] ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
      \fill [green!80!purple] ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
      \fill [yellow!80!red] ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
    }

    \foreach  \depth  in {4,3,2,1} {
      \draw  ({\depth  - 5},4) -- ({\depth  - 1},0) -- ({\depth }, 0) -- ({\depth  - 4}, 4) -- cycle;
      \draw  ({\depth  - 1},0) -- ({\depth  + 3},4) -- ({\depth  + 4}, 4) -- ({\depth }, 0) -- cycle;
      \draw  ({\depth  + 3},4) -- ({\depth  + 7},0) -- ({\depth  + 8}, 0) -- ({\depth  + 4}, 4) -- cycle;
    }
  \end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  The homology chops off the intersections, and so we enter the first page of the spectral sequence, consisting of strands with the top and bottom part cut off. Repeatedly taking homology, we are finally left with the rectangular part in the middle, which is the graded components of the desired homology group of the entire complex.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2845</fr:anchor><fr:addr
type="user">hmlg-0012</fr:addr><fr:route>hmlg-0012.xml</fr:route><fr:title
text="Long exact sequence of homologies">Long exact sequence of homologies</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a short exact sequence of chain complexes
  <fr:tex
display="block"><![CDATA[0 \to  A_\bullet  \to  B_\bullet  \to  C_\bullet  \to  0,]]></fr:tex>
  there is a long exact sequence of homology groups
  <fr:tex
display="block"><![CDATA[\cdots  \to  H_{n+1}(C) \xrightarrow {\partial } H_n(A) \to  H_n (B) \to  H_n (C) \xrightarrow {\partial } H_{n-1} (A) \to  \cdots ]]></fr:tex>
  The map <fr:tex
display="inline"><![CDATA[\partial ]]></fr:tex> here is, after unpacking some quotients, simply the boundary map <fr:tex
display="inline"><![CDATA[B_n \to  B_{n-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2847</fr:anchor><fr:addr
type="user">hmlg-0010</fr:addr><fr:route>hmlg-0010.xml</fr:route><fr:title
text="Snake lemma">Snake lemma</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, given the middle two rows of the diagram
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8ab3a474de427cef2dbcc4a25ff72149"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
    & {\ker  f} & {\ker  g} & {\ker  h} \\
    {\ker  i} & \bullet  & \bullet  & \bullet  & 0 \\
    0 & \bullet  & \bullet  & \bullet  & {\operatorname {coker} j} \\
    & {\operatorname {coker} f} & {\operatorname {coker} g} & {\operatorname {coker} h}
    \arrow ["f", from=2-2, to=3-2]
    \arrow ["g", from=2-3, to=3-3]
    \arrow ["h", from=2-4, to=3-4]
    \arrow [from=1-2, to=2-2]
    \arrow [from=1-3, to=2-3]
    \arrow [from=1-4, to=2-4]
    \arrow [blue, >->, out=90, in=180, from=2-1, to=1-2]
    \arrow [from=2-1, to=2-2]
    \arrow ["i", from=2-2, to=2-3]
    \arrow [from=2-3, to=2-4]
    \arrow [from=3-2, to=3-3]
    \arrow ["j", from=3-3, to=3-4]
    \arrow [from=3-4, to=3-5]
    \arrow [blue, ->>, out=0, in=-90, from=4-4, to=3-5]
    \arrow [from=3-2, to=4-2]
    \arrow [from=3-3, to=4-3]
    \arrow [from=3-4, to=4-4]
    \arrow [blue, from=1-2, to=1-3]
    \arrow [blue, from=1-3, to=1-4]
    \arrow [blue, from=4-2, to=4-3]
    \arrow [blue, from=4-3, to=4-4]
    \arrow [blue, dashed, out=0, in=180, from=1-4, to=4-2]
    \arrow [from=2-4, to=2-5]
    \arrow [from=3-1, to=3-2]
  \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <fr:tex
display="inline"><![CDATA[0 \to  \ker  i \to  \ker  f \to  \ker  g \to  \ker  h \xrightarrow {\partial } \operatorname {coker} f \to  \operatorname {coker} g \to  \operatorname {coker} h \to  \operatorname {coker} j \to  0]]></fr:tex>. In particular, if <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is monic and <fr:tex
display="inline"><![CDATA[j]]></fr:tex> is epic, this leads to a six-term exact sequence.</fr:p><fr:p>There are multiple ways to prove this claim. We can first <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">prove it in categories of modules</fr:link>, and <fr:link
type="local"
href="hmlg-0011.xml"
addr="hmlg-0011"
title="Using the Freyd–Mitchell embedding to prove theorems">use the Freyd–Mitchell embedding</fr:link>. We can also use <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">pseudo-elements</fr:link> to <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">perform diagram chases</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2849</fr:anchor><fr:addr
type="user">hmlg-0011</fr:addr><fr:route>hmlg-0011.xml</fr:route><fr:title
text="Using the Freyd–Mitchell embedding to prove theorems">Using the <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">Freyd–Mitchell embedding</fr:link> to prove theorems</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We use the <fr:link
type="local"
href="hmlg-0010.xml"
addr="hmlg-0010"
title="Snake lemma">snake lemma</fr:link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.</fr:p><fr:p>Suppose we have already <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">proved</fr:link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, which we can embed in a module category <fr:tex
display="inline"><![CDATA[R\text {-}\mathsf {Mod}]]></fr:tex>.</fr:p><fr:p>Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> is a full abelian subcategory of <fr:tex
display="inline"><![CDATA[R\text {-}\mathsf {Mod}]]></fr:tex>, these morphisms are contained in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>, and the sequence is still exact. And since <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> is a full abelian subcategory of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the sequence is again exact in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2851</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2853</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>468</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>470</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2855</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2857</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2859</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2861</fr:anchor><fr:addr
type="user">hmlg-000Z</fr:addr><fr:route>hmlg-000Z.xml</fr:route><fr:title
text="Monomorphisms can be expressed using finite limits">Monomorphisms can be expressed using finite limits</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> in an arbitrary category, we can express the condition of being monic using finite limits.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2150</fr:anchor><fr:addr
type="machine">#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We claim that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> being monic is equivalent to the following square being a pullback square:
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="b498bc7c8e96729df8b9019499c15b06"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      X & X \\
      X & Y
      \arrow ["f"', from=2-1, to=2-2]
      \arrow ["f", from=1-2, to=2-2]
      \arrow ["\textrm {id}"', from=1-1, to=2-1]
      \arrow ["\textrm {id}", from=1-1, to=1-2]
      \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span></fr:p>

  <fr:p>For the forward implication, we consider the diagram
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="e425743d109ca2729ae73915d30e7362"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
      Z \\
      & X & X \\
      & X & Y
      \arrow ["f"', from=3-2, to=3-3]
      \arrow ["f", from=2-3, to=3-3]
      \arrow ["\textrm {id}"', from=2-2, to=3-2]
      \arrow ["\textrm {id}", from=2-2, to=2-3]
      \arrow ["\lrcorner "{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
      \arrow [dashed, from=1-1, to=2-2]
      \arrow ["g"', curve={height=6pt}, from=1-1, to=3-2]
      \arrow ["h", curve={height=-6pt}, from=1-1, to=2-3]
    \end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is mono, this diagram commutes iff <fr:tex
display="inline"><![CDATA[g = h]]></fr:tex>, in which case there is a unique way to fill in the dashed arrow, which is <fr:tex
display="inline"><![CDATA[g]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, if the diagram is a pullback, then for every pair of morphisms <fr:tex
display="inline"><![CDATA[g, h : Z \rightrightarrows  X]]></fr:tex>, we can draw the diagram above, and obtain the dashed arrow <fr:tex
display="inline"><![CDATA[k : Z \to  X]]></fr:tex>. The diagram commuting implies <fr:tex
display="inline"><![CDATA[g = \textrm {id} \mathbin {\circ } k = h]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2863</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2865</fr:anchor><fr:addr
type="user">hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title
text="Freyd–Mitchell embedding theorem">Freyd–Mitchell embedding theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules for some ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1189</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>(TODO)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2867</fr:anchor><fr:addr
type="user">hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>435</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>437</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>468</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>470</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>398</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr
type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2869</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2871</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2873</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2875</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2877</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2879</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2881</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2883</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2885</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>437</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2887</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2889</fr:anchor><fr:addr
type="user">hmlg-000N</fr:addr><fr:route>hmlg-000N.xml</fr:route><fr:title
text="Signs in bicomplexes">Signs in bicomplexes</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Some sources require a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> to have anti-commuting squares. In this way, the <fr:link
type="local"
href="hmlg-000M.xml"
addr="hmlg-000M"
title="Total complex">total complex</fr:link> has the simpler differential <fr:tex
display="inline"><![CDATA[\partial  = d + \delta ]]></fr:tex>. These two definitions are convertible by flipping the signs of the horizontal boundary maps in every other row.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2891</fr:anchor><fr:addr
type="user">hmlg-000M</fr:addr><fr:route>hmlg-000M.xml</fr:route><fr:title
text="Total complex">Total complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> <fr:tex
display="inline"><![CDATA[C_{\bullet , \bullet }]]></fr:tex>, we can collapse it into a chain complex in two ways. In either way, <fr:tex
display="inline"><![CDATA[C_{p, q}]]></fr:tex> is contained in the total complex at degree <fr:tex
display="inline"><![CDATA[(m+n)]]></fr:tex>. We can use the direct sum to combine them: <fr:tex
display="block"><![CDATA[\operatorname {Tot}^\oplus (C)_n = \bigoplus _{n = p+q} C_{p, q},]]></fr:tex> or the direct product: <fr:tex
display="block"><![CDATA[\operatorname {Tot}^\Pi (C)_n = \prod _{n=p+q} C_{p,q}.]]></fr:tex></fr:p><fr:p>The total differential acts on elements in <fr:tex
display="inline"><![CDATA[C_{p, q}]]></fr:tex> by <fr:tex
display="block"><![CDATA[\partial (x) = d(x) + (-1)^q \delta (x),]]></fr:tex> where <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is the vertical map, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> the horizontal map. The <fr:link
type="local"
href="hmlg-000N.xml"
addr="hmlg-000N"
title="Signs in bicomplexes">sign</fr:link> here is to ensure that <fr:tex
display="inline"><![CDATA[\partial ^2 = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2893</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2895</fr:anchor><fr:addr
type="user">hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title
text="Chain complexes">Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> freely generated by cells of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The critical feature of the operator is <fr:tex
display="block"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0,]]></fr:tex> simply written as <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2249</fr:anchor><fr:addr
type="user">hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title
text="Chain complex of abelian groups">Chain complex of abelian groups</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex
display="inline"><![CDATA[G_\bullet ]]></fr:tex> together with homomorphisms <fr:tex
display="inline"><![CDATA[d_n : G_n \to  G_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2250</fr:anchor><fr:addr
type="user">hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title
text="Chain complex of R-modules">Chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors /><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is given by a sequence of modules <fr:tex
display="inline"><![CDATA[M_\bullet ]]></fr:tex> together with <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-linear maps <fr:tex
display="inline"><![CDATA[d_n : R_n \to  R_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2251</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2253</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2255</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2257</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2259</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2261</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2263</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2265</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2267</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2897</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2899</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2901</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2259</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2903</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2905</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2907</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2909</fr:anchor><fr:addr
type="user">hmlg-0001</fr:addr><fr:route>hmlg-0001.xml</fr:route><fr:title
text="Homological Algebra">Homological Algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes primarily based on <fr:link
type="local"
href="homological-algebra.xml"
addr="homological-algebra"
title="An Introduction to Homological Algebra">Weibel</fr:link> and <fr:link
type="local"
href="wwli.xml"
addr="wwli"
title="Wen-Wei Li">Wen-Wei Li</fr:link>’s <fr:link
type="local"
href="methods-of-algebra-2.xml"
addr="methods-of-algebra-2"
title="代数学方法 卷二: 线性代数">unpublished book</fr:link>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2246</fr:anchor><fr:addr
type="user">hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title
text="Chain complexes">Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> freely generated by cells of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The critical feature of the operator is <fr:tex
display="block"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0,]]></fr:tex> simply written as <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2249</fr:anchor><fr:addr
type="user">hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title
text="Chain complex of abelian groups">Chain complex of abelian groups</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex
display="inline"><![CDATA[G_\bullet ]]></fr:tex> together with homomorphisms <fr:tex
display="inline"><![CDATA[d_n : G_n \to  G_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2250</fr:anchor><fr:addr
type="user">hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title
text="Chain complex of R-modules">Chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors /><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A chain complex of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is given by a sequence of modules <fr:tex
display="inline"><![CDATA[M_\bullet ]]></fr:tex> together with <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-linear maps <fr:tex
display="inline"><![CDATA[d_n : R_n \to  R_{n-1}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2251</fr:anchor><fr:addr
type="user">hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title
text="Components of a chain complex">Components of a chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a <fr:link
type="local"
href="hmlg-0003.xml"
addr="hmlg-0003"
title="Chain complex of R-modules">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex
display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex
display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex
display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex
display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex
display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex
display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms">homomorphism theorem</fr:link>, the quotient <fr:tex
display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex
display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex
display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex
display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex
display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2253</fr:anchor><fr:addr
type="user">hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title
text="Chain complex">Chain complex</fr:title><fr:taxon>Visualization</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
type="external"
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook">here</fr:link>.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="75975521ce806e2a3d6a44765ebdd313"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2255</fr:anchor><fr:addr
type="user">hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title
text="Chain map">Chain map</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two chain complexes <fr:tex
display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex
display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="4aa5fcb9e53dbbd7babc45525f24eb54"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2257</fr:anchor><fr:addr
type="user">hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title
text="Chain maps induce maps on homology">Chain maps induce maps on homology</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A chain map <fr:tex
display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex
display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex
display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex
display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2259</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex
display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2261</fr:anchor><fr:addr
type="user">hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title
text="Quasi-isomorphism">Quasi-isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="hmlg-0008.xml"
addr="hmlg-0008"
title="Chain map">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
type="local"
href="hmlg-0007.xml"
addr="hmlg-0007"
title="Components of a chain complex">homology groups</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2263</fr:anchor><fr:addr
type="user">hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title
text="Acyclic chain complex">Acyclic chain complex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2265</fr:anchor><fr:addr
type="user">hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title
text="Short exact sequence">Short exact sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex
display="inline"><![CDATA[C]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2267</fr:anchor><fr:addr
type="user">hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title
text="Difference of exactness and acyclicity">Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Although the definition of exactness and acyclicity are the same, they have different <fr:link
type="external"
href="https://ncatlab.org/nlab/show/concept+with+an+attitude">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2269</fr:anchor><fr:addr
type="user">hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>435</fr:anchor><fr:addr
type="user">hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title
text="Operations on chain complexes">Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>437</fr:anchor><fr:addr
type="user">hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title
text="Direct sum and product of chain complexes">Direct sum and product of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a family of chain complexes <fr:tex
display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex
display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex
display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As another example, the consideration of quotienting out a subspace <fr:tex
display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title
text="Bicomplex">Bicomplex</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex
display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex
display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex
display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex
display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.</fr:p><fr:p>Each column <fr:tex
display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex
display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex
display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title
text="Exact sequence of chain complexes">Exact sequence of chain complexes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex
display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link
type="local"
href="hmlg-000K.xml"
addr="hmlg-000K"
title="Bicomplex">bicomplex</fr:link> such that the rows are <fr:link
type="local"
href="hmlg-000D.xml"
addr="hmlg-000D"
title="Acyclic chain complex">exact</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="user">hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title
text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a chain map <fr:tex
display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7f44dffea9c1eec664c77459ec2227ac"><fr:embedded-tex-preamble><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:addr
type="user">hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title
text="Additive and abelian categories">Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since many <fr:link
type="local"
href="hmlg-000L.xml"
addr="hmlg-000L"
title="Operations on chain complexes">operations</fr:link> on abelian groups and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.</fr:p><fr:p>First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr
type="user">hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title
text="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex
display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr
type="user">hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title
text="Additive category">Additive category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex
display="inline"><![CDATA[0]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex
display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex
display="block"><![CDATA[f_{ij} = \begin {cases}       \textrm {id} & (i = j) \\       0 & (i \ne  j)     \end {cases}]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex
display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex
display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.</fr:p>

  <fr:p>When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="user">hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title
text="Being an additive category is a property">Being an additive category is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a category, if it can be endowed with an <fr:link
type="local"
href="hmlg-000O.xml"
addr="hmlg-000O"
title="{Ab}-enriched category"><fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Notice that having finite products and coproducts is a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">property</fr:link>. These do not mention the enrichment structure.</fr:p>

  <fr:p>With these properties satisfied, the addition structure on the <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex
display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex
display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex
display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex
display="inline"><![CDATA[0']]></fr:tex> and <fr:tex
display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex
display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex
display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex
display="inline"><![CDATA[+']]></fr:tex>.</fr:p>

  <fr:p>Recall that arrows <fr:tex
display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex
display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex
display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex
display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex
display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link
type="local"
href="todo.xml"
addr="todo"
title="Unfinished trees">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr
type="user">hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title
text="Additive functor">Additive functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link> and a functor <fr:tex
display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <fr:strong>additive</fr:strong>.</fr:p><fr:ul><fr:li>The functor preserves finite products.</fr:li>
  <fr:li>The functor preserves finite coproducts.</fr:li>
  <fr:li>The functor is a homomorphism on the abelian groups <fr:tex
display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</fr:li></fr:ul>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex
display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex
display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex
display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex
display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.</fr:p>

  <fr:p>Since the abelian group structure on morphisms is <fr:link
type="local"
href="hmlg-000R.xml"
addr="hmlg-000R"
title="Being an additive category is a property">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex
display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr
type="user">hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title
text="Adjunctions are additive">Adjunctions are additive</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an adjunction <fr:tex
display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition" /> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Kernels and cokernels are also greatly simplified in additive categories.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title
text="Equalizers can be reduced to kernels in {Ab}-enriched categories">Equalizers can be reduced to kernels in <fr:tex
display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched categories</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can express equalizers with kernels (which are equalizers with the zero morphism).</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>We simply need to note that an equalizer for <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex
display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>468</fr:anchor><fr:addr
type="user">hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title
text="Abelian categories">Abelian categories</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">Abelian categories</fr:link> are one step further from <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex
display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex
display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex
display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>470</fr:anchor><fr:addr
type="user">hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title
text="Abelian category">Abelian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given an <fr:link
type="local"
href="hmlg-000P.xml"
addr="hmlg-000P"
title="Additive category">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds.</fr:p><fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
  <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
  <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>The definition of abelian categories may look intimidating, but thinking of it as <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
type="local"
href="hmlg-000F.xml"
addr="hmlg-000F"
title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.</fr:p><fr:p>Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
type="local"
href="hmlg-000X.xml"
addr="hmlg-000X"
title="Left and right exact functor">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="user">hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title
text="Left and right exact functor">Left and right exact functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An <fr:link
type="local"
href="hmlg-000S.xml"
addr="hmlg-000S"
title="Additive functor">additive functor</fr:link> <fr:tex
display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves kernels.</fr:li>
  <fr:li>It preserves finite limits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></fr:li></fr:ul><fr:p>Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.</fr:p><fr:ul><fr:li>It preserves cokernels.</fr:li>
  <fr:li>It preserves finite colimits.</fr:li>
  <fr:li>It preserves the exactness of sequences <fr:tex
display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></fr:li></fr:ul><fr:p>If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex
display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>Since additive functors already preserves finite products, and <fr:link
type="local"
href="hmlg-000Y.xml"
addr="hmlg-000Y"
title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.</fr:p>

  <fr:p>The sequence <fr:tex
display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex
display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex
display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr
type="user">hmlg-002H</fr:addr><fr:route>hmlg-002H.xml</fr:route><fr:title
text="Exactness of ">Exactness of <fr:tex
display="inline"><![CDATA[\hom ]]></fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:ref
addr="hmlg-000X"
href="hmlg-000X.xml"
taxon="Definition" /> it is left exact. Similarly <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <fr:em>right</fr:em> exact. We only need to guarantee that <fr:tex
display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:addr
type="user">hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title
text="Projective object">Projective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex
display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>398</fr:anchor><fr:addr
type="user">hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title
text="Projective objects">Projective objects</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>399</fr:anchor><fr:addr
type="user">hmlg-002I</fr:addr><fr:route>hmlg-002I.xml</fr:route><fr:title
text="Projective modules are direct summands of free modules">Projective modules are direct summands of free modules</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In the <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link> of modules over a ring <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, the <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex
display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>A free module evidently projective. If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex
display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p>

  <fr:p>On the other hand, suppose <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex
display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex
display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is its direct summand.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Dually, we have the definition of injective objects, which make <fr:tex
display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr
type="user">hmlg-002J</fr:addr><fr:route>hmlg-002J.xml</fr:route><fr:title
text="Injective object">Injective object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In an <fr:link
type="local"
href="hmlg-000Q.xml"
addr="hmlg-000Q"
title="Abelian category">abelian category</fr:link>, an object <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is <fr:strong>injective</fr:strong> iff every morphism <fr:tex
display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex
display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link
type="local"
href="hmlg-0004.xml"
addr="hmlg-0004"
title="Projective object">projective object</fr:link> in the dual category.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:addr
type="user">hmlg-002O</fr:addr><fr:route>hmlg-002O.xml</fr:route><fr:title
text="Abelian groups are injective iff divisible">Abelian groups are injective iff divisible</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An abelian group <fr:tex
display="inline"><![CDATA[G]]></fr:tex> is <fr:link
type="local"
href="hmlg-002J.xml"
addr="hmlg-002J"
title="Injective object">injective</fr:link> iff it is <fr:strong>divisible</fr:strong>, i.e. for element <fr:tex
display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex
display="inline"><![CDATA[nx = g]]></fr:tex>.</fr:p>
  
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr
type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-002O</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>In one direction, suppose the group is injective, then the map <fr:tex
display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex
display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.</fr:p>

  <fr:p>On the other hand, suppose divisibility holds. Given a morphism <fr:tex
display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex
display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> by Zorn's lemma. Consider the poset of homomorphisms extending <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex
display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex
display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex
display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex
display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex
display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex
display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex
display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex
display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex
display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex
display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="true"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2911</fr:anchor><fr:addr
type="user">trebor-0001</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Trebor’s forest">Trebor’s forest</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is my forest, which is <fr:link
type="external"
href="https://www.jonmsterling.com/jms-005P.xml">a way of organizing notes</fr:link>. Here is <fr:link
type="external"
href="https://www.jonmsterling.com/jms-009H.xml">a list of other websites organized as forests</fr:link>. Some of the contents here:</fr:p><fr:ul><fr:li><fr:link
type="local"
href="hmlg-0001.xml"
addr="hmlg-0001"
title="Homological Algebra">Notes on homological algebra</fr:link></fr:li>
  <fr:li><fr:link
type="local"
href="hmlg-001K.xml"
addr="hmlg-001K"
title="Effective homology">Effective homology</fr:link></fr:li>
  <fr:li>Algebraic geometry (Under namespace <fr:code>algm</fr:code>, not organized)</fr:li>
  <fr:li><fr:link
type="local"
href="ualg-000H.xml"
addr="ualg-000H"
title="Beck monadicity theorem">Beck monadicity theorem</fr:link></fr:li></fr:ul><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>805</fr:anchor><fr:addr
type="user">trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title
text="Style of writing">Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="trebor.xml"
addr="trebor"
title="Trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I try to adhere to several principles when composing trees.</fr:p><fr:ul><fr:li>If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.</fr:li>
  <fr:li>Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex
display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex
display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.</fr:li>
  <fr:li>Apply <fr:link
type="external"
href="https://ncatlab.org/nlab/show/biased+definition">unbiased terminology</fr:link> and <fr:link
type="external"
href="https://ncatlab.org/nlab/show/negative+thinking">negative thinking</fr:link>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>