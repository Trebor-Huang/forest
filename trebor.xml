<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1652</anchor> <taxon>Person</taxon> <addr>trebor</addr><route>trebor.xml</route>    <title>Trebor</title>   <meta name="institution">Tsinghua University</meta><meta name="position">Bachelor Student</meta><meta name="external">https://github.com/Trebor-Huang</meta></frontmatter> <mainmatter><p>
  My name is 黄栩 (<em>Huang Xu</em>), but I go by the name <em>Trebor</em> online. I’m interested in (homotopy) type theory, category theory and jazz.
</p></mainmatter> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1653</anchor> <taxon>Definition</taxon> <addr>hmlg-001N</addr><route>hmlg-001N.xml</route>  <date><year>2024</year> <month>4</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Discrete vector field</title>   </frontmatter> <mainmatter><p>
  A <strong>discrete vector field</strong> (DVF) on an <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link> is given by a collection of pairs of cells <tex>( \sigma ,  \tau )</tex>, where <tex>\sigma</tex> is a <link href="hmlg-001O.xml" type="local" addr="hmlg-001O" title="Regular face in an algebraic cellular complex">regular face</link> of <tex>\tau</tex>, standing for a vector pointing from <tex>\sigma</tex> to <tex>\tau</tex>, which we will write as <tex>\overrightharpoon { \sigma   \tau }</tex>. We require that every cell appears at most once in these vectors.
</p><p>
  A DVF naturally partitions the cells into three kinds: the <em>sources</em>, the <em>targets</em>, and the rest of the cells are called <em>critical cells</em>. This name comes from the analogy to Morse theory. Indeed there is a notion of <link href="https://en.wikipedia.org/wiki/Discrete_Morse_theory" type="external">discrete Morse function</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1654</anchor> <taxon>Definition</taxon> <addr>hmlg-001O</addr><route>hmlg-001O.xml</route>  <date><year>2024</year> <month>4</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Regular face in an algebraic cellular complex</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link> and a cell <tex>\sigma</tex>, a <strong>regular face</strong> of <tex>\sigma</tex> is a cell whose coefficient in <tex>d \sigma</tex> is <tex>\pm  1</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1655</anchor> <taxon>Theorem</taxon> <addr>algm-001T</addr><route>algm-001T.xml</route>  <date><year>2024</year> <month>4</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Slice of presheaf category</title>   </frontmatter> <mainmatter><p>
  We have an equivalence of categories
  <tex display="block">\mathsf { Psh } ( \mathcal { C } )/P  \cong   \mathsf { Psh } \left ( \int _{ \mathcal { C } } P \right ).</tex>
  In the special case that <tex>P =  \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</tex>, we have
  <tex display="block">\mathsf { Psh } ( \mathcal { C } )/ \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)  \cong   \mathsf { Psh } ( \mathcal { C } /U).</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1656</anchor> <taxon>Construction</taxon> <addr>algm-001U</addr><route>algm-001U.xml</route>  <date><year>2024</year> <month>4</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Slice of sheaf category</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex> with a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link> <tex>J</tex> and a sheaf <tex>F</tex>, there is a Grothendieck coverage <tex>J'</tex> on <tex>\int _{ \mathcal { C } } F</tex> such that the equivalence in <ref addr="algm-001T" href="algm-001T.xml" taxon="Theorem"/> restricts to an equivalence
  <tex display="block">\mathsf { Sh } ( \mathcal { C } , J)/F  \cong   \mathsf { Sh } \left ( \int _{ \mathcal { C } } F, J' \right ).</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1657</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>4</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-001U</parent> </frontmatter> <mainmatter>
  <p>
    Suppose we have a covering sieve <tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</tex> in <tex>\mathcal { C }</tex>, then an element <tex>f  \in   \Gamma (U, F)</tex> uniquely corresponds to a matching family <tex>s  \in   \hom (S, F)</tex>. In the category of elements <tex>\int _{ \mathcal { C } } F</tex>, <tex>s</tex> corresponds to a sieve over <tex>f</tex>. This is the required Grothendieck coverage.
  </p>

  <p>
    Another way to construct this is through the <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> <tex>j</tex>. The subobject classifier of a slice category is simply <tex>\Omega   \times  F  \to  F</tex>. Hence we can let <tex>j</tex> act on the <tex>\Omega</tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1658</anchor> <taxon>Definition</taxon> <addr>algm-001Q</addr><route>algm-001Q.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Dense subobject of a Lawvere–Tierney operator</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> <tex>j</tex>, a subobject <tex>F  \hookrightarrow  G</tex> is <tex>j</tex>-<strong>dense</strong> if <tex>G  \to   \Omega   \xrightarrow {j}  \Omega</tex> is the constant true. In terms of the corresponding <tex>J  \hookrightarrow   \Omega</tex>, we need the pullback of it with <tex>G  \to   \Omega</tex> to be <tex>\operatorname {id}  : G  \to  G</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1659</anchor> <taxon>Construction</taxon> <addr>algm-001O</addr><route>algm-001O.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Exponentials of sheaves</title>   </frontmatter> <mainmatter><p>
  The exponentials of sheaves coincide with those of presheaves. To see this, we assume <tex>X^Y</tex> is the exponential of sheaves and calculate
  <tex display="block">\begin {aligned}      \Gamma (U, X^Y)     &amp;=  \hom _{ \mathsf { Psh } }( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X^Y)  \\      &amp;=  \hom _{ \mathsf { Sh } }( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X^Y)  \\      &amp;=  \hom _{ \mathsf { Sh } }(Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Sh } }(Y^{++}  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Sh } }((Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U))^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Psh } }(Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X)  \\     \end {aligned}</tex>
  which is evidently <tex>\Gamma (U, X^Y)</tex> but this time the exponential is taken in the category of presheaves. We used the fact that <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">the plus construction preserves finite product</link>. However, we still need to prove that this indeed forms a sheaf.
</p><p>
  Expressing the <link href="algm-001P.xml" type="local" addr="algm-001P" title="Sheaf condition using Lawvere–Tierney operators">sheaf condition using Lawvere–Tierney operators</link>, we only need to show for <link href="algm-001Q.xml" type="local" addr="algm-001Q" title="Dense subobject of a Lawvere–Tierney operator">dense subobjects</link> <tex>F  \hookrightarrow  G</tex> that <tex>\hom (G, X^Y)  \to   \hom (F, X^Y)</tex> is a bijection. This is equivalent to <tex display="block">\hom (Y  \times  G, X)  \to   \hom (Y  \times  F, X).</tex> Note that the subobject <tex>Y  \times  F  \hookrightarrow  Y  \times  G</tex> corresponds to the characteristic function <tex>Y  \times  G  \to  G  \to   \Omega</tex>. Hence the denseness of <tex>F  \hookrightarrow  G</tex> implies the denseness of <tex>Y  \times  F  \hookrightarrow  Y  \times  G</tex>. Since <tex>X</tex> is a sheaf, we conclude that <tex>X^Y</tex> is also a sheaf.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1660</anchor> <taxon>Definition</taxon> <addr>algm-001R</addr><route>algm-001R.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Local object</title>   </frontmatter> <mainmatter><p>
  Given a class of arrows <tex>S</tex>, an <tex>S</tex>-<strong>local object</strong> is an object <tex>X</tex> such that for every <tex>f : A  \to  B</tex> in <tex>S</tex>, the composition map <tex display="block">\hom (B, X)  \to   \hom (A, X)</tex> is an isomorphism.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1661</anchor>  <addr>algm-001P</addr><route>algm-001P.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf condition using Lawvere–Tierney operators</title>   </frontmatter> <mainmatter><p>
  Knowing the <link href="algm-001N.xml" type="local" addr="algm-001N" title="Grothendieck coverages and Lawvere–Tierney operators">correspondence</link> of Grothendieck coverages on <tex>\mathcal { C }</tex> and Lawvere–Tierney operators on <tex>\mathsf { Psh } ( \mathcal { C } )</tex>, we naturally want to rewrite the <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaf condition</link> to use <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operators</link> instead of <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverages</link>.
</p><p>
  Recall that the <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaf condition</link> requires for every covering sieve <tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</tex> that the composition <tex>\hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X)  \to   \hom (S, X)</tex> is an isomorphism. We can reify this to a definition.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1662</anchor> <taxon>Definition</taxon> <addr>algm-001R</addr><route>algm-001R.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Local object</title>   </frontmatter> <mainmatter><p>
  Given a class of arrows <tex>S</tex>, an <tex>S</tex>-<strong>local object</strong> is an object <tex>X</tex> such that for every <tex>f : A  \to  B</tex> in <tex>S</tex>, the composition map <tex display="block">\hom (B, X)  \to   \hom (A, X)</tex> is an isomorphism.
</p></mainmatter> </tree><p>
  Now we just need to pick out the class of morphisms <tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</tex> using the Lawvere–Tierney operator <tex>j</tex>. Note that this operator does not necessarily live in a presheaf topos, so we must find a way to generalize this class of arrows to not necessarily representable presheaves. Since every presheaf is a colimit of representables, we can look at the corresponding colimit of morphisms <tex>\operatorname *{colim}  S_i  \hookrightarrow   \operatorname *{colim}   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i)</tex>. A local object will satisfy
  <tex display="block">\begin {aligned}      \hom ( \operatorname *{colim} \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i), X)  \cong   \lim \hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i), X)  \quad   \\       \xrightarrow { \sim }  \lim \hom (S_i, X)  \cong   \hom ( \operatorname *{colim}  S_i, X).    \end {aligned}</tex>
  Hence we can safely include these arrows into the class and still get the same concept of local objects. Now it's illuminating to look at the characteristic maps. A sieve <tex>S  \to   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</tex> corresponds to a characteristic map in <tex>\hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U),  \Omega )  \cong   \Gamma (U,  \Omega )</tex>. Generalizing to an arbitrary presheaf expressed (canonically) as a colimit of representables, we need the image of every section to be a covering sieve.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1663</anchor> <taxon>Definition</taxon> <addr>algm-001Q</addr><route>algm-001Q.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Dense subobject of a Lawvere–Tierney operator</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> <tex>j</tex>, a subobject <tex>F  \hookrightarrow  G</tex> is <tex>j</tex>-<strong>dense</strong> if <tex>G  \to   \Omega   \xrightarrow {j}  \Omega</tex> is the constant true. In terms of the corresponding <tex>J  \hookrightarrow   \Omega</tex>, we need the pullback of it with <tex>G  \to   \Omega</tex> to be <tex>\operatorname {id}  : G  \to  G</tex>.
</p></mainmatter> </tree><p>
  In terms of sieves, for every section <tex>s  \in   \Gamma (U, G)</tex>, the sieve of arrows on <tex>U</tex> along whom the restriction of <tex>s</tex> is in <tex>F</tex> must be a covering sieve. We have arrived at the desired reformulation of the sheaf condition.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1664</anchor> <taxon>Definition</taxon> <addr>algm-001S</addr><route>algm-001S.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf of a Lawvere–Tierney operator</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> <tex>j</tex>, a <tex>j</tex>-<strong>sheaf</strong> is defined as a <tex>j</tex>-<strong>local object</strong>, i.e. a <link href="algm-001R.xml" type="local" addr="algm-001R" title="Local object">local object</link> under the <link href="algm-001Q.xml" type="local" addr="algm-001Q" title="Dense subobject of a Lawvere–Tierney operator"><tex>j</tex>-dense monomorphisms</link>.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1665</anchor> <taxon>Definition</taxon> <addr>algm-001S</addr><route>algm-001S.xml</route>  <date><year>2024</year> <month>4</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf of a Lawvere–Tierney operator</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> <tex>j</tex>, a <tex>j</tex>-<strong>sheaf</strong> is defined as a <tex>j</tex>-<strong>local object</strong>, i.e. a <link href="algm-001R.xml" type="local" addr="algm-001R" title="Local object">local object</link> under the <link href="algm-001Q.xml" type="local" addr="algm-001Q" title="Dense subobject of a Lawvere–Tierney operator"><tex>j</tex>-dense monomorphisms</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1666</anchor>  <addr>algm-001N</addr><route>algm-001N.xml</route>  <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Grothendieck coverages and Lawvere–Tierney operators</title>   </frontmatter> <mainmatter><p>
  Consider a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> on a presheaf category. Then we may calculate the subobject classifier as in <ref addr="algm-001M" href="algm-001M.xml" taxon="Construction"/>.
</p><p>
  By the definition of subobject classifiers, a <link href="algm-001L.xml" type="local" addr="algm-001L" title="Lawvere–Tierney operator">Lawvere–Tierney operator</link> can be equivalently expressed as a subobject <tex>J  \subseteq   \Omega</tex>. Translating the condition of preserving finite intersections, it needs to contain the improper sieve, be upwards closed and closed under finite intersections. And <tex>j  \circ  j = j</tex> implies the following pullback square:
</p>
  <embedded-tex hash="fe9346d10209c9585845365330f42e41"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} %tex
  J &amp; J \\
  \Omega &amp; \Omega
  \arrow[hook, from=1-2, to=2-2]
  \arrow[&quot;j&quot;', from=2-1, to=2-2]
  \arrow[hook, from=1-1, to=2-1]
  \arrow[from=1-1, to=1-2]
  \arrow[&quot;\lrcorner&quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2] \end {tikzcd}
  </embedded-tex-body></embedded-tex>
<p>
  In other words, a sieve is contained in <tex>J</tex> iff its image under <tex>j</tex> is also contained in <tex>J</tex>. Unfolding this, a sieve <tex>S</tex> is contained in <tex>J</tex> iff the arrows <tex>g</tex> such that <tex>g^* S</tex> is contained in <tex>J</tex> also form a sieve in <tex>J</tex>. Looking at the definition of a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link>, we see that they are equivalent, if we regard <tex>J</tex> as picking out the covering sieves.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1667</anchor> <taxon>Definition</taxon> <addr>algm-001L</addr><route>algm-001L.xml</route>  <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Lawvere–Tierney operator</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, a <strong>Lawvere–Tierney operator</strong> is a morphism <tex>j :  \Omega   \to   \Omega</tex> where <tex>\Omega</tex> is the subobject classifier, such that <tex>j</tex> preserves finite intersections, and <tex>j  \circ  j = j</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1668</anchor> <taxon>Construction</taxon> <addr>algm-001M</addr><route>algm-001M.xml</route>  <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Subobject classifier of presheaves</title>   </frontmatter> <mainmatter><p>
  The subobject classifier <tex>\Omega</tex> of presheaves can be given by a quick calculation.
  <tex display="block">\Gamma (U,  \Omega )    \cong   \hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U),  \Omega )    \cong   \operatorname {Sub}( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U))</tex>
  By definition, this is the set of <link href="algm-001B.xml" type="local" addr="algm-001B" title="Sieve">sieves</link> on <tex>U</tex>, and the functorial action is the <link href="algm-001C.xml" type="local" addr="algm-001C" title="Pullback of sieves">pullback</link>. For a monomorphism <tex>F  \hookrightarrow  G</tex>, an element <tex>s  \in   \Gamma (U, G)</tex> is sent to the sieve consisting of arrows <tex>f : V  \to  U</tex> such that the restriction along <tex>f</tex> is included in <tex>F</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1669</anchor> <taxon>Construction</taxon> <addr>algm-001K</addr><route>algm-001K.xml</route>  <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Separation of presheaf</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link>, the inclusion of <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">separated presheaves</link> to presheaves has a left adjoint <tex>(-)^ { \operatorname {sep}}</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1670</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-001K</parent> </frontmatter> <mainmatter>
  <p>
    We define <tex>\Gamma (U, P^ { \operatorname {sep}} )</tex> to be a quotient of <tex>\Gamma (U, P)</tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <tex>P  \to  Q</tex> to a separated presheaf, if two sections of <tex>P</tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <tex>Q</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1671</anchor> <taxon>Theorem</taxon> <addr>algm-001I</addr><route>algm-001I.xml</route>  <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf condition in terms of plus construction</title>   </frontmatter> <mainmatter><p>
  Given a presheaf <tex>P</tex>, the morphism <tex>P  \to  P^+</tex> to its <link href="algm-001E.xml" type="local" addr="algm-001E" title="Plus construction">plus construction</link> is a monomorphism iff <tex>P</tex> is <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">separated</link>, and it is an isomorphism iff <tex>P</tex> is a <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaf</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1672</anchor> <taxon>Definition</taxon> <addr>algm-001J</addr><route>algm-001J.xml</route>  <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheafification</title>   </frontmatter> <mainmatter><p><strong>Sheafification</strong> is defined as the left adjoint of the inclusion from <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaves</link> to the category of presheaves. Hence it freely constructs a sheaf from a presheaf.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1673</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-001J</parent> </frontmatter> <mainmatter>
  <p>
    We construct sheafification as <link href="algm-001G.xml" type="local" addr="algm-001G" title="Iterated plus construction produces a sheaf">an iterated plus construction</link>. This produces a functor. By <ref addr="algm-001H" href="algm-001H.xml" taxon="Theorem"/> we have a natural bijection
    <tex display="block">\hom (P^{++}, F)  \cong   \hom (P^+, F)  \cong   \hom (P, F).</tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <tex>P  \to  P^+</tex> and <tex>P^+  \to  P^{++}</tex>, we see that the unit of the adjunction is given by the composition <tex>P  \to  P^{++}</tex>.
  </p>

  <p>
    Alternatively, using <ref addr="algm-001K" href="algm-001K.xml" taxon="Construction"/>, we may compose two adjunctions to first <link href="algm-001K.xml" type="local" addr="algm-001K" title="Separation of presheaf">separate</link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1674</anchor> <taxon>Theorem</taxon> <addr>algm-001H</addr><route>algm-001H.xml</route>  <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Universal property of <link href="algm-001E.xml" type="local" addr="algm-001E" title="Plus construction">plus construction</link></title>   </frontmatter> <mainmatter><p>
  For any presheaf <tex>P</tex> and sheaf <tex>F</tex>, there is a natural bijection <tex display="block">\hom (P, F)  \cong   \hom (P^+, F)</tex> given by composition with <tex>\eta _P : P  \to  P^+</tex>.
</p><p>
  As a corollary of this and <ref addr="algm-001G" href="algm-001G.xml" taxon="Theorem"/>, when restricted to separated presheaves, it is left adjoint to the forgetful functor from sheaves to separated presheaves.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1675</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>4</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-001H</parent> </frontmatter> <mainmatter>
  <p>
    For every morphism <tex>P  \to  F</tex>, there is a unique way to extend the map to <tex>P^+</tex> using the <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaf condition</link> of <tex>F</tex>. A section of <tex>P^+</tex> consists of a matching family <tex>s_f</tex>, and it is also the gluing of <tex>\eta _P(s_f)</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1676</anchor> <taxon>Definition</taxon> <addr>algm-001A</addr><route>algm-001A.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Grothendieck coverage</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, a <strong>Grothendieck coverage</strong> declares some <link href="algm-001B.xml" type="local" addr="algm-001B" title="Sieve">sieves</link> to be coverings, such that
  <ul><li>The maximal sieve <tex>\mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)  \subseteq   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)</tex> is always a covering.</li>
    <li>Covering sieves are upwards closed, i.e. if <tex>S  \subseteq  S'</tex> and <tex>S</tex> is a covering sieve, then so is <tex>S'</tex>.</li>
    <li>If <tex>S</tex> is a covering sieve of <tex>A</tex>, and <tex>g : B  \to  A</tex> is a morphism, then the <link href="algm-001C.xml" type="local" addr="algm-001C" title="Pullback of sieves">pullback</link> <tex>g^* S</tex> is also a covering.</li>
    <li>Suppose <tex>S</tex> is a sieve, then the collection of arrows <tex>g</tex> such that <tex>g^* S</tex> is a covering is a sieve itself. If this sieve is a covering, then <tex>S</tex> is also a covering.</li></ul>
  A Grothendieck coverage can be viewed as a <link href="algm-0019.xml" type="local" addr="algm-0019" title="Coverage">coverage</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1677</anchor> <taxon>Definition</taxon> <addr>algm-0019</addr><route>algm-0019.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Coverage</title>   </frontmatter> <mainmatter><p>
  A <strong>coverage</strong> on an arbitrary category <tex>\mathcal { C }</tex> is given by a family of covers. A <strong>cover</strong> of some object <tex>A</tex> in <tex>\mathcal { C }</tex> is a family of maps with codomain <tex>A</tex>. Given a cover <tex>f_i : U_i  \to  A</tex> and a map <tex>g : B  \to  A</tex>, there is a cover of <tex>B</tex> such that its composition with <tex>g</tex> is a <strong>refinement</strong> of <tex>f_i</tex>, in the sense that every map in the cover factors through one of <tex>f_i</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1678</anchor> <taxon>Definition</taxon> <addr>algm-001D</addr><route>algm-001D.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Descent data of presheaves</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, a <link href="algm-001B.xml" type="local" addr="algm-001B" title="Sieve">sieve</link> <tex>S</tex> and a presheaf <tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</tex>, a set of <strong>descent data</strong> or a <strong>compatible family</strong> is a morphism <tex>S  \to  P</tex>. Expanding this, it is a family of <em>local sections</em> <tex>s  \in   \Gamma (U, P)</tex> assigned for each morphism <tex>U  \to  A</tex> in the sieve <tex>S</tex>, such that the local sections are compatible on restriction. There is an obvious map from the sections <tex>\Gamma (A, P)</tex> to the descent data given by restriction.
</p><p>
  More generally, given a general <link href="algm-0019.xml" type="local" addr="algm-0019" title="Coverage">cover</link>, a set of descent data is a family of sections <tex>s_i  \in   \Gamma (U_i, P)</tex> for each morphism <tex>f_i : U_i  \to  A</tex> in the cover, such that in any common restriction of <tex>U_i</tex> and <tex>U_j</tex>, the sections agree. This can be equivalently expressed as the descent data of the sieve generated by the cover.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1679</anchor> <taxon>Theorem</taxon> <addr>algm-001G</addr><route>algm-001G.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Iterated <link href="algm-001E.xml" type="local" addr="algm-001E" title="Plus construction">plus construction</link> produces a sheaf</title>   </frontmatter> <mainmatter><p>
  Given any presheaf <tex>P</tex>, <tex>P^+</tex> is a <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">separated presheaf</link>, and if <tex>P</tex> is already separated, <tex>P^+</tex> is a <link href="algm-001F.xml" type="local" addr="algm-001F" title="Sheaf">sheaf</link>. Therefore <tex>P^{++}</tex> is always a sheaf.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1680</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-001G</parent> </frontmatter> <mainmatter>
  <p>
    We first prove that <tex>P^+</tex> is separated. Suppose there are two gluings of a set of descent data on a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">covering sieve</link> <tex>S</tex> over <tex>A</tex>, then we have two sieves <tex>S_1, S_2</tex> over <tex>A</tex> with compatible families <tex>s_{1, f}, s_{2, f}</tex>. Since they are gluings of the same descent data, the restriction along any morphism <tex>g : U  \to  A</tex> in <tex>S</tex> would be equal. Hence there is a common refinement of <tex>g^* S_1</tex> and <tex>g^* S_2</tex> where the two families become equal. Expanding this, there is a covering sieve on <tex>U</tex> such that <tex>g  \circ  h  \in  S_1  \cap  S_2</tex> for every <tex>h</tex> in the sieve, and <tex>s_{1, g  \circ  h} = s_{2, g  \circ  h}</tex>. But then by the axioms of a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link>, <tex>g  \circ  h</tex> for all <tex>h</tex> in the said sieve and <tex>g  \in  S</tex> also generates a covering sieve. Hence <tex>s_1</tex> and <tex>s_2</tex> are already equal on a covering subsieve, and so they are equal in <tex>\Gamma (A, P^+)</tex>.
  </p>

  <p>
    Let’s see why <tex>P^+</tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <link href="algm-001D.xml" type="local" addr="algm-001D" title="Descent data of presheaves">compatible family</link> of local sections of <tex>P^+</tex> is a family of covering sieves <tex>S_f</tex> over <tex>U</tex> for each morphism <tex>f : U  \to  A</tex> in <tex>S</tex>, and for each <tex>S_f</tex> a family of sections <tex>s_{f, g}  \in   \Gamma (V, P)</tex> where <tex>g : V  \to  U</tex> lies in <tex>S_f</tex>. By the axioms of a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link>, the union <tex>\bigcup _{f  \in  S} f  \circ  S_f</tex> is a sieve, since <tex>S_f  \subseteq  f^* (f  \circ  S_f)</tex>. (Warning: <tex>f  \circ  S_f</tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <tex>s'</tex> by <tex>s'_{f  \circ  g} = s_{f, g}</tex>. Hence we need to prove <tex>s_{f, g} = s_{f', g'}</tex> if <tex>f  \circ  g = f'  \circ  g'</tex>.
  </p>

  <p>
    Since the families <tex>s_{f}</tex> are compatible, given any <tex>g : V  \to  U</tex> we have <tex>s_{f, g  \circ  r} = s_{f  \circ  g, r}</tex> for a family of arrows <tex>r</tex> that generates a covering sieve on <tex>V</tex>. However we cannot necessarily take <tex>r =  \operatorname {id}</tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <tex>s_{f, g  \circ  r} = s_{f  \circ  g, r}</tex> forms a compatible family over <tex>V</tex> as <tex>r</tex> ranges over the covering sieve. And therefore <tex>s_{f, g}</tex> and <tex>s_{f  \circ  g,  \operatorname {id} }</tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1681</anchor> <taxon>Definition</taxon> <addr>algm-001E</addr><route>algm-001E.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Plus construction</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001A.xml" type="local" addr="algm-001A" title="Grothendieck coverage">Grothendieck coverage</link> on <tex>\mathcal { C }</tex> and a presheaf <tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</tex>, the <strong>plus construction</strong> produces a new presheaf <tex>P^+</tex> by taking a directed limit over all the <link href="algm-001D.xml" type="local" addr="algm-001D" title="Descent data of presheaves">descent data</link>. More precisely, we assign <tex display="block">\Gamma (A, P^+) =  \operatorname *{colim} _{S  \text { covers } A}  \hom (S, P).</tex> This means the sections of <tex>P^+</tex> are compatible families of sections of <tex>P</tex>, and two families are considered equal if they are equal on a common covering subsieve.
</p><p>
  Given a map <tex>g : B  \to  A</tex>, we have a <link href="algm-001C.xml" type="local" addr="algm-001C" title="Pullback of sieves">pullback</link> <tex>\hom (S, P)  \to   \hom (g^*S, P)</tex>. This induces the functorial action of <tex>P^+</tex>. There is an obvious natural transformation <tex>P  \to  P^+</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1682</anchor> <taxon>Definition</taxon> <addr>algm-001C</addr><route>algm-001C.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Pullback of sieves</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-001B.xml" type="local" addr="algm-001B" title="Sieve">sieve</link> <tex>S</tex> over <tex>A</tex> and a morphism <tex>g : B  \to  A</tex>, the <strong>pullback</strong> <tex>g^* S</tex> is a sieve over <tex>B</tex>. <tex>h : C  \to  B</tex> is in this sieve iff <tex>g  \circ  h</tex> is in <tex>S</tex>. There is a natural map <tex>g^* S  \to  S</tex> given by <tex>g  \circ  -</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1683</anchor> <taxon>Definition</taxon> <addr>algm-001F</addr><route>algm-001F.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex> equipped with a <link href="algm-0019.xml" type="local" addr="algm-0019" title="Coverage">coverage</link>, we define a presheaf <tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</tex> to be a <strong>sheaf</strong> if it satisfies the <strong>sheaf condition</strong>: for every cover of <tex>A</tex>, the map from sections of <tex>A</tex> to <link href="algm-001D.xml" type="local" addr="algm-001D" title="Descent data of presheaves">descent data</link> of the cover is a bijection. It is a <strong>separated presheaf</strong> if the map is an injection.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1684</anchor> <taxon>Definition</taxon> <addr>algm-001B</addr><route>algm-001B.xml</route>  <date><year>2024</year> <month>4</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sieve</title>   </frontmatter> <mainmatter><p>
  A <strong>sieve</strong> over an object <tex>A</tex> of an arbitrary category <tex>\mathcal { C }</tex> is a subfunctor of <tex>\mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)</tex>. More explicitly, it selects some arrows with codomain <tex>A</tex>, such that the selected arrows absorbs composition (i.e. if <tex>f : B  \to  A</tex> is selected and <tex>g : C  \to  B</tex>, then <tex>g  \circ  f</tex> is also selected).
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1685</anchor> <taxon>Theorem</taxon> <addr>nsan-0003</addr><route>nsan-0003.xml</route>  <date><year>2024</year> <month>3</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\mathsf { Germ }</tex> is <tex>\mathsf { Filt }</tex> localized at inclusion maps of large subsets</title>   </frontmatter> <mainmatter><p>
  The <link href="nsan-0002.xml" type="local" addr="nsan-0002" title="Category of germs">category of germs</link> is equivalent to the category of <link href="nsan-0001.xml" type="local" addr="nsan-0001" title="Filter space">filter spaces</link> localized at maps of the form <tex>X  \hookrightarrow  Y</tex>, where <tex>X</tex> is a large subset of <tex>Y</tex>, whose filter is induced by restriction from <tex>Y</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1686</anchor> <taxon>Definition</taxon> <addr>nsan-0002</addr><route>nsan-0002.xml</route>  <date><year>2024</year> <month>3</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Category of germs</title>   </frontmatter> <mainmatter><p>
  The <link href="nsan-0001.xml" type="local" addr="nsan-0001" title="Filter space">filter spaces</link> form another category, whose morphisms are <strong>germs</strong>, i.e. partial continuous functions defined on a large set, with equality considered up to some difference on a small set. This category is written <tex>\mathsf { Germ }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1687</anchor> <taxon>Definition</taxon> <addr>nsan-0001</addr><route>nsan-0001.xml</route>  <date><year>2024</year> <month>3</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Filter space</title>   </frontmatter> <mainmatter><p>
  A <strong>filter space</strong> is a set equipped with a filter. A morphism between germ spaces is a function such that the preimage of a large set is still large, which is often referred to as <strong>continuous</strong>. This creates a category <tex>\mathsf { Filt }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1688</anchor> <taxon>Construction</taxon> <addr>hmlg-001M</addr><route>hmlg-001M.xml</route>  <date><year>2024</year> <month>3</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain reduction of mapping cones</title>   </frontmatter> <mainmatter><p>
  Given a pair of <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reductions</link> <tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex> and <tex>\rho ' : C'  \Rightarrow \mkern {-14mu} \Rightarrow  D'</tex>, we can construct a reduction from the mapping cone <tex>\operatorname {Cone} (f)</tex> of a chain map <tex>f : C  \to  C'</tex> to (the action of <tex>\rho</tex> on <tex>f</tex>).
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1689</anchor> <taxon>Theorem</taxon> <addr>algm-0018</addr><route>algm-0018.xml</route>  <date><year>2024</year> <month>3</month> <day>16</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>A space is noetherian iff hereditarily quasi-compact</title>   </frontmatter> <mainmatter><p>
  A space is <link href="algm-000C.xml" type="local" addr="algm-000C" title="Noetherian space">noetherian</link> iff it is <em>hereditarily</em> <link href="algm-000A.xml" type="local" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</link>, that is, if all its opens are quasi-compact.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1690</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>16</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0018</parent> </frontmatter> <mainmatter>
  <p>
    We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.
  </p>

  <p>
    For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1691</anchor> <taxon>Theorem</taxon> <addr>algm-0016</addr><route>algm-0016.xml</route>  <date><year>2024</year> <month>3</month> <day>15</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Nike’s trick</title>   </frontmatter> <mainmatter><p>
  The intersections of two <link href="algm-000Q.xml" type="local" addr="algm-000Q" title="Affine scheme">affine</link> subschemes <tex>\operatorname {Spec} (R_1),  \operatorname {Spec} (R_2)  \hookrightarrow  X</tex> can be covered by affine schemes distinguished in both of them.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1692</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>15</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0016</parent> </frontmatter> <mainmatter>
  <p>
    We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <tex>\mathfrak { p }</tex> of <tex>R_1</tex>. We can pick a distinguished open <tex>D(f)</tex> of <tex>\operatorname {Spec} (R_2)</tex> contained in the intersection and containing <tex>\mathfrak { p }</tex>, and a distinguished open <tex>D(g)</tex> of <tex>\operatorname {Spec} (R_1)</tex> contained in <tex>D(f)</tex> and containing <tex>\mathfrak { p }</tex>. Now we prove that <tex>D(g)</tex> is a distinguished open in <tex>\operatorname {Spec} (R_2)</tex>.
  </p>

  <p>
    It suffices to prove that <tex>D(g)</tex> is a distinguished open in <tex>\operatorname {Spec} (R_2 [f^{-1}])</tex>, since this would imply the existence of an element <tex>g'/f^{n}  \in  R_2[f^{-1}]</tex>, and we can take <tex>D(g')  \cap  D(f) = D(g' f)</tex> in <tex>\operatorname {Spec} (R_2)</tex>. Now there is an inclusion map <tex>\operatorname {Spec} (R_2[f^{-1}])  \to   \operatorname {Spec} (R_1)</tex>, which amounts to a ring homomorphism <tex>\varphi</tex> by <ref addr="algm-000X" href="algm-000X.xml" taxon="Theorem"/>. In this case, <tex>D( \varphi (g))</tex> is the required distinguished open, since <tex>\varphi ^{-1}D(u)</tex> is equal to <tex>D( \varphi (u))</tex> in <tex>\operatorname {Spec} (R_2 [f^{-1}])</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1693</anchor> <taxon>Definition</taxon> <addr>algm-0017</addr><route>algm-0017.xml</route>  <date><year>2024</year> <month>3</month> <day>15</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Affine local properties</title>   </frontmatter> <mainmatter><p>
  Suppose a property on affine subschemes <tex>\operatorname {Spec} (R)  \hookrightarrow  X</tex> is closed under taking distinguished subsets <tex>\operatorname {Spec} (R_f)  \hookrightarrow  X</tex>, and for <tex>\gcd \{ f_i \}  = 1</tex>, the property being true on <tex>\operatorname {Spec} (R_{f_i})  \hookrightarrow  X</tex> implies it being true on <tex>\operatorname {Spec} (R)  \hookrightarrow  X</tex>. Then such a property is called <strong>affine local</strong>. We then say that <tex>X</tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.
</p><p>
  If the property <tex>P</tex> only depends on <tex>\operatorname {Spec} (R)</tex> and not <tex>X</tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <tex>P'</tex> on schemes, which we will usually refer to as <strong>locally</strong> <tex>P</tex>. Suppose the scheme is furthermore <link href="algm-000A.xml" type="local" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</link>, we say the scheme satisfies <tex>P</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1694</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>15</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0017</parent> </frontmatter> <mainmatter>
  <p>
    We prove that if some affine cover <tex>\{ \operatorname {Spec} (R_i)  \hookrightarrow  X \}</tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <tex>\operatorname {Spec} (S)  \hookrightarrow  X</tex>, using <link href="algm-0016.xml" type="local" addr="algm-0016" title="Nike’s trick">Nike’s trick</link>, we see that the intersection with <tex>\operatorname {Spec} (R_i)</tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <tex>\operatorname {Spec} (S)  \hookrightarrow  X</tex> with the said property, and therefore itself also.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1695</anchor> <taxon>Definition</taxon> <addr>algm-0015</addr><route>algm-0015.xml</route>  <date><year>2024</year> <month>3</month> <day>15</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Irreducible space</title>   </frontmatter> <mainmatter><p>
  A space is <strong>irreducible</strong> iff finitely many non-empty opens always has non-empty intersection. In other words, iff it is non-empty and cannot be written as a union of two closed sets.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1696</anchor> <taxon>Theorem</taxon> <addr>algm-0014</addr><route>algm-0014.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Adjunction of global section and <tex>\operatorname {Spec}</tex></title>   </frontmatter> <mainmatter><p>
  We have an adjunction of functors <tex display="block">\mathsf { CRing } ^ \textrm {op}   \xtofrom [ \Gamma ( \top ,  \mathscr { O } _{(-)})]{ \operatorname {Spec} }  \mathsf { Sch } ,</tex> with <tex>\operatorname {Spec}</tex> being the right adjoint (or <tex>\operatorname {Spec}  :  \mathsf { CRing }   \to   \mathsf { Sch } ^ \textrm {op}</tex> being the left adjoint). In fact, we can replace <tex>\mathsf { Sch }</tex> with the category of <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed spaces</link> <tex>\mathsf { LRS }</tex>, of whom <tex>\mathsf { Sch }</tex> is a full subcategory.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1697</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0014</parent> </frontmatter> <mainmatter>
  <p>
    We need to give a natural bijection
    <tex display="block">\hom (X,  \operatorname {Spec} (R))  \cong   \hom (R,  \Gamma ( \top ,  \mathscr { O } _X)).</tex>
    In other words, maps <tex>X  \to   \operatorname {Spec} (R)</tex> between locally ringed spaces are uniquely specified by the action of global sections.
  </p>

  <p>
    Since <tex>X</tex> is glued from affine open subschemes, a map from <tex>X</tex> is equivalent to a map from each open subscheme <tex>\operatorname {Spec} (S_i)</tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <tex>R  \to  S_i</tex> by <ref addr="algm-000X" href="algm-000X.xml" taxon="Theorem"/>. The elements of <tex>\Gamma ( \top ,  \mathscr { O } _X)</tex> are also given by a set of compatible elements from <tex>S_i</tex>. Hence these two sets are naturally bijective.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1698</anchor> <taxon>Theorem</taxon> <addr>algm-0011</addr><route>algm-0011.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Characterization of the locale <tex>\operatorname {Proj} (S)</tex></title>   </frontmatter> <mainmatter><p>
  The opens of the <link href="algm-000Y.xml" type="local" addr="algm-000Y" title="Projective spectrum of a graded ring">projective spectrum</link> <tex>\operatorname {Proj} (S)</tex> are in bijection with graded radical ideals with <tex>\mathfrak { r } _0 = 0</tex>. Hence we write <tex>D_+ ( \mathfrak { r } )</tex> for this open. The proof is exactly the same as <ref addr="algm-0008" href="algm-0008.xml" taxon="Theorem"/>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1699</anchor> <taxon>Intuition</taxon> <addr>algm-000Z</addr><route>algm-000Z.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Geometry of graded rings</title>   </frontmatter> <mainmatter><p>
  To define projective spaces, we start with an affine space, and restricts ourselves to regions invariant under dilation — or using the language of points, we consider lines through the origin as points. Hence we need to define how an element of a ring (which is geometrically a function on the affine space) behaves under dilation.
</p><p>
  In polynomial rings, for example, the polynomial <tex>x^2 + 2y + 7</tex> becomes <tex>\lambda ^2 x^2 + 2  \lambda  y + 7</tex> under a dilation by <tex>\lambda</tex>. Note how each term can be classified by the power of <tex>\lambda</tex> it obtains. Hence, what we need is a <strong>grading</strong> on the ring, which partitions <tex>R =  \bigoplus _d R_d</tex> (as abelian groups). <tex>R_d</tex> is intuitively the elements that get the factor <tex>\lambda ^d</tex> upon dilation. The multiplication of a degree <tex>p</tex> element with a degree <tex>q</tex> element should produce a degree <tex>(p+q)</tex> element, since <tex>\lambda ^p  \lambda ^q =  \lambda ^{p+q}</tex>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1700</anchor> <taxon>Definition</taxon> <addr>hmlg-001L</addr><route>hmlg-001L.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Graded ring</title>   </frontmatter> <mainmatter><p>
  A D-<strong>graded ring</strong> is a sequence of abelian groups <tex>R_d</tex>, where <tex>d  \in  D</tex> are elements of a commutative monoid called the <strong>grading</strong>. We have a bilinear multiplication map <tex display="block">R_p  \otimes  R_q  \to  R_{p+q}</tex> and a identity element <tex>1  \in  R_0</tex> satisfying the associativity and identity laws.
</p><p>
  Usually, the grading is one of <tex>\mathbb  Z</tex> or <tex>\mathbb  N</tex>. A <strong>bigraded ring</strong> is graded over <tex>D^2</tex> instead of <tex>D</tex>, whatever the context implies the grading is.
</p></mainmatter> </tree><p>
  The opens of a projective space should come from the non-vanishing region of a homogeneous function, i.e. elements with a single degree. This ensures that dilation doesn’t change the opens. However, we would have multiple ways to represent the entire space: in a two-dimensional affine space, <tex>D(x)  \cup  D(y)</tex> and <tex>D(1)</tex> are both invariant under dilation, but the former excludes the origin, while the latter does not. In a projective setting, we don’t care about the origin at all, and considering that all homogeneous polynomials of positive degree vanish at the origin, we should make that mandatory. Hence, we only consider the opens corresponding to positively graded elements, which we write as <tex>D_+ (f)</tex>. We can construct a space similar to the <link href="algm-0007.xml" type="local" addr="algm-0007" title="Localic spectrum of a commutative ring">localic spectrum of a commutative ring</link>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1701</anchor> <taxon>Definition</taxon> <addr>algm-000Y</addr><route>algm-000Y.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Projective spectrum of a graded ring</title>   </frontmatter> <mainmatter><p>
  Given a <tex>\mathbb  N</tex>-graded ring <tex>S_ \bullet</tex>, we construct a locale analogous to <link href="algm-0007.xml" type="local" addr="algm-0007" title="Localic spectrum of a commutative ring">the <tex>\operatorname {Spec}</tex> construction</link> for affine schemes. We start with symbols of <strong>distinguished opens</strong> <tex>D_+ (f)</tex> for each positively graded element <tex>f</tex>, and impose the same relations: <tex>D_+</tex> sends finite products to finite intersections, and for elements of the same grade, <tex>D_+ ( \sum _i f_i)  \subseteq   \bigcup _i D_+(f_i)</tex>.
</p></mainmatter> </tree><p>
  As for the structure sheaf, we need to decide what the sections over <tex>D_+ (f)</tex> are. They should be functions defined on the affine space <tex>D(f)  \subseteq   \operatorname {Spec} (S)</tex>, but invariant under dilation. Note that it is stronger than requiring vanishing region be invariant. We actually need the grade <tex>0</tex> elements here. Recalling from <link href="algm-000I.xml" type="local" addr="algm-000I" title="Structure sheaf of a ring spectrum">structure sheaf of a ring spectrum</link> that <tex>\Gamma (D(f),  \mathscr { O } _{ \operatorname {Spec} (S)}) = S[f^{-1}]</tex> (which can be given a canonical grading since <tex>f</tex> is a graded element), we can make the following definition.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1702</anchor> <taxon>Definition</taxon> <addr>algm-0010</addr><route>algm-0010.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Structure sheaf of <tex>\operatorname {Proj} (S)</tex></title>   </frontmatter> <mainmatter><p>
  Fix a <link href="hmlg-001L.xml" type="local" addr="hmlg-001L" title="Graded ring">graded ring</link> <tex>S</tex>. For a positively graded element <tex>f</tex>, we have a graded ring localization <tex>S[f^{-1}]_ \bullet</tex>. Let <tex>\Gamma (D_+(f),  \mathscr { O } )</tex> be the zeroth degree component <tex>S[f^{-1}]_0</tex>. This defines a sheaf over the <link href="algm-000Y.xml" type="local" addr="algm-000Y" title="Projective spectrum of a graded ring">projective spectrum</link>, and moreover gives a <link href="algm-000R.xml" type="local" addr="algm-000R" title="Scheme">scheme</link> <tex>\operatorname {Proj} (S)</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1703</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    We claim that <tex>\operatorname {Proj} (S)</tex> can alternatively be given by gluing affine schemes. We assign <tex>D_+ (f)</tex> the affine scheme <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> (which is possible because the open subspace <tex>D_+ (f)</tex> is homeomorphic to <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> as a space). Given two positively graded elements <tex>f</tex> and <tex>g</tex>, we have an isomorphism between <tex>\operatorname {Proj} (S)</tex> restricted to <tex>D_+ (f g)</tex> and <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> restricted to <tex>D(g^{ \deg  f}/f^{ \deg  g})</tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1704</anchor> <taxon>Definition</taxon> <addr>hmlg-001L</addr><route>hmlg-001L.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Graded ring</title>   </frontmatter> <mainmatter><p>
  A D-<strong>graded ring</strong> is a sequence of abelian groups <tex>R_d</tex>, where <tex>d  \in  D</tex> are elements of a commutative monoid called the <strong>grading</strong>. We have a bilinear multiplication map <tex display="block">R_p  \otimes  R_q  \to  R_{p+q}</tex> and a identity element <tex>1  \in  R_0</tex> satisfying the associativity and identity laws.
</p><p>
  Usually, the grading is one of <tex>\mathbb  Z</tex> or <tex>\mathbb  N</tex>. A <strong>bigraded ring</strong> is graded over <tex>D^2</tex> instead of <tex>D</tex>, whatever the context implies the grading is.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1705</anchor> <taxon>Definition</taxon> <addr>algm-0013</addr><route>algm-0013.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Irrelevant ideal</title>   </frontmatter> <mainmatter><p>
  Given a <tex>\mathbb  N</tex>-<link href="hmlg-001L.xml" type="local" addr="hmlg-001L" title="Graded ring">graded ring</link> <tex>S</tex>, its <strong>irrelevant ideal</strong> <tex>\mathord { \odot }</tex> is defined by the subset <tex>S_+</tex> of all positively graded elements.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1706</anchor> <taxon>Theorem</taxon> <addr>algm-0012</addr><route>algm-0012.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Points of the projective spectrum</title>   </frontmatter> <mainmatter><p>
  The points of the <link href="algm-000Y.xml" type="local" addr="algm-000Y" title="Projective spectrum of a graded ring">projective scheme</link> <tex>\operatorname {Proj} (S)</tex> are given by prime ideals not dividing the <link href="algm-0013.xml" type="local" addr="algm-0013" title="Irrelevant ideal">irrelevant ideal</link> <tex>\mathord { \odot }</tex>. This is in bijection with ideals with <tex>\mathfrak { p } _0 = 0</tex> (equivalently <tex>\mathord { \odot }   \nmid   \mathfrak { p }</tex>), and the condition for prime ideals holds for positively graded elements, i.e. <tex display="block">\mathfrak { p }   \mid  x y  \iff  ( \mathfrak { p }   \mid  x  \lor   \mathfrak { p }   \mid  y)</tex> for positively graded <tex>x</tex> and <tex>y</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1707</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0012</parent> </frontmatter> <mainmatter>
  <p>
    To specify a point <tex>P</tex>, we need to specify which opens <tex>D_+(f)</tex> it belongs to, where <tex>f</tex> ranges over positively graded elements. Equivalently, we specify the closeds <tex>V_+(f)</tex>. Since <tex>V_+(f)  \cap  V_+(g)  \subseteq  V_+(f + g)</tex>, if <tex>P  \in  V_+(f)</tex> and <tex>P  \in  V_+(g)</tex> then <tex>P  \in  V_+(f + g)</tex>. Similarly since <tex>V_+(f)  \subseteq  V_+(f g)</tex>, <tex>P  \in  V_+(f)</tex> implies <tex>P  \in  V_+(f g)</tex>. Collecting all the elements whose distinguished closed contains <tex>P</tex>, we get an ideal <tex>\mathfrak { a }</tex> whose zeroth degree vanishes.
  </p>

  <p>
    We have <tex>V_+(f g) = V_+(f)  \cup  V_+(g)</tex>, so if <tex>\mathfrak { a }   \mid  f g</tex>, then either <tex>\mathfrak { a }   \mid  f</tex> or <tex>\mathfrak { a }   \mid  g</tex>. This is almost the condition for prime ideals, but recall that <tex>f</tex> and <tex>g</tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <ref addr="algm-0011" href="algm-0011.xml" taxon="Theorem"/>.
  </p>

  <p>
    Next, we prove these ideals are in bijection with prime ideals not dividing <tex>\mathord { \odot }</tex>. One direction of the correspondence is obvious: we take a prime ideal <tex>\mathfrak { p }</tex> and remove the zeroth degree, which amounts to taking <tex>\operatorname {lcm} ( \mathfrak { p } ,  \mathord { \odot } )</tex>.
  </p>

  <p>
    We prove injectivity. Suppose primes <tex>\mathfrak { p }</tex> and <tex>\mathfrak { q }</tex> satisfy <tex>\operatorname {lcm} ( \mathfrak { p } ,  \mathord { \odot } ) =  \operatorname {lcm} ( \mathfrak { q } ,  \mathord { \odot } )</tex>, then <tex>\mathfrak { p }   \mid   \operatorname {lcm} ( \mathfrak { q } ,  \mathord { \odot } )  \mid   \mathfrak { q }   \cdot   \mathord { \odot }</tex>, so either <tex>\mathfrak { p }   \mid   \mathord { \odot }</tex> which is forbidden, or <tex>\mathfrak { p }   \mid   \mathfrak { q }</tex>. Conversely we must have <tex>\mathfrak { q }   \mid   \mathfrak { p }</tex>, hence <tex>\mathfrak { p }  =  \mathfrak { q }</tex>.
  </p>

  <p>
    We prove surjectivity. Given an ideal <tex>\mathfrak { a }</tex>, we need to supplement it with a zeroth degree component <tex>\mathfrak { a } _0</tex> so that together they make a prime ideal not divided by <tex>\mathord { \odot }</tex>. We define <tex>\mathfrak { a } _0  \mid  c</tex> iff there exists some positively graded <tex>\mathfrak { a }   \nmid  f</tex> such that <tex>\mathfrak { a }   \mid  cf</tex>. The verification is routine element chasing.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1708</anchor> <taxon>Definition</taxon> <addr>algm-000Y</addr><route>algm-000Y.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Projective spectrum of a graded ring</title>   </frontmatter> <mainmatter><p>
  Given a <tex>\mathbb  N</tex>-graded ring <tex>S_ \bullet</tex>, we construct a locale analogous to <link href="algm-0007.xml" type="local" addr="algm-0007" title="Localic spectrum of a commutative ring">the <tex>\operatorname {Spec}</tex> construction</link> for affine schemes. We start with symbols of <strong>distinguished opens</strong> <tex>D_+ (f)</tex> for each positively graded element <tex>f</tex>, and impose the same relations: <tex>D_+</tex> sends finite products to finite intersections, and for elements of the same grade, <tex>D_+ ( \sum _i f_i)  \subseteq   \bigcup _i D_+(f_i)</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1709</anchor> <taxon>Definition</taxon> <addr>algm-0010</addr><route>algm-0010.xml</route>  <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Structure sheaf of <tex>\operatorname {Proj} (S)</tex></title>   </frontmatter> <mainmatter><p>
  Fix a <link href="hmlg-001L.xml" type="local" addr="hmlg-001L" title="Graded ring">graded ring</link> <tex>S</tex>. For a positively graded element <tex>f</tex>, we have a graded ring localization <tex>S[f^{-1}]_ \bullet</tex>. Let <tex>\Gamma (D_+(f),  \mathscr { O } )</tex> be the zeroth degree component <tex>S[f^{-1}]_0</tex>. This defines a sheaf over the <link href="algm-000Y.xml" type="local" addr="algm-000Y" title="Projective spectrum of a graded ring">projective spectrum</link>, and moreover gives a <link href="algm-000R.xml" type="local" addr="algm-000R" title="Scheme">scheme</link> <tex>\operatorname {Proj} (S)</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1710</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>12</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0010</parent> </frontmatter> <mainmatter>
  <p>
    We claim that <tex>\operatorname {Proj} (S)</tex> can alternatively be given by gluing affine schemes. We assign <tex>D_+ (f)</tex> the affine scheme <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> (which is possible because the open subspace <tex>D_+ (f)</tex> is homeomorphic to <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> as a space). Given two positively graded elements <tex>f</tex> and <tex>g</tex>, we have an isomorphism between <tex>\operatorname {Proj} (S)</tex> restricted to <tex>D_+ (f g)</tex> and <tex>\operatorname {Spec} (S[f^{-1}]_0)</tex> restricted to <tex>D(g^{ \deg  f}/f^{ \deg  g})</tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1711</anchor> <taxon>Theorem</taxon> <addr>algm-000W</addr><route>algm-000W.xml</route>  <date><year>2024</year> <month>3</month> <day>8</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Action of morphisms on stalks of locally ringed spaces</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-000S.xml" type="local" addr="algm-000S" title="Morphism of ringed spaces">morphism of ringed spaces</link> <tex>\varphi  : X  \to  Y</tex>, if it is <link href="algm-000U.xml" type="local" addr="algm-000U" title="Morphism of locally ringed spaces">local</link>, a germ is invertible iff its <link href="algm-000V.xml" type="local" addr="algm-000V" title="Terminology of pullbacks">pullback</link> under <tex>\varphi</tex> is invertible. If the space <tex>X</tex> has enough points, then the inverse implication is also true.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1712</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>8</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000W</parent> </frontmatter> <mainmatter>
  <p>
    Note that the stalk <tex>( \varphi ^{-1} \mathscr { O } _{Y})_x =  \mathscr { O } _{Y,  \varphi (x)}</tex>. A germ being invertible implies for some neighborhood <tex>U</tex> of <tex>x</tex>, it comes from an invertible section <tex>f  \in   \Gamma (U,  \varphi ^{-1} \mathscr { O } _Y)</tex>, so the image in <tex>\Gamma (U,  \mathscr { O } _X)</tex> is also invertible, and hence the image germ. The locality condition gives the converse.
  </p>

  <p>
    On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1713</anchor> <taxon>Theorem</taxon> <addr>algm-000X</addr><route>algm-000X.xml</route>  <date><year>2024</year> <month>3</month> <day>8</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Morphisms of affine schemes</title>   </frontmatter> <mainmatter><p><link href="algm-000U.xml" type="local" addr="algm-000U" title="Morphism of locally ringed spaces">Morphism</link> of <link href="algm-000Q.xml" type="local" addr="algm-000Q" title="Affine scheme">affine schemes</link> are in natural bijection with ring homomorphisms in the opposite direction. In other words, there is a fully faithful embedding <tex>\mathsf { CRing } ^ \textrm {op}   \to   \mathsf { Sch }</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1714</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>8</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000X</parent> </frontmatter> <mainmatter>
  <p>
    Given two rings <tex>R</tex>, <tex>S</tex>, a ring homomorphism <tex>\varphi  : S  \to  R</tex> naturally induces a map of <link href="algm-0004.xml" type="local" addr="algm-0004" title="Distinguished opens of {Spec}(R)">distinguished opens</link> <tex>f  \mapsto   \varphi (f)</tex>. This is a continuous map <tex>\operatorname {Spec} (R)  \to   \operatorname {Spec} (S)</tex>, because <tex>\varphi</tex> preserves <tex>\operatorname {lcm}</tex> and <tex>\gcd</tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <tex>\Gamma (D(s),  \mathscr { O } _{ \operatorname {Spec} (S)})  \to   \Gamma (D(r),  \mathscr { O } _{ \operatorname {Spec} (R)})</tex> whenever <tex>D(r)  \subseteq   \varphi ^{-1}D(s) = D( \varphi (s))</tex>. This is just a homomorphism <tex>S[s^{-1}]  \to  R[r^{-1}]</tex>, which is obvious because <tex>\varphi (s)</tex> must be invertible in <tex>R[r^{-1}]</tex>.
  </p>

  <p>
    We need to prove our map is <link href="algm-000U.xml" type="local" addr="algm-000U" title="Morphism of locally ringed spaces">local</link>. Using the <link href="algm-000W.xml" type="local" addr="algm-000W" title="Action of morphisms on stalks of locally ringed spaces">characterization on stalks</link>, we just need to verify that <tex>S_{ \varphi ^{-1}( \mathfrak { p } )}  \to  R_{ \mathfrak { p } }</tex> reflects invertibility. This is true by construction. Hence we have a map <tex>\hom _{ \mathsf { CRing } }(S, R)  \to   \hom _{ \mathsf { Sch } }( \operatorname {Spec} (R),  \operatorname {Spec} (S))</tex>.
  </p>

  <p>
    In the reverse direction, given a morphism <tex>\varphi  :  \operatorname {Spec} (R)  \to   \operatorname {Spec} (S)</tex>, we can extract a ring homomorphism by looking at the global sections
    <tex display="block">S  \cong   \Gamma ( \top ,  \varphi ^{-1} \mathscr { O } _{ \operatorname {Spec} (S)})  \to   \Gamma ( \top ,  \mathscr { O } _{ \operatorname {Spec} (R)})  \cong  R.</tex>
    We obviously have going from <tex>\mathsf { CRing }</tex> to <tex>\mathsf { Sch }</tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:
  </p>

  
  <embedded-tex hash="b2218c11f9fffc76a55f570d96e735cd"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
    S &amp; R  \\ 
    {S_{ \mathfrak { q } }} &amp; {R_{ \mathfrak { p } }}
     \arrow [from=1-1, to=1-2]
     \arrow [from=2-1, to=2-2]
     \arrow [two heads, from=1-1, to=2-1]
     \arrow [two heads, from=1-2, to=2-2]
   \end {tikzcd}
  </embedded-tex-body></embedded-tex>


  <p>
    where <tex>\left [ \mathfrak { q } \right ]</tex> is the image of the point <tex>\left [ \mathfrak { p } \right ]</tex> under the underlying continuous map of <tex>\varphi</tex>. This fixes the action of <tex>\varphi</tex> on the stalks. Furthermore, the <link href="algm-000W.xml" type="local" addr="algm-000W" title="Action of morphisms on stalks of locally ringed spaces">locality</link> implies the preimage of <tex>\mathfrak { p }</tex> under the ring homomorphism divides <tex>\mathfrak { q }</tex>, and since <tex>\mathfrak { q }</tex> is maximal in the local ring <tex>S_{ \mathfrak { q } }</tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1715</anchor> <taxon>Remark</taxon> <addr>algm-000V</addr><route>algm-000V.xml</route>  <date><year>2024</year> <month>3</month> <day>8</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Terminology of pullbacks</title>   </frontmatter> <mainmatter><p>
  In general, a pullback is any contravariant functorial action. In other words, we have a functor <tex>F :  \mathcal { C } ^ \textrm {op}   \to   \mathcal { D }</tex>, and pulling back along a morphism <tex>f</tex> in <tex>\mathcal { C }</tex> means the action of <tex>F(f)</tex>.
</p><p>
  In differential geometry, we have a set of <tex>k</tex>-forms <tex>\Omega ^k(M)</tex>, which forms a functor <tex>\mathsf { Mfd } ^ \textrm {op}   \to   \mathsf { Set }</tex>. Pullbacks of differential forms is then the functorial action. In the special case of <tex>k = 0</tex>, this corresponds to composition, which is sometimes also referred to as pullbacks.
</p><p>
  The categorical pullback can also be construed as a contravariant action, which forms the functor from <tex>\mathcal { C } ^ \textrm {op}</tex> to the <tex>2</tex>-category <tex>\mathsf { Cat }</tex> given by taking slices.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1716</anchor> <taxon>Definition</taxon> <addr>algm-000U</addr><route>algm-000U.xml</route>  <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Morphism of locally ringed spaces</title>   </frontmatter> <mainmatter><p>
  Given two <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed spaces</link>, a <link href="algm-000S.xml" type="local" addr="algm-000S" title="Morphism of ringed spaces">morphism of ringed spaces</link> <tex>\varphi</tex> between them is <strong>local</strong> when sections of <tex>\varphi ^{-1} \mathscr { O } _Y</tex> are invertible iff their images in <tex>\mathscr { O } _X</tex> are invertible, i.e. the following diagram is a pullback:
</p>
  <embedded-tex hash="69e54c9a812569360596e10c9b32a793"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  { \varphi ^{-1} \mathscr { O } _Y^ \times } &amp; { \mathscr { O } _X^ \times }  \\ 
  { \varphi ^{-1} \mathscr { O } _Y} &amp; { \mathscr { O } _X}
   \arrow [hook, from=1-1, to=2-1]
   \arrow [hook, from=1-2, to=2-2]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [&quot; \lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
<p>
  Note that the <link href="algm-000T.xml" type="local" addr="algm-000T" title="Subsheaf of units">subsheaf of units</link> is given by a finite limit, hence <tex>\varphi ^{-1}</tex> preserves it. Since the lower map map <tex>\varphi ^{-1}  \mathscr { O } _Y  \to   \mathscr { O } _X</tex> is a ring homomorphism on the sections, it maps units to units. Hence restriction to the upper map makes sense.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1717</anchor> <taxon>Definition</taxon> <addr>algm-000T</addr><route>algm-000T.xml</route>  <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Subsheaf of units</title>   </frontmatter> <mainmatter><p>
  Given a sheaf <tex>\mathscr { O }</tex> of rings, we can define a subsheaf <tex>\mathscr { O } ^ \times</tex> consisting of the invertible elements, i.e. <tex>\Gamma (U,  \mathscr { O } ^ \times ) =  \Gamma (U,  \mathscr { O } )^ \times</tex>. This is the <strong>subsheaf of units</strong>.
</p><p>
  This can be equivalently expressed as a pullback of <tex>\mathscr { O }   \times   \mathscr { O }   \xrightarrow {(f,g)  \mapsto  f g}  \mathscr { O }</tex> and <tex>1  \xrightarrow {1}  \mathscr { O }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1718</anchor> <taxon>Definition</taxon> <addr>algm-000Q</addr><route>algm-000Q.xml</route>  <date><year>2024</year> <month>3</month> <day>6</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Affine scheme</title>   </frontmatter> <mainmatter><p>
  An <strong>affine scheme</strong> is a <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed space</link> of the form <tex>\operatorname {Spec} (R)</tex> for some commutative ring <tex>R</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1719</anchor> <taxon>Intuition</taxon> <addr>algm-000O</addr><route>algm-000O.xml</route>  <date><year>2024</year> <month>3</month> <day>6</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Locally ringed space</title>   </frontmatter> <mainmatter><p>
  The <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locality</link> requirement for a <link href="algm-000M.xml" type="local" addr="algm-000M" title="Ringed space">ringed space</link> is to guarantee that the sections behave like functions valued in some field.
</p><p>
  It is impossible in general to discuss the vanishing region of a section <tex>f  \in   \Gamma (U,  \mathscr { O } )</tex>. For instance, the germs of continuous functions are non-zero on their support, which is the closure of the non-vanishing region. In algebraic geometry, such an overspill destroys most valuable information. We can talk about the maximal region on which the section is invertible, but this is different from being non-zero if sections don’t behave like functions. Similarly, it is also impossible to discuss the value of a section at some point in general. In locally ringed space, we have <ref addr="algm-000P" href="algm-000P.xml" taxon="Definition"/>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1720</anchor> <taxon>Definition</taxon> <addr>algm-000S</addr><route>algm-000S.xml</route>  <date><year>2024</year> <month>3</month> <day>6</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Morphism of ringed spaces</title>   </frontmatter> <mainmatter><p>
  Given two <link href="algm-000M.xml" type="local" addr="algm-000M" title="Ringed space">ringed spaces</link> <tex>X, Y</tex>, a morphism <tex>\varphi  : X  \to  Y</tex> is given by a continuous map of the underlying spaces, and a sheaf morphism <tex>\varphi ^{-1}  \mathscr { O } _Y  \to   \mathscr { O } _X</tex>, equivalently <tex>\mathscr { O } _Y  \to   \varphi _*  \mathscr { O } _X</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1721</anchor> <taxon>Definition</taxon> <addr>algm-000R</addr><route>algm-000R.xml</route>  <date><year>2024</year> <month>3</month> <day>6</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Scheme</title>   </frontmatter> <mainmatter><p>
  A <strong>scheme</strong> is a <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed space</link> with an open covering on which the space is isomorphic to <link href="algm-000Q.xml" type="local" addr="algm-000Q" title="Affine scheme">affine schemes</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1722</anchor> <taxon>Definition</taxon> <addr>algm-000P</addr><route>algm-000P.xml</route>  <date><year>2024</year> <month>3</month> <day>6</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Value of section at a point</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed space</link> and a section <tex>f  \in   \Gamma (U,  \mathscr { O } )</tex>, the germ of <tex>f</tex> at a point is an element of a local ring. The image of this element in the residue field, i.e. the quotient by the unique maximal ideal is called the <strong>value</strong> of this section at this point.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1723</anchor> <taxon>Definition</taxon> <addr>algm-000L</addr><route>algm-000L.xml</route>  <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Locally ringed space</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-000M.xml" type="local" addr="algm-000M" title="Ringed space">ringed space</link>, i.e. a space <tex>X</tex> with a sheaf of rings <tex>\mathscr { O }</tex>, it is said to be <strong>locally ringed</strong> iff the following conditions hold:
  <ul><li>If <tex>\Gamma (U,  \mathscr { O } ) = 0</tex>, then <tex>U</tex> is empty.</li>
    <li>Suppose <tex>f + g  \in   \Gamma (U,  \mathscr { O } )</tex> is invertible, then we can cover <tex>U</tex> with two open sets such that <tex>f</tex> and <tex>g</tex> are invertible when restricted respectively.</li></ul>
  This can be unified as one condition: If a finite sum in <tex>\Gamma (U,  \mathscr { O } )</tex> is invertible, then each summand is invertible when restricted to an open, which jointly covers <tex>U</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1724</anchor> <taxon>Definition</taxon> <addr>algm-000M</addr><route>algm-000M.xml</route>  <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Ringed space</title>   </frontmatter> <mainmatter><p>
  A <strong>ringed space</strong> is a space equipped with a sheaf of rings, called the <strong>structure sheaf</strong>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1725</anchor> <taxon>Remark</taxon> <addr>algm-000K</addr><route>algm-000K.xml</route>  <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Sheaf and stalk from <tex>R</tex>-modules</title>   </frontmatter> <mainmatter><p>
  The proofs in <ref addr="algm-000I" href="algm-000I.xml" taxon="Definition"/> and <ref addr="algm-000J" href="algm-000J.xml" taxon="Theorem"/> do not make use of the multiplication on the numerators. Therefore they immediately generalizes to modules. In particular, we have a sheaf corresponding to an <tex>R</tex>-module <tex>M</tex>, whose sections over <tex>D(f)</tex> form the <tex>R[f^{-1}]</tex>-module <tex>M[f^{-1}]</tex>. The stalk on <tex>\left [ \mathfrak { p } \right ]</tex> is isomorphic to <tex>M_{ \left [ \mathfrak { p } \right ] }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1726</anchor> <taxon>Theorem</taxon> <addr>algm-000J</addr><route>algm-000J.xml</route>  <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Stalk of the structure sheaf on <tex>\operatorname {Spec} (R)</tex></title>   </frontmatter> <mainmatter><p>
  Given a point <tex>\left [ \mathfrak { p } \right ]   \in   \operatorname {Spec} (R)</tex>, the stalk at the point is the localization <tex>R_{ \mathfrak { p } }</tex>. In particular, the ring spectrum is a <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed space</link> by <ref addr="algm-000N" href="algm-000N.xml" taxon="Theorem"/>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1727</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000J</parent> </frontmatter> <mainmatter>
  <p>
    We take a directed limit. The elements are from some <tex>R[f^{-1}]</tex> with <tex>\mathfrak { p }   \nmid  f</tex>, i.e. the elements can be written as <tex>g/f^n</tex>. Two elements are equal iff their common restriction to some <tex>D(f)</tex> is equal, i.e. <tex>g_1/f_1^n = g_2/f_2^m</tex> iff <tex>(g_1 f_2^m - g_2 f_1^n) f^k = 0</tex>. These are exactly the definition of the localization away from <tex>\mathfrak { p }</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1728</anchor> <taxon>Theorem</taxon> <addr>algm-000N</addr><route>algm-000N.xml</route>  <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Stalks of locally ringed topological space</title>   </frontmatter> <mainmatter><p>
  Given a <link href="algm-000M.xml" type="local" addr="algm-000M" title="Ringed space">ringed</link> topological space, it is <link href="algm-000L.xml" type="local" addr="algm-000L" title="Locally ringed space">locally ringed</link> iff every stalk is a local ring.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1729</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>5</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000N</parent> </frontmatter> <mainmatter>
  <p>
    Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.
  </p>

  <p>
    In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1730</anchor> <taxon>Theorem</taxon> <addr>algm-000H</addr><route>algm-000H.xml</route>  <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Irreducible closeds in a ring spectrum</title>   </frontmatter> <mainmatter><p>
  A closed <tex>V( \mathfrak { r } )</tex> in <tex>\operatorname {Spec} (R)</tex> is irreducible iff <tex>\mathfrak { r }</tex> is prime, and it is an irreducible component iff <tex>\mathfrak { r }</tex> is a minimal prime ideal, i.e. prime ideals that divide no other prime ideals.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1731</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000H</parent> </frontmatter> <mainmatter>
  <p>
    Translating via <ref addr="algm-0002" href="algm-0002.xml" taxon="Theorem"/>, we have a proper ideal <tex>\mathfrak { r }</tex> that cannot be written as <tex>\operatorname {lcm} ( \mathfrak { r } _1,  \mathfrak { r } _2)</tex> non-trivially. Suppose <tex>\mathfrak { r }   \mid  f g</tex>, then <tex>\mathfrak { r }   \mid   \sqrt {f g}  \mid   \operatorname {lcm} (f, g)</tex>. So
    <tex display="block">\begin {aligned}        \mathfrak { r }  &amp;=  \gcd ( \mathfrak { r } ,  \operatorname {lcm} (f, g))  \\        &amp;=  \operatorname {lcm} ( \gcd ( \mathfrak { r } , f),  \gcd ( \mathfrak { r } , g)).      \end {aligned}</tex>
    Hence at least one of the two must be equal to <tex>\mathfrak { r }</tex>. So <tex>\mathfrak { r }   \mid  f</tex> or <tex>\mathfrak { r }   \mid  g</tex>.
  </p>

  <p>
    An irreducible closed is an irreducible <em>component</em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1732</anchor>  <addr>algm-000G</addr><route>algm-000G.xml</route>  <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Noetherian rings and <link href="algm-000C.xml" type="local" addr="algm-000C" title="Noetherian space">noetherian spaces</link></title>   </frontmatter> <mainmatter><p>
  The <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring">spectrum</link> of a noetherian ring is always noetherian: the closeds corresponds to radical ideals. The converse does not hold. Consider a polynomial ring with infinitely many indeterminates <tex>x_1, x_2,  \dots</tex> quotiented by the relations <tex>x_k^k = 0</tex>. <link href="algm-000E.xml" type="local" addr="algm-000E" title="Ideals under quotient and localization">The ideals in the quotient ring</link> correspond to ideals in the polynomial ring dividing <tex>x_k^k</tex> for every <tex>k</tex>. So there are only two radical ideals: the trivial one, and the one that divides all indeterminates, but not constants. Hence the spectrum must be a noetherian space, but the ring is obviously not noetherian since it is not finitely generated itself.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1733</anchor> <taxon>Definition</taxon> <addr>algm-000I</addr><route>algm-000I.xml</route>  <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Structure sheaf of a ring spectrum</title>   </frontmatter> <mainmatter><p>
  Given a commutative ring <tex>R</tex>, we define a sheaf <tex>\mathscr { O }</tex> of rings on <tex>\operatorname {Spec} (R)</tex> called the <strong>structure sheaf</strong>. Let <tex>\Gamma (D(f),  \mathscr { O } ) = R[f^{-1}]</tex>. Suppose <tex>D(f)  \subseteq  D(g)</tex> we define the restriction morphism to be the localization map <tex>R[g^{-1}]  \to  R[f^{-1}]</tex>, since by <ref addr="algm-0002" href="algm-0002.xml" taxon="Theorem"/> the latter is a further localization of the former. This turns <tex>\operatorname {Spec} (R)</tex> into a <link href="algm-000M.xml" type="local" addr="algm-000M" title="Ringed space">ringed space</link>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1734</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000I</parent> </frontmatter> <mainmatter>
  <p>
    We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <tex>f_i  \in  R</tex> such that <tex>\bigcup _i D(f_i) = D(f)</tex>, we need to show that
    <tex display="block">R[f^{-1}]  \to   \prod _{i  \in  I} R[f_i^{-1}]  \rightrightarrows   \prod _{i  \ne  j} R[(f_i f_j)^{-1}]</tex>
    is an equalizer. Notice that <tex>R[f_i^{-1}]  \cong  R[f^{-1}][f_i^{-1}]</tex>. So we may reassign <tex>S = R[f^{-1}]</tex>. This simplifies the problem to
    <tex display="block">S  \to   \prod _{i  \in  I} S[f_i^{-1}]  \rightrightarrows   \prod _{i  \ne  j} S[(f_i f_j)^{-1}],</tex>
    where <tex>D(f_i)</tex> covers the whole space <tex>\operatorname {Spec} (S)</tex>. 
  </p>

  <p>
    We first describe the intuition. Since we know <tex>\operatorname {Spec} (S)</tex> is <link href="algm-000B.xml" type="local" addr="algm-000B" title="A ring spectrum is quasi-compact">quasi-compact</link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <tex>g_i/f_i^{d_i}  \in  S[f_i^{-1}]</tex> that are equal in their common domain. Since <tex>D(f_i) = D(f_i^{d_i})</tex> covers <tex>\operatorname {Spec} (S)</tex>, we have a linear combination <tex>1 =  \sum _i c_i f_i^{d_i}</tex>, which is akin to a partition of unity. Suppose the putative gluing is <tex>f</tex>, multiplying with the partition of unity we get
    <tex display="block">\begin {aligned}       f &amp;=  \sum _{i  \in  I} c_i f_i^{d_i} f  \\        &amp;=  \sum  c_i f_i^{d_i}  \frac {g_i}{f_i^{d_i}}  \\        &amp;=  \sum  c_i g_i.      \end {aligned}</tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.
  </p>

  <p>
    Suppose there are elements <tex>g_i/f_i^d  \in  S[f_i^{-1}]</tex>, where we are allowed to use a single exponent <tex>d</tex> by finiteness. The compatibility requirement is <tex display="block">(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.</tex> If there is a solution <tex>f</tex> to the gluing problem, it would need to satisfy <tex>(f f_i^d - g_i) f_i^M = 0</tex>. Since <tex>D(f_i) = D(f_i^R)</tex> covers <tex>\operatorname {Spec} (S)</tex>, we have a linear combination <tex>1 =  \sum _i c_i f_i^R</tex> for large enough <tex>R</tex>. Hence
    <tex display="block">f =  \sum _{i  \in  I} c_i f f_i^R =  \sum  c_i g_i f_i^{R-d}.</tex> This uniquely determines <tex>f</tex>. And indeed, this solution satisfies our requirements, because when restricted to <tex>D(f_j)</tex>, we have
    <tex display="block">\begin {aligned}       f f_j^d  \cdot  f_j^R &amp;=  \sum  c_i g_i f_i^{R-d} f_j^{R+d}  \\        &amp;=  \sum  c_i g_j f_i^{R} f_j^{R}  \\        &amp;= g_j f_j^R  \cdot   \sum  c_i f_i^R = g_j f_j^R.      \end {aligned}</tex>
    This reasoning is valid as long as <tex>R &gt; N + 2d</tex>.
  </p>

  <p>
    If there are infinitely many opens, we first use <link href="algm-000B.xml" type="local" addr="algm-000B" title="A ring spectrum is quasi-compact">quasi-compactness</link> to select a finite number <tex>D(f_1),  \dots , D(f_k)</tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <tex>f</tex> for <tex>D(f_1),  \dots , D(f_k)</tex>. Then consider the solution on <tex>D(f_1),  \dots , D(f_k) , D(g)</tex> for every <tex>g</tex>. This solution must be equal to <tex>f</tex> by uniqueness. Therefore <tex>f</tex> restrict to the correct function on each <tex>D(g)</tex>, showing that <tex>f</tex> is the required solution.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1735</anchor>  <addr>trebor-0002</addr><route>trebor-0002.xml</route>  <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Style of writing</title>   </frontmatter> <mainmatter><p>
  I try to adhere to several principles when composing trees.
</p><ul><li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </li>
  <li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <tex>\mathfrak { a }   \mid  x</tex> instead of <tex>x  \in   \mathfrak { a }</tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <tex>\operatorname {Spec} (A)</tex>, we do not identify them.
  </li>
  <li>
    Apply <link href="https://ncatlab.org/nlab/show/biased+definition" type="external">unbiased terminology</link> and <link href="https://ncatlab.org/nlab/show/negative+thinking" type="external">negative thinking</link>.
  </li></ul></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1736</anchor> <taxon>Theorem</taxon> <addr>algm-0009</addr><route>algm-0009.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\operatorname {Spec} {R}</tex> is disconnected iff <tex>R</tex> is a product of non-zero rings</title>   </frontmatter> <mainmatter><p>
  Given a commutative ring <tex>R</tex>, <tex>\operatorname {Spec} {R}</tex> is disconnected iff <tex>R  \cong  R_1  \times  R_2</tex>, where <tex>R_1, R_2</tex> are non-zero commutative rings.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1737</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0009</parent> </frontmatter> <mainmatter>
  <p>
    In one direction, if <tex>\operatorname {Spec} {R}</tex> is disconnected, we have two opens <tex>D( \mathfrak { a } )</tex> and <tex>D( \mathfrak { b } )</tex> whose intersection is empty and union is the entire space. In other words radical ideals <tex>\mathfrak { a } ,  \mathfrak { b }</tex> such that <tex>\sqrt { \gcd ( \mathfrak { a } ,  \mathfrak { b } )} = 1</tex> (equivalent to <tex>\gcd ( \mathfrak { a } ,  \mathfrak { b } ) = 1</tex>) and <tex>\operatorname {lcm} ( \mathfrak { a } ,  \mathfrak { b } ) = 0</tex>. We have <tex>\mathfrak { a }   \mid  a</tex> and <tex>\mathfrak { b }   \mid  b</tex> such that <tex>a + b = 1</tex>. But <tex>\operatorname {lcm} ( \mathfrak { a } ,  \mathfrak { b } )  \mid  a b</tex>, therefore <tex>a b = 0</tex>. This implies <tex>a(1-a) = 0</tex>, or <tex>a^2 = a</tex>. The same goes for <tex>b</tex>.
  </p>

  <p>
    Let <tex>R_1</tex> be the subset of <tex>R</tex> consisting of multiples of <tex>a</tex>. It contains an identity <tex>a</tex>, since <tex>a  \cdot  a x = a x</tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <tex>R_2</tex>, the multiples of <tex>b</tex>. There is an obvious map <tex>R_1  \times  R_2  \to  R</tex>, given by <tex>(ax, by)  \mapsto  ax + by</tex>. This is an injection since <tex>z  \mapsto  a z</tex> recovers the first argument, and <tex>z  \mapsto  b z</tex> recovers the second. It is also a surjection because <tex>z = a z + b z</tex> is the image of <tex>(az, bz)</tex>. Hence we found an isomorphism.
  </p>

  <p>
    In the other direction, suppose <tex>R  \cong  R_1  \times  R_2</tex>, then <tex>D((1,0))</tex> and <tex>D((0,1))</tex> separates the spectrum into two disjoint parts.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1738</anchor> <taxon>Theorem</taxon> <addr>algm-000F</addr><route>algm-000F.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Hilbert basis theorem</title>   </frontmatter> <mainmatter><p>
  If a commutative ring <tex>R</tex> is noetherian, then <tex>R[x]</tex> is also noetherian.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1739</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000F</parent> </frontmatter> <mainmatter>
  <p>
    Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <tex>\mathfrak { a } R  \subseteq  R</tex>. We recursively produce a list of generators. Suppose we have already selected <tex>f_1,  \dots , f_n</tex>. If this doesn’t generate <tex>\mathfrak { a } R</tex>, then we select another one of the lowest degree. We prove that this procedure terminates.
  </p>

  <p>
    Consider the initial coefficient <tex>c_i</tex> of <tex>f_i</tex>. The ideal <tex>\mathfrak { c } _k</tex> generated by the first <tex>k</tex> elements must eventually stabilize. Let’s say <tex>c_{n+1} =  \sum _{i=1}^n b_i c_i</tex>. Then we can subtract <tex>f_{n+1}</tex> by suitable multiples of <tex>f_1,  \dots , f_n</tex> to cancel the leading term. This must not belong to ideal generated by <tex>f_1,  \dots , f_n</tex>, which contradicts our choice of generators, being of the lowest degree.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1740</anchor> <taxon>Theorem</taxon> <addr>algm-000B</addr><route>algm-000B.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>A <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring">ring spectrum</link> is quasi-compact</title>   </frontmatter> <mainmatter><p>
  The space <tex>\operatorname {Spec} (R)</tex> is always <link href="algm-000A.xml" type="local" addr="algm-000A" title="Terminology of compactness in algebraic geometry">quasi-compact</link>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1741</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000B</parent> </frontmatter> <mainmatter>
  <p>
    Since quasi-compectness can be tested on a basis, we just have to show that if <tex>\bigcup _i D(f_i) =  \top</tex>, then there is a finite union equal to <tex>\top</tex>. Algebraically this means <tex>\sqrt { \gcd \{ f_i \} } = 1</tex>, equivalently <tex>\gcd \{ f_i \}  = 1</tex>. So we have a linear combination <tex>\sum _k a_k f_k = 1</tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1742</anchor> <taxon>Theorem</taxon> <addr>algm-000D</addr><route>algm-000D.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>A closed in a noetherian space is uniquely a finite union of irreducible closeds</title>   </frontmatter> <mainmatter><p>
  If <tex>X</tex> is a <link href="algm-000C.xml" type="local" addr="algm-000C" title="Noetherian space">noetherian space</link>, then a closed <tex>Z  \subseteq  X</tex> can be written uniquely as the union of finitely many irreducible closeds.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1743</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-000D</parent> </frontmatter> <mainmatter>
  <p>
    We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <tex>Z</tex> can be written as a finite union. If <tex>Z</tex> is irreducible then we’re done. Otherwise <tex>Z = Z_1  \cup  Z_2</tex> is a non-trivial union of two closeds. By the induction hypothesis <tex>Z_1</tex> and <tex>Z_2</tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.
  </p>

  <p>
    We then prove uniqueness. Suppose
    <tex display="block">Z_1  \cup   \cdots   \cup  Z_n = Z'_1  \cup   \cdots   \cup  Z'_m.</tex>
    Consider the intersection with <tex>Z_1</tex>. The left hand side collapses to <tex>Z_1</tex>. The right hand side becomes <tex>\bigcup _{i=1}^m (Z'_i  \cap  Z_1)</tex>. Since <tex>Z_1</tex> is irreducible, <tex>Z'_i  \cap  Z_1</tex> must be either <tex>Z_1</tex> or empty. In the former case, since <tex>Z'_i</tex> is also irreducible, <tex>Z'_i = Z_1</tex>. Therefore each <tex>Z_j</tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1744</anchor> <taxon>Theorem</taxon> <addr>algm-0008</addr><route>algm-0008.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Characterization of the locale <tex>\operatorname {Spec} (R)</tex></title>   </frontmatter> <mainmatter><p>
  The opens in <link href="algm-0007.xml" type="local" addr="algm-0007" title="Localic spectrum of a commutative ring">the locale</link> <tex>\operatorname {Spec} (R)</tex> bijectively corresponds to radical ideals of <tex>R</tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</link> by <ref addr="algm-0002" href="algm-0002.xml" taxon="Theorem"/>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1745</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0008</parent> </frontmatter> <mainmatter>
  <p>
    We can first put the opens in disjunctive normal form
    <tex display="block">U =  \bigcup _{i  \in  I}  \bigcap _{j=1}^{n_i} D(f_{i, j}).</tex>
    By the definition we can reduce the intersections into products. Write <tex>f_i =  \prod _j f_{i, j}</tex>, we have <tex>U =  \bigcup _i D(f_i)</tex>. Given this form, we can try to <em>saturate</em> the union, by throwing in everything that doesn’t enlarge <tex>U</tex>. In other words, we only consider the unions such that no other generator <tex>D(f)</tex> can be added, i.e. <tex>D(f)  \nsubseteq  U</tex>. This would uniquely determine <tex>U</tex>.
  </p>

  <p>
    Such a saturated set would have to be closed under addition since <tex>D(f+g)  \subseteq  D(f)  \cup  D(g)</tex>, and for the nullary case it must include <tex>D(0) =  \bot</tex>. It also has to absorb multiplication, because <tex>D(f  \cdot  g)  \subseteq  D(f)</tex>. This means we are dealing with ideals. Henceforth, we write <tex>D( \mathfrak { a } )</tex> for the union <tex>\bigcup _{ \mathfrak { a }   \mid  f} D(f)</tex>.
  </p>

  <p>
    There is one last requirement we haven’t dealt with, i.e. <tex>D(f  \cdot  g)</tex> is the <em>greatest</em> lower bound of <tex>D(f)</tex> and <tex>D(g)</tex>, instead of simply a lower bound. For example, this gives the equality <tex>D(f^n) = D(f)</tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <tex>f  \cdot  g</tex> is equal to the lowest common multiple of the radical ideals generated by <tex>f</tex> and <tex>g</tex>, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1746</anchor> <taxon>Definition</taxon> <addr>algm-0004</addr><route>algm-0004.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Distinguished opens of <tex>\operatorname {Spec} (R)</tex></title>   </frontmatter> <mainmatter><p>
  We define a basis of opens on <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring"><tex>\operatorname {Spec} (R)</tex></link> by <tex>D(f)</tex> for every element <tex>f  \in  R</tex>. These are called <strong>distinguished opens</strong>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1747</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0004</parent> </frontmatter> <mainmatter>
  <p>
    We claim that <tex display="block">D( \mathfrak { a } ) =  \bigcup _{ \mathfrak { a }   \mid  f} D(f).</tex> Alternatively, <tex>V( \mathfrak { a } ) =  \bigcap _{ \mathfrak { a }   \mid  f} V(f)</tex>. Since <tex>\mathfrak { a }   \mid  f</tex> implies <tex>V( \mathfrak { a } )  \subseteq  V(f)</tex>, we have the forward inclusion. For the backwards inclusion, suppose <tex>\left [ \mathfrak { p } \right ]   \notin  V( \mathfrak { a } )</tex>, i.e. <tex>\mathfrak { p }   \nmid   \mathfrak { a }</tex>, then by definition there is an element <tex>\mathfrak { a }   \mid  f</tex> such that <tex>\mathfrak { p }   \nmid  f</tex>, meaning that <tex>\left [ \mathfrak { p } \right ]   \notin  V(f)</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1748</anchor> <taxon>Theorem</taxon> <addr>algm-000E</addr><route>algm-000E.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Ideals under quotient and localization</title>   </frontmatter> <mainmatter><p>
  Given a commutative ring <tex>R</tex>, the ideals of <tex>R/ \mathfrak { a }</tex> bijectively corresponds to the ideals in <tex>R</tex> that divides <tex>\mathfrak { a }</tex>. The ideals of <tex>R[S^{-1}]</tex> are generated by images of ideals in <tex>R</tex> under the localization map, written as <tex>\mathfrak { b } [S^{-1}]</tex>, isomorphic to <tex>\mathfrak { b }   \otimes _R R[S^{-1}]</tex>.
</p><p>
  The prime ideals in <tex>R</tex> that doesn’t intersect <tex>S</tex> bijectively correspond to prime ideals in <tex>R[S^{-1}]</tex> via the localization map.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1749</anchor>  <addr>algm-0005</addr><route>algm-0005.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Localic spectrum of a commutative ring</title>   </frontmatter> <mainmatter><p>
  To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <tex>f/g</tex>, so the domain should be the non-vanishing part of <tex>g</tex>, which we denote as <tex>D(g)</tex>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1750</anchor>  <addr>algm-0006</addr><route>algm-0006.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Rational functions not definable via a single expression</title>   </frontmatter> <mainmatter><p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</p><p>
  For example, on the space given by <tex>xy = zw</tex>, we can define a funtion given by <tex>x/w</tex>, which is equal to <tex>z/y</tex>. They are only jointly undefined on <tex>w = z = 0</tex>, but there is no single expression that achieves this.
</p></mainmatter> </tree><p>
  Recognizing this, we can try to freely generate a locale using <tex>D(g)</tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1751</anchor> <taxon>Definition</taxon> <addr>algm-0007</addr><route>algm-0007.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Localic spectrum of a commutative ring</title>   </frontmatter> <mainmatter><p>
  Given a commutative ring <tex>R</tex>, we define a frame generated by the symbols <tex>D(f)</tex> for <tex>f  \in  R</tex>, subject to the following relations:
  <tex display="block">\begin {aligned}     D(0) &amp;=  \bot   \\      D(1) &amp;=  \top   \\      D(f  \cdot  g) &amp;= D(f)  \cap  D(g)  \\      D(f + g) &amp; \subseteq  D(f)  \cup  D(g)    \end {aligned}</tex>
  The resulting frame defines the <strong>localic spectrum</strong> <tex>\operatorname {Spec} (R)</tex>.
</p></mainmatter> </tree><p>
  We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1752</anchor> <taxon>Theorem</taxon> <addr>algm-0008</addr><route>algm-0008.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Characterization of the locale <tex>\operatorname {Spec} (R)</tex></title>   </frontmatter> <mainmatter><p>
  The opens in <link href="algm-0007.xml" type="local" addr="algm-0007" title="Localic spectrum of a commutative ring">the locale</link> <tex>\operatorname {Spec} (R)</tex> bijectively corresponds to radical ideals of <tex>R</tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</link> by <ref addr="algm-0002" href="algm-0002.xml" taxon="Theorem"/>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1753</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    We can first put the opens in disjunctive normal form
    <tex display="block">U =  \bigcup _{i  \in  I}  \bigcap _{j=1}^{n_i} D(f_{i, j}).</tex>
    By the definition we can reduce the intersections into products. Write <tex>f_i =  \prod _j f_{i, j}</tex>, we have <tex>U =  \bigcup _i D(f_i)</tex>. Given this form, we can try to <em>saturate</em> the union, by throwing in everything that doesn’t enlarge <tex>U</tex>. In other words, we only consider the unions such that no other generator <tex>D(f)</tex> can be added, i.e. <tex>D(f)  \nsubseteq  U</tex>. This would uniquely determine <tex>U</tex>.
  </p>

  <p>
    Such a saturated set would have to be closed under addition since <tex>D(f+g)  \subseteq  D(f)  \cup  D(g)</tex>, and for the nullary case it must include <tex>D(0) =  \bot</tex>. It also has to absorb multiplication, because <tex>D(f  \cdot  g)  \subseteq  D(f)</tex>. This means we are dealing with ideals. Henceforth, we write <tex>D( \mathfrak { a } )</tex> for the union <tex>\bigcup _{ \mathfrak { a }   \mid  f} D(f)</tex>.
  </p>

  <p>
    There is one last requirement we haven’t dealt with, i.e. <tex>D(f  \cdot  g)</tex> is the <em>greatest</em> lower bound of <tex>D(f)</tex> and <tex>D(g)</tex>, instead of simply a lower bound. For example, this gives the equality <tex>D(f^n) = D(f)</tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <tex>f  \cdot  g</tex> is equal to the lowest common multiple of the radical ideals generated by <tex>f</tex> and <tex>g</tex>, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1754</anchor> <taxon>Definition</taxon> <addr>algm-0007</addr><route>algm-0007.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Localic spectrum of a commutative ring</title>   </frontmatter> <mainmatter><p>
  Given a commutative ring <tex>R</tex>, we define a frame generated by the symbols <tex>D(f)</tex> for <tex>f  \in  R</tex>, subject to the following relations:
  <tex display="block">\begin {aligned}     D(0) &amp;=  \bot   \\      D(1) &amp;=  \top   \\      D(f  \cdot  g) &amp;= D(f)  \cap  D(g)  \\      D(f + g) &amp; \subseteq  D(f)  \cup  D(g)    \end {aligned}</tex>
  The resulting frame defines the <strong>localic spectrum</strong> <tex>\operatorname {Spec} (R)</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1755</anchor> <taxon>Definition</taxon> <addr>algm-000C</addr><route>algm-000C.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Noetherian space</title>   </frontmatter> <mainmatter><p>
  A space is <strong>noetherian</strong> if every descending chain of closeds, or equivalently every ascending chain of opens stabilizes. In other words, the partial order of closeds is well-founded.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1756</anchor>  <addr>algm-0006</addr><route>algm-0006.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Rational functions not definable via a single expression</title>   </frontmatter> <mainmatter><p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</p><p>
  For example, on the space given by <tex>xy = zw</tex>, we can define a funtion given by <tex>x/w</tex>, which is equal to <tex>z/y</tex>. They are only jointly undefined on <tex>w = z = 0</tex>, but there is no single expression that achieves this.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1757</anchor> <taxon>Remark</taxon> <addr>algm-000A</addr><route>algm-000A.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Terminology of compactness in algebraic geometry</title>   </frontmatter> <mainmatter><p>
  The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1758</anchor> <taxon>Theorem</taxon> <addr>algm-0003</addr><route>algm-0003.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>The radical ideal is the lcm of prime ideal divisors</title>   </frontmatter> <mainmatter><p>
  For any ideal <tex>\mathfrak { a }</tex> of a commutative ring, the radical <tex>\sqrt { \mathfrak { a } }</tex> is the lowest common multiple of the prime ideals <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1759</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0003</parent> </frontmatter> <mainmatter>
  <p>
    On one hand, if <tex>\sqrt { \mathfrak { a } }  \mid  f</tex>, then <tex>\mathfrak { a }   \mid  f^n</tex> for some natural number <tex>n</tex>. This means for all <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex>, we have <tex>\mathfrak { p }   \mid  f^n</tex>, which by being a prime ideal implies <tex>\mathfrak { p }   \mid  f</tex>.
  </p>

  <p>
    On the other hand, suppose <tex>\mathfrak { a }   \nmid  f^n</tex> for any <tex>n</tex>, we construct a prime ideal divisor of <tex>\mathfrak { a }</tex> that is not a divisor of <tex>f</tex>. Consider the set of all ideals not a divisor of <tex>f^n</tex> for any <tex>n</tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <tex>\mathfrak { d }</tex> still in this set, since <tex>\mathfrak { d }</tex> divides exactly the elements divided by some ideal in the chain. By <link href="https://en.wikipedia.org/wiki/Zorn%27s_lemma" type="external">Zorn’s lemma</link>, the set contains some <tex>\mathfrak { q }</tex> not divided by any other ideal in the set. This ideal must be prime: take <tex>\mathfrak { q }   \nmid  x, y</tex> such that <tex>\mathfrak { q }   \mid  x y</tex>, then <tex>\mathfrak { q } ' =  \gcd ( \mathfrak { q } , x y)</tex> is a proper divisor of <tex>\mathfrak { q }</tex>, and by construction it cannot be in the previously constructed set. Hence there is some <tex>n</tex> such that <tex>x y  \mid  f^n</tex>, so <tex>\mathfrak { q }   \mid  x y  \mid  f^n</tex>, contradiction.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1760</anchor> <taxon>Theorem</taxon> <addr>algm-0002</addr><route>algm-0002.xml</route>  <date><year>2024</year> <month>3</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Radical ideals bijectively correspond to open sets</title>   </frontmatter> <mainmatter><p>
  In an arbitrary <link href="algm-0001.xml" type="local" addr="algm-0001" title="Topological spectrum of a commutative ring">topological spectrum of a commutative ring</link>, we have <tex>D( \mathfrak { a } ) = D( \sqrt { \mathfrak { a } })</tex>. There is a containment of opens <tex>D( \mathfrak { a } )  \subseteq  D( \mathfrak { b } )</tex> — equivalently <tex>V( \mathfrak { b } )  \subseteq  V( \mathfrak { a } )</tex> — iff <tex>\sqrt { \mathfrak { b } }  \mid   \sqrt { \mathfrak { a } }</tex>, and the points contained in an open set completely determines the radical ideal.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1761</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>algm-0002</parent> </frontmatter> <mainmatter>
  <p>
    Since <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex> implies <tex>\sqrt { \mathfrak { p } }  \mid   \sqrt { \mathfrak { a } }</tex>, but <tex>\mathfrak { p }  =  \sqrt { \mathfrak { p } }</tex>, we see that <tex>D( \mathfrak { a } ) = D( \sqrt { \mathfrak { a } })</tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <tex>\mathfrak { p }</tex> we have <tex>\mathfrak { p }   \mid   \mathfrak { b }   \implies   \mathfrak { p }   \mid   \mathfrak { a }</tex>. We need to prove that <tex>\sqrt { \mathfrak { a } }  \mid  f  \implies   \sqrt { \mathfrak { b } }  \mid  f</tex>.
  </p>

  <p>
    Given <tex>\sqrt { \mathfrak { a } }  \mid  f</tex>, we have <tex>\mathfrak { p }   \mid  f</tex> for all prime ideals <tex>\mathfrak { p }   \mid   \sqrt { \mathfrak { a } }</tex> (which is equivalent to <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex>). So we know that for all <tex>\mathfrak { p }   \mid   \mathfrak { b }</tex>, <tex>\mathfrak { p }   \mid  f</tex>. This is now purely a condition on <tex>\mathfrak { b }</tex>. The next lemma finishes the proof.
  </p>

  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1762</anchor> <taxon>Theorem</taxon> <addr>algm-0003</addr><route>algm-0003.xml</route>  <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>The radical ideal is the lcm of prime ideal divisors</title>   </frontmatter> <mainmatter><p>
  For any ideal <tex>\mathfrak { a }</tex> of a commutative ring, the radical <tex>\sqrt { \mathfrak { a } }</tex> is the lowest common multiple of the prime ideals <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1763</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>3</month> <day>3</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    On one hand, if <tex>\sqrt { \mathfrak { a } }  \mid  f</tex>, then <tex>\mathfrak { a }   \mid  f^n</tex> for some natural number <tex>n</tex>. This means for all <tex>\mathfrak { p }   \mid   \mathfrak { a }</tex>, we have <tex>\mathfrak { p }   \mid  f^n</tex>, which by being a prime ideal implies <tex>\mathfrak { p }   \mid  f</tex>.
  </p>

  <p>
    On the other hand, suppose <tex>\mathfrak { a }   \nmid  f^n</tex> for any <tex>n</tex>, we construct a prime ideal divisor of <tex>\mathfrak { a }</tex> that is not a divisor of <tex>f</tex>. Consider the set of all ideals not a divisor of <tex>f^n</tex> for any <tex>n</tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <tex>\mathfrak { d }</tex> still in this set, since <tex>\mathfrak { d }</tex> divides exactly the elements divided by some ideal in the chain. By <link href="https://en.wikipedia.org/wiki/Zorn%27s_lemma" type="external">Zorn’s lemma</link>, the set contains some <tex>\mathfrak { q }</tex> not divided by any other ideal in the set. This ideal must be prime: take <tex>\mathfrak { q }   \nmid  x, y</tex> such that <tex>\mathfrak { q }   \mid  x y</tex>, then <tex>\mathfrak { q } ' =  \gcd ( \mathfrak { q } , x y)</tex> is a proper divisor of <tex>\mathfrak { q }</tex>, and by construction it cannot be in the previously constructed set. Hence there is some <tex>n</tex> such that <tex>x y  \mid  f^n</tex>, so <tex>\mathfrak { q }   \mid  x y  \mid  f^n</tex>, contradiction.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1764</anchor> <taxon>Definition</taxon> <addr>algm-0001</addr><route>algm-0001.xml</route>  <date><year>2024</year> <month>3</month> <day>2</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Topological spectrum of a commutative ring</title>   </frontmatter> <mainmatter><p>
  The topological <strong>spectrum</strong> of a commutative ring <tex>R</tex>, denoted <tex>\operatorname {Spec} (R)</tex>, is a topological space whose points are given by prime ideals of <tex>R</tex>. We denote the point corresponding to <tex>\mathfrak { p }</tex> as <tex>\left [ \mathfrak { p } \right ]</tex>. We define an open <tex>D( \mathfrak { a } )</tex> for each ideal <tex>\mathfrak { a }</tex> which contains the point <tex>\left [ \mathfrak { p } \right ]</tex> when <tex>\mathfrak { p }   \nmid   \mathfrak { a }</tex>. The corresponding closed is written as <tex>V( \mathfrak { a } )</tex>.
</p><p>
  We abuse the notation and write <tex>D(f)</tex> for the case where <tex>\mathfrak { a }</tex> is generated by <tex>f</tex>. Similar notations apply to <tex>V</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1765</anchor> <taxon>Definition</taxon> <addr>hmlg-001J</addr><route>hmlg-001J.xml</route>  <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Effective homology</title>   </frontmatter> <mainmatter><p>
  Given a mathematical object <tex>X</tex> canonically associated with an <link href="hmlg-001A.xml" type="local" addr="hmlg-001A" title="Effective algebraic cellular complex">effective</link> chain complex <tex>C_ \bullet  (X)</tex> (e.g. the <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">normalized chain complex</link> of a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">simplicial set</link>), it is said to be equipped with the structure of <strong>effective homology</strong>, if we have a <link href="hmlg-001I.xml" type="local" addr="hmlg-001I" title="Strong homology equivalence">strong homology equivalence</link> <tex>C_ \bullet  (X)  \Leftarrow   \mkern {-13mu}  \Leftrightarrow   \mkern {-13mu}  \Rightarrow  E_ \bullet</tex>, such that <tex>E_ \bullet</tex> is <link href="hmlg-001A.xml" type="local" addr="hmlg-001A" title="Effective algebraic cellular complex">effective of finite type</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1766</anchor>  <addr>hmlg-001K</addr><route>hmlg-001K.xml</route>  <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Effective homology</title>   </frontmatter> <mainmatter><p>
  This is a set of notes on effective homology and algebraic topology. Main references are <link href="constructive-homological-algebra.xml" type="local" addr="constructive-homological-algebra" title="Constructive Homological Algebra and Applications">Constructive Homological Algebra and Applications</link> and ...
</p><p>
  TODO: composition of <link href="hmlg-001I.xml" type="local" addr="hmlg-001I" title="Strong homology equivalence">strong homology equivalence</link>, tensor product, cone, bicomplex, (effective) simplicial set, simplicial group, Kan complex
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1767</anchor> <taxon>Definition</taxon> <addr>hmlg-001I</addr><route>hmlg-001I.xml</route>  <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Strong homology equivalence</title>   </frontmatter> <mainmatter><p>
  A <strong>strong homology equivalence</strong> between chain complexes <tex>C</tex> and <tex>D</tex> is a span of chain reductions, i.e. a third chain complex <tex>X</tex> with <tex>X  \Rightarrow \mkern {-14mu} \Rightarrow  C</tex> and <tex>X  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex>. We denote a strong homology equivalence with <tex>C  \Leftarrow   \mkern {-13mu}  \Leftrightarrow   \mkern {-13mu}  \Rightarrow  D</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1768</anchor> <taxon>Construction</taxon> <addr>hmlg-001G</addr><route>hmlg-001G.xml</route>  <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><link href="hmlg-001G.xml" type="local" addr="hmlg-001G" title="Perturbation of the larger chain complex in a chain reduction">Perturbation</link> of the larger chain complex in a <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reduction</link></title>   </frontmatter> <mainmatter><p>
  Given a reduction <tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex> and a perturbation <tex>\delta _C</tex> for <tex>C</tex>, we assume that <tex>h_{ \rho }   \circ   \delta _C</tex> is pointwise nilpotent, i.e. <tex display="block">\forall  c  \in  C_k,  \exists  n  \in   \mathbb {N},  \;  ( h_{ \rho } \delta _C)^n (c) = 0.</tex> We can construct a new chain reduction <tex>\rho ' : C'  \Rightarrow \mkern {-14mu} \Rightarrow  D'</tex>, where <tex>C'</tex> is <tex>C</tex> perturbed by <tex>\delta _C</tex>.
</p><p>
  Note that this situation is much harder compared to <ref addr="hmlg-001E" href="hmlg-001E.xml" taxon="Construction"/>, as it is generally impossible without the added condition.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1769</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-001G</parent> </frontmatter> <mainmatter>
  <p>
    For this construction using the third equivalent definition of a chain reduction in <ref addr="hmlg-001H" href="hmlg-001H.xml" taxon="Theorem"/>, i.e. a homotopy operator on <tex>C</tex> such that <tex>h  \circ  h = 0</tex> and <tex>h  \circ  d_C  \circ  h = h</tex>.
  </p>

  <p>
    We need to construct a new homotopy operator such that <tex>h'  \circ  h' = 0</tex> and <tex>h'  \circ  (d_C +  \delta _C)  \circ  h' = h'</tex>. We approach this through a “perturbative” mindset. Starting with <tex>h_0 = h</tex>, the second equation is off by a difference of <tex>h_0  \delta _C h_0</tex>. We simply add this as a correction term, <tex>h_1 = h_0 +  \alpha  h_0  \delta _C h_0</tex> where <tex>\alpha</tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <tex>h_0  \delta _C h_0  \delta _C  \cdots  h_0</tex>, since nothing else has the same type.) We still have <tex>h_1  \circ  h_1 = 0</tex>, and for the second equation this creates a new error term
    <tex display="block">\begin {aligned}       &amp; \quad  h_1 (d_C +  \delta _C) h_1 - h_1  \\        &amp;= (1 +  \alpha ) h_0  \delta _C h_0 + 2 ( \alpha  +  \alpha ^2) h_0  \delta _C h_0  \delta _C h_0 +  \alpha ^2 h_0  \delta _C h_0  \delta _C h_0  \delta _C h_0      \end {aligned}</tex>
    and we can eliminate the first and second order part by setting <tex>\alpha  = -1</tex>. The natural next step would be to add a further correction <tex>h_2 = h_1 +  \beta  h_0  \delta _C h_0  \delta _C h_0</tex>. This turns out to require <tex>\beta  = +1</tex>, and so on.
  </p>

  <p>
    From the informal discussion above, we can conjecture the formula
    <tex display="block">h' =  \sum _{k=0}^ \infty  (-1)^k (h  \delta _C)^k h.</tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <tex>h'  \circ  h' = 0</tex> from <tex>h  \circ  h = 0</tex>, and the second equation follows from a nice telescopic sum
    <tex display="block">\begin {aligned}       h'  \circ  (d_C +  \delta _C)  \circ  h'       &amp;=  \sum _{i, j} (-1)^{i + j} (h  \delta _C)^i h (d_C +  \delta _C) (h  \delta _C)^j h  \\        &amp;=  \sum _{i, j} (-1)^{i + j}  \left [(h  \delta _C)^{i + j + 1} h + (h  \delta _C)^{i + j} h \right ]  \\        &amp;=  \sum _{k} (k+1) (-1)^k  \left [(h  \delta _C)^{k + 1} h + (h  \delta _C)^k h \right ]  \\        &amp;=  \sum _k (-1)^k (h  \delta _C)^k h = h'.      \end {aligned}</tex></p>

  <p>
    We can reconstruct the other two components of the reduction <tex>\iota _{ \rho ' }</tex> and <tex>\pi _{ \rho ' }</tex> through <ref addr="hmlg-001H" href="hmlg-001H.xml" taxon="Theorem"/>. In particular, <tex>D'</tex> is given by a perturbation of <tex>D</tex>. We only write down the results below for easy reference.
    <tex display="block">\begin {aligned}      \pi _{ \rho ' }  &amp;=  \sum _{k=0}^ \infty  (-1)^k  \pi _{ \rho }  ( \delta _C  h_{ \rho } )^k  \\       \iota _{ \rho ' }  &amp;=  \sum _{k=0}^ \infty  (-1)^k ( h_{ \rho }   \delta _C)^k  \iota _{ \rho }   \\       \delta _D &amp;=  \sum _{k=0}^ \infty  (-1)^k  \pi _{ \rho }   \delta _C ( h_{ \rho }   \delta _C)^k  \iota _{ \rho } .      \end {aligned}</tex></p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1770</anchor> <taxon>Theorem</taxon> <addr>hmlg-001H</addr><route>hmlg-001H.xml</route>  <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Characterization of <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reduction</link></title>   </frontmatter> <mainmatter><p>
  The following data are equivalent:
  <ul><li>A <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reduction</link> <tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex>.</li>
    <li>A splitting <tex>C  \cong  D  \oplus  E</tex>, where <tex>E</tex> is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">split exact</link>.</li>
    <li>A <link href="hmlg-0016.xml" type="local" addr="hmlg-0016" title="Chain homotopy">chain homotopy</link> <tex>h : C  \to  C</tex> satisfying <tex>h  \circ  h = 0</tex> and <tex>h  \circ  d_C  \circ  h = h</tex>.</li></ul></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1771</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-001H</parent> </frontmatter> <mainmatter>
  <p>
    A chain reduction consists of maps <tex>C_k  \mathrel { \smash { \xtofrom [g_k]{f_k}}} D_k</tex> such that <tex>f_k  \circ  g_k =  \operatorname {id}</tex>. Therefore <tex>C_ \bullet</tex> <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">splits</link> as <tex>D_ \bullet   \oplus  E_ \bullet</tex>, and the boundary maps are preserved since <tex>f, g</tex> are chain maps. We have a homotopy <tex>h_k : D_k  \oplus  E_k  \to  D_{k+1}  \oplus  E_{k+1}</tex>, which we may write as a <tex>(2  \times  2)</tex>-matrix. <tex>f  \circ  h = 0</tex> demands the first row to be zero, and <tex>h  \circ  g = 0</tex> requires the first column to vanish. This leaves us with
    <tex display="block">\begin {bmatrix}       0 &amp; 0  \\        0 &amp; r_k      \end {bmatrix}</tex>
    such that <tex>r_{k+1}  \circ  r_k = 0</tex>, since <tex>h  \circ  h = 0</tex>.
  </p>

  <p>
    Substituting the requirement that <tex>h</tex> is a homotopy <tex>\operatorname {id}   \to  g  \circ  f</tex>, we get the equation <tex display="block">d_{k+1}  \circ  r_k + r_{k-1}  \circ  d_k =  \operatorname {id} ,</tex> where <tex>d</tex> is the boundary operator on <tex>E_ \bullet</tex>. In other words, <tex>r</tex> is a null-homotopy of <tex>E_ \bullet</tex>, rendering it <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">split exact</link>. Conversely, given <tex>C  \cong  D  \oplus  E</tex>, we can reconstruct <tex>f</tex> and <tex>g</tex> as the projection and inclusion maps, with <tex>h</tex> obtained out of <tex>r</tex> in the manner depicted above.
  </p>

  <p>
    On the other hand, given only the homotopy operator, we expect to have <tex>d  \circ  h + h  \circ  d =  \operatorname {id}  - g  \circ  f</tex>. And since <tex>g  \circ  f</tex> should be the projector of <tex>C</tex> onto the subspace <tex>D</tex>, <tex>\operatorname {id}  - g  \circ  f</tex> should be the projector onto <tex>E</tex>. We are thus led to proving <tex>p = d  \circ  h + h  \circ  d</tex> is indeed a projector.
    <tex display="block">\begin {aligned}       p_k  \circ  p_k &amp;= (d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k)  \circ  (d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k)  \\        &amp;= d_{k+1}  \circ   \overbrace {h_k  \circ  d_{k+1}  \circ  h_k}^{h_k} + d_{k+1}  \circ   \overbrace {h_k  \circ  h_{k-1}}^{0}  \circ  d_k  \\        &amp; \qquad  + h_{k-1}  \circ   \underbrace {d_k  \circ  d_{k+1}}_{0}  \circ  h_k +  \underbrace {h_{k-1}  \circ  d_k  \circ  h_{k-1}}_{h_{k-1}}  \circ  d_k  \\        &amp;= d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k = p_k.      \end {aligned}</tex>
    Therefore we conclude that <tex>p_k</tex> splits <tex>C_k  \cong  D_k  \oplus  E_k</tex>. More over, <tex>p  \circ  d = d  \circ  h  \circ  d = d  \circ  p</tex>, meaning <tex>p</tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <tex>h  \circ  p = p  \circ  h = h  \circ  d  \circ  h = h</tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <tex>E_k</tex> to get a homotopy from <tex>\operatorname {id} _E</tex> to <tex>0</tex>.
  </p>

  <p>
    Finally, restricting <tex>h</tex> onto <tex>D_k</tex> we see that it must be zero, since <tex>h( \operatorname {id}  - p) = h - h  \circ  d  \circ  h = 0</tex>. This means that all the information of <tex>h</tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1772</anchor> <taxon>Construction</taxon> <addr>hmlg-001E</addr><route>hmlg-001E.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><link href="hmlg-001C.xml" type="local" addr="hmlg-001C" title="Perturbation of chain complex">Perturbation</link> of the smaller chain complex in a <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reduction</link></title>   </frontmatter> <mainmatter><p>
  Given a reduction <tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex> and a perturbation <tex>\delta _D</tex> for <tex>D</tex>, we can construct a perturbation <tex>\delta _C</tex> for <tex>C</tex>, such that the same <tex>\rho</tex> can serve as a reduction of the perturbed chain complexes.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1773</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-001E</parent> </frontmatter> <mainmatter>
  <p>
    Let the reduction <tex>\rho</tex> be made out of the three maps <tex>\pi _{ \rho }  : C  \to  D</tex>, <tex>\iota _{ \rho }  : D  \to  C</tex> and <tex>h_{ \rho }  : C  \to  C</tex>. Then since <tex>C</tex> splits as the direct sum of <tex>D</tex> and an <link href="hmlg-000D.xml" type="local" addr="hmlg-000D" title="Acyclic chain complex">acyclic</link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <tex>\delta _C =  \iota _{ \rho }   \circ   \delta _D  \circ   \pi _{ \rho }</tex>. A quick computation shows that <tex>\rho</tex> is still a reduction of the perturbed chain complexes.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1774</anchor> <taxon>Remark</taxon> <addr>hmlg-001B</addr><route>hmlg-001B.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Terminology of <link href="hmlg-001A.xml" type="local" addr="hmlg-001A" title="Effective algebraic cellular complex">effective <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link></link></title>   </frontmatter> <mainmatter><p>
  The terminology chosen here differs from that in <link href="kenzo.xml" type="local" addr="kenzo" title="Kenzo">Kenzo</link>. What we call effective is named <em>locally effective</em>; and what we call effective of finite type is named <em>effective</em> instead.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1775</anchor>  <addr>hmlg-001D</addr><route>hmlg-001D.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Geometric interpretation of <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link></title>   </frontmatter> <mainmatter><p>
  An ACC can be viewed as the algebraic distillation of a <link href="hmlg-0002.xml" type="local" addr="hmlg-0002" title="Chain complex of abelian groups">chain complex</link>. The generators in dimension <tex>n</tex> are regarded as <tex>n</tex>-cells. However, we only record a formal sum of the boundaries, and forget the exact configuration. Hence, ACC is a suitable middle ground for both geometric transformations and algebraic operations.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1776</anchor>  <addr>hmlg-001F</addr><route>hmlg-001F.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Geometric interpretation of <link href="hmlg-001C.xml" type="local" addr="hmlg-001C" title="Perturbation of chain complex">perturbations</link></title>   </frontmatter> <mainmatter><p>
  For <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">ACCs</link>, the effect of a perturbation is to “reconnect” the cells. But it may not create or delete cells, since the abelian groups are unchanged.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1777</anchor> <taxon>Definition</taxon> <addr>hmlg-001C</addr><route>hmlg-001C.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Perturbation of chain complex</title>   </frontmatter> <mainmatter><p>
  A <strong>perturbation</strong> of a chain complex with boundary operator <tex>d</tex> is an operator <tex>\delta</tex> of degree <tex>(-1)</tex> such that <tex>d +  \delta</tex> also forms a boundary operator.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1778</anchor> <taxon>Definition</taxon> <addr>hmlg-001A</addr><route>hmlg-001A.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Effective <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link></title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-0013.xml" type="local" addr="hmlg-0013" title="Algebraic cellular complex">algebraic cellular complex</link>, suppose we can encode the basis sets <tex>C_ \bullet</tex> such that they have <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">decidable equality</link>, and the maps <tex>C_k  \to   \mathbb {Z}[C_{k-1}]</tex> are computable, then we say the ACC is <strong>effective</strong>. Suppose further that <tex>C_ \bullet</tex> are (computably) finite sets, then we say it is <strong>effective of finite type</strong>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1779</anchor> <taxon>Theorem</taxon> <addr>hmlg-0018</addr><route>hmlg-0018.xml</route>  <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>An additive functor is exact iff it preserves quasi-isomorphisms</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-000S.xml" type="local" addr="hmlg-000S" title="Additive functor">additive functor</link> <tex>F :  \mathcal { A }   \to   \mathcal { B }</tex> between <link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">abelian categories</link>, it is <link href="hmlg-000X.xml" type="local" addr="hmlg-000X" title="Left and right exact functor">exact</link> iff it sends <link href="hmlg-000C.xml" type="local" addr="hmlg-000C" title="Quasi-isomorphism">quasi-isomorphisms</link> to quasi-isomorphisms.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1780</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-0018</parent> </frontmatter> <mainmatter>
  <p>
    Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.
  </p>

  <p>
    On the other hand, <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">exact functors commute with homology functors</link>. Therefore if <tex>f : C_ \bullet   \to  D_ \bullet</tex> is a quasi-isomorphism, <tex>H_n (f)</tex> are all isomorphisms. Therefore <tex>H_n (F(f)) = F(H_n(f))</tex> is the functorial action on an isomorphism, which must also produce an isomorphism.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1781</anchor> <taxon>Definition</taxon> <addr>hmlg-0016</addr><route>hmlg-0016.xml</route>  <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain homotopy</title>   </frontmatter> <mainmatter><p>
  Given two chain complexes <tex>C_ \bullet</tex> and <tex>D_ \bullet</tex> with two <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain maps</link> <tex>f, g : C  \to  D</tex> between them, a <strong>chain homotopy</strong> from <tex>f</tex> to <tex>g</tex> is given by a family of maps <tex>h_n : C_n  \to  D_{n+1}</tex>, such that
  <tex display="block">d_{n+1}  \circ  h_n + h_{n-1}  \circ  d_n = f_n - g_n.</tex>
  Note that the two <tex>d</tex>’s denote the boundary map of different chain complexes.
</p><p>
  The chain homotopy can be written as <tex>h : f  \to  g</tex> or as <tex>h : C  \to  D</tex>. This causes no confusion, and the latter is convenient in situations where the maps <tex>f, g</tex> matter less than their difference <tex>f - g</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1782</anchor> <taxon>Definition</taxon> <addr>hmlg-0017</addr><route>hmlg-0017.xml</route>  <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain reduction</title>   </frontmatter> <mainmatter><p>
  Given two chain complexes <tex>C, D</tex>, a <strong>chain reduction</strong> consists of a chain map <tex>\pi  : C  \to  D</tex>, a chain map <tex>\iota  : D  \to  C</tex> and a <link href="hmlg-0016.xml" type="local" addr="hmlg-0016" title="Chain homotopy">chain homotopy</link> <tex>h :  \operatorname {id}   \to  g  \circ  f</tex>, such that <tex>\pi   \circ   \iota  =  \operatorname {id}</tex>, and <tex display="block">\pi   \circ  h = h  \circ   \iota  = h  \circ  h = 0.</tex> Here the compositions are understood to have the appropriate subscript so the degrees match.
</p><p>
  We write the reduction as <tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex>. The three components are denoted <tex>\pi _{ \rho }  : C  \to  D</tex>, <tex>\iota _{ \rho }  : D  \to  C</tex> and <tex>h_{ \rho }  : C  \to  C</tex>, respectively.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1783</anchor> <taxon>Visualization</taxon> <addr>hmlg-0019</addr><route>hmlg-0019.xml</route>  <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain reduction</title>   </frontmatter> <mainmatter><p>
  For a <link href="hmlg-0017.xml" type="local" addr="hmlg-0017" title="Chain reduction">chain reduction</link> <tex>C  \Rightarrow \mkern {-14mu} \Rightarrow  D</tex>, <tex>D</tex> is embedded as a subcomplex of <tex>C</tex>. It is cleanly separated, indicating that <link href="hmlg-001H.xml" type="local" addr="hmlg-001H" title="Characterization of chain reduction">it is split</link>. The other part of <tex>C</tex> is <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">split exact</link>, and so its homology component is drawn as empty, with the components separated.
</p>
  <embedded-tex hash="81ce63757e7f7fb0ee8337ca981f934d"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
  %tex
  \begin{scope}
    \clip (-1.9, -1.4) rectangle (5.9, 1.7);
    \tikzset{every path/.style={thick}}

    \draw (-3.6,0) -- (-0.4,0) arc (0:180:1.6);
    \draw (-1.6,0) -- (1.6,0) arc (0:180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4,0) -- (3.6,0) arc (0:180:1.6);
    \draw (2.4,0) -- (5.6,0) arc (0:180:1.6);
    \draw (4.4,0) -- (7.6,0) arc (0:180:1.6);

    % arccos(1/1.6) = 51.318deg
    \draw (-1.6, -0.1) -- (-0.4, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4, -0.1) -- (1.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (2.4, -0.1) -- (3.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \draw (4.4, -0.1) -- (5.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
  \end{scope}
  \node at (2, -1.6) {\(C_n\)};
  \node at (2, 1.1) {\(H_n\)};
  \draw[thick, decoration={brace, mirror}, decorate] (-2.1, 1.6) -- node[left] {\(C_\bullet\)} (-2.1, -1.35);
  \draw[thick, decoration={brace}, decorate] (6.1, 1.6) -- node[right] {\(D_\bullet\)} (6.1, 0);
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1784</anchor> <taxon>Definition</taxon> <addr>hmlg-0013</addr><route>hmlg-0013.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Algebraic cellular complex</title>   </frontmatter> <mainmatter><p>
  An <strong>algebraic cellular complex</strong> (or ACC) is a <link href="hmlg-0002.xml" type="local" addr="hmlg-0002" title="Chain complex of abelian groups">chain complex</link> of free abelian groups, with designated generators. The generators are called <strong>cells</strong>, and the boundary maps can be expressed using the generators as a basis, yielding the <strong>incidence matrices</strong>.
</p><p>
  More precisely, we may define an ACC as a sequence of sets <tex>C_ \bullet</tex>, with a sequence of functions <tex>d : C_k  \to   \mathbb {Z}[C_{k-1}]</tex>, such that <tex>d^2 = 0</tex> is satisfied. When a generator has non-zero coefficient in some <tex>d \sigma</tex>, the generator is called a <strong>face</strong> of <tex>\sigma</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1785</anchor> <taxon>Visualization</taxon> <addr>hmlg-0015</addr><route>hmlg-0015.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Filtered chain complex</title>   </frontmatter> <mainmatter><p>
  Combining <ref addr="hmlg-000A" href="hmlg-000A.xml" taxon="Visualization"/> and <ref addr="hmlg-0014" href="hmlg-0014.xml" taxon="Visualization"/>, we arrive at the following picture. Each family of colors corresponds to the filtration <tex>F_ \bullet  C_n</tex> in one dimension, and the different shades corresponds to the degree in the filtration.
</p>
  <embedded-tex hash="a9c6c901bdc2a89b19b8d769a0865f82"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
   \tikzset {every path/.style={thick, fill opacity = 0.2, line join = round}}
   \foreach   \depth  in {4,3,2,1} {
     \fill [blue!80!yellow] (-4,4) -- (0,0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
     \fill [green!80!purple] (0,0) -- (4,4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
     \fill [yellow!80!red] (4,4) -- (8,0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
  }

   \foreach   \depth  in {4,3,2,1} {
     \draw  ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
     \draw  ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
     \draw  ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
  }
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
<p>
  Note that we arranged so that only the higher degree (i.e. the lighter color) components may touch the lower degree components in the next dimension. So the intersection is a triangle shape instead of a complete diamond grid. This corresponds to the requirement that the boundary map sends <tex>F_i C_j</tex> to <tex>F_i C_{j+1}</tex>.
</p><p>
  We can see the associated spectral sequences directly from the visualization. We start with the graded components, which form strands of chain complexes. Here the second degree is highlighted.
  
  <embedded-tex hash="983018d43c8358bce43cb22365996fde"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
     \tikzset {every path/.style={thick, fill opacity = 0.4, line join = round}}
     \foreach   \depth  in {2} {
       \fill [blue!80!yellow] ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
       \fill [green!80!purple] ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
       \fill [yellow!80!red] ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
    }

     \foreach   \depth  in {4,3,2,1} {
       \draw  ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
       \draw  ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
       \draw  ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
    }
   \end {tikzpicture}
  </embedded-tex-body></embedded-tex>

  The homology chops off the intersections, and so we enter the first page of the spectral sequence, consisting of strands with the top and bottom part cut off. Repeatedly taking homology, we are finally left with the rectangular part in the middle, which is the graded components of the desired homology group of the entire complex.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1786</anchor> <taxon>Visualization</taxon> <addr>hmlg-0014</addr><route>hmlg-0014.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Filtered object</title>   </frontmatter> <mainmatter><p>
  We can visualize a filtered object <tex>F_1 A  \subseteq  F_2 A  \subseteq  F_3 A  \subseteq  A</tex> as nested rectangles.
</p>
  <embedded-tex hash="d3dc80106e5931a76b7bad463be6bd50"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
   \tikzset {every path/.style={thick, fill = blue!80!yellow, fill opacity = 0.1}}
   \filldraw  (0,-1) rectangle (4,1);
   \filldraw  (0,-1) rectangle (3,1);
   \filldraw  (0,-1) rectangle (2,1);
   \filldraw  (0,-1) rectangle (1,1);
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
<p>
  The graded components of this filtration are the individual rectangular regions.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1787</anchor> <taxon>Construction</taxon> <addr>hmlg-0012</addr><route>hmlg-0012.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Long exact sequence of homologies</title>   </frontmatter> <mainmatter><p>
  Given a short exact sequence of chain complexes
  <tex display="block">0  \to  A_ \bullet   \to  B_ \bullet   \to  C_ \bullet   \to  0,</tex>
  there is a long exact sequence of homology groups
  <tex display="block">\cdots   \to  H_{n+1}(C)  \xrightarrow { \partial } H_n(A)  \to  H_n (B)  \to  H_n (C)  \xrightarrow { \partial } H_{n-1} (A)  \to   \cdots</tex>
  The map <tex>\partial</tex> here is, after unpacking some quotients, simply the boundary map <tex>B_n  \to  B_{n-1}</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1788</anchor> <taxon>Theorem</taxon> <addr>hmlg-0010</addr><route>hmlg-0010.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Snake lemma</title>   </frontmatter> <mainmatter><p>
  In an <link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">abelian category</link>, given the middle two rows of the diagram
</p>
  <embedded-tex hash="bfd31b393d484de454b827c0217f73ad"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  &amp; { \ker  f} &amp; { \ker  g} &amp; { \ker  h}  \\ 
  { \ker  i} &amp;  \bullet  &amp;  \bullet  &amp;  \bullet  &amp; 0  \\ 
  0 &amp;  \bullet  &amp;  \bullet  &amp;  \bullet  &amp; { \operatorname {coker}  j}  \\ 
  &amp; { \operatorname {coker}  f} &amp; { \operatorname {coker}  g} &amp; { \operatorname {coker}  h}
   \arrow [&quot;f&quot;, from=2-2, to=3-2]
   \arrow [&quot;g&quot;, from=2-3, to=3-3]
   \arrow [&quot;h&quot;, from=2-4, to=3-4]
   \arrow [from=1-2, to=2-2]
   \arrow [from=1-3, to=2-3]
   \arrow [from=1-4, to=2-4]
   \arrow [blue, &gt;-&gt;, out=90, in=180, from=2-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [&quot;i&quot;, from=2-2, to=2-3]
   \arrow [from=2-3, to=2-4]
   \arrow [from=3-2, to=3-3]
   \arrow [&quot;j&quot;, from=3-3, to=3-4]
   \arrow [from=3-4, to=3-5]
   \arrow [blue, -&gt;&gt;, out=0, in=-90, from=4-4, to=3-5]
   \arrow [from=3-2, to=4-2]
   \arrow [from=3-3, to=4-3]
   \arrow [from=3-4, to=4-4]
   \arrow [blue, from=1-2, to=1-3]
   \arrow [blue, from=1-3, to=1-4]
   \arrow [blue, from=4-2, to=4-3]
   \arrow [blue, from=4-3, to=4-4]
   \arrow [blue, dashed, out=0, in=180, from=1-4, to=4-2]
   \arrow [from=2-4, to=2-5]
   \arrow [from=3-1, to=3-2]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
<p>
  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <tex>0  \to   \ker  i  \to   \ker  f  \to   \ker  g  \to   \ker  h  \xrightarrow { \partial }  \operatorname {coker}  f  \to   \operatorname {coker}  g  \to   \operatorname {coker}  h  \to   \operatorname {coker}  j  \to  0</tex>. In particular, if <tex>i</tex> is monic and <tex>j</tex> is epic, this leads to a six-term exact sequence.
</p><p>
  There are multiple ways to prove this claim. We can first <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">prove it in categories of modules</link>, and <link href="hmlg-0011.xml" type="local" addr="hmlg-0011" title="Using the Freyd–Mitchell embedding to prove theorems">use the Freyd–Mitchell embedding</link>. We can also use <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">pseudo-elements</link> to <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">perform diagram chases</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1789</anchor>  <addr>hmlg-0011</addr><route>hmlg-0011.xml</route>  <date><year>2024</year> <month>2</month> <day>20</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Using the <link href="hmlg-000F.xml" type="local" addr="hmlg-000F" title="Freyd–Mitchell embedding theorem">Freyd–Mitchell embedding</link> to prove theorems</title>   </frontmatter> <mainmatter><p>
  We use the <link href="hmlg-0010.xml" type="local" addr="hmlg-0010" title="Snake lemma">snake lemma</link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.
</p><p>
  Suppose we have already <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">proved</link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">abelian category</link> <tex>\mathcal { C }</tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <tex>\mathcal { D }</tex>, which we can embed in a module category <tex>R \text {-} \mathsf { Mod }</tex>.
</p><p>
  Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <tex>\mathcal { D }</tex> is a full abelian subcategory of <tex>R \text {-} \mathsf { Mod }</tex>, these morphisms are contained in <tex>\mathcal { D }</tex>, and the sequence is still exact. And since <tex>\mathcal { D }</tex> is a full abelian subcategory of <tex>\mathcal { C }</tex>, the sequence is again exact in <tex>\mathcal { C }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1790</anchor> <taxon>Intuition</taxon> <addr>hmlg-000W</addr><route>hmlg-000W.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><p><link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">Abelian categories</link> are one step further from <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link>. Similar to the situation of abelian groups or modules, every morphism <tex>f : X  \to  Y</tex> has four key components, the image, the kernel, the coimage <tex>X /  \ker  f</tex>, and the cokernel <tex>Y /  \operatorname {im}  f</tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1791</anchor>  <addr>hmlg-000U</addr><route>hmlg-000U.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive and abelian categories</title>   </frontmatter> <mainmatter><p>
  Since many <link href="hmlg-000L.xml" type="local" addr="hmlg-000L" title="Operations on chain complexes">operations</link> on abelian groups and <tex>R</tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</p><p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1792</anchor> <taxon>Definition</taxon> <addr>hmlg-000O</addr><route>hmlg-000O.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\mathsf { Ab }</tex>-enriched category</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, an <tex>\mathsf { Ab }</tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1793</anchor> <taxon>Definition</taxon> <addr>hmlg-000P</addr><route>hmlg-000P.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive category</title>   </frontmatter> <mainmatter><p>
  Let <tex>\mathcal { C }</tex> be <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enriched</link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <strong>additive category</strong>. In particular, the nullary product and coproduct coincide, and we call the object <strong>zero object</strong>, denoted <tex>0</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1794</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <tex>X_i</tex> to their product is given by a matrix of morphisms <tex>f_{ij} : X_i  \to  X_j</tex>. We choose the identity matrix
    <tex display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</tex>
    where <tex>0</tex> is the additive neutral element in the abelian group <tex>\hom (X_i, X_j)</tex>. This gives a canonical map <tex>\coprod _i X_i  \to   \prod _i X_i</tex>.
  </p>

  <p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <tex display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><p>
  Due to this coincidence creating gadgets with <em>two universal properties</em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1795</anchor> <taxon>Theorem</taxon> <addr>hmlg-000R</addr><route>hmlg-000R.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Being an additive category is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link></title>   </frontmatter> <mainmatter><p>
  Given a category, if it can be endowed with an <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enrichment</link> that makes it an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1796</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Notice that having finite products and coproducts is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>, and the canonical morphism between them being an isomorphism is also a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>. These do not mention the enrichment structure.
  </p>

  <p>
    With these properties satisfied, the addition structure on the <tex>\hom</tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <tex display="block">X  \to  0  \to  Y,</tex>
    and given two parallel morphisms <tex>f, g : X  \to  Y</tex>, the following composition
    <tex display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</tex>
    is equal to the addition <tex>f + g</tex>. For disambiguation, we temporarily denote these constructions as <tex>0'</tex> and <tex>f +' g</tex>. By interpreting <tex>\oplus</tex> as a product or a coproduct at appropriate times, it is easy to see that <tex>0'</tex> is indeed the neutral element for <tex>+'</tex>.
  </p>

  <p>
    Recall that arrows <tex>X  \oplus  X  \to  Y  \oplus  Y</tex> is given by a <tex>2  \times  2</tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <tex>f  \oplus  g</tex> comes from a diagonal matrix with <tex>f, g</tex> as entries, so this operation is linear, which entails <tex>+'</tex> is also linear. By the <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">Eckmann–Hilton argument</link>, the two addition operations must coincide.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1797</anchor> <taxon>Definition</taxon> <addr>hmlg-000S</addr><route>hmlg-000S.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive functor</title>   </frontmatter> <mainmatter><p>
  Given two <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link> and a functor <tex>F :  \mathcal { C }   \to   \mathcal { D }</tex> between them, the following are equivalent:
  <ul><li>The functor preserves finite products.</li>
    <li>The functor preserves finite coproducts.</li>
    <li>The functor is a homomorphism on the abelian groups <tex>\hom _{ \mathcal { C } }(X, Y)</tex>, i.e. it is an <tex>\mathsf { Ab }</tex>-enriched functor.</li></ul>
  In this case, we call the functor <strong>additive</strong>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1798</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    For the equivalence of the first two claims, we have a composition
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</tex>
    where the middle morphism comes from the canonical isomorphism <tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <tex>F</tex>, we can compute that the composition is the canonical isomorphism from <tex>F(X) + F(Y)</tex> to <tex>F(X)  \times  F(Y)</tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </p>

  <p>
    Since the abelian group structure on morphisms is <link href="hmlg-000R.xml" type="local" addr="hmlg-000R" title="Being an additive category is a property">uniquely determined</link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <tex>F(1)  \to  1</tex> and <tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</tex> are isomorphisms. For the first one, since <tex>1</tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</tex>
    Using the bilinearity of composition and that <tex>F</tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1799</anchor> <taxon>Theorem</taxon> <addr>hmlg-000T</addr><route>hmlg-000T.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Adjunctions are additive</title>   </frontmatter> <mainmatter><p>
  In an adjunction <tex>F  \dashv  G</tex>, both functors are automatically additive.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1800</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter><p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <ref addr="hmlg-000S" href="hmlg-000S.xml" taxon="Definition"/> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</p></mainmatter> </tree>
  
</mainmatter> </tree><p>
  Kernels and cokernels are also greatly simplified in additive categories.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1801</anchor> <taxon>Theorem</taxon> <addr>hmlg-000Y</addr><route>hmlg-000Y.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Equalizers can be reduced to kernels in <tex>\mathsf { Ab }</tex>-enriched categories</title>   </frontmatter> <mainmatter><p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1802</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    We simply need to note that an equalizer for <tex>f</tex> and <tex>g</tex> is equivalent to an equalizer for <tex>(f-g)</tex> and <tex>0</tex>, by bilinearity of composition.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1803</anchor> <taxon>Intuition</taxon> <addr>hmlg-000W</addr><route>hmlg-000W.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><p><link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">Abelian categories</link> are one step further from <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link>. Similar to the situation of abelian groups or modules, every morphism <tex>f : X  \to  Y</tex> has four key components, the image, the kernel, the coimage <tex>X /  \ker  f</tex>, and the cokernel <tex>Y /  \operatorname {im}  f</tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1804</anchor> <taxon>Definition</taxon> <addr>hmlg-000Q</addr><route>hmlg-000Q.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian category</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, it is an <strong>abelian category</strong> if the following condition holds:
  <ul><li>Every morphism has a kernel and a cokernel.</li>
    <li>Every monomorphism is the kernel of its cokernel.</li>
    <li>Every epimorphism is the cokernel of its kernel.</li></ul></p></mainmatter> </tree><p>
  The definition of abelian categories may look intimidating, but thinking of it as <tex>R</tex>-modules is a very effective way to reduce mental load. In fact, <link href="hmlg-000F.xml" type="local" addr="hmlg-000F" title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</p><p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <link href="hmlg-000X.xml" type="local" addr="hmlg-000X" title="Left and right exact functor">exact</link>, but many functors fail to satisfy this for various reasons. <mark>One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</mark> This leads to intricate and beautiful structures emerging.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1805</anchor> <taxon>Definition</taxon> <addr>hmlg-000X</addr><route>hmlg-000X.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Left and right exact functor</title>   </frontmatter> <mainmatter><p>
  An <link href="hmlg-000S.xml" type="local" addr="hmlg-000S" title="Additive functor">additive functor</link> <tex>F :  \mathcal { A }   \to   \mathcal { B }</tex> between abelian categories is <strong>left exact</strong> if it satisfies the following equivalent conditions.

  <ul><li>It preserves kernels.</li>
    <li>It preserves finite limits.</li>
    <li>It preserves the exactness of sequences <tex display="block">0  \to  A  \to  B  \to  C.</tex></li></ul></p><p>
  Dually, an additive functor is <strong>right exact</strong> if it satisfies the following equivalent conditions.
  <ul><li>It preserves cokernels.</li>
    <li>It preserves finite colimits.</li>
    <li>It preserves the exactness of sequences <tex display="block">A  \to  B  \to  C  \to  0.</tex></li></ul>
  If a functor is both left exact and right exact, it is simply called an <strong>exact functor</strong>, which is equivalent to it preserving the exactness of sequences <tex>A  \to  B  \to  C</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1806</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Since additive functors already preserves finite products, and <link href="hmlg-000Y.xml" type="local" addr="hmlg-000Y" title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general coequalizers</link> using the additive structure, the first two conditions are equivalent.
  </p>

  <p>
    The sequence <tex>A  \rightarrowtail  B  \to  C</tex> being exact is equivalent to <tex>A</tex> being a kernel of <tex>B  \to  C</tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1807</anchor> <taxon>Theorem</taxon> <addr>hmlg-000Y</addr><route>hmlg-000Y.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Equalizers can be reduced to kernels in <tex>\mathsf { Ab }</tex>-enriched categories</title>   </frontmatter> <mainmatter><p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1808</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000Y</parent> </frontmatter> <mainmatter>
  <p>
    We simply need to note that an equalizer for <tex>f</tex> and <tex>g</tex> is equivalent to an equalizer for <tex>(f-g)</tex> and <tex>0</tex>, by bilinearity of composition.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1809</anchor>  <addr>hmlg-000V</addr><route>hmlg-000V.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Kernel, image, cokernel and coimage of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a chain map <tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</p>
  <embedded-tex hash="294ed28114fa55f0507e63597a971463"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [&quot; \sim &quot;, from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1810</anchor> <taxon>Definition</taxon> <addr>hmlg-000X</addr><route>hmlg-000X.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Left and right exact functor</title>   </frontmatter> <mainmatter><p>
  An <link href="hmlg-000S.xml" type="local" addr="hmlg-000S" title="Additive functor">additive functor</link> <tex>F :  \mathcal { A }   \to   \mathcal { B }</tex> between abelian categories is <strong>left exact</strong> if it satisfies the following equivalent conditions.

  <ul><li>It preserves kernels.</li>
    <li>It preserves finite limits.</li>
    <li>It preserves the exactness of sequences <tex display="block">0  \to  A  \to  B  \to  C.</tex></li></ul></p><p>
  Dually, an additive functor is <strong>right exact</strong> if it satisfies the following equivalent conditions.
  <ul><li>It preserves cokernels.</li>
    <li>It preserves finite colimits.</li>
    <li>It preserves the exactness of sequences <tex display="block">A  \to  B  \to  C  \to  0.</tex></li></ul>
  If a functor is both left exact and right exact, it is simply called an <strong>exact functor</strong>, which is equivalent to it preserving the exactness of sequences <tex>A  \to  B  \to  C</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1811</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000X</parent> </frontmatter> <mainmatter>
  <p>
    Since additive functors already preserves finite products, and <link href="hmlg-000Y.xml" type="local" addr="hmlg-000Y" title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general coequalizers</link> using the additive structure, the first two conditions are equivalent.
  </p>

  <p>
    The sequence <tex>A  \rightarrowtail  B  \to  C</tex> being exact is equivalent to <tex>A</tex> being a kernel of <tex>B  \to  C</tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1812</anchor> <taxon>Theorem</taxon> <addr>hmlg-000Z</addr><route>hmlg-000Z.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Monomorphisms can be expressed using finite limits</title>   </frontmatter> <mainmatter><p>
  Given a morphism <tex>f : X  \to  Y</tex> in an arbitrary category, we can express the condition of being monic using finite limits.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1813</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000Z</parent> </frontmatter> <mainmatter>
  <p>
    We claim that <tex>f</tex> being monic is equivalent to the following square being a pullback square:
  </p>

  
  <embedded-tex hash="61a6c1d9cb0e1971a1d8db56ef03e73e"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
    X &amp; X  \\ 
    X &amp; Y
     \arrow [&quot;f&quot;', from=2-1, to=2-2]
     \arrow [&quot;f&quot;, from=1-2, to=2-2]
     \arrow [&quot; \operatorname {id} &quot;', from=1-1, to=2-1]
     \arrow [&quot; \operatorname {id} &quot;, from=1-1, to=1-2]
     \arrow [&quot; \lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
   \end {tikzcd}
  </embedded-tex-body></embedded-tex>


  <p>
    For the forward implication, we consider the diagram
  </p>

  
  <embedded-tex hash="26bfdbd158e80a7b344e0e4b491d5dd9"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
    Z  \\ 
    &amp; X &amp; X  \\ 
    &amp; X &amp; Y
     \arrow [&quot;f&quot;', from=3-2, to=3-3]
     \arrow [&quot;f&quot;, from=2-3, to=3-3]
     \arrow [&quot; \operatorname {id} &quot;', from=2-2, to=3-2]
     \arrow [&quot; \operatorname {id} &quot;, from=2-2, to=2-3]
     \arrow [&quot; \lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
     \arrow [dashed, from=1-1, to=2-2]
     \arrow [&quot;g&quot;', curve={height=6pt}, from=1-1, to=3-2]
     \arrow [&quot;h&quot;, curve={height=-6pt}, from=1-1, to=2-3]
   \end {tikzcd}
  </embedded-tex-body></embedded-tex>


  <p>
    Since <tex>f</tex> is mono, this diagram commutes iff <tex>g = h</tex>, in which case there is a unique way to fill in the dashed arrow, which is <tex>g</tex>.
  </p>

  <p>
    On the other hand, if the diagram is a pullback, then for every pair of morphisms <tex>g, h : Z  \rightrightarrows  X</tex>, we can draw the diagram above, and obtain the dashed arrow <tex>k : Z  \to  X</tex>. The diagram commuting implies <tex>g =  \operatorname {id}   \circ  k = h</tex>.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1814</anchor> <taxon>Definition</taxon> <addr>hmlg-000O</addr><route>hmlg-000O.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\mathsf { Ab }</tex>-enriched category</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, an <tex>\mathsf { Ab }</tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1815</anchor> <taxon>Theorem</taxon> <addr>hmlg-000F</addr><route>hmlg-000F.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Freyd–Mitchell embedding theorem</title>   </frontmatter> <mainmatter><p>
  Any small abelian category can be realized as a full abelian subcategory of a category of left <tex>R</tex>-modules for some ring <tex>R</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1816</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000F</parent> </frontmatter> <mainmatter><p>
  (TODO)
</p></mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1817</anchor>  <addr>hmlg-000G</addr><route>hmlg-000G.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1818</anchor>  <addr>hmlg-000L</addr><route>hmlg-000L.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Operations on chain complexes</title>   </frontmatter> <mainmatter><p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1819</anchor> <taxon>Definition</taxon> <addr>hmlg-000I</addr><route>hmlg-000I.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Direct sum and product of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a family of chain complexes <tex>C_{ \alpha ,  \bullet }</tex>, we can take the direct sum in each dimension, giving <tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</tex>, which is another chain complex. Dually, we can take the direct product <tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</tex>.
</p></mainmatter> </tree><p>
  As another example, the consideration of quotienting out a subspace <tex>Y  \subseteq  X</tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <tex display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1820</anchor> <taxon>Definition</taxon> <addr>hmlg-000K</addr><route>hmlg-000K.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Bicomplex</title>   </frontmatter> <mainmatter><p>
  A <strong>bicomplex</strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <tex>A_{m, n}</tex>, vertical maps <tex>d : A_{m, n}  \to  A_{m, n-1}</tex> and horizontal maps <tex>\delta  : A_{m, n}  \to  A_{m-1, n}</tex>. Every square in the grid commutes, and <tex>d^2 =  \delta ^2 = 0</tex>.
</p><p>
  Each column <tex>A_{m,  \bullet }</tex> in the bicomplex is a chain complex, and <tex>\delta</tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <tex>d</tex> are chain maps between the row complexes.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1821</anchor> <taxon>Definition</taxon> <addr>hmlg-000J</addr><route>hmlg-000J.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Exact sequence of chain complexes</title>   </frontmatter> <mainmatter><p>
  An <strong>exact sequence</strong> of chain complexes <tex>C_{m,  \bullet }</tex> is a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> such that the rows are <link href="hmlg-000D.xml" type="local" addr="hmlg-000D" title="Acyclic chain complex">exact</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1822</anchor>  <addr>hmlg-000V</addr><route>hmlg-000V.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Kernel, image, cokernel and coimage of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a chain map <tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</p>
  <embedded-tex hash="294ed28114fa55f0507e63597a971463"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [&quot; \sim &quot;, from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1823</anchor>  <addr>hmlg-000U</addr><route>hmlg-000U.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive and abelian categories</title>   </frontmatter> <mainmatter><p>
  Since many <link href="hmlg-000L.xml" type="local" addr="hmlg-000L" title="Operations on chain complexes">operations</link> on abelian groups and <tex>R</tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</p><p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1824</anchor> <taxon>Definition</taxon> <addr>hmlg-000O</addr><route>hmlg-000O.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\mathsf { Ab }</tex>-enriched category</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, an <tex>\mathsf { Ab }</tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1825</anchor> <taxon>Definition</taxon> <addr>hmlg-000P</addr><route>hmlg-000P.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive category</title>   </frontmatter> <mainmatter><p>
  Let <tex>\mathcal { C }</tex> be <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enriched</link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <strong>additive category</strong>. In particular, the nullary product and coproduct coincide, and we call the object <strong>zero object</strong>, denoted <tex>0</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1826</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <tex>X_i</tex> to their product is given by a matrix of morphisms <tex>f_{ij} : X_i  \to  X_j</tex>. We choose the identity matrix
    <tex display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</tex>
    where <tex>0</tex> is the additive neutral element in the abelian group <tex>\hom (X_i, X_j)</tex>. This gives a canonical map <tex>\coprod _i X_i  \to   \prod _i X_i</tex>.
  </p>

  <p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <tex display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><p>
  Due to this coincidence creating gadgets with <em>two universal properties</em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1827</anchor> <taxon>Theorem</taxon> <addr>hmlg-000R</addr><route>hmlg-000R.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Being an additive category is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link></title>   </frontmatter> <mainmatter><p>
  Given a category, if it can be endowed with an <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enrichment</link> that makes it an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1828</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Notice that having finite products and coproducts is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>, and the canonical morphism between them being an isomorphism is also a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>. These do not mention the enrichment structure.
  </p>

  <p>
    With these properties satisfied, the addition structure on the <tex>\hom</tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <tex display="block">X  \to  0  \to  Y,</tex>
    and given two parallel morphisms <tex>f, g : X  \to  Y</tex>, the following composition
    <tex display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</tex>
    is equal to the addition <tex>f + g</tex>. For disambiguation, we temporarily denote these constructions as <tex>0'</tex> and <tex>f +' g</tex>. By interpreting <tex>\oplus</tex> as a product or a coproduct at appropriate times, it is easy to see that <tex>0'</tex> is indeed the neutral element for <tex>+'</tex>.
  </p>

  <p>
    Recall that arrows <tex>X  \oplus  X  \to  Y  \oplus  Y</tex> is given by a <tex>2  \times  2</tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <tex>f  \oplus  g</tex> comes from a diagonal matrix with <tex>f, g</tex> as entries, so this operation is linear, which entails <tex>+'</tex> is also linear. By the <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">Eckmann–Hilton argument</link>, the two addition operations must coincide.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1829</anchor> <taxon>Definition</taxon> <addr>hmlg-000S</addr><route>hmlg-000S.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive functor</title>   </frontmatter> <mainmatter><p>
  Given two <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link> and a functor <tex>F :  \mathcal { C }   \to   \mathcal { D }</tex> between them, the following are equivalent:
  <ul><li>The functor preserves finite products.</li>
    <li>The functor preserves finite coproducts.</li>
    <li>The functor is a homomorphism on the abelian groups <tex>\hom _{ \mathcal { C } }(X, Y)</tex>, i.e. it is an <tex>\mathsf { Ab }</tex>-enriched functor.</li></ul>
  In this case, we call the functor <strong>additive</strong>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1830</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    For the equivalence of the first two claims, we have a composition
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</tex>
    where the middle morphism comes from the canonical isomorphism <tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <tex>F</tex>, we can compute that the composition is the canonical isomorphism from <tex>F(X) + F(Y)</tex> to <tex>F(X)  \times  F(Y)</tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </p>

  <p>
    Since the abelian group structure on morphisms is <link href="hmlg-000R.xml" type="local" addr="hmlg-000R" title="Being an additive category is a property">uniquely determined</link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <tex>F(1)  \to  1</tex> and <tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</tex> are isomorphisms. For the first one, since <tex>1</tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</tex>
    Using the bilinearity of composition and that <tex>F</tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1831</anchor> <taxon>Theorem</taxon> <addr>hmlg-000T</addr><route>hmlg-000T.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Adjunctions are additive</title>   </frontmatter> <mainmatter><p>
  In an adjunction <tex>F  \dashv  G</tex>, both functors are automatically additive.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1832</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter><p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <ref addr="hmlg-000S" href="hmlg-000S.xml" taxon="Definition"/> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</p></mainmatter> </tree>
  
</mainmatter> </tree><p>
  Kernels and cokernels are also greatly simplified in additive categories.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1833</anchor> <taxon>Theorem</taxon> <addr>hmlg-000Y</addr><route>hmlg-000Y.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Equalizers can be reduced to kernels in <tex>\mathsf { Ab }</tex>-enriched categories</title>   </frontmatter> <mainmatter><p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1834</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    We simply need to note that an equalizer for <tex>f</tex> and <tex>g</tex> is equivalent to an equalizer for <tex>(f-g)</tex> and <tex>0</tex>, by bilinearity of composition.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1835</anchor> <taxon>Intuition</taxon> <addr>hmlg-000W</addr><route>hmlg-000W.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><p><link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">Abelian categories</link> are one step further from <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link>. Similar to the situation of abelian groups or modules, every morphism <tex>f : X  \to  Y</tex> has four key components, the image, the kernel, the coimage <tex>X /  \ker  f</tex>, and the cokernel <tex>Y /  \operatorname {im}  f</tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1836</anchor> <taxon>Definition</taxon> <addr>hmlg-000Q</addr><route>hmlg-000Q.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian category</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, it is an <strong>abelian category</strong> if the following condition holds:
  <ul><li>Every morphism has a kernel and a cokernel.</li>
    <li>Every monomorphism is the kernel of its cokernel.</li>
    <li>Every epimorphism is the cokernel of its kernel.</li></ul></p></mainmatter> </tree><p>
  The definition of abelian categories may look intimidating, but thinking of it as <tex>R</tex>-modules is a very effective way to reduce mental load. In fact, <link href="hmlg-000F.xml" type="local" addr="hmlg-000F" title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</p><p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <link href="hmlg-000X.xml" type="local" addr="hmlg-000X" title="Left and right exact functor">exact</link>, but many functors fail to satisfy this for various reasons. <mark>One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</mark> This leads to intricate and beautiful structures emerging.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1837</anchor> <taxon>Definition</taxon> <addr>hmlg-000X</addr><route>hmlg-000X.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Left and right exact functor</title>   </frontmatter> <mainmatter><p>
  An <link href="hmlg-000S.xml" type="local" addr="hmlg-000S" title="Additive functor">additive functor</link> <tex>F :  \mathcal { A }   \to   \mathcal { B }</tex> between abelian categories is <strong>left exact</strong> if it satisfies the following equivalent conditions.

  <ul><li>It preserves kernels.</li>
    <li>It preserves finite limits.</li>
    <li>It preserves the exactness of sequences <tex display="block">0  \to  A  \to  B  \to  C.</tex></li></ul></p><p>
  Dually, an additive functor is <strong>right exact</strong> if it satisfies the following equivalent conditions.
  <ul><li>It preserves cokernels.</li>
    <li>It preserves finite colimits.</li>
    <li>It preserves the exactness of sequences <tex display="block">A  \to  B  \to  C  \to  0.</tex></li></ul>
  If a functor is both left exact and right exact, it is simply called an <strong>exact functor</strong>, which is equivalent to it preserving the exactness of sequences <tex>A  \to  B  \to  C</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1838</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Since additive functors already preserves finite products, and <link href="hmlg-000Y.xml" type="local" addr="hmlg-000Y" title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general coequalizers</link> using the additive structure, the first two conditions are equivalent.
  </p>

  <p>
    The sequence <tex>A  \rightarrowtail  B  \to  C</tex> being exact is equivalent to <tex>A</tex> being a kernel of <tex>B  \to  C</tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1839</anchor> <taxon>Definition</taxon> <addr>hmlg-000Q</addr><route>hmlg-000Q.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian category</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, it is an <strong>abelian category</strong> if the following condition holds:
  <ul><li>Every morphism has a kernel and a cokernel.</li>
    <li>Every monomorphism is the kernel of its cokernel.</li>
    <li>Every epimorphism is the cokernel of its kernel.</li></ul></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1840</anchor> <taxon>Definition</taxon> <addr>hmlg-000P</addr><route>hmlg-000P.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive category</title>   </frontmatter> <mainmatter><p>
  Let <tex>\mathcal { C }</tex> be <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enriched</link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <strong>additive category</strong>. In particular, the nullary product and coproduct coincide, and we call the object <strong>zero object</strong>, denoted <tex>0</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1841</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000P</parent> </frontmatter> <mainmatter>
  <p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <tex>X_i</tex> to their product is given by a matrix of morphisms <tex>f_{ij} : X_i  \to  X_j</tex>. We choose the identity matrix
    <tex display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</tex>
    where <tex>0</tex> is the additive neutral element in the abelian group <tex>\hom (X_i, X_j)</tex>. This gives a canonical map <tex>\coprod _i X_i  \to   \prod _i X_i</tex>.
  </p>

  <p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <tex display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1842</anchor> <taxon>Definition</taxon> <addr>hmlg-000S</addr><route>hmlg-000S.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive functor</title>   </frontmatter> <mainmatter><p>
  Given two <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link> and a functor <tex>F :  \mathcal { C }   \to   \mathcal { D }</tex> between them, the following are equivalent:
  <ul><li>The functor preserves finite products.</li>
    <li>The functor preserves finite coproducts.</li>
    <li>The functor is a homomorphism on the abelian groups <tex>\hom _{ \mathcal { C } }(X, Y)</tex>, i.e. it is an <tex>\mathsf { Ab }</tex>-enriched functor.</li></ul>
  In this case, we call the functor <strong>additive</strong>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1843</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000S</parent> </frontmatter> <mainmatter>
  <p>
    For the equivalence of the first two claims, we have a composition
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</tex>
    where the middle morphism comes from the canonical isomorphism <tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <tex>F</tex>, we can compute that the composition is the canonical isomorphism from <tex>F(X) + F(Y)</tex> to <tex>F(X)  \times  F(Y)</tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </p>

  <p>
    Since the abelian group structure on morphisms is <link href="hmlg-000R.xml" type="local" addr="hmlg-000R" title="Being an additive category is a property">uniquely determined</link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <tex>F(1)  \to  1</tex> and <tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</tex> are isomorphisms. For the first one, since <tex>1</tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</tex>
    Using the bilinearity of composition and that <tex>F</tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1844</anchor> <taxon>Theorem</taxon> <addr>hmlg-000T</addr><route>hmlg-000T.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Adjunctions are additive</title>   </frontmatter> <mainmatter><p>
  In an adjunction <tex>F  \dashv  G</tex>, both functors are automatically additive.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1845</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000T</parent> </frontmatter> <mainmatter><p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <ref addr="hmlg-000S" href="hmlg-000S.xml" taxon="Definition"/> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</p></mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1846</anchor> <taxon>Theorem</taxon> <addr>hmlg-000R</addr><route>hmlg-000R.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Being an additive category is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link></title>   </frontmatter> <mainmatter><p>
  Given a category, if it can be endowed with an <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enrichment</link> that makes it an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1847</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000R</parent> </frontmatter> <mainmatter>
  <p>
    Notice that having finite products and coproducts is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>, and the canonical morphism between them being an isomorphism is also a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>. These do not mention the enrichment structure.
  </p>

  <p>
    With these properties satisfied, the addition structure on the <tex>\hom</tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <tex display="block">X  \to  0  \to  Y,</tex>
    and given two parallel morphisms <tex>f, g : X  \to  Y</tex>, the following composition
    <tex display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</tex>
    is equal to the addition <tex>f + g</tex>. For disambiguation, we temporarily denote these constructions as <tex>0'</tex> and <tex>f +' g</tex>. By interpreting <tex>\oplus</tex> as a product or a coproduct at appropriate times, it is easy to see that <tex>0'</tex> is indeed the neutral element for <tex>+'</tex>.
  </p>

  <p>
    Recall that arrows <tex>X  \oplus  X  \to  Y  \oplus  Y</tex> is given by a <tex>2  \times  2</tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <tex>f  \oplus  g</tex> comes from a diagonal matrix with <tex>f, g</tex> as entries, so this operation is linear, which entails <tex>+'</tex> is also linear. By the <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">Eckmann–Hilton argument</link>, the two addition operations must coincide.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1848</anchor> <taxon>Definition</taxon> <addr>hmlg-000K</addr><route>hmlg-000K.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Bicomplex</title>   </frontmatter> <mainmatter><p>
  A <strong>bicomplex</strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <tex>A_{m, n}</tex>, vertical maps <tex>d : A_{m, n}  \to  A_{m, n-1}</tex> and horizontal maps <tex>\delta  : A_{m, n}  \to  A_{m-1, n}</tex>. Every square in the grid commutes, and <tex>d^2 =  \delta ^2 = 0</tex>.
</p><p>
  Each column <tex>A_{m,  \bullet }</tex> in the bicomplex is a chain complex, and <tex>\delta</tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <tex>d</tex> are chain maps between the row complexes.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1849</anchor> <taxon>Definition</taxon> <addr>hmlg-000I</addr><route>hmlg-000I.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Direct sum and product of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a family of chain complexes <tex>C_{ \alpha ,  \bullet }</tex>, we can take the direct sum in each dimension, giving <tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</tex>, which is another chain complex. Dually, we can take the direct product <tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1850</anchor> <taxon>Definition</taxon> <addr>hmlg-000J</addr><route>hmlg-000J.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Exact sequence of chain complexes</title>   </frontmatter> <mainmatter><p>
  An <strong>exact sequence</strong> of chain complexes <tex>C_{m,  \bullet }</tex> is a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> such that the rows are <link href="hmlg-000D.xml" type="local" addr="hmlg-000D" title="Acyclic chain complex">exact</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1851</anchor>  <addr>hmlg-000L</addr><route>hmlg-000L.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Operations on chain complexes</title>   </frontmatter> <mainmatter><p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1852</anchor> <taxon>Definition</taxon> <addr>hmlg-000I</addr><route>hmlg-000I.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Direct sum and product of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a family of chain complexes <tex>C_{ \alpha ,  \bullet }</tex>, we can take the direct sum in each dimension, giving <tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</tex>, which is another chain complex. Dually, we can take the direct product <tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</tex>.
</p></mainmatter> </tree><p>
  As another example, the consideration of quotienting out a subspace <tex>Y  \subseteq  X</tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <tex display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1853</anchor> <taxon>Definition</taxon> <addr>hmlg-000K</addr><route>hmlg-000K.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Bicomplex</title>   </frontmatter> <mainmatter><p>
  A <strong>bicomplex</strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <tex>A_{m, n}</tex>, vertical maps <tex>d : A_{m, n}  \to  A_{m, n-1}</tex> and horizontal maps <tex>\delta  : A_{m, n}  \to  A_{m-1, n}</tex>. Every square in the grid commutes, and <tex>d^2 =  \delta ^2 = 0</tex>.
</p><p>
  Each column <tex>A_{m,  \bullet }</tex> in the bicomplex is a chain complex, and <tex>\delta</tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <tex>d</tex> are chain maps between the row complexes.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1854</anchor> <taxon>Definition</taxon> <addr>hmlg-000J</addr><route>hmlg-000J.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Exact sequence of chain complexes</title>   </frontmatter> <mainmatter><p>
  An <strong>exact sequence</strong> of chain complexes <tex>C_{m,  \bullet }</tex> is a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> such that the rows are <link href="hmlg-000D.xml" type="local" addr="hmlg-000D" title="Acyclic chain complex">exact</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1855</anchor>  <addr>hmlg-000V</addr><route>hmlg-000V.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Kernel, image, cokernel and coimage of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a chain map <tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</p>
  <embedded-tex hash="294ed28114fa55f0507e63597a971463"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [&quot; \sim &quot;, from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1856</anchor> <taxon>Definition</taxon> <addr>hmlg-000H</addr><route>hmlg-000H.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Short exact sequence</title>   </frontmatter> <mainmatter><p>
  A <strong>short exact sequence</strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <tex display="block">0  \to  A  \to  B  \to  C  \to  0.</tex> Short exact sequence describes how <tex>B</tex> is made up of a subobject <tex>A</tex> and a quotient <tex>C</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1857</anchor> <taxon>Remark</taxon> <addr>hmlg-000N</addr><route>hmlg-000N.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Signs in bicomplexes</title>   </frontmatter> <mainmatter><p>
  Some sources require a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> to have anti-commuting squares. In this way, the <link href="hmlg-000M.xml" type="local" addr="hmlg-000M" title="Total complex">total complex</link> has the simpler differential <tex>\partial  = d +  \delta</tex>. These two definitions are convertible by flipping the signs of the horizontal boundary maps in every other row.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1858</anchor> <taxon>Definition</taxon> <addr>hmlg-000M</addr><route>hmlg-000M.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Total complex</title>   </frontmatter> <mainmatter><p>
  Given a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> <tex>C_{ \bullet ,  \bullet }</tex>, we can collapse it into a chain complex in two ways. In either way, <tex>C_{p, q}</tex> is contained in the total complex at degree <tex>(m+n)</tex>. We can use the direct sum to combine them: <tex display="block">\operatorname {Tot} ^ \oplus (C)_n =  \bigoplus _{n = p+q} C_{p, q},</tex> or the direct product: <tex display="block">\operatorname {Tot} ^ \Pi (C)_n =  \prod _{n=p+q} C_{p,q}.</tex></p><p>
  The total differential acts on elements in <tex>C_{p, q}</tex> by <tex display="block">\partial (x) = d(x) + (-1)^q  \delta (x),</tex> where <tex>d</tex> is the vertical map, and <tex>\delta</tex> the horizontal map. The <link href="hmlg-000N.xml" type="local" addr="hmlg-000N" title="Signs in bicomplexes">sign</link> here is to ensure that <tex>\partial ^2 = 0</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1859</anchor> <taxon>Definition</taxon> <addr>hmlg-000D</addr><route>hmlg-000D.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Acyclic chain complex</title>   </frontmatter> <mainmatter><p>
  If all the homology groups vanish, then the chain complex is said fo be <strong>acyclic</strong> or <strong>exact</strong>. Equivalently, every cycle is a boundary.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1860</anchor> <taxon>Visualization</taxon> <addr>hmlg-000A</addr><route>hmlg-000A.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain complex</title>   </frontmatter> <mainmatter><p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <link href="https://www.3blue1brown.com/blog/exact-sequence-picturebook" type="external">here</link>.
</p>
  <embedded-tex hash="f54725dcd4c386fc74f41f8d152fec4a"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
<p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1861</anchor>  <addr>hmlg-0006</addr><route>hmlg-0006.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain complexes</title>   </frontmatter> <mainmatter><p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <tex>C_n</tex> freely generated by cells of dimension <tex>n</tex> (i.e. encoding the formal sums of cells), and a <em>boundary</em> operator <tex>d_n : C_n  \to  C_{n-1}</tex>. The critical feature of the operator is <tex display="block">d_{n-1}  \circ  d_n = 0,</tex> simply written as <tex>d^2 = 0</tex>, reflecting a deep geometric phenomenon that <mark>the boundary of a shape doesn’t have any boundary itself</mark>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1862</anchor> <taxon>Definition</taxon> <addr>hmlg-0002</addr><route>hmlg-0002.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date>  <title>Chain complex of abelian groups</title>   </frontmatter> <mainmatter><p>
  A chain complex of abelian groups is given by a sequence of abelian groups <tex>G_ \bullet</tex> together with homomorphisms <tex>d_n : G_n  \to  G_{n-1}</tex>, such that <tex>d_{n-1}  \circ  d_n = 0</tex>.
</p></mainmatter> </tree><p>This is eligible to immediate generalization.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1863</anchor> <taxon>Definition</taxon> <addr>hmlg-0003</addr><route>hmlg-0003.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date>  <title>Chain complex of <tex>R</tex>-modules</title>   <meta name="generalizes">hmlg-0002</meta></frontmatter> <mainmatter><p>
  A chain complex of <tex>R</tex>-modules is given by a sequence of modules <tex>M_ \bullet</tex> together with <tex>R</tex>-linear maps <tex>d_n : R_n  \to  R_{n-1}</tex>, such that <tex>d_{n-1}  \circ  d_n = 0</tex>.
</p></mainmatter> </tree><p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1864</anchor> <taxon>Definition</taxon> <addr>hmlg-0007</addr><route>hmlg-0007.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Components of a chain complex</title>   </frontmatter> <mainmatter><p>
  Given a <link href="hmlg-0003.xml" type="local" addr="hmlg-0003" title="Chain complex of R-modules">chain complex</link>, the <strong>cycles</strong> <tex>Z_n</tex> of dimension <tex>n</tex> are given by the kernel of <tex>d_n : C_n  \to  C_{n-1}</tex>. The <strong>boundaries</strong> <tex>B_n</tex> are given by the image of <tex>d_{n+1} : C_{n+1}  \to  C_n</tex>. The equation <tex>d^2 = 0</tex> is equivalent to <tex display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <link href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms" type="external">homomorphism theorem</link>, the quotient <tex>C_n / Z_n</tex> is isomorphic to the image of <tex>d_n</tex>, which is the next boundary <tex>B_{n-1}</tex>. On the other hand, the <strong>homology groups</strong> <tex>H_n(C)</tex> are defined as the quotient <tex>Z_n/B_n</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1865</anchor> <taxon>Visualization</taxon> <addr>hmlg-000A</addr><route>hmlg-000A.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain complex</title>   </frontmatter> <mainmatter><p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <link href="https://www.3blue1brown.com/blog/exact-sequence-picturebook" type="external">here</link>.
</p>
  <embedded-tex hash="f54725dcd4c386fc74f41f8d152fec4a"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
<p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1866</anchor> <taxon>Definition</taxon> <addr>hmlg-0008</addr><route>hmlg-0008.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Given two chain complexes <tex>C_ \bullet , D_ \bullet</tex>, the natural notion of morphisms between them is <strong>chain maps</strong>, i.e. a sequence of maps <tex>f_n : C_n  \to  D_n</tex> such that all the squares commute.
</p>
  <embedded-tex hash="2942ad6f5f0e67d4aaf0692a706bdfe6"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow [&quot;d&quot;, from=1-3, to=1-4]
   \arrow [&quot;{f_n}&quot;', from=1-3, to=2-3]
   \arrow [&quot;{f_{n-1}}&quot;', from=1-4, to=2-4]
   \arrow [&quot;d&quot;', from=2-3, to=2-4]
   \arrow [&quot;d&quot;', from=2-2, to=2-3]
   \arrow [&quot;d&quot;, from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow [&quot;{f_{n+1}}&quot;', from=1-2, to=2-2]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1867</anchor> <taxon>Visualization</taxon> <addr>hmlg-0009</addr><route>hmlg-0009.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Appropriately combing two copies of <ref addr="hmlg-000A" href="hmlg-000A.xml" taxon="Visualization"/>, we get the following picture for a <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</p>
  <embedded-tex hash="163ee9b3aafad0dfcf9e12dc63132caf"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1868</anchor> <taxon>Construction</taxon> <addr>hmlg-000B</addr><route>hmlg-000B.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain maps induce maps on homology</title>   </frontmatter> <mainmatter><p>
  A chain map <tex>f : C  \to  D</tex> induces a family of homomorphisms <tex>f_* : H_n (C)  \to  H_n (D)</tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <tex>f  \circ  g</tex> induces composition homomorphism <tex>(f  \circ  g)_* = f_*  \circ  g_*</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1869</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter><p>
  Referring to <ref addr="hmlg-0009" href="hmlg-0009.xml" taxon="Visualization"/> makes all the moving parts clear here. Since <tex>f</tex> commutes with the boundary maps, it maps the boundaries in <tex>C_n</tex> to the boundaries in <tex>D_n</tex>. Therefore the map is well-defined after passing to the quotient.
</p></mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1870</anchor> <taxon>Definition</taxon> <addr>hmlg-000C</addr><route>hmlg-000C.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Quasi-isomorphism</title>   </frontmatter> <mainmatter><p>
  A <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link> is a <strong>quasi-isomorphism</strong> if it induces isomorphisms on the <link href="hmlg-0007.xml" type="local" addr="hmlg-0007" title="Components of a chain complex">homology groups</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1871</anchor> <taxon>Definition</taxon> <addr>hmlg-000D</addr><route>hmlg-000D.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Acyclic chain complex</title>   </frontmatter> <mainmatter><p>
  If all the homology groups vanish, then the chain complex is said fo be <strong>acyclic</strong> or <strong>exact</strong>. Equivalently, every cycle is a boundary.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1872</anchor> <taxon>Definition</taxon> <addr>hmlg-000H</addr><route>hmlg-000H.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Short exact sequence</title>   </frontmatter> <mainmatter><p>
  A <strong>short exact sequence</strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <tex display="block">0  \to  A  \to  B  \to  C  \to  0.</tex> Short exact sequence describes how <tex>B</tex> is made up of a subobject <tex>A</tex> and a quotient <tex>C</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1873</anchor>  <addr>hmlg-000E</addr><route>hmlg-000E.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Difference of exactness and acyclicity</title>   </frontmatter> <mainmatter><p>
  Although the definition of exactness and acyclicity are the same, they have different <link href="https://ncatlab.org/nlab/show/concept+with+an+attitude" type="external">attitudes</link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1874</anchor> <taxon>Definition</taxon> <addr>hmlg-0008</addr><route>hmlg-0008.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Given two chain complexes <tex>C_ \bullet , D_ \bullet</tex>, the natural notion of morphisms between them is <strong>chain maps</strong>, i.e. a sequence of maps <tex>f_n : C_n  \to  D_n</tex> such that all the squares commute.
</p>
  <embedded-tex hash="2942ad6f5f0e67d4aaf0692a706bdfe6"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow [&quot;d&quot;, from=1-3, to=1-4]
   \arrow [&quot;{f_n}&quot;', from=1-3, to=2-3]
   \arrow [&quot;{f_{n-1}}&quot;', from=1-4, to=2-4]
   \arrow [&quot;d&quot;', from=2-3, to=2-4]
   \arrow [&quot;d&quot;', from=2-2, to=2-3]
   \arrow [&quot;d&quot;, from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow [&quot;{f_{n+1}}&quot;', from=1-2, to=2-2]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1875</anchor> <taxon>Visualization</taxon> <addr>hmlg-0009</addr><route>hmlg-0009.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Appropriately combing two copies of <ref addr="hmlg-000A" href="hmlg-000A.xml" taxon="Visualization"/>, we get the following picture for a <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</p>
  <embedded-tex hash="163ee9b3aafad0dfcf9e12dc63132caf"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1876</anchor> <taxon>Construction</taxon> <addr>hmlg-000B</addr><route>hmlg-000B.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain maps induce maps on homology</title>   </frontmatter> <mainmatter><p>
  A chain map <tex>f : C  \to  D</tex> induces a family of homomorphisms <tex>f_* : H_n (C)  \to  H_n (D)</tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <tex>f  \circ  g</tex> induces composition homomorphism <tex>(f  \circ  g)_* = f_*  \circ  g_*</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1877</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>   <parent>hmlg-000B</parent> </frontmatter> <mainmatter><p>
  Referring to <ref addr="hmlg-0009" href="hmlg-0009.xml" taxon="Visualization"/> makes all the moving parts clear here. Since <tex>f</tex> commutes with the boundary maps, it maps the boundaries in <tex>C_n</tex> to the boundaries in <tex>D_n</tex>. Therefore the map is well-defined after passing to the quotient.
</p></mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1878</anchor> <taxon>Definition</taxon> <addr>hmlg-0007</addr><route>hmlg-0007.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Components of a chain complex</title>   </frontmatter> <mainmatter><p>
  Given a <link href="hmlg-0003.xml" type="local" addr="hmlg-0003" title="Chain complex of R-modules">chain complex</link>, the <strong>cycles</strong> <tex>Z_n</tex> of dimension <tex>n</tex> are given by the kernel of <tex>d_n : C_n  \to  C_{n-1}</tex>. The <strong>boundaries</strong> <tex>B_n</tex> are given by the image of <tex>d_{n+1} : C_{n+1}  \to  C_n</tex>. The equation <tex>d^2 = 0</tex> is equivalent to <tex display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <link href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms" type="external">homomorphism theorem</link>, the quotient <tex>C_n / Z_n</tex> is isomorphic to the image of <tex>d_n</tex>, which is the next boundary <tex>B_{n-1}</tex>. On the other hand, the <strong>homology groups</strong> <tex>H_n(C)</tex> are defined as the quotient <tex>Z_n/B_n</tex>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1879</anchor>  <addr>hmlg-000E</addr><route>hmlg-000E.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Difference of exactness and acyclicity</title>   </frontmatter> <mainmatter><p>
  Although the definition of exactness and acyclicity are the same, they have different <link href="https://ncatlab.org/nlab/show/concept+with+an+attitude" type="external">attitudes</link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1880</anchor> <taxon>Definition</taxon> <addr>hmlg-000C</addr><route>hmlg-000C.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Quasi-isomorphism</title>   </frontmatter> <mainmatter><p>
  A <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link> is a <strong>quasi-isomorphism</strong> if it induces isomorphisms on the <link href="hmlg-0007.xml" type="local" addr="hmlg-0007" title="Components of a chain complex">homology groups</link>.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1881</anchor>  <addr>hmlg-0001</addr><route>hmlg-0001.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Homological Algebra</title>   </frontmatter> <mainmatter><p>This is a set of notes primarily based on <link href="homological-algebra.xml" type="local" addr="homological-algebra" title="An Introduction to Homological Algebra">Weibel</link> and <link href="wwli.xml" type="local" addr="wwli" title="Wen-Wei Li">Wen-Wei Li</link>’s <link href="methods-of-algebra-2.xml" type="local" addr="methods-of-algebra-2" title="代数学方法 卷二: 线性代数">unpublished book</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1882</anchor>  <addr>hmlg-0006</addr><route>hmlg-0006.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain complexes</title>   </frontmatter> <mainmatter><p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <tex>C_n</tex> freely generated by cells of dimension <tex>n</tex> (i.e. encoding the formal sums of cells), and a <em>boundary</em> operator <tex>d_n : C_n  \to  C_{n-1}</tex>. The critical feature of the operator is <tex display="block">d_{n-1}  \circ  d_n = 0,</tex> simply written as <tex>d^2 = 0</tex>, reflecting a deep geometric phenomenon that <mark>the boundary of a shape doesn’t have any boundary itself</mark>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1883</anchor> <taxon>Definition</taxon> <addr>hmlg-0002</addr><route>hmlg-0002.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date>  <title>Chain complex of abelian groups</title>   </frontmatter> <mainmatter><p>
  A chain complex of abelian groups is given by a sequence of abelian groups <tex>G_ \bullet</tex> together with homomorphisms <tex>d_n : G_n  \to  G_{n-1}</tex>, such that <tex>d_{n-1}  \circ  d_n = 0</tex>.
</p></mainmatter> </tree><p>This is eligible to immediate generalization.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1884</anchor> <taxon>Definition</taxon> <addr>hmlg-0003</addr><route>hmlg-0003.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date>  <title>Chain complex of <tex>R</tex>-modules</title>   <meta name="generalizes">hmlg-0002</meta></frontmatter> <mainmatter><p>
  A chain complex of <tex>R</tex>-modules is given by a sequence of modules <tex>M_ \bullet</tex> together with <tex>R</tex>-linear maps <tex>d_n : R_n  \to  R_{n-1}</tex>, such that <tex>d_{n-1}  \circ  d_n = 0</tex>.
</p></mainmatter> </tree><p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1885</anchor> <taxon>Definition</taxon> <addr>hmlg-0007</addr><route>hmlg-0007.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Components of a chain complex</title>   </frontmatter> <mainmatter><p>
  Given a <link href="hmlg-0003.xml" type="local" addr="hmlg-0003" title="Chain complex of R-modules">chain complex</link>, the <strong>cycles</strong> <tex>Z_n</tex> of dimension <tex>n</tex> are given by the kernel of <tex>d_n : C_n  \to  C_{n-1}</tex>. The <strong>boundaries</strong> <tex>B_n</tex> are given by the image of <tex>d_{n+1} : C_{n+1}  \to  C_n</tex>. The equation <tex>d^2 = 0</tex> is equivalent to <tex display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <link href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms" type="external">homomorphism theorem</link>, the quotient <tex>C_n / Z_n</tex> is isomorphic to the image of <tex>d_n</tex>, which is the next boundary <tex>B_{n-1}</tex>. On the other hand, the <strong>homology groups</strong> <tex>H_n(C)</tex> are defined as the quotient <tex>Z_n/B_n</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1886</anchor> <taxon>Visualization</taxon> <addr>hmlg-000A</addr><route>hmlg-000A.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain complex</title>   </frontmatter> <mainmatter><p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <link href="https://www.3blue1brown.com/blog/exact-sequence-picturebook" type="external">here</link>.
</p>
  <embedded-tex hash="f54725dcd4c386fc74f41f8d152fec4a"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
<p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1887</anchor> <taxon>Definition</taxon> <addr>hmlg-0008</addr><route>hmlg-0008.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Given two chain complexes <tex>C_ \bullet , D_ \bullet</tex>, the natural notion of morphisms between them is <strong>chain maps</strong>, i.e. a sequence of maps <tex>f_n : C_n  \to  D_n</tex> such that all the squares commute.
</p>
  <embedded-tex hash="2942ad6f5f0e67d4aaf0692a706bdfe6"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow [&quot;d&quot;, from=1-3, to=1-4]
   \arrow [&quot;{f_n}&quot;', from=1-3, to=2-3]
   \arrow [&quot;{f_{n-1}}&quot;', from=1-4, to=2-4]
   \arrow [&quot;d&quot;', from=2-3, to=2-4]
   \arrow [&quot;d&quot;', from=2-2, to=2-3]
   \arrow [&quot;d&quot;, from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow [&quot;{f_{n+1}}&quot;', from=1-2, to=2-2]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1888</anchor> <taxon>Visualization</taxon> <addr>hmlg-0009</addr><route>hmlg-0009.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain map</title>   </frontmatter> <mainmatter><p>
  Appropriately combing two copies of <ref addr="hmlg-000A" href="hmlg-000A.xml" taxon="Visualization"/>, we get the following picture for a <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</p>
  <embedded-tex hash="163ee9b3aafad0dfcf9e12dc63132caf"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
    \usetikzlibrary{decorations.pathreplacing}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1889</anchor> <taxon>Construction</taxon> <addr>hmlg-000B</addr><route>hmlg-000B.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Chain maps induce maps on homology</title>   </frontmatter> <mainmatter><p>
  A chain map <tex>f : C  \to  D</tex> induces a family of homomorphisms <tex>f_* : H_n (C)  \to  H_n (D)</tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <tex>f  \circ  g</tex> induces composition homomorphism <tex>(f  \circ  g)_* = f_*  \circ  g_*</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1890</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter><p>
  Referring to <ref addr="hmlg-0009" href="hmlg-0009.xml" taxon="Visualization"/> makes all the moving parts clear here. Since <tex>f</tex> commutes with the boundary maps, it maps the boundaries in <tex>C_n</tex> to the boundaries in <tex>D_n</tex>. Therefore the map is well-defined after passing to the quotient.
</p></mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1891</anchor> <taxon>Definition</taxon> <addr>hmlg-000C</addr><route>hmlg-000C.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Quasi-isomorphism</title>   </frontmatter> <mainmatter><p>
  A <link href="hmlg-0008.xml" type="local" addr="hmlg-0008" title="Chain map">chain map</link> is a <strong>quasi-isomorphism</strong> if it induces isomorphisms on the <link href="hmlg-0007.xml" type="local" addr="hmlg-0007" title="Components of a chain complex">homology groups</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1892</anchor> <taxon>Definition</taxon> <addr>hmlg-000D</addr><route>hmlg-000D.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Acyclic chain complex</title>   </frontmatter> <mainmatter><p>
  If all the homology groups vanish, then the chain complex is said fo be <strong>acyclic</strong> or <strong>exact</strong>. Equivalently, every cycle is a boundary.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1893</anchor> <taxon>Definition</taxon> <addr>hmlg-000H</addr><route>hmlg-000H.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Short exact sequence</title>   </frontmatter> <mainmatter><p>
  A <strong>short exact sequence</strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <tex display="block">0  \to  A  \to  B  \to  C  \to  0.</tex> Short exact sequence describes how <tex>B</tex> is made up of a subobject <tex>A</tex> and a quotient <tex>C</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1894</anchor>  <addr>hmlg-000E</addr><route>hmlg-000E.xml</route>  <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Difference of exactness and acyclicity</title>   </frontmatter> <mainmatter><p>
  Although the definition of exactness and acyclicity are the same, they have different <link href="https://ncatlab.org/nlab/show/concept+with+an+attitude" type="external">attitudes</link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1895</anchor>  <addr>hmlg-000G</addr><route>hmlg-000G.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1896</anchor>  <addr>hmlg-000L</addr><route>hmlg-000L.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Operations on chain complexes</title>   </frontmatter> <mainmatter><p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1897</anchor> <taxon>Definition</taxon> <addr>hmlg-000I</addr><route>hmlg-000I.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Direct sum and product of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a family of chain complexes <tex>C_{ \alpha ,  \bullet }</tex>, we can take the direct sum in each dimension, giving <tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</tex>, which is another chain complex. Dually, we can take the direct product <tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</tex>.
</p></mainmatter> </tree><p>
  As another example, the consideration of quotienting out a subspace <tex>Y  \subseteq  X</tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <tex display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1898</anchor> <taxon>Definition</taxon> <addr>hmlg-000K</addr><route>hmlg-000K.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Bicomplex</title>   </frontmatter> <mainmatter><p>
  A <strong>bicomplex</strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <tex>A_{m, n}</tex>, vertical maps <tex>d : A_{m, n}  \to  A_{m, n-1}</tex> and horizontal maps <tex>\delta  : A_{m, n}  \to  A_{m-1, n}</tex>. Every square in the grid commutes, and <tex>d^2 =  \delta ^2 = 0</tex>.
</p><p>
  Each column <tex>A_{m,  \bullet }</tex> in the bicomplex is a chain complex, and <tex>\delta</tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <tex>d</tex> are chain maps between the row complexes.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1899</anchor> <taxon>Definition</taxon> <addr>hmlg-000J</addr><route>hmlg-000J.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Exact sequence of chain complexes</title>   </frontmatter> <mainmatter><p>
  An <strong>exact sequence</strong> of chain complexes <tex>C_{m,  \bullet }</tex> is a <link href="hmlg-000K.xml" type="local" addr="hmlg-000K" title="Bicomplex">bicomplex</link> such that the rows are <link href="hmlg-000D.xml" type="local" addr="hmlg-000D" title="Acyclic chain complex">exact</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1900</anchor>  <addr>hmlg-000V</addr><route>hmlg-000V.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Kernel, image, cokernel and coimage of chain complexes</title>   </frontmatter> <mainmatter><p>
  Given a chain map <tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</p>
  <embedded-tex hash="294ed28114fa55f0507e63597a971463"><embedded-tex-preamble>
        \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
  </embedded-tex-preamble> <embedded-tex-body>
     \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [&quot; \sim &quot;, from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
  </embedded-tex-body></embedded-tex>
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1901</anchor>  <addr>hmlg-000U</addr><route>hmlg-000U.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive and abelian categories</title>   </frontmatter> <mainmatter><p>
  Since many <link href="hmlg-000L.xml" type="local" addr="hmlg-000L" title="Operations on chain complexes">operations</link> on abelian groups and <tex>R</tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</p><p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1902</anchor> <taxon>Definition</taxon> <addr>hmlg-000O</addr><route>hmlg-000O.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title><tex>\mathsf { Ab }</tex>-enriched category</title>   </frontmatter> <mainmatter><p>
  Given a category <tex>\mathcal { C }</tex>, an <tex>\mathsf { Ab }</tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1903</anchor> <taxon>Definition</taxon> <addr>hmlg-000P</addr><route>hmlg-000P.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive category</title>   </frontmatter> <mainmatter><p>
  Let <tex>\mathcal { C }</tex> be <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enriched</link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <strong>additive category</strong>. In particular, the nullary product and coproduct coincide, and we call the object <strong>zero object</strong>, denoted <tex>0</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1904</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <tex>X_i</tex> to their product is given by a matrix of morphisms <tex>f_{ij} : X_i  \to  X_j</tex>. We choose the identity matrix
    <tex display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</tex>
    where <tex>0</tex> is the additive neutral element in the abelian group <tex>\hom (X_i, X_j)</tex>. This gives a canonical map <tex>\coprod _i X_i  \to   \prod _i X_i</tex>.
  </p>

  <p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <tex display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><p>
  Due to this coincidence creating gadgets with <em>two universal properties</em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1905</anchor> <taxon>Theorem</taxon> <addr>hmlg-000R</addr><route>hmlg-000R.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Being an additive category is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link></title>   </frontmatter> <mainmatter><p>
  Given a category, if it can be endowed with an <link href="hmlg-000O.xml" type="local" addr="hmlg-000O" title="{Ab}-enriched category"><tex>\mathsf { Ab }</tex>-enrichment</link> that makes it an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1906</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Notice that having finite products and coproducts is a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>, and the canonical morphism between them being an isomorphism is also a <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">property</link>. These do not mention the enrichment structure.
  </p>

  <p>
    With these properties satisfied, the addition structure on the <tex>\hom</tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <tex display="block">X  \to  0  \to  Y,</tex>
    and given two parallel morphisms <tex>f, g : X  \to  Y</tex>, the following composition
    <tex display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</tex>
    is equal to the addition <tex>f + g</tex>. For disambiguation, we temporarily denote these constructions as <tex>0'</tex> and <tex>f +' g</tex>. By interpreting <tex>\oplus</tex> as a product or a coproduct at appropriate times, it is easy to see that <tex>0'</tex> is indeed the neutral element for <tex>+'</tex>.
  </p>

  <p>
    Recall that arrows <tex>X  \oplus  X  \to  Y  \oplus  Y</tex> is given by a <tex>2  \times  2</tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <tex>f  \oplus  g</tex> comes from a diagonal matrix with <tex>f, g</tex> as entries, so this operation is linear, which entails <tex>+'</tex> is also linear. By the <link href="todo.xml" type="local" addr="todo" title="Placeholder tree">Eckmann–Hilton argument</link>, the two addition operations must coincide.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1907</anchor> <taxon>Definition</taxon> <addr>hmlg-000S</addr><route>hmlg-000S.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Additive functor</title>   </frontmatter> <mainmatter><p>
  Given two <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link> and a functor <tex>F :  \mathcal { C }   \to   \mathcal { D }</tex> between them, the following are equivalent:
  <ul><li>The functor preserves finite products.</li>
    <li>The functor preserves finite coproducts.</li>
    <li>The functor is a homomorphism on the abelian groups <tex>\hom _{ \mathcal { C } }(X, Y)</tex>, i.e. it is an <tex>\mathsf { Ab }</tex>-enriched functor.</li></ul>
  In this case, we call the functor <strong>additive</strong>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1908</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    For the equivalence of the first two claims, we have a composition
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</tex>
    where the middle morphism comes from the canonical isomorphism <tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <tex>F</tex>, we can compute that the composition is the canonical isomorphism from <tex>F(X) + F(Y)</tex> to <tex>F(X)  \times  F(Y)</tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </p>

  <p>
    Since the abelian group structure on morphisms is <link href="hmlg-000R.xml" type="local" addr="hmlg-000R" title="Being an additive category is a property">uniquely determined</link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <tex>F(1)  \to  1</tex> and <tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</tex> are isomorphisms. For the first one, since <tex>1</tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <tex display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</tex>
    Using the bilinearity of composition and that <tex>F</tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1909</anchor> <taxon>Theorem</taxon> <addr>hmlg-000T</addr><route>hmlg-000T.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Adjunctions are additive</title>   </frontmatter> <mainmatter><p>
  In an adjunction <tex>F  \dashv  G</tex>, both functors are automatically additive.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1910</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter><p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <ref addr="hmlg-000S" href="hmlg-000S.xml" taxon="Definition"/> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</p></mainmatter> </tree>
  
</mainmatter> </tree><p>
  Kernels and cokernels are also greatly simplified in additive categories.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1911</anchor> <taxon>Theorem</taxon> <addr>hmlg-000Y</addr><route>hmlg-000Y.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Equalizers can be reduced to kernels in <tex>\mathsf { Ab }</tex>-enriched categories</title>   </frontmatter> <mainmatter><p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1912</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    We simply need to note that an equalizer for <tex>f</tex> and <tex>g</tex> is equivalent to an equalizer for <tex>(f-g)</tex> and <tex>0</tex>, by bilinearity of composition.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1913</anchor> <taxon>Intuition</taxon> <addr>hmlg-000W</addr><route>hmlg-000W.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian categories</title>   </frontmatter> <mainmatter><p><link href="hmlg-000Q.xml" type="local" addr="hmlg-000Q" title="Abelian category">Abelian categories</link> are one step further from <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive categories</link>. Similar to the situation of abelian groups or modules, every morphism <tex>f : X  \to  Y</tex> has four key components, the image, the kernel, the coimage <tex>X /  \ker  f</tex>, and the cokernel <tex>Y /  \operatorname {im}  f</tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1914</anchor> <taxon>Definition</taxon> <addr>hmlg-000Q</addr><route>hmlg-000Q.xml</route>  <date><year>2024</year> <month>2</month> <day>18</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Abelian category</title>   </frontmatter> <mainmatter><p>
  Given an <link href="hmlg-000P.xml" type="local" addr="hmlg-000P" title="Additive category">additive category</link>, it is an <strong>abelian category</strong> if the following condition holds:
  <ul><li>Every morphism has a kernel and a cokernel.</li>
    <li>Every monomorphism is the kernel of its cokernel.</li>
    <li>Every epimorphism is the cokernel of its kernel.</li></ul></p></mainmatter> </tree><p>
  The definition of abelian categories may look intimidating, but thinking of it as <tex>R</tex>-modules is a very effective way to reduce mental load. In fact, <link href="hmlg-000F.xml" type="local" addr="hmlg-000F" title="Freyd–Mitchell embedding theorem">the Freyd–Mitchell embedding theorem</link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</p><p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <link href="hmlg-000X.xml" type="local" addr="hmlg-000X" title="Left and right exact functor">exact</link>, but many functors fail to satisfy this for various reasons. <mark>One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</mark> This leads to intricate and beautiful structures emerging.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1915</anchor> <taxon>Definition</taxon> <addr>hmlg-000X</addr><route>hmlg-000X.xml</route>  <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Left and right exact functor</title>   </frontmatter> <mainmatter><p>
  An <link href="hmlg-000S.xml" type="local" addr="hmlg-000S" title="Additive functor">additive functor</link> <tex>F :  \mathcal { A }   \to   \mathcal { B }</tex> between abelian categories is <strong>left exact</strong> if it satisfies the following equivalent conditions.

  <ul><li>It preserves kernels.</li>
    <li>It preserves finite limits.</li>
    <li>It preserves the exactness of sequences <tex display="block">0  \to  A  \to  B  \to  C.</tex></li></ul></p><p>
  Dually, an additive functor is <strong>right exact</strong> if it satisfies the following equivalent conditions.
  <ul><li>It preserves cokernels.</li>
    <li>It preserves finite colimits.</li>
    <li>It preserves the exactness of sequences <tex display="block">A  \to  B  \to  C  \to  0.</tex></li></ul>
  If a functor is both left exact and right exact, it is simply called an <strong>exact functor</strong>, which is equivalent to it preserving the exactness of sequences <tex>A  \to  B  \to  C</tex>.
</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>1916</anchor> <taxon>Proof</taxon>   <date><year>2024</year> <month>2</month> <day>19</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors>    </frontmatter> <mainmatter>
  <p>
    Since additive functors already preserves finite products, and <link href="hmlg-000Y.xml" type="local" addr="hmlg-000Y" title="Equalizers can be reduced to kernels in {Ab}-enriched categories">kernels are equivalent to general coequalizers</link> using the additive structure, the first two conditions are equivalent.
  </p>

  <p>
    The sequence <tex>A  \rightarrowtail  B  \to  C</tex> being exact is equivalent to <tex>A</tex> being a kernel of <tex>B  \to  C</tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1917</anchor> <taxon>Definition</taxon> <addr>hmlg-0004</addr><route>hmlg-0004.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date>  <title>Projective objects</title>   </frontmatter> <mainmatter><p>In an abelian category, an object <tex>P</tex> is <strong>projective</strong> iff for every morphism <tex>P  \to  B</tex> can be lifted through an epimorphism <tex>A  \twoheadrightarrow  B</tex>, i.e. there exists a (non-unique) morphism <tex>P  \to  A</tex> making the triangle commute.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1918</anchor> <taxon>Intuition</taxon> <addr>hmlg-0005</addr><route>hmlg-0005.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date>  <title>Projective objects</title>   </frontmatter> <mainmatter><p><link href="hmlg-0004.xml" type="local" addr="hmlg-0004" title="Projective objects">Projective objects</link> are defined to capture a key property of free objects. For an arbitrary abelian group <tex>P</tex>, lifting a map <tex>P  \to  B</tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="true"><frontmatter><anchor>1919</anchor>  <addr>trebor-0001</addr><route>index.xml</route>  <date><year>2024</year> <month>2</month> <day>16</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Trebor’s forest</title>   </frontmatter> <mainmatter><p>
  This is my forest, which is <link href="https://www.jonmsterling.com/jms-005P.xml" type="external">a way of organizing notes</link>. Here is <link href="https://www.jonmsterling.com/jms-009H.xml" type="external">a list of other websites organized as forests</link>. Some of the contents here:
  <ul><li><link href="hmlg-0001.xml" type="local" addr="hmlg-0001" title="Homological Algebra">Notes on homological algebra</link></li>
    <li><link href="hmlg-001K.xml" type="local" addr="hmlg-001K" title="Effective homology">Effective homology</link></li>
    <li>Algebraic geometry (Under namespace <code>algm</code>, not organized)</li></ul></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1920</anchor>  <addr>trebor-0002</addr><route>trebor-0002.xml</route>  <date><year>2024</year> <month>3</month> <day>4</day></date> <authors><author><link href="trebor.xml" type="local" trebor="addr">Trebor</link></author> </authors> <title>Style of writing</title>   </frontmatter> <mainmatter><p>
  I try to adhere to several principles when composing trees.
</p><ul><li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </li>
  <li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <tex>\mathfrak { a }   \mid  x</tex> instead of <tex>x  \in   \mathfrak { a }</tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <tex>\operatorname {Spec} (A)</tex>, we do not identify them.
  </li>
  <li>
    Apply <link href="https://ncatlab.org/nlab/show/biased+definition" type="external">unbiased terminology</link> and <link href="https://ncatlab.org/nlab/show/negative+thinking" type="external">negative thinking</link>.
  </li></ul></mainmatter> </tree></mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>