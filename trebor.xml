<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1954</fr:anchor><fr:taxon>Person</fr:taxon><fr:addr>trebor</fr:addr><fr:route>trebor.xml</fr:route><fr:title>Trebor</fr:title><fr:meta
name="institution">Tsinghua University</fr:meta><fr:meta
name="position">Bachelor Student</fr:meta><fr:meta
name="external">https://github.com/Trebor-Huang</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  My name is 黄栩 (<fr:em>Huang Xu</fr:em>), but I go by the name <fr:em>Trebor</fr:em> online. I’m interested in (homotopy) type theory, category theory and jazz.
</fr:p></fr:mainmatter><fr:backmatter><fr:contributions><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1670</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000B</fr:addr><fr:route>ualg-000B.xml</fr:route><fr:title>Split coequalizer</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We define a <fr:strong>split coequalizer</fr:strong> to be the following diagram:
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="d7f012500ab1ec188665474d430177ad"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
    X &amp; Y &amp; Z
     \arrow ["{ \partial _0}", shift left, curve={height=-6pt}, from=1-1, to=1-2]
     \arrow ["{ \partial _1}"', shift right, curve={height=6pt}, from=1-1, to=1-2]
     \arrow ["s"{description}, from=1-2, to=1-1]
     \arrow ["q", from=1-2, to=1-3]
     \arrow ["r", curve={height=-6pt}, from=1-3, to=1-2]
   \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  such that <fr:tex>q  \circ  r =  \operatorname {id} _Z</fr:tex>, <fr:tex>r  \circ  q = s  \circ   \partial _1</fr:tex> and <fr:tex>s  \circ   \partial _2 =  \operatorname {id} _Y</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1672</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title>Monadic functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functors <fr:tex>F  \dashv  G</fr:tex>, <fr:tex>G</fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
href="ualg-0009.xml"
type="local"
addr="ualg-0009">comparison functor</fr:link> to <fr:tex>\mathcal { C } ^{G  \circ  F}</fr:tex> is an equivalence in <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">the bicategory of decompositions</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1674</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title>The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1676</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title>The Kleisli category induces the initial decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1678</fr:anchor><fr:addr>ualg-0007</fr:addr><fr:route>ualg-0007.xml</fr:route><fr:title>Decomposition of a monad into adjoint functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functor <fr:tex>F  \dashv  G</fr:tex>, <fr:tex>G  \circ  F</fr:tex> forms a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link>. As a converse, we can consider the adjunctions whose composition is a given monad <fr:tex>M</fr:tex>. These decompositions form a bicategory. The morphisms between two adjunctions are given by functors <fr:tex>L</fr:tex> that make the two triangles below commute.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="ad1369f55e70e83541ee4678c83b691b"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
    { \mathcal { D } _2} &amp; { \mathcal { D } _1} &amp; { \mathcal { C } }
     \arrow [shift right, from=1-2, to=1-3]
     \arrow [shift right, from=1-3, to=1-2]
     \arrow [shift right, curve={height=18pt}, from=1-1, to=1-3]
     \arrow [shift right, curve={height=18pt}, from=1-3, to=1-1]
     \arrow ["L"{description}, from=1-2, to=1-1]
   \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  More precisely, the objects of this bicategory are given by adjunctions <fr:tex>F  \dashv  G</fr:tex> together with a natural isomorphism <fr:tex>G  \circ  F  \cong  M</fr:tex>. A morphism from <fr:tex>F_1  \dashv  G_1</fr:tex> to <fr:tex>F_2  \dashv  G_2</fr:tex> is given by a functor <fr:tex>L</fr:tex> together with two natural isomorphisms <fr:tex>L  \circ  G_1  \cong  G_2</fr:tex>, <fr:tex>F_1  \cong  F_2  \circ  L</fr:tex>. A <fr:tex>2</fr:tex>-morphism is given by a natural transformation such that the relevant composition of natural transformations are equal.
</fr:p><fr:p>
  This bicategory has initial and terminal objects.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>244</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0008</fr:addr><fr:route>ualg-0008.xml</fr:route><fr:title>The Kleisli category induces the initial decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> together with its canonical adjunction is the initial <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>246</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0009</fr:addr><fr:route>ualg-0009.xml</fr:route><fr:title>The Eilenberg–Moore category induces the terminal decomposition of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">Eilenberg–Moore category</fr:link> together with its canonical adjunction is the terminal <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">decomposition of a monad into adjoint functors</fr:link>. Hence there is a unique morphism from any decomposition to it, named the <fr:strong>comparison functor</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>248</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-000A</fr:addr><fr:route>ualg-000A.xml</fr:route><fr:title>Monadic functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of adjoint functors <fr:tex>F  \dashv  G</fr:tex>, <fr:tex>G</fr:tex> is <fr:strong>monadic</fr:strong> if the corresponding <fr:link
href="ualg-0009.xml"
type="local"
addr="ualg-0009">comparison functor</fr:link> to <fr:tex>\mathcal { C } ^{G  \circ  F}</fr:tex> is an equivalence in <fr:link
href="ualg-0007.xml"
type="local"
addr="ualg-0007">the bicategory of decompositions</fr:link>.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1680</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>ualg-0006</fr:addr><fr:route>ualg-0006.xml</fr:route><fr:title>Objects of the Kleisli category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An object of <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">the Kleisli category of a monad</fr:link> can be considered as a <fr:link
href="ualg-0003.xml"
type="local"
addr="ualg-0003">free algebra</fr:link>, but <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">equipped with a canonical choice of generators</html:mark>. Hence although <fr:link
href="ualg-0005.xml"
type="local"
addr="ualg-0005">the Kleisli category is equivalent to the category of free algebras</fr:link>, the objects are essentially different. This manifests as the curious fact that the Kleisli category is not univalent, since an equality of Kleisli objects requires an isomorphism of the generators, but an isomorphism only requires the two free algebras to be isomorphic.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1682</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>ualg-0005</fr:addr><fr:route>ualg-0005.xml</fr:route><fr:title>The Kleisli category is equivalent to the category of free algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given category <fr:tex>\mathcal { C }</fr:tex>, <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">the Kleisli category of a monad</fr:link> <fr:tex>M :  \mathcal { C }   \to   \mathcal { C }</fr:tex> is equivalent to the full subcategory of the <fr:tex>M</fr:tex>-<fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebras</fr:link> spanned by the <fr:link
href="ualg-0003.xml"
type="local"
addr="ualg-0003">free algebras</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>287</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0005</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Consider the functor from the Kleisli category to the category of free algebras, sending <fr:tex>X</fr:tex> to the free algebra on <fr:tex>X</fr:tex>. This is fully faithful and surjective on objects.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1684</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0004</fr:addr><fr:route>ualg-0004.xml</fr:route><fr:title>The Kleisli category of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M :  \mathcal { C }   \to   \mathcal { C }</fr:tex> and two objects <fr:tex>X, Y</fr:tex> in <fr:tex>\mathcal { C }</fr:tex>, a <fr:strong>Kleisli arrow</fr:strong> from <fr:tex>X</fr:tex> to <fr:tex>Y</fr:tex> is simply any arrow <fr:tex>X  \to  MY</fr:tex>. This represents an algebra homomorphism from the free algebra generated by <fr:tex>X</fr:tex> to that of <fr:tex>Y</fr:tex>.
</fr:p><fr:p>
  The identity Kleisli arrow is defined as <fr:tex>\eta  : X  \to  MX</fr:tex>. The composition of <fr:tex>f : X  \to  MY</fr:tex> and <fr:tex>g : Y  \to  MZ</fr:tex> is given by <fr:tex
display="block">X  \xrightarrow {f} MY  \xrightarrow {Mg} M^2 Z  \xrightarrow { \mu } MZ.</fr:tex> This forms a category whose objects are the objects of <fr:tex>\mathcal { C }</fr:tex>, as a formal symbol standing for the free algebra generated by those objects, and morphisms are Kleisli arrows. This is the <fr:strong>Kleisli category</fr:strong> <fr:tex>\mathcal { C } _M</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1686</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0002</fr:addr><fr:route>ualg-0002.xml</fr:route><fr:title>Algebra of a monad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M :  \mathcal { C }   \to   \mathcal { C }</fr:tex>, an <fr:tex>M</fr:tex>-<fr:strong>algebra</fr:strong> is defined as an object <fr:tex>X</fr:tex> equipped with a morphism <fr:tex>\alpha  : MX  \to  X</fr:tex>, such that the following two diagrams commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="787ec6baf9212839fad7a2632f367207"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} %tex
  {M^2X} &amp; MX &amp; X &amp; MX \\
  MX &amp; X &amp;&amp; X
  \arrow["\alpha"', from=2-1, to=2-2]
  \arrow["\alpha", from=1-2, to=2-2]
  \arrow["\mu"', from=1-1, to=2-1]
  \arrow["M\alpha", from=1-1, to=1-2]
  \arrow["\operatorname{id}"', from=1-3, to=2-4]
  \arrow["\eta", from=1-3, to=1-4]
  \arrow["\alpha", from=1-4, to=2-4] \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  In an unbiased formulation, we require the natural transformation <fr:tex>M^n  \to  M</fr:tex> of the monad evaluated at the object <fr:tex>X</fr:tex> composed with <fr:tex>\alpha  : MX  \to  X</fr:tex> to be equal to <fr:tex
display="block">M^n X  \xrightarrow {M^{n-1} \alpha } M^{n-1}X  \to   \cdots   \xrightarrow { \alpha } X.</fr:tex></fr:p><fr:p>
  The algebras of a monad form a category <fr:tex>\mathcal { C } ^M</fr:tex>, whose morphisms are commutative squares. This is also known as the <fr:strong>Eilenberg–Moore category</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1688</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>ualg-0003</fr:addr><fr:route>ualg-0003.xml</fr:route><fr:title>Free monad algebras</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="ualg-0001.xml"
type="local"
addr="ualg-0001">monad</fr:link> <fr:tex>M</fr:tex> on a category <fr:tex>\mathcal { C }</fr:tex>, there is a canonical adjunction between the <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">category of algebras</fr:link> <fr:tex>\mathcal { C } ^M</fr:tex> and <fr:tex>\mathcal { C }</fr:tex>. The <fr:strong>forgetful functor</fr:strong> <fr:tex>U_M</fr:tex> takes an <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebra</fr:link> and forgets the algebra structure. The <fr:strong>free functor</fr:strong> <fr:tex>F_M</fr:tex> takes an object <fr:tex>X</fr:tex> and produces an algebra on <fr:tex>MX</fr:tex> given by the monad multiplication map <fr:tex>\mu  : M^2 X  \to  MX</fr:tex>, called the <fr:strong>free algebra</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>295</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>ualg-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We verify that they form an adjunction. Algebra homomorphisms <fr:tex>\varphi  : F_M X  \to  Y</fr:tex> are given by commutative squares
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="7333f0d82efd61bdb7ce936fbe3b82de"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} %tex
      {M^2 X} &amp; MY \\
      MX &amp; Y
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2] \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    while morphisms <fr:tex>f : X  \to  Y</fr:tex> fits in the diagram as such: 
    
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="db2ad0a755f43c4914bf816c04cc5ae6"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} %tex
      {M^2 X} &amp; MY \\
      MX &amp; Y \\
      X
      \arrow["{\alpha_Y}", from=1-2, to=2-2]
      \arrow["\mu"', from=1-1, to=2-1]
      \arrow["\varphi", from=2-1, to=2-2]
      \arrow["{M\varphi}", from=1-1, to=1-2]
      \arrow["f"', from=3-1, to=2-2]
      \arrow["\eta", from=3-1, to=2-1]
      \arrow[from=2-1, to=1-2] \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

    Given a homomorphism <fr:tex>\varphi</fr:tex> of algebras, we can compute <fr:tex>f</fr:tex> by composing with <fr:tex>\eta</fr:tex>. On the other hand, given <fr:tex>f</fr:tex>, we define <fr:tex>\varphi</fr:tex> by <fr:tex>\alpha _Y  \circ  Mf</fr:tex>. This creates a commutative square because
    <fr:tex
display="block">\begin {aligned}        \alpha _Y  \circ  M  \varphi        &amp;=  \alpha _Y  \circ  M \alpha _Y  \circ  M^2 f  \\        &amp;=  \alpha _Y  \circ   \mu   \circ  M^2 f  \\        &amp;=  \alpha _Y  \circ  M f  \circ   \mu   \\        &amp;=  \varphi   \circ   \mu .      \end {aligned}</fr:tex></fr:p>

  <fr:p>
    We just have to verify that the two conversions are mutual inverses. In one way, we need to verify <fr:tex>\alpha _Y  \circ  M f  \circ   \eta  = f</fr:tex>. This is true because by the naturality of <fr:tex>\eta</fr:tex> we get <fr:tex>M f  \circ   \eta  =  \eta   \circ  f</fr:tex>. Then by the definition of <fr:link
href="ualg-0002.xml"
type="local"
addr="ualg-0002">algebra</fr:link> <fr:tex>\alpha _Y  \circ   \eta  =  \operatorname {id}</fr:tex>, proving the equality. On the other hand, we need to show <fr:tex>\alpha _Y  \circ  M( \varphi   \circ   \eta ) =  \varphi</fr:tex>. This follows from the algebra identity <fr:tex>\alpha _Y  \circ  M  \alpha _Y =  \alpha _Y  \circ   \mu</fr:tex> and the monad identity <fr:tex>\mu   \circ  M  \eta  =  \operatorname {id}</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1690</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ualg-0001</fr:addr><fr:route>ualg-0001.xml</fr:route><fr:title>Monad on a category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>monad</fr:strong> on a category <fr:tex>\mathcal { C }</fr:tex> is a functor <fr:tex>M :  \mathcal { C }   \to   \mathcal { C }</fr:tex> equipped with natural transformations <fr:tex>\eta  :  \operatorname {Id}   \to  M</fr:tex> and <fr:tex>\mu  : M  \circ  M  \to  M</fr:tex> satisfying identity and associativity laws. In an unbiased way, we have a family of natural transformations <fr:tex>M^n  \to  M</fr:tex> with associativity.
</fr:p><fr:p>
  In short, it is a monoid in the category of endofunctors equipped with composition as the monoidal product.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1692</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001R</fr:addr><fr:route>hmlg-001R.xml</fr:route><fr:title>Chain reduction generated by a discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissible discrete vector field</fr:link> on a <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> <fr:tex>(C_k, d)</fr:tex>, we can generate a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link>. It will be computable when the cellular complex is <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>372</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    The DVF partitions the chain groups into a direct sum <fr:tex>C_k^{s}  \oplus  C_k^t  \oplus  C_k^c</fr:tex>, corresponding to source, target and critical cells. We would like to create a reduction to the critical cells only. To do this, we invoke <fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G"><fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">perturbation</fr:link> of the larger chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> and start with a simpler chain reduction.
  </fr:p>

  <fr:p>
    Consider the algebraic cellular complex whose chain groups are <fr:tex>C_k</fr:tex>, but the differential <fr:tex>d'( \sigma ) =  \pm   \tau</fr:tex> iff <fr:tex>\overrightharpoon { \tau   \sigma }</fr:tex> is in the vector field, and zero otherwise. The sign is determined as the sign of <fr:tex>\tau</fr:tex> in <fr:tex>d( \sigma )</fr:tex>. Hence <fr:tex>d' : C_{k+1}^{t}  \to  C_k^s</fr:tex>, and is zero otherwise. Therefore using the <fr:link
href="hmlg-001H.xml"
type="local"
addr="hmlg-001H">characterization of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:link> as a direct sum with a split exact chain complex, we see that this complex can be reduced to the complex on <fr:tex>C_k^p</fr:tex> whose differential is identically zero.
  </fr:p>

  <fr:p>
    Next, we try to perturb <fr:tex>d'</fr:tex> to <fr:tex>d</fr:tex>. We need <fr:tex>h_{ \rho }   \circ  (d' - d)</fr:tex> to be locally nilpotent, where <fr:tex>\rho</fr:tex> is the reduction constructed above. <fr:tex>h_{ \rho }</fr:tex> can be viewed as the inverse of <fr:tex>d'</fr:tex>, as it maps the source cell to the target cell. Expanding the definition, we see that this map transports cells down the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">discrete field line</fr:link>. Since the vector field is admissible, such a transportation eventually terminates and it becomes zero.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1694</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-001S</fr:addr><fr:route>hmlg-001S.xml</fr:route><fr:title>Discrete field lines can branch and merge</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although we make an analogy between a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link> and a vector field, the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">field lines</fr:link> of a DVF may branch out. For instance, take a triangle <fr:tex>\tau</fr:tex> with three edges <fr:tex>\sigma _1,  \sigma _2,  \sigma _3</fr:tex>. We can have a vector <fr:tex>\overrightharpoon { \sigma _1  \tau }</fr:tex> pointing into the triangle, and <fr:tex>\sigma _2,  \sigma _3</fr:tex> each having vectors pointing out. Similarly multiple field lines may join when they reach a lower-degree cell. Because of this, we need to take care in the phrasing of <fr:link
href="hmlg-001P.xml"
type="local"
addr="hmlg-001P">admissibility</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1696</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001P</fr:addr><fr:route>hmlg-001P.xml</fr:route><fr:title>Admissible discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link>, if is <fr:strong>admissible</fr:strong> if the lengths of the <fr:link
href="hmlg-001Q.xml"
type="local"
addr="hmlg-001Q">field lines</fr:link> starting from a cell are bounded. In other words, we can assign a natural number to every cell such that the field lines starting from this cell have length bounded by the number. The number can be different for each cell, and can be unbounded overall.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1698</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001Q</fr:addr><fr:route>hmlg-001Q.xml</fr:route><fr:title>Discrete field line</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-001N.xml"
type="local"
addr="hmlg-001N">discrete vector field</fr:link>, the discrete version of <fr:strong>field lines</fr:strong> is defined as a sequence of cells alternating between degree <fr:tex>p</fr:tex> and <fr:tex>(p-1)</fr:tex> starting and ending with lower-degree cells, with a few requirements.
</fr:p><fr:ul><fr:li>When the degree increases, the two cells must occur as a vector in the DVF.</fr:li>
  <fr:li>When the degree decreases, the degree <fr:tex>(p-1)</fr:tex> cell must be a (possible non-<fr:link
href="hmlg-001O.xml"
type="local"
addr="hmlg-001O">regular</fr:link>) face of the degree <fr:tex>p</fr:tex> cell.</fr:li>
  <fr:li>Two degree <fr:tex>(p-1)</fr:tex> cells separated by a degree <fr:tex>p</fr:tex> cell must not be the same.</fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1700</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001N</fr:addr><fr:route>hmlg-001N.xml</fr:route><fr:title>Discrete vector field</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>discrete vector field</fr:strong> (DVF) of degree <fr:tex>p</fr:tex> on an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> is given by a collection of pairs of cells <fr:tex>( \sigma ,  \tau )</fr:tex>, where <fr:tex>\sigma</fr:tex> is a <fr:link
href="hmlg-001O.xml"
type="local"
addr="hmlg-001O">regular face</fr:link> of the degree <fr:tex>p</fr:tex> cell <fr:tex>\tau</fr:tex>, standing for a vector pointing from <fr:tex>\sigma</fr:tex> to <fr:tex>\tau</fr:tex>, which we will write as <fr:tex>\overrightharpoon { \sigma   \tau }</fr:tex>. We require that every cell appears at most once in these vectors.
</fr:p><fr:p>
  A DVF naturally partitions the cells into three kinds: the <fr:em>sources</fr:em>, the <fr:em>targets</fr:em>, and the rest of the cells are called <fr:em>critical cells</fr:em>. This name comes from the analogy to Morse theory. Indeed there is a notion of <fr:link
href="https://en.wikipedia.org/wiki/Discrete_Morse_theory"
type="external">discrete Morse function</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1702</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001O</fr:addr><fr:route>hmlg-001O.xml</fr:route><fr:title>Regular face in an algebraic cellular complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link> and a cell <fr:tex>\sigma</fr:tex>, a <fr:strong>regular face</fr:strong> of <fr:tex>\sigma</fr:tex> is a cell whose coefficient in <fr:tex>d \sigma</fr:tex> is <fr:tex>\pm  1</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1704</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001T</fr:addr><fr:route>algm-001T.xml</fr:route><fr:title>Slice of presheaf category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We have an equivalence of categories
  <fr:tex
display="block">\mathsf { Psh } ( \mathcal { C } )/P  \cong   \mathsf { Psh } \left ( \int _{ \mathcal { C } } P \right ).</fr:tex>
  In the special case that <fr:tex>P =  \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</fr:tex>, we have
  <fr:tex
display="block">\mathsf { Psh } ( \mathcal { C } )/ \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)  \cong   \mathsf { Psh } ( \mathcal { C } /U).</fr:tex></fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1706</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001U</fr:addr><fr:route>algm-001U.xml</fr:route><fr:title>Slice of sheaf category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex> with a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link> <fr:tex>J</fr:tex> and a sheaf <fr:tex>F</fr:tex>, there is a Grothendieck coverage <fr:tex>J'</fr:tex> on <fr:tex>\int _{ \mathcal { C } } F</fr:tex> such that the equivalence in <fr:ref
addr="algm-001T"
href="algm-001T.xml"
taxon="Theorem"></fr:ref> restricts to an equivalence
  <fr:tex
display="block">\mathsf { Sh } ( \mathcal { C } , J)/F  \cong   \mathsf { Sh } \left ( \int _{ \mathcal { C } } F, J' \right ).</fr:tex></fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001U</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose we have a covering sieve <fr:tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</fr:tex> in <fr:tex>\mathcal { C }</fr:tex>, then an element <fr:tex>f  \in   \Gamma (U, F)</fr:tex> uniquely corresponds to a matching family <fr:tex>s  \in   \hom (S, F)</fr:tex>. In the category of elements <fr:tex>\int _{ \mathcal { C } } F</fr:tex>, <fr:tex>s</fr:tex> corresponds to a sieve over <fr:tex>f</fr:tex>. This is the required Grothendieck coverage.
  </fr:p>

  <fr:p>
    Another way to construct this is through the <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>. The subobject classifier of a slice category is simply <fr:tex>\Omega   \times  F  \to  F</fr:tex>. Hence we can let <fr:tex>j</fr:tex> act on the <fr:tex>\Omega</fr:tex> factor. This gives a Lawvere–Tierney operator on the slice category and it coincides with the Grothendieck coverage constructed above.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1708</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title>Dense subobject of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a subobject <fr:tex>F  \hookrightarrow  G</fr:tex> is <fr:tex>j</fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex>G  \to   \Omega   \xrightarrow {j}  \Omega</fr:tex> is the constant true. In terms of the corresponding <fr:tex>J  \hookrightarrow   \Omega</fr:tex>, we need the pullback of it with <fr:tex>G  \to   \Omega</fr:tex> to be <fr:tex>\operatorname {id}  : G  \to  G</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1710</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001O</fr:addr><fr:route>algm-001O.xml</fr:route><fr:title>Exponentials of sheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The exponentials of sheaves coincide with those of presheaves. To see this, we assume <fr:tex>X^Y</fr:tex> is the exponential of sheaves and calculate
  <fr:tex
display="block">\begin {aligned}      \Gamma (U, X^Y)     &amp;=  \hom _{ \mathsf { Psh } }( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X^Y)  \\      &amp;=  \hom _{ \mathsf { Sh } }( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X^Y)  \\      &amp;=  \hom _{ \mathsf { Sh } }(Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Sh } }(Y^{++}  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Sh } }((Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U))^{++}, X)  \\      &amp;=  \hom _{ \mathsf { Psh } }(Y  \times   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X)  \\     \end {aligned}</fr:tex>
  which is evidently <fr:tex>\Gamma (U, X^Y)</fr:tex> but this time the exponential is taken in the category of presheaves. We used the fact that <fr:link
href="todo.xml"
type="local"
addr="todo">the plus construction preserves finite product</fr:link>. However, we still need to prove that this indeed forms a sheaf.
</fr:p><fr:p>
  Expressing the <fr:link
href="algm-001P.xml"
type="local"
addr="algm-001P">sheaf condition using Lawvere–Tierney operators</fr:link>, we only need to show for <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q">dense subobjects</fr:link> <fr:tex>F  \hookrightarrow  G</fr:tex> that <fr:tex>\hom (G, X^Y)  \to   \hom (F, X^Y)</fr:tex> is a bijection. This is equivalent to <fr:tex
display="block">\hom (Y  \times  G, X)  \to   \hom (Y  \times  F, X).</fr:tex> Note that the subobject <fr:tex>Y  \times  F  \hookrightarrow  Y  \times  G</fr:tex> corresponds to the characteristic function <fr:tex>Y  \times  G  \to  G  \to   \Omega</fr:tex>. Hence the denseness of <fr:tex>F  \hookrightarrow  G</fr:tex> implies the denseness of <fr:tex>Y  \times  F  \hookrightarrow  Y  \times  G</fr:tex>. Since <fr:tex>X</fr:tex> is a sheaf, we conclude that <fr:tex>X^Y</fr:tex> is also a sheaf.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1712</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title>Local object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a class of arrows <fr:tex>S</fr:tex>, an <fr:tex>S</fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex>X</fr:tex> such that for every <fr:tex>f : A  \to  B</fr:tex> in <fr:tex>S</fr:tex>, the composition map <fr:tex
display="block">\hom (B, X)  \to   \hom (A, X)</fr:tex> is an isomorphism.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1714</fr:anchor><fr:addr>algm-001P</fr:addr><fr:route>algm-001P.xml</fr:route><fr:title>Sheaf condition using Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Knowing the <fr:link
href="algm-001N.xml"
type="local"
addr="algm-001N">correspondence</fr:link> of Grothendieck coverages on <fr:tex>\mathcal { C }</fr:tex> and Lawvere–Tierney operators on <fr:tex>\mathsf { Psh } ( \mathcal { C } )</fr:tex>, we naturally want to rewrite the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> to use <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operators</fr:link> instead of <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverages</fr:link>.
</fr:p><fr:p>
  Recall that the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> requires for every covering sieve <fr:tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</fr:tex> that the composition <fr:tex>\hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U), X)  \to   \hom (S, X)</fr:tex> is an isomorphism. We can reify this to a definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001R</fr:addr><fr:route>algm-001R.xml</fr:route><fr:title>Local object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a class of arrows <fr:tex>S</fr:tex>, an <fr:tex>S</fr:tex>-<fr:strong>local object</fr:strong> is an object <fr:tex>X</fr:tex> such that for every <fr:tex>f : A  \to  B</fr:tex> in <fr:tex>S</fr:tex>, the composition map <fr:tex
display="block">\hom (B, X)  \to   \hom (A, X)</fr:tex> is an isomorphism.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Now we just need to pick out the class of morphisms <fr:tex>S  \hookrightarrow   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</fr:tex> using the Lawvere–Tierney operator <fr:tex>j</fr:tex>. Note that this operator does not necessarily live in a presheaf topos, so we must find a way to generalize this class of arrows to not necessarily representable presheaves. Since every presheaf is a colimit of representables, we can look at the corresponding colimit of morphisms <fr:tex>\operatorname *{colim}  S_i  \hookrightarrow   \operatorname *{colim}   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i)</fr:tex>. A local object will satisfy
  <fr:tex
display="block">\begin {aligned}      \hom ( \operatorname *{colim} \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i), X)  \cong   \lim \hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U_i), X)  \quad   \\       \xrightarrow { \sim }  \lim \hom (S_i, X)  \cong   \hom ( \operatorname *{colim}  S_i, X).    \end {aligned}</fr:tex>
  Hence we can safely include these arrows into the class and still get the same concept of local objects. Now it's illuminating to look at the characteristic maps. A sieve <fr:tex>S  \to   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U)</fr:tex> corresponds to a characteristic map in <fr:tex>\hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U),  \Omega )  \cong   \Gamma (U,  \Omega )</fr:tex>. Generalizing to an arbitrary presheaf expressed (canonically) as a colimit of representables, we need the image of every section to be a covering sieve.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001Q</fr:addr><fr:route>algm-001Q.xml</fr:route><fr:title>Dense subobject of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a subobject <fr:tex>F  \hookrightarrow  G</fr:tex> is <fr:tex>j</fr:tex>-<fr:strong>dense</fr:strong> if <fr:tex>G  \to   \Omega   \xrightarrow {j}  \Omega</fr:tex> is the constant true. In terms of the corresponding <fr:tex>J  \hookrightarrow   \Omega</fr:tex>, we need the pullback of it with <fr:tex>G  \to   \Omega</fr:tex> to be <fr:tex>\operatorname {id}  : G  \to  G</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  In terms of sieves, for every section <fr:tex>s  \in   \Gamma (U, G)</fr:tex>, the sieve of arrows on <fr:tex>U</fr:tex> along whom the restriction of <fr:tex>s</fr:tex> is in <fr:tex>F</fr:tex> must be a covering sieve. We have arrived at the desired reformulation of the sheaf condition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title>Sheaf of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a <fr:tex>j</fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex>j</fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
href="algm-001R.xml"
type="local"
addr="algm-001R">local object</fr:link> under the <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q"><fr:tex>j</fr:tex>-dense monomorphisms</fr:link>.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1716</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001S</fr:addr><fr:route>algm-001S.xml</fr:route><fr:title>Sheaf of a Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> <fr:tex>j</fr:tex>, a <fr:tex>j</fr:tex>-<fr:strong>sheaf</fr:strong> is defined as a <fr:tex>j</fr:tex>-<fr:strong>local object</fr:strong>, i.e. a <fr:link
href="algm-001R.xml"
type="local"
addr="algm-001R">local object</fr:link> under the <fr:link
href="algm-001Q.xml"
type="local"
addr="algm-001Q"><fr:tex>j</fr:tex>-dense monomorphisms</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1718</fr:anchor><fr:addr>algm-001N</fr:addr><fr:route>algm-001N.xml</fr:route><fr:title>Grothendieck coverages and Lawvere–Tierney operators</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Consider a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> on a presheaf category. Then we may calculate the subobject classifier as in <fr:ref
addr="algm-001M"
href="algm-001M.xml"
taxon="Construction"></fr:ref>.
</fr:p><fr:p>
  By the definition of subobject classifiers, a <fr:link
href="algm-001L.xml"
type="local"
addr="algm-001L">Lawvere–Tierney operator</fr:link> can be equivalently expressed as a subobject <fr:tex>J  \subseteq   \Omega</fr:tex>. Translating the condition of preserving finite intersections, it needs to contain the improper sieve, be upwards closed and closed under finite intersections. And <fr:tex>j  \circ  j = j</fr:tex> implies the following pullback square:
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="41024147dc2e0dacd8110f9ae45f7f85"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} %tex
  J &amp; J \\
  \Omega &amp; \Omega
  \arrow[hook, from=1-2, to=2-2]
  \arrow["j"', from=2-1, to=2-2]
  \arrow[hook, from=1-1, to=2-1]
  \arrow[from=1-1, to=1-2]
  \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2] \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  In other words, a sieve is contained in <fr:tex>J</fr:tex> iff its image under <fr:tex>j</fr:tex> is also contained in <fr:tex>J</fr:tex>. Unfolding this, a sieve <fr:tex>S</fr:tex> is contained in <fr:tex>J</fr:tex> iff the arrows <fr:tex>g</fr:tex> such that <fr:tex>g^* S</fr:tex> is contained in <fr:tex>J</fr:tex> also form a sieve in <fr:tex>J</fr:tex>. Looking at the definition of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, we see that they are equivalent, if we regard <fr:tex>J</fr:tex> as picking out the covering sieves.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1720</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001L</fr:addr><fr:route>algm-001L.xml</fr:route><fr:title>Lawvere–Tierney operator</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, a <fr:strong>Lawvere–Tierney operator</fr:strong> is a morphism <fr:tex>j :  \Omega   \to   \Omega</fr:tex> where <fr:tex>\Omega</fr:tex> is the subobject classifier, such that <fr:tex>j</fr:tex> preserves finite intersections, and <fr:tex>j  \circ  j = j</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1722</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001M</fr:addr><fr:route>algm-001M.xml</fr:route><fr:title>Subobject classifier of presheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The subobject classifier <fr:tex>\Omega</fr:tex> of presheaves can be given by a quick calculation.
  <fr:tex
display="block">\Gamma (U,  \Omega )    \cong   \hom ( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U),  \Omega )    \cong   \operatorname {Sub}( \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (U))</fr:tex>
  By definition, this is the set of <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieves</fr:link> on <fr:tex>U</fr:tex>, and the functorial action is the <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link>. For a monomorphism <fr:tex>F  \hookrightarrow  G</fr:tex>, an element <fr:tex>s  \in   \Gamma (U, G)</fr:tex> is sent to the sieve consisting of arrows <fr:tex>f : V  \to  U</fr:tex> such that the restriction along <fr:tex>f</fr:tex> is included in <fr:tex>F</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1724</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>algm-001K</fr:addr><fr:route>algm-001K.xml</fr:route><fr:title>Separation of presheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, the inclusion of <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated presheaves</fr:link> to presheaves has a left adjoint <fr:tex>(-)^ { \operatorname {sep}}</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001K</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We define <fr:tex>\Gamma (U, P^ { \operatorname {sep}} )</fr:tex> to be a quotient of <fr:tex>\Gamma (U, P)</fr:tex>. Two sections are considered the same if they are equal on a covering sieve. It is obvious that this is separated, and in a morphism <fr:tex>P  \to  Q</fr:tex> to a separated presheaf, if two sections of <fr:tex>P</fr:tex> are equal on a covering sieve, then their image will also be, and by separatedness they must be actually equal in <fr:tex>Q</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1726</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001I</fr:addr><fr:route>algm-001I.xml</fr:route><fr:title>Sheaf condition in terms of plus construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a presheaf <fr:tex>P</fr:tex>, the morphism <fr:tex>P  \to  P^+</fr:tex> to its <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link> is a monomorphism iff <fr:tex>P</fr:tex> is <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated</fr:link>, and it is an isomorphism iff <fr:tex>P</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001J</fr:addr><fr:route>algm-001J.xml</fr:route><fr:title>Sheafification</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Sheafification</fr:strong> is defined as the left adjoint of the inclusion from <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaves</fr:link> to the category of presheaves. Hence it freely constructs a sheaf from a presheaf.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>531</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We construct sheafification as <fr:link
href="algm-001G.xml"
type="local"
addr="algm-001G">an iterated plus construction</fr:link>. This produces a functor. By <fr:ref
addr="algm-001H"
href="algm-001H.xml"
taxon="Theorem"></fr:ref> we have a natural bijection
    <fr:tex
display="block">\hom (P^{++}, F)  \cong   \hom (P^+, F)  \cong   \hom (P, F).</fr:tex>
    Hence it is indeed the left adjoint. Since the bijections are given by composition with <fr:tex>P  \to  P^+</fr:tex> and <fr:tex>P^+  \to  P^{++}</fr:tex>, we see that the unit of the adjunction is given by the composition <fr:tex>P  \to  P^{++}</fr:tex>.
  </fr:p>

  <fr:p>
    Alternatively, using <fr:ref
addr="algm-001K"
href="algm-001K.xml"
taxon="Construction"></fr:ref>, we may compose two adjunctions to first <fr:link
href="algm-001K.xml"
type="local"
addr="algm-001K">separate</fr:link> the presheaf, and then perform the plus construction. By uniqueness of adjunction these two constructions are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001H</fr:addr><fr:route>algm-001H.xml</fr:route><fr:title>Universal property of <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any presheaf <fr:tex>P</fr:tex> and sheaf <fr:tex>F</fr:tex>, there is a natural bijection <fr:tex
display="block">\hom (P, F)  \cong   \hom (P^+, F)</fr:tex> given by composition with <fr:tex>\eta _P : P  \to  P^+</fr:tex>.
</fr:p><fr:p>
  As a corollary of this and <fr:ref
addr="algm-001G"
href="algm-001G.xml"
taxon="Theorem"></fr:ref>, when restricted to separated presheaves, it is left adjoint to the forgetful functor from sheaves to separated presheaves.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>551</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For every morphism <fr:tex>P  \to  F</fr:tex>, there is a unique way to extend the map to <fr:tex>P^+</fr:tex> using the <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf condition</fr:link> of <fr:tex>F</fr:tex>. A section of <fr:tex>P^+</fr:tex> consists of a matching family <fr:tex>s_f</fr:tex>, and it is also the gluing of <fr:tex>\eta _P(s_f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1732</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001A</fr:addr><fr:route>algm-001A.xml</fr:route><fr:title>Grothendieck coverage</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, a <fr:strong>Grothendieck coverage</fr:strong> declares some <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieves</fr:link> to be coverings, such that
  <fr:ul><fr:li>The maximal sieve <fr:tex>\mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)  \subseteq   \mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)</fr:tex> is always a covering.</fr:li>
    <fr:li>Covering sieves are upwards closed, i.e. if <fr:tex>S  \subseteq  S'</fr:tex> and <fr:tex>S</fr:tex> is a covering sieve, then so is <fr:tex>S'</fr:tex>.</fr:li>
    <fr:li>If <fr:tex>S</fr:tex> is a covering sieve of <fr:tex>A</fr:tex>, and <fr:tex>g : B  \to  A</fr:tex> is a morphism, then the <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link> <fr:tex>g^* S</fr:tex> is also a covering.</fr:li>
    <fr:li>Suppose <fr:tex>S</fr:tex> is a sieve, then the collection of arrows <fr:tex>g</fr:tex> such that <fr:tex>g^* S</fr:tex> is a covering is a sieve itself. If this sieve is a covering, then <fr:tex>S</fr:tex> is also a covering.</fr:li></fr:ul>
  A Grothendieck coverage can be viewed as a <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">coverage</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1734</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0019</fr:addr><fr:route>algm-0019.xml</fr:route><fr:title>Coverage</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>coverage</fr:strong> on an arbitrary category <fr:tex>\mathcal { C }</fr:tex> is given by a family of covers. A <fr:strong>cover</fr:strong> of some object <fr:tex>A</fr:tex> in <fr:tex>\mathcal { C }</fr:tex> is a family of maps with codomain <fr:tex>A</fr:tex>. Given a cover <fr:tex>f_i : U_i  \to  A</fr:tex> and a map <fr:tex>g : B  \to  A</fr:tex>, there is a cover of <fr:tex>B</fr:tex> such that its composition with <fr:tex>g</fr:tex> is a <fr:strong>refinement</fr:strong> of <fr:tex>f_i</fr:tex>, in the sense that every map in the cover factors through one of <fr:tex>f_i</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001D</fr:addr><fr:route>algm-001D.xml</fr:route><fr:title>Descent data of presheaves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, a <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieve</fr:link> <fr:tex>S</fr:tex> and a presheaf <fr:tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</fr:tex>, a set of <fr:strong>descent data</fr:strong> or a <fr:strong>compatible family</fr:strong> is a morphism <fr:tex>S  \to  P</fr:tex>. Expanding this, it is a family of <fr:em>local sections</fr:em> <fr:tex>s  \in   \Gamma (U, P)</fr:tex> assigned for each morphism <fr:tex>U  \to  A</fr:tex> in the sieve <fr:tex>S</fr:tex>, such that the local sections are compatible on restriction. There is an obvious map from the sections <fr:tex>\Gamma (A, P)</fr:tex> to the descent data given by restriction.
</fr:p><fr:p>
  More generally, given a general <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">cover</fr:link>, a set of descent data is a family of sections <fr:tex>s_i  \in   \Gamma (U_i, P)</fr:tex> for each morphism <fr:tex>f_i : U_i  \to  A</fr:tex> in the cover, such that in any common restriction of <fr:tex>U_i</fr:tex> and <fr:tex>U_j</fr:tex>, the sections agree. This can be equivalently expressed as the descent data of the sieve generated by the cover.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1738</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-001G</fr:addr><fr:route>algm-001G.xml</fr:route><fr:title>Iterated <fr:link
href="algm-001E.xml"
type="local"
addr="algm-001E">plus construction</fr:link> produces a sheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given any presheaf <fr:tex>P</fr:tex>, <fr:tex>P^+</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">separated presheaf</fr:link>, and if <fr:tex>P</fr:tex> is already separated, <fr:tex>P^+</fr:tex> is a <fr:link
href="algm-001F.xml"
type="local"
addr="algm-001F">sheaf</fr:link>. Therefore <fr:tex>P^{++}</fr:tex> is always a sheaf.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>555</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first prove that <fr:tex>P^+</fr:tex> is separated. Suppose there are two gluings of a set of descent data on a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">covering sieve</fr:link> <fr:tex>S</fr:tex> over <fr:tex>A</fr:tex>, then we have two sieves <fr:tex>S_1, S_2</fr:tex> over <fr:tex>A</fr:tex> with compatible families <fr:tex>s_{1, f}, s_{2, f}</fr:tex>. Since they are gluings of the same descent data, the restriction along any morphism <fr:tex>g : U  \to  A</fr:tex> in <fr:tex>S</fr:tex> would be equal. Hence there is a common refinement of <fr:tex>g^* S_1</fr:tex> and <fr:tex>g^* S_2</fr:tex> where the two families become equal. Expanding this, there is a covering sieve on <fr:tex>U</fr:tex> such that <fr:tex>g  \circ  h  \in  S_1  \cap  S_2</fr:tex> for every <fr:tex>h</fr:tex> in the sieve, and <fr:tex>s_{1, g  \circ  h} = s_{2, g  \circ  h}</fr:tex>. But then by the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, <fr:tex>g  \circ  h</fr:tex> for all <fr:tex>h</fr:tex> in the said sieve and <fr:tex>g  \in  S</fr:tex> also generates a covering sieve. Hence <fr:tex>s_1</fr:tex> and <fr:tex>s_2</fr:tex> are already equal on a covering subsieve, and so they are equal in <fr:tex>\Gamma (A, P^+)</fr:tex>.
  </fr:p>

  <fr:p>
    Let’s see why <fr:tex>P^+</fr:tex> is not necessarily a sheaf. To be a sheaf, we need to find a gluing for each compatible family. A <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">compatible family</fr:link> of local sections of <fr:tex>P^+</fr:tex> is a family of covering sieves <fr:tex>S_f</fr:tex> over <fr:tex>U</fr:tex> for each morphism <fr:tex>f : U  \to  A</fr:tex> in <fr:tex>S</fr:tex>, and for each <fr:tex>S_f</fr:tex> a family of sections <fr:tex>s_{f, g}  \in   \Gamma (V, P)</fr:tex> where <fr:tex>g : V  \to  U</fr:tex> lies in <fr:tex>S_f</fr:tex>. By the axioms of a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link>, the union <fr:tex>\bigcup _{f  \in  S} f  \circ  S_f</fr:tex> is a sieve, since <fr:tex>S_f  \subseteq  f^* (f  \circ  S_f)</fr:tex>. (Warning: <fr:tex>f  \circ  S_f</fr:tex> is not a covering sieve itself.) So we are tempted to simply construct a glued section <fr:tex>s'</fr:tex> by <fr:tex>s'_{f  \circ  g} = s_{f, g}</fr:tex>. Hence we need to prove <fr:tex>s_{f, g} = s_{f', g'}</fr:tex> if <fr:tex>f  \circ  g = f'  \circ  g'</fr:tex>.
  </fr:p>

  <fr:p>
    Since the families <fr:tex>s_{f}</fr:tex> are compatible, given any <fr:tex>g : V  \to  U</fr:tex> we have <fr:tex>s_{f, g  \circ  r} = s_{f  \circ  g, r}</fr:tex> for a family of arrows <fr:tex>r</fr:tex> that generates a covering sieve on <fr:tex>V</fr:tex>. However we cannot necessarily take <fr:tex>r =  \operatorname {id}</fr:tex>, so this is not necessarily well-defined. Here is where the separatedness comes in. Notice that <fr:tex>s_{f, g  \circ  r} = s_{f  \circ  g, r}</fr:tex> forms a compatible family over <fr:tex>V</fr:tex> as <fr:tex>r</fr:tex> ranges over the covering sieve. And therefore <fr:tex>s_{f, g}</fr:tex> and <fr:tex>s_{f  \circ  g,  \operatorname {id} }</fr:tex> are both a gluing of the family. By separatedness, they must be equal. Hence our problem is solved.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1740</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001E</fr:addr><fr:route>algm-001E.xml</fr:route><fr:title>Plus construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001A.xml"
type="local"
addr="algm-001A">Grothendieck coverage</fr:link> on <fr:tex>\mathcal { C }</fr:tex> and a presheaf <fr:tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</fr:tex>, the <fr:strong>plus construction</fr:strong> produces a new presheaf <fr:tex>P^+</fr:tex> by taking a directed limit over all the <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">descent data</fr:link>. More precisely, we assign <fr:tex
display="block">\Gamma (A, P^+) =  \operatorname *{colim} _{S  \text { covers } A}  \hom (S, P).</fr:tex> This means the sections of <fr:tex>P^+</fr:tex> are compatible families of sections of <fr:tex>P</fr:tex>, and two families are considered equal if they are equal on a common covering subsieve.
</fr:p><fr:p>
  Given a map <fr:tex>g : B  \to  A</fr:tex>, we have a <fr:link
href="algm-001C.xml"
type="local"
addr="algm-001C">pullback</fr:link> <fr:tex>\hom (S, P)  \to   \hom (g^*S, P)</fr:tex>. This induces the functorial action of <fr:tex>P^+</fr:tex>. There is an obvious natural transformation <fr:tex>P  \to  P^+</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1742</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001C</fr:addr><fr:route>algm-001C.xml</fr:route><fr:title>Pullback of sieves</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-001B.xml"
type="local"
addr="algm-001B">sieve</fr:link> <fr:tex>S</fr:tex> over <fr:tex>A</fr:tex> and a morphism <fr:tex>g : B  \to  A</fr:tex>, the <fr:strong>pullback</fr:strong> <fr:tex>g^* S</fr:tex> is a sieve over <fr:tex>B</fr:tex>. <fr:tex>h : C  \to  B</fr:tex> is in this sieve iff <fr:tex>g  \circ  h</fr:tex> is in <fr:tex>S</fr:tex>. There is a natural map <fr:tex>g^* S  \to  S</fr:tex> given by <fr:tex>g  \circ  -</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1744</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001F</fr:addr><fr:route>algm-001F.xml</fr:route><fr:title>Sheaf</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex> equipped with a <fr:link
href="algm-0019.xml"
type="local"
addr="algm-0019">coverage</fr:link>, we define a presheaf <fr:tex>P :  \mathcal { C } ^ \textrm {op}   \to   \mathsf { Set }</fr:tex> to be a <fr:strong>sheaf</fr:strong> if it satisfies the <fr:strong>sheaf condition</fr:strong>: for every cover of <fr:tex>A</fr:tex>, the map from sections of <fr:tex>A</fr:tex> to <fr:link
href="algm-001D.xml"
type="local"
addr="algm-001D">descent data</fr:link> of the cover is a bijection. It is a <fr:strong>separated presheaf</fr:strong> if the map is an injection.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1746</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-001B</fr:addr><fr:route>algm-001B.xml</fr:route><fr:title>Sieve</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>sieve</fr:strong> over an object <fr:tex>A</fr:tex> of an arbitrary category <fr:tex>\mathcal { C }</fr:tex> is a subfunctor of <fr:tex>\mathop { \mkern {-2mu} \text {よ} \mkern {-2mu}} (A)</fr:tex>. More explicitly, it selects some arrows with codomain <fr:tex>A</fr:tex>, such that the selected arrows absorbs composition (i.e. if <fr:tex>f : B  \to  A</fr:tex> is selected and <fr:tex>g : C  \to  B</fr:tex>, then <fr:tex>g  \circ  f</fr:tex> is also selected).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1748</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>nsan-0003</fr:addr><fr:route>nsan-0003.xml</fr:route><fr:title><fr:tex>\mathsf { Germ }</fr:tex> is <fr:tex>\mathsf { Filt }</fr:tex> localized at inclusion maps of large subsets</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="nsan-0002.xml"
type="local"
addr="nsan-0002">category of germs</fr:link> is equivalent to the category of <fr:link
href="nsan-0001.xml"
type="local"
addr="nsan-0001">filter spaces</fr:link> localized at maps of the form <fr:tex>X  \hookrightarrow  Y</fr:tex>, where <fr:tex>X</fr:tex> is a large subset of <fr:tex>Y</fr:tex>, whose filter is induced by restriction from <fr:tex>Y</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1750</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>nsan-0002</fr:addr><fr:route>nsan-0002.xml</fr:route><fr:title>Category of germs</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="nsan-0001.xml"
type="local"
addr="nsan-0001">filter spaces</fr:link> form another category, whose morphisms are <fr:strong>germs</fr:strong>, i.e. partial continuous functions defined on a large set, with equality considered up to some difference on a small set. This category is written <fr:tex>\mathsf { Germ }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1752</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>nsan-0001</fr:addr><fr:route>nsan-0001.xml</fr:route><fr:title>Filter space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>filter space</fr:strong> is a set equipped with a filter. A morphism between germ spaces is a function such that the preimage of a large set is still large, which is often referred to as <fr:strong>continuous</fr:strong>. This creates a category <fr:tex>\mathsf { Filt }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1754</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001M</fr:addr><fr:route>hmlg-001M.xml</fr:route><fr:title>Chain reduction of mapping cones</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a pair of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reductions</fr:link> <fr:tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex> and <fr:tex>\rho ' : C'  \Rightarrow \mkern {-14mu} \Rightarrow  D'</fr:tex>, we can construct a reduction from the mapping cone <fr:tex>\operatorname {Cone} (f)</fr:tex> of a chain map <fr:tex>f : C  \to  C'</fr:tex> to (the action of <fr:tex>\rho</fr:tex> on <fr:tex>f</fr:tex>).
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1756</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0018</fr:addr><fr:route>algm-0018.xml</fr:route><fr:title>A space is noetherian iff hereditarily quasi-compact</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian</fr:link> iff it is <fr:em>hereditarily</fr:em> <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>, that is, if all its opens are quasi-compact.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>705</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first show the forward direction. By the definition of being noetherian, all its opens are automatically noetherian. So we just need to prove that noetherian spaces are quasi-compact. This is obvious, since taking unions of the open covers we have an ascending chain of opens, which must terminate.
  </fr:p>

  <fr:p>
    For the other direction, given an ascending chain of opens, they form a cover of their union. Since the union is an open, it is quasi-compact by hypothesis, and therefore the cover has a finite subcover, proving that the chain stabilizes after finitely many terms.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1758</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0016</fr:addr><fr:route>algm-0016.xml</fr:route><fr:title>Nike’s trick</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The intersections of two <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine</fr:link> subschemes <fr:tex>\operatorname {Spec} (R_1),  \operatorname {Spec} (R_2)  \hookrightarrow  X</fr:tex> can be covered by affine schemes distinguished in both of them.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>720</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0016</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex>\mathfrak { p }</fr:tex> of <fr:tex>R_1</fr:tex>. We can pick a distinguished open <fr:tex>D(f)</fr:tex> of <fr:tex>\operatorname {Spec} (R_2)</fr:tex> contained in the intersection and containing <fr:tex>\mathfrak { p }</fr:tex>, and a distinguished open <fr:tex>D(g)</fr:tex> of <fr:tex>\operatorname {Spec} (R_1)</fr:tex> contained in <fr:tex>D(f)</fr:tex> and containing <fr:tex>\mathfrak { p }</fr:tex>. Now we prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname {Spec} (R_2)</fr:tex>.
  </fr:p>

  <fr:p>
    It suffices to prove that <fr:tex>D(g)</fr:tex> is a distinguished open in <fr:tex>\operatorname {Spec} (R_2 [f^{-1}])</fr:tex>, since this would imply the existence of an element <fr:tex>g'/f^{n}  \in  R_2[f^{-1}]</fr:tex>, and we can take <fr:tex>D(g')  \cap  D(f) = D(g' f)</fr:tex> in <fr:tex>\operatorname {Spec} (R_2)</fr:tex>. Now there is an inclusion map <fr:tex>\operatorname {Spec} (R_2[f^{-1}])  \to   \operatorname {Spec} (R_1)</fr:tex>, which amounts to a ring homomorphism <fr:tex>\varphi</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. In this case, <fr:tex>D( \varphi (g))</fr:tex> is the required distinguished open, since <fr:tex>\varphi ^{-1}D(u)</fr:tex> is equal to <fr:tex>D( \varphi (u))</fr:tex> in <fr:tex>\operatorname {Spec} (R_2 [f^{-1}])</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1760</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0017</fr:addr><fr:route>algm-0017.xml</fr:route><fr:title>Affine local properties</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Suppose a property on affine subschemes <fr:tex>\operatorname {Spec} (R)  \hookrightarrow  X</fr:tex> is closed under taking distinguished subsets <fr:tex>\operatorname {Spec} (R_f)  \hookrightarrow  X</fr:tex>, and for <fr:tex>\gcd \{ f_i \}  = 1</fr:tex>, the property being true on <fr:tex>\operatorname {Spec} (R_{f_i})  \hookrightarrow  X</fr:tex> implies it being true on <fr:tex>\operatorname {Spec} (R)  \hookrightarrow  X</fr:tex>. Then such a property is called <fr:strong>affine local</fr:strong>. We then say that <fr:tex>X</fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.
</fr:p><fr:p>
  If the property <fr:tex>P</fr:tex> only depends on <fr:tex>\operatorname {Spec} (R)</fr:tex> and not <fr:tex>X</fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex>P'</fr:tex> on schemes, which we will usually refer to as <fr:strong>locally</fr:strong> <fr:tex>P</fr:tex>. Suppose the scheme is furthermore <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex>P</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>709</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0017</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We prove that if some affine cover <fr:tex>\{ \operatorname {Spec} (R_i)  \hookrightarrow  X \}</fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex>\operatorname {Spec} (S)  \hookrightarrow  X</fr:tex>, using <fr:link
href="algm-0016.xml"
type="local"
addr="algm-0016">Nike’s trick</fr:link>, we see that the intersection with <fr:tex>\operatorname {Spec} (R_i)</fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex>\operatorname {Spec} (S)  \hookrightarrow  X</fr:tex> with the said property, and therefore itself also.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1762</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0015</fr:addr><fr:route>algm-0015.xml</fr:route><fr:title>Irreducible space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:strong>irreducible</fr:strong> iff finitely many non-empty opens always has non-empty intersection. In other words, iff it is non-empty and cannot be written as a union of two closed sets.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1764</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0014</fr:addr><fr:route>algm-0014.xml</fr:route><fr:title>Adjunction of global section and <fr:tex>\operatorname {Spec}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We have an adjunction of functors <fr:tex
display="block">\mathsf { CRing } ^ \textrm {op}   \xtofrom [ \Gamma ( \top ,  \mathscr { O } _{(-)})]{ \operatorname {Spec} }  \mathsf { Sch } ,</fr:tex> with <fr:tex>\operatorname {Spec}</fr:tex> being the right adjoint (or <fr:tex>\operatorname {Spec}  :  \mathsf { CRing }   \to   \mathsf { Sch } ^ \textrm {op}</fr:tex> being the left adjoint). In fact, we can replace <fr:tex>\mathsf { Sch }</fr:tex> with the category of <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed spaces</fr:link> <fr:tex>\mathsf { LRS }</fr:tex>, of whom <fr:tex>\mathsf { Sch }</fr:tex> is a full subcategory.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>736</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0014</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We need to give a natural bijection
    <fr:tex
display="block">\hom (X,  \operatorname {Spec} (R))  \cong   \hom (R,  \Gamma ( \top ,  \mathscr { O } _X)).</fr:tex>
    In other words, maps <fr:tex>X  \to   \operatorname {Spec} (R)</fr:tex> between locally ringed spaces are uniquely specified by the action of global sections.
  </fr:p>

  <fr:p>
    Since <fr:tex>X</fr:tex> is glued from affine open subschemes, a map from <fr:tex>X</fr:tex> is equivalent to a map from each open subscheme <fr:tex>\operatorname {Spec} (S_i)</fr:tex> that agree on common restrictions (which again can be checked on an affine covering). Since the codomain is affine, these maps are equivalently ring homomorphisms <fr:tex>R  \to  S_i</fr:tex> by <fr:ref
addr="algm-000X"
href="algm-000X.xml"
taxon="Theorem"></fr:ref>. The elements of <fr:tex>\Gamma ( \top ,  \mathscr { O } _X)</fr:tex> are also given by a set of compatible elements from <fr:tex>S_i</fr:tex>. Hence these two sets are naturally bijective.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1766</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0011</fr:addr><fr:route>algm-0011.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname {Proj} (S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens of the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link> <fr:tex>\operatorname {Proj} (S)</fr:tex> are in bijection with graded radical ideals with <fr:tex>\mathfrak { r } _0 = 0</fr:tex>. Hence we write <fr:tex>D_+ ( \mathfrak { r } )</fr:tex> for this open. The proof is exactly the same as <fr:ref
addr="algm-0008"
href="algm-0008.xml"
taxon="Theorem"></fr:ref>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1768</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>algm-000Z</fr:addr><fr:route>algm-000Z.xml</fr:route><fr:title>Geometry of graded rings</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  To define projective spaces, we start with an affine space, and restricts ourselves to regions invariant under dilation — or using the language of points, we consider lines through the origin as points. Hence we need to define how an element of a ring (which is geometrically a function on the affine space) behaves under dilation.
</fr:p><fr:p>
  In polynomial rings, for example, the polynomial <fr:tex>x^2 + 2y + 7</fr:tex> becomes <fr:tex>\lambda ^2 x^2 + 2  \lambda  y + 7</fr:tex> under a dilation by <fr:tex>\lambda</fr:tex>. Note how each term can be classified by the power of <fr:tex>\lambda</fr:tex> it obtains. Hence, what we need is a <fr:strong>grading</fr:strong> on the ring, which partitions <fr:tex>R =  \bigoplus _d R_d</fr:tex> (as abelian groups). <fr:tex>R_d</fr:tex> is intuitively the elements that get the factor <fr:tex>\lambda ^d</fr:tex> upon dilation. The multiplication of a degree <fr:tex>p</fr:tex> element with a degree <fr:tex>q</fr:tex> element should produce a degree <fr:tex>(p+q)</fr:tex> element, since <fr:tex>\lambda ^p  \lambda ^q =  \lambda ^{p+q}</fr:tex>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>758</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title>Graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex>R_d</fr:tex>, where <fr:tex>d  \in  D</fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block">R_p  \otimes  R_q  \to  R_{p+q}</fr:tex> and a identity element <fr:tex>1  \in  R_0</fr:tex> satisfying the associativity and identity laws.
</fr:p><fr:p>
  Usually, the grading is one of <fr:tex>\mathbb  Z</fr:tex> or <fr:tex>\mathbb  N</fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex>D^2</fr:tex> instead of <fr:tex>D</fr:tex>, whatever the context implies the grading is.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  The opens of a projective space should come from the non-vanishing region of a homogeneous function, i.e. elements with a single degree. This ensures that dilation doesn’t change the opens. However, we would have multiple ways to represent the entire space: in a two-dimensional affine space, <fr:tex>D(x)  \cup  D(y)</fr:tex> and <fr:tex>D(1)</fr:tex> are both invariant under dilation, but the former excludes the origin, while the latter does not. In a projective setting, we don’t care about the origin at all, and considering that all homogeneous polynomials of positive degree vanish at the origin, we should make that mandatory. Hence, we only consider the opens corresponding to positively graded elements, which we write as <fr:tex>D_+ (f)</fr:tex>. We can construct a space similar to the <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">localic spectrum of a commutative ring</fr:link>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>760</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title>Projective spectrum of a graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb  N</fr:tex>-graded ring <fr:tex>S_ \bullet</fr:tex>, we construct a locale analogous to <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the <fr:tex>\operatorname {Spec}</fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex>D_+ (f)</fr:tex> for each positively graded element <fr:tex>f</fr:tex>, and impose the same relations: <fr:tex>D_+</fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex>D_+ ( \sum _i f_i)  \subseteq   \bigcup _i D_+(f_i)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As for the structure sheaf, we need to decide what the sections over <fr:tex>D_+ (f)</fr:tex> are. They should be functions defined on the affine space <fr:tex>D(f)  \subseteq   \operatorname {Spec} (S)</fr:tex>, but invariant under dilation. Note that it is stronger than requiring vanishing region be invariant. We actually need the grade <fr:tex>0</fr:tex> elements here. Recalling from <fr:link
href="algm-000I.xml"
type="local"
addr="algm-000I">structure sheaf of a ring spectrum</fr:link> that <fr:tex>\Gamma (D(f),  \mathscr { O } _{ \operatorname {Spec} (S)}) = S[f^{-1}]</fr:tex> (which can be given a canonical grading since <fr:tex>f</fr:tex> is a graded element), we can make the following definition.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>764</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title>Structure sheaf of <fr:tex>\operatorname {Proj} (S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Fix a <fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>. For a positively graded element <fr:tex>f</fr:tex>, we have a graded ring localization <fr:tex>S[f^{-1}]_ \bullet</fr:tex>. Let <fr:tex>\Gamma (D_+(f),  \mathscr { O } )</fr:tex> be the zeroth degree component <fr:tex>S[f^{-1}]_0</fr:tex>. This defines a sheaf over the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link>, and moreover gives a <fr:link
href="algm-000R.xml"
type="local"
addr="algm-000R">scheme</fr:link> <fr:tex>\operatorname {Proj} (S)</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>762</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>\operatorname {Proj} (S)</fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex>D_+ (f)</fr:tex> the affine scheme <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> (which is possible because the open subspace <fr:tex>D_+ (f)</fr:tex> is homeomorphic to <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> as a space). Given two positively graded elements <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, we have an isomorphism between <fr:tex>\operatorname {Proj} (S)</fr:tex> restricted to <fr:tex>D_+ (f g)</fr:tex> and <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> restricted to <fr:tex>D(g^{ \deg  f}/f^{ \deg  g})</fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1770</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001L</fr:addr><fr:route>hmlg-001L.xml</fr:route><fr:title>Graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A D-<fr:strong>graded ring</fr:strong> is a sequence of abelian groups <fr:tex>R_d</fr:tex>, where <fr:tex>d  \in  D</fr:tex> are elements of a commutative monoid called the <fr:strong>grading</fr:strong>. We have a bilinear multiplication map <fr:tex
display="block">R_p  \otimes  R_q  \to  R_{p+q}</fr:tex> and a identity element <fr:tex>1  \in  R_0</fr:tex> satisfying the associativity and identity laws.
</fr:p><fr:p>
  Usually, the grading is one of <fr:tex>\mathbb  Z</fr:tex> or <fr:tex>\mathbb  N</fr:tex>. A <fr:strong>bigraded ring</fr:strong> is graded over <fr:tex>D^2</fr:tex> instead of <fr:tex>D</fr:tex>, whatever the context implies the grading is.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1772</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0013</fr:addr><fr:route>algm-0013.xml</fr:route><fr:title>Irrelevant ideal</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb  N</fr:tex>-<fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>, its <fr:strong>irrelevant ideal</fr:strong> <fr:tex>\mathord { \odot }</fr:tex> is defined by the subset <fr:tex>S_+</fr:tex> of all positively graded elements.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1774</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0012</fr:addr><fr:route>algm-0012.xml</fr:route><fr:title>Points of the projective spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The points of the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective scheme</fr:link> <fr:tex>\operatorname {Proj} (S)</fr:tex> are given by prime ideals not dividing the <fr:link
href="algm-0013.xml"
type="local"
addr="algm-0013">irrelevant ideal</fr:link> <fr:tex>\mathord { \odot }</fr:tex>. This is in bijection with ideals with <fr:tex>\mathfrak { p } _0 = 0</fr:tex> (equivalently <fr:tex>\mathord { \odot }   \nmid   \mathfrak { p }</fr:tex>), and the condition for prime ideals holds for positively graded elements, i.e. <fr:tex
display="block">\mathfrak { p }   \mid  x y  \iff  ( \mathfrak { p }   \mid  x  \lor   \mathfrak { p }   \mid  y)</fr:tex> for positively graded <fr:tex>x</fr:tex> and <fr:tex>y</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>740</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    To specify a point <fr:tex>P</fr:tex>, we need to specify which opens <fr:tex>D_+(f)</fr:tex> it belongs to, where <fr:tex>f</fr:tex> ranges over positively graded elements. Equivalently, we specify the closeds <fr:tex>V_+(f)</fr:tex>. Since <fr:tex>V_+(f)  \cap  V_+(g)  \subseteq  V_+(f + g)</fr:tex>, if <fr:tex>P  \in  V_+(f)</fr:tex> and <fr:tex>P  \in  V_+(g)</fr:tex> then <fr:tex>P  \in  V_+(f + g)</fr:tex>. Similarly since <fr:tex>V_+(f)  \subseteq  V_+(f g)</fr:tex>, <fr:tex>P  \in  V_+(f)</fr:tex> implies <fr:tex>P  \in  V_+(f g)</fr:tex>. Collecting all the elements whose distinguished closed contains <fr:tex>P</fr:tex>, we get an ideal <fr:tex>\mathfrak { a }</fr:tex> whose zeroth degree vanishes.
  </fr:p>

  <fr:p>
    We have <fr:tex>V_+(f g) = V_+(f)  \cup  V_+(g)</fr:tex>, so if <fr:tex>\mathfrak { a }   \mid  f g</fr:tex>, then either <fr:tex>\mathfrak { a }   \mid  f</fr:tex> or <fr:tex>\mathfrak { a }   \mid  g</fr:tex>. This is almost the condition for prime ideals, but recall that <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> must have positive grading, so we actually get the ideals in the theorem statement. Conversely, being such an ideal is sufficient condition for the specification of the point to be valid, by calculation with <fr:ref
addr="algm-0011"
href="algm-0011.xml"
taxon="Theorem"></fr:ref>.
  </fr:p>

  <fr:p>
    Next, we prove these ideals are in bijection with prime ideals not dividing <fr:tex>\mathord { \odot }</fr:tex>. One direction of the correspondence is obvious: we take a prime ideal <fr:tex>\mathfrak { p }</fr:tex> and remove the zeroth degree, which amounts to taking <fr:tex>\operatorname {lcm} ( \mathfrak { p } ,  \mathord { \odot } )</fr:tex>.
  </fr:p>

  <fr:p>
    We prove injectivity. Suppose primes <fr:tex>\mathfrak { p }</fr:tex> and <fr:tex>\mathfrak { q }</fr:tex> satisfy <fr:tex>\operatorname {lcm} ( \mathfrak { p } ,  \mathord { \odot } ) =  \operatorname {lcm} ( \mathfrak { q } ,  \mathord { \odot } )</fr:tex>, then <fr:tex>\mathfrak { p }   \mid   \operatorname {lcm} ( \mathfrak { q } ,  \mathord { \odot } )  \mid   \mathfrak { q }   \cdot   \mathord { \odot }</fr:tex>, so either <fr:tex>\mathfrak { p }   \mid   \mathord { \odot }</fr:tex> which is forbidden, or <fr:tex>\mathfrak { p }   \mid   \mathfrak { q }</fr:tex>. Conversely we must have <fr:tex>\mathfrak { q }   \mid   \mathfrak { p }</fr:tex>, hence <fr:tex>\mathfrak { p }  =  \mathfrak { q }</fr:tex>.
  </fr:p>

  <fr:p>
    We prove surjectivity. Given an ideal <fr:tex>\mathfrak { a }</fr:tex>, we need to supplement it with a zeroth degree component <fr:tex>\mathfrak { a } _0</fr:tex> so that together they make a prime ideal not divided by <fr:tex>\mathord { \odot }</fr:tex>. We define <fr:tex>\mathfrak { a } _0  \mid  c</fr:tex> iff there exists some positively graded <fr:tex>\mathfrak { a }   \nmid  f</fr:tex> such that <fr:tex>\mathfrak { a }   \mid  cf</fr:tex>. The verification is routine element chasing.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1776</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Y</fr:addr><fr:route>algm-000Y.xml</fr:route><fr:title>Projective spectrum of a graded ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:tex>\mathbb  N</fr:tex>-graded ring <fr:tex>S_ \bullet</fr:tex>, we construct a locale analogous to <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the <fr:tex>\operatorname {Spec}</fr:tex> construction</fr:link> for affine schemes. We start with symbols of <fr:strong>distinguished opens</fr:strong> <fr:tex>D_+ (f)</fr:tex> for each positively graded element <fr:tex>f</fr:tex>, and impose the same relations: <fr:tex>D_+</fr:tex> sends finite products to finite intersections, and for elements of the same grade, <fr:tex>D_+ ( \sum _i f_i)  \subseteq   \bigcup _i D_+(f_i)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1778</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0010</fr:addr><fr:route>algm-0010.xml</fr:route><fr:title>Structure sheaf of <fr:tex>\operatorname {Proj} (S)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Fix a <fr:link
href="hmlg-001L.xml"
type="local"
addr="hmlg-001L">graded ring</fr:link> <fr:tex>S</fr:tex>. For a positively graded element <fr:tex>f</fr:tex>, we have a graded ring localization <fr:tex>S[f^{-1}]_ \bullet</fr:tex>. Let <fr:tex>\Gamma (D_+(f),  \mathscr { O } )</fr:tex> be the zeroth degree component <fr:tex>S[f^{-1}]_0</fr:tex>. This defines a sheaf over the <fr:link
href="algm-000Y.xml"
type="local"
addr="algm-000Y">projective spectrum</fr:link>, and moreover gives a <fr:link
href="algm-000R.xml"
type="local"
addr="algm-000R">scheme</fr:link> <fr:tex>\operatorname {Proj} (S)</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>762</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0010</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>\operatorname {Proj} (S)</fr:tex> can alternatively be given by gluing affine schemes. We assign <fr:tex>D_+ (f)</fr:tex> the affine scheme <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> (which is possible because the open subspace <fr:tex>D_+ (f)</fr:tex> is homeomorphic to <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> as a space). Given two positively graded elements <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, we have an isomorphism between <fr:tex>\operatorname {Proj} (S)</fr:tex> restricted to <fr:tex>D_+ (f g)</fr:tex> and <fr:tex>\operatorname {Spec} (S[f^{-1}]_0)</fr:tex> restricted to <fr:tex>D(g^{ \deg  f}/f^{ \deg  g})</fr:tex>, given by the obvious ring isomorphism. We can verify that this satisfies the cocycle condition, and hence defines a scheme.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1780</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000W</fr:addr><fr:route>algm-000W.xml</fr:route><fr:title>Action of morphisms on stalks of locally ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000S.xml"
type="local"
addr="algm-000S">morphism of ringed spaces</fr:link> <fr:tex>\varphi  : X  \to  Y</fr:tex>, if it is <fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">local</fr:link>, a germ is invertible iff its <fr:link
href="algm-000V.xml"
type="local"
addr="algm-000V">pullback</fr:link> under <fr:tex>\varphi</fr:tex> is invertible. If the space <fr:tex>X</fr:tex> has enough points, then the inverse implication is also true.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>821</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000W</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Note that the stalk <fr:tex>( \varphi ^{-1} \mathscr { O } _{Y})_x =  \mathscr { O } _{Y,  \varphi (x)}</fr:tex>. A germ being invertible implies for some neighborhood <fr:tex>U</fr:tex> of <fr:tex>x</fr:tex>, it comes from an invertible section <fr:tex>f  \in   \Gamma (U,  \varphi ^{-1} \mathscr { O } _Y)</fr:tex>, so the image in <fr:tex>\Gamma (U,  \mathscr { O } _X)</fr:tex> is also invertible, and hence the image germ. The locality condition gives the converse.
  </fr:p>

  <fr:p>
    On the other hand, if the space has enough points, then being invertible at each stalk implies being invertible. This is enough to guarantee logical equivalence.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1782</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000X</fr:addr><fr:route>algm-000X.xml</fr:route><fr:title>Morphisms of affine schemes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">Morphism</fr:link> of <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine schemes</fr:link> are in natural bijection with ring homomorphisms in the opposite direction. In other words, there is a fully faithful embedding <fr:tex>\mathsf { CRing } ^ \textrm {op}   \to   \mathsf { Sch }</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Given two rings <fr:tex>R</fr:tex>, <fr:tex>S</fr:tex>, a ring homomorphism <fr:tex>\varphi  : S  \to  R</fr:tex> naturally induces a map of <fr:link
href="algm-0004.xml"
type="local"
addr="algm-0004">distinguished opens</fr:link> <fr:tex>f  \mapsto   \varphi (f)</fr:tex>. This is a continuous map <fr:tex>\operatorname {Spec} (R)  \to   \operatorname {Spec} (S)</fr:tex>, because <fr:tex>\varphi</fr:tex> preserves <fr:tex>\operatorname {lcm}</fr:tex> and <fr:tex>\gcd</fr:tex> on radical ideals. For the structure sheaf, we can use the distinguished basis, thus we need to supply a ring homomorphism <fr:tex>\Gamma (D(s),  \mathscr { O } _{ \operatorname {Spec} (S)})  \to   \Gamma (D(r),  \mathscr { O } _{ \operatorname {Spec} (R)})</fr:tex> whenever <fr:tex>D(r)  \subseteq   \varphi ^{-1}D(s) = D( \varphi (s))</fr:tex>. This is just a homomorphism <fr:tex>S[s^{-1}]  \to  R[r^{-1}]</fr:tex>, which is obvious because <fr:tex>\varphi (s)</fr:tex> must be invertible in <fr:tex>R[r^{-1}]</fr:tex>.
  </fr:p>

  <fr:p>
    We need to prove our map is <fr:link
href="algm-000U.xml"
type="local"
addr="algm-000U">local</fr:link>. Using the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">characterization on stalks</fr:link>, we just need to verify that <fr:tex>S_{ \varphi ^{-1}( \mathfrak { p } )}  \to  R_{ \mathfrak { p } }</fr:tex> reflects invertibility. This is true by construction. Hence we have a map <fr:tex>\hom _{ \mathsf { CRing } }(S, R)  \to   \hom _{ \mathsf { Sch } }( \operatorname {Spec} (R),  \operatorname {Spec} (S))</fr:tex>.
  </fr:p>

  <fr:p>
    In the reverse direction, given a morphism <fr:tex>\varphi  :  \operatorname {Spec} (R)  \to   \operatorname {Spec} (S)</fr:tex>, we can extract a ring homomorphism by looking at the global sections
    <fr:tex
display="block">S  \cong   \Gamma ( \top ,  \varphi ^{-1} \mathscr { O } _{ \operatorname {Spec} (S)})  \to   \Gamma ( \top ,  \mathscr { O } _{ \operatorname {Spec} (R)})  \cong  R.</fr:tex>
    We obviously have going from <fr:tex>\mathsf { CRing }</fr:tex> to <fr:tex>\mathsf { Sch }</fr:tex> and then back is the identity. For the other direction, we first claim that the global section ring homomorphism (and the topological map) completely determines the morphism. Indeed, we need a commutative diagram:
  </fr:p>

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="5c8d88f17fb49eabfdaea7640e756c38"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
    S &amp; R  \\ 
    {S_{ \mathfrak { q } }} &amp; {R_{ \mathfrak { p } }}
     \arrow [from=1-1, to=1-2]
     \arrow [from=2-1, to=2-2]
     \arrow [two heads, from=1-1, to=2-1]
     \arrow [two heads, from=1-2, to=2-2]
   \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  <fr:p>
    where <fr:tex>\left [ \mathfrak { q } \right ]</fr:tex> is the image of the point <fr:tex>\left [ \mathfrak { p } \right ]</fr:tex> under the underlying continuous map of <fr:tex>\varphi</fr:tex>. This fixes the action of <fr:tex>\varphi</fr:tex> on the stalks. Furthermore, the <fr:link
href="algm-000W.xml"
type="local"
addr="algm-000W">locality</fr:link> implies the preimage of <fr:tex>\mathfrak { p }</fr:tex> under the ring homomorphism divides <fr:tex>\mathfrak { q }</fr:tex>, and since <fr:tex>\mathfrak { q }</fr:tex> is maximal in the local ring <fr:tex>S_{ \mathfrak { q } }</fr:tex>, the two ideals are equal. Hence the ring homomorphism determines the topological map too. This finishes the proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1784</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000V</fr:addr><fr:route>algm-000V.xml</fr:route><fr:title>Terminology of pullbacks</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In general, a pullback is any contravariant functorial action. In other words, we have a functor <fr:tex>F :  \mathcal { C } ^ \textrm {op}   \to   \mathcal { D }</fr:tex>, and pulling back along a morphism <fr:tex>f</fr:tex> in <fr:tex>\mathcal { C }</fr:tex> means the action of <fr:tex>F(f)</fr:tex>.
</fr:p><fr:p>
  In differential geometry, we have a set of <fr:tex>k</fr:tex>-forms <fr:tex>\Omega ^k(M)</fr:tex>, which forms a functor <fr:tex>\mathsf { Mfd } ^ \textrm {op}   \to   \mathsf { Set }</fr:tex>. Pullbacks of differential forms is then the functorial action. In the special case of <fr:tex>k = 0</fr:tex>, this corresponds to composition, which is sometimes also referred to as pullbacks.
</fr:p><fr:p>
  The categorical pullback can also be construed as a contravariant action, which forms the functor from <fr:tex>\mathcal { C } ^ \textrm {op}</fr:tex> to the <fr:tex>2</fr:tex>-category <fr:tex>\mathsf { Cat }</fr:tex> given by taking slices.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1786</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000U</fr:addr><fr:route>algm-000U.xml</fr:route><fr:title>Morphism of locally ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed spaces</fr:link>, a <fr:link
href="algm-000S.xml"
type="local"
addr="algm-000S">morphism of ringed spaces</fr:link> <fr:tex>\varphi</fr:tex> between them is <fr:strong>local</fr:strong> when sections of <fr:tex>\varphi ^{-1} \mathscr { O } _Y</fr:tex> are invertible iff their images in <fr:tex>\mathscr { O } _X</fr:tex> are invertible, i.e. the following diagram is a pullback:
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="3b6e2be8301faa9947f4232311c98ebe"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  { \varphi ^{-1} \mathscr { O } _Y^ \times } &amp; { \mathscr { O } _X^ \times }  \\ 
  { \varphi ^{-1} \mathscr { O } _Y} &amp; { \mathscr { O } _X}
   \arrow [hook, from=1-1, to=2-1]
   \arrow [hook, from=1-2, to=2-2]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [" \lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  Note that the <fr:link
href="algm-000T.xml"
type="local"
addr="algm-000T">subsheaf of units</fr:link> is given by a finite limit, hence <fr:tex>\varphi ^{-1}</fr:tex> preserves it. Since the lower map map <fr:tex>\varphi ^{-1}  \mathscr { O } _Y  \to   \mathscr { O } _X</fr:tex> is a ring homomorphism on the sections, it maps units to units. Hence restriction to the upper map makes sense.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1788</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000T</fr:addr><fr:route>algm-000T.xml</fr:route><fr:title>Subsheaf of units</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>7</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a sheaf <fr:tex>\mathscr { O }</fr:tex> of rings, we can define a subsheaf <fr:tex>\mathscr { O } ^ \times</fr:tex> consisting of the invertible elements, i.e. <fr:tex>\Gamma (U,  \mathscr { O } ^ \times ) =  \Gamma (U,  \mathscr { O } )^ \times</fr:tex>. This is the <fr:strong>subsheaf of units</fr:strong>.
</fr:p><fr:p>
  This can be equivalently expressed as a pullback of <fr:tex>\mathscr { O }   \times   \mathscr { O }   \xrightarrow {(f,g)  \mapsto  f g}  \mathscr { O }</fr:tex> and <fr:tex>1  \xrightarrow {1}  \mathscr { O }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1790</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000Q</fr:addr><fr:route>algm-000Q.xml</fr:route><fr:title>Affine scheme</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>affine scheme</fr:strong> is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> of the form <fr:tex>\operatorname {Spec} (R)</fr:tex> for some commutative ring <fr:tex>R</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1792</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>algm-000O</fr:addr><fr:route>algm-000O.xml</fr:route><fr:title>Locally ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locality</fr:link> requirement for a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link> is to guarantee that the sections behave like functions valued in some field.
</fr:p><fr:p>
  It is impossible in general to discuss the vanishing region of a section <fr:tex>f  \in   \Gamma (U,  \mathscr { O } )</fr:tex>. For instance, the germs of continuous functions are non-zero on their support, which is the closure of the non-vanishing region. In algebraic geometry, such an overspill destroys most valuable information. We can talk about the maximal region on which the section is invertible, but this is different from being non-zero if sections don’t behave like functions. Similarly, it is also impossible to discuss the value of a section at some point in general. In locally ringed space, we have <fr:ref
addr="algm-000P"
href="algm-000P.xml"
taxon="Definition"></fr:ref>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1794</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000S</fr:addr><fr:route>algm-000S.xml</fr:route><fr:title>Morphism of ringed spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed spaces</fr:link> <fr:tex>X, Y</fr:tex>, a morphism <fr:tex>\varphi  : X  \to  Y</fr:tex> is given by a continuous map of the underlying spaces, and a sheaf morphism <fr:tex>\varphi ^{-1}  \mathscr { O } _Y  \to   \mathscr { O } _X</fr:tex>, equivalently <fr:tex>\mathscr { O } _Y  \to   \varphi _*  \mathscr { O } _X</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1796</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000R</fr:addr><fr:route>algm-000R.xml</fr:route><fr:title>Scheme</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>scheme</fr:strong> is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> with an open covering on which the space is isomorphic to <fr:link
href="algm-000Q.xml"
type="local"
addr="algm-000Q">affine schemes</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1798</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000P</fr:addr><fr:route>algm-000P.xml</fr:route><fr:title>Value of section at a point</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>6</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> and a section <fr:tex>f  \in   \Gamma (U,  \mathscr { O } )</fr:tex>, the germ of <fr:tex>f</fr:tex> at a point is an element of a local ring. The image of this element in the residue field, i.e. the quotient by the unique maximal ideal is called the <fr:strong>value</fr:strong> of this section at this point.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1800</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000L</fr:addr><fr:route>algm-000L.xml</fr:route><fr:title>Locally ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link>, i.e. a space <fr:tex>X</fr:tex> with a sheaf of rings <fr:tex>\mathscr { O }</fr:tex>, it is said to be <fr:strong>locally ringed</fr:strong> iff the following conditions hold:
  <fr:ul><fr:li>If <fr:tex>\Gamma (U,  \mathscr { O } ) = 0</fr:tex>, then <fr:tex>U</fr:tex> is empty.</fr:li>
    <fr:li>Suppose <fr:tex>f + g  \in   \Gamma (U,  \mathscr { O } )</fr:tex> is invertible, then we can cover <fr:tex>U</fr:tex> with two open sets such that <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> are invertible when restricted respectively.</fr:li></fr:ul>
  This can be unified as one condition: If a finite sum in <fr:tex>\Gamma (U,  \mathscr { O } )</fr:tex> is invertible, then each summand is invertible when restricted to an open, which jointly covers <fr:tex>U</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1802</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000M</fr:addr><fr:route>algm-000M.xml</fr:route><fr:title>Ringed space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>ringed space</fr:strong> is a space equipped with a sheaf of rings, called the <fr:strong>structure sheaf</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1804</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000K</fr:addr><fr:route>algm-000K.xml</fr:route><fr:title>Sheaf and stalk from <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The proofs in <fr:ref
addr="algm-000I"
href="algm-000I.xml"
taxon="Definition"></fr:ref> and <fr:ref
addr="algm-000J"
href="algm-000J.xml"
taxon="Theorem"></fr:ref> do not make use of the multiplication on the numerators. Therefore they immediately generalizes to modules. In particular, we have a sheaf corresponding to an <fr:tex>R</fr:tex>-module <fr:tex>M</fr:tex>, whose sections over <fr:tex>D(f)</fr:tex> form the <fr:tex>R[f^{-1}]</fr:tex>-module <fr:tex>M[f^{-1}]</fr:tex>. The stalk on <fr:tex>\left [ \mathfrak { p } \right ]</fr:tex> is isomorphic to <fr:tex>M_{ \left [ \mathfrak { p } \right ] }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1806</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000J</fr:addr><fr:route>algm-000J.xml</fr:route><fr:title>Stalk of the structure sheaf on <fr:tex>\operatorname {Spec} (R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a point <fr:tex>\left [ \mathfrak { p } \right ]   \in   \operatorname {Spec} (R)</fr:tex>, the stalk at the point is the localization <fr:tex>R_{ \mathfrak { p } }</fr:tex>. In particular, the ring spectrum is a <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed space</fr:link> by <fr:ref
addr="algm-000N"
href="algm-000N.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>913</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000J</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We take a directed limit. The elements are from some <fr:tex>R[f^{-1}]</fr:tex> with <fr:tex>\mathfrak { p }   \nmid  f</fr:tex>, i.e. the elements can be written as <fr:tex>g/f^n</fr:tex>. Two elements are equal iff their common restriction to some <fr:tex>D(f)</fr:tex> is equal, i.e. <fr:tex>g_1/f_1^n = g_2/f_2^m</fr:tex> iff <fr:tex>(g_1 f_2^m - g_2 f_1^n) f^k = 0</fr:tex>. These are exactly the definition of the localization away from <fr:tex>\mathfrak { p }</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1808</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000N</fr:addr><fr:route>algm-000N.xml</fr:route><fr:title>Stalks of locally ringed topological space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed</fr:link> topological space, it is <fr:link
href="algm-000L.xml"
type="local"
addr="algm-000L">locally ringed</fr:link> iff every stalk is a local ring.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>917</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000N</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Recall the axiom for a local ring: if any sum is invertible, then one of the summand is invertible. When applied to the direct limit in each stalk, this immediately expands to the definition of a locally ringed space.
  </fr:p>

  <fr:p>
    In particular, a crucial property is used in the reverse implication, i.e. if one open contains all the points of another, then the former covers the latter. This is equivalent to the condition of having enough points.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1810</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000H</fr:addr><fr:route>algm-000H.xml</fr:route><fr:title>Irreducible closeds in a ring spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A closed <fr:tex>V( \mathfrak { r } )</fr:tex> in <fr:tex>\operatorname {Spec} (R)</fr:tex> is irreducible iff <fr:tex>\mathfrak { r }</fr:tex> is prime, and it is an irreducible component iff <fr:tex>\mathfrak { r }</fr:tex> is a minimal prime ideal, i.e. prime ideals that divide no other prime ideals.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Translating via <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>, we have a proper ideal <fr:tex>\mathfrak { r }</fr:tex> that cannot be written as <fr:tex>\operatorname {lcm} ( \mathfrak { r } _1,  \mathfrak { r } _2)</fr:tex> non-trivially. Suppose <fr:tex>\mathfrak { r }   \mid  f g</fr:tex>, then <fr:tex>\mathfrak { r }   \mid   \sqrt {f g}  \mid   \operatorname {lcm} (f, g)</fr:tex>. So
    <fr:tex
display="block">\begin {aligned}        \mathfrak { r }  &amp;=  \gcd ( \mathfrak { r } ,  \operatorname {lcm} (f, g))  \\        &amp;=  \operatorname {lcm} ( \gcd ( \mathfrak { r } , f),  \gcd ( \mathfrak { r } , g)).      \end {aligned}</fr:tex>
    Hence at least one of the two must be equal to <fr:tex>\mathfrak { r }</fr:tex>. So <fr:tex>\mathfrak { r }   \mid  f</fr:tex> or <fr:tex>\mathfrak { r }   \mid  g</fr:tex>.
  </fr:p>

  <fr:p>
    An irreducible closed is an irreducible <fr:em>component</fr:em> if it is contained in no other irreducible closed. We immediately get the definition of minimal prime ideals translating to the algebraic realm.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1812</fr:anchor><fr:addr>algm-000G</fr:addr><fr:route>algm-000G.xml</fr:route><fr:title>Noetherian rings and <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian spaces</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">spectrum</fr:link> of a noetherian ring is always noetherian: the closeds corresponds to radical ideals. The converse does not hold. Consider a polynomial ring with infinitely many indeterminates <fr:tex>x_1, x_2,  \dots</fr:tex> quotiented by the relations <fr:tex>x_k^k = 0</fr:tex>. <fr:link
href="algm-000E.xml"
type="local"
addr="algm-000E">The ideals in the quotient ring</fr:link> correspond to ideals in the polynomial ring dividing <fr:tex>x_k^k</fr:tex> for every <fr:tex>k</fr:tex>. So there are only two radical ideals: the trivial one, and the one that divides all indeterminates, but not constants. Hence the spectrum must be a noetherian space, but the ring is obviously not noetherian since it is not finitely generated itself.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1814</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000I</fr:addr><fr:route>algm-000I.xml</fr:route><fr:title>Structure sheaf of a ring spectrum</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a sheaf <fr:tex>\mathscr { O }</fr:tex> of rings on <fr:tex>\operatorname {Spec} (R)</fr:tex> called the <fr:strong>structure sheaf</fr:strong>. Let <fr:tex>\Gamma (D(f),  \mathscr { O } ) = R[f^{-1}]</fr:tex>. Suppose <fr:tex>D(f)  \subseteq  D(g)</fr:tex> we define the restriction morphism to be the localization map <fr:tex>R[g^{-1}]  \to  R[f^{-1}]</fr:tex>, since by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref> the latter is a further localization of the former. This turns <fr:tex>\operatorname {Spec} (R)</fr:tex> into a <fr:link
href="algm-000M.xml"
type="local"
addr="algm-000M">ringed space</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>752</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000I</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We just need to verify the sheaf axioms on the bases, i.e. given a family of elements <fr:tex>f_i  \in  R</fr:tex> such that <fr:tex>\bigcup _i D(f_i) = D(f)</fr:tex>, we need to show that
    <fr:tex
display="block">R[f^{-1}]  \to   \prod _{i  \in  I} R[f_i^{-1}]  \rightrightarrows   \prod _{i  \ne  j} R[(f_i f_j)^{-1}]</fr:tex>
    is an equalizer. Notice that <fr:tex>R[f_i^{-1}]  \cong  R[f^{-1}][f_i^{-1}]</fr:tex>. So we may reassign <fr:tex>S = R[f^{-1}]</fr:tex>. This simplifies the problem to
    <fr:tex
display="block">S  \to   \prod _{i  \in  I} S[f_i^{-1}]  \rightrightarrows   \prod _{i  \ne  j} S[(f_i f_j)^{-1}],</fr:tex>
    where <fr:tex>D(f_i)</fr:tex> covers the whole space <fr:tex>\operatorname {Spec} (S)</fr:tex>. 
  </fr:p>

  <fr:p>
    We first describe the intuition. Since we know <fr:tex>\operatorname {Spec} (S)</fr:tex> is <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compact</fr:link>, we can roughly expect to reduce the problem to finite cases. Localization is a bit complicated due to zero-divisors, but suppose we don’t have them, we have elements <fr:tex>g_i/f_i^{d_i}  \in  S[f_i^{-1}]</fr:tex> that are equal in their common domain. Since <fr:tex>D(f_i) = D(f_i^{d_i})</fr:tex> covers <fr:tex>\operatorname {Spec} (S)</fr:tex>, we have a linear combination <fr:tex>1 =  \sum _i c_i f_i^{d_i}</fr:tex>, which is akin to a partition of unity. Suppose the putative gluing is <fr:tex>f</fr:tex>, multiplying with the partition of unity we get
    <fr:tex
display="block">\begin {aligned}       f &amp;=  \sum _{i  \in  I} c_i f_i^{d_i} f  \\        &amp;=  \sum  c_i f_i^{d_i}  \frac {g_i}{f_i^{d_i}}  \\        &amp;=  \sum  c_i g_i.      \end {aligned}</fr:tex>
    which defines the gluing. We just have to make this reasoning precise. We first deal with the finite case.
  </fr:p>

  <fr:p>
    Suppose there are elements <fr:tex>g_i/f_i^d  \in  S[f_i^{-1}]</fr:tex>, where we are allowed to use a single exponent <fr:tex>d</fr:tex> by finiteness. The compatibility requirement is <fr:tex
display="block">(g_i f_j^d - g_j f_i^d) (f_i f_j)^{N} = 0.</fr:tex> If there is a solution <fr:tex>f</fr:tex> to the gluing problem, it would need to satisfy <fr:tex>(f f_i^d - g_i) f_i^M = 0</fr:tex>. Since <fr:tex>D(f_i) = D(f_i^R)</fr:tex> covers <fr:tex>\operatorname {Spec} (S)</fr:tex>, we have a linear combination <fr:tex>1 =  \sum _i c_i f_i^R</fr:tex> for large enough <fr:tex>R</fr:tex>. Hence
    <fr:tex
display="block">f =  \sum _{i  \in  I} c_i f f_i^R =  \sum  c_i g_i f_i^{R-d}.</fr:tex> This uniquely determines <fr:tex>f</fr:tex>. And indeed, this solution satisfies our requirements, because when restricted to <fr:tex>D(f_j)</fr:tex>, we have
    <fr:tex
display="block">\begin {aligned}       f f_j^d  \cdot  f_j^R &amp;=  \sum  c_i g_i f_i^{R-d} f_j^{R+d}  \\        &amp;=  \sum  c_i g_j f_i^{R} f_j^{R}  \\        &amp;= g_j f_j^R  \cdot   \sum  c_i f_i^R = g_j f_j^R.      \end {aligned}</fr:tex>
    This reasoning is valid as long as <fr:tex>R &gt; N + 2d</fr:tex>.
  </fr:p>

  <fr:p>
    If there are infinitely many opens, we first use <fr:link
href="algm-000B.xml"
type="local"
addr="algm-000B">quasi-compactness</fr:link> to select a finite number <fr:tex>D(f_1),  \dots , D(f_k)</fr:tex> that covers the whole space. The uniqueness of gluing solutions in the finite case implies that of the infinite case. For existence, first take the solution <fr:tex>f</fr:tex> for <fr:tex>D(f_1),  \dots , D(f_k)</fr:tex>. Then consider the solution on <fr:tex>D(f_1),  \dots , D(f_k) , D(g)</fr:tex> for every <fr:tex>g</fr:tex>. This solution must be equal to <fr:tex>f</fr:tex> by uniqueness. Therefore <fr:tex>f</fr:tex> restrict to the correct function on each <fr:tex>D(g)</fr:tex>, showing that <fr:tex>f</fr:tex> is the required solution.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1816</fr:anchor><fr:addr>trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title>Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  I try to adhere to several principles when composing trees.
</fr:p><fr:ul><fr:li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </fr:li>
  <fr:li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex>\mathfrak { a }   \mid  x</fr:tex> instead of <fr:tex>x  \in   \mathfrak { a }</fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex>\operatorname {Spec} (A)</fr:tex>, we do not identify them.
  </fr:li>
  <fr:li>
    Apply <fr:link
href="https://ncatlab.org/nlab/show/biased+definition"
type="external">unbiased terminology</fr:link> and <fr:link
href="https://ncatlab.org/nlab/show/negative+thinking"
type="external">negative thinking</fr:link>.
  </fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1818</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0009</fr:addr><fr:route>algm-0009.xml</fr:route><fr:title><fr:tex>\operatorname {Spec} {R}</fr:tex> is disconnected iff <fr:tex>R</fr:tex> is a product of non-zero rings</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, <fr:tex>\operatorname {Spec} {R}</fr:tex> is disconnected iff <fr:tex>R  \cong  R_1  \times  R_2</fr:tex>, where <fr:tex>R_1, R_2</fr:tex> are non-zero commutative rings.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>999</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    In one direction, if <fr:tex>\operatorname {Spec} {R}</fr:tex> is disconnected, we have two opens <fr:tex>D( \mathfrak { a } )</fr:tex> and <fr:tex>D( \mathfrak { b } )</fr:tex> whose intersection is empty and union is the entire space. In other words radical ideals <fr:tex>\mathfrak { a } ,  \mathfrak { b }</fr:tex> such that <fr:tex>\sqrt { \gcd ( \mathfrak { a } ,  \mathfrak { b } )} = 1</fr:tex> (equivalent to <fr:tex>\gcd ( \mathfrak { a } ,  \mathfrak { b } ) = 1</fr:tex>) and <fr:tex>\operatorname {lcm} ( \mathfrak { a } ,  \mathfrak { b } ) = 0</fr:tex>. We have <fr:tex>\mathfrak { a }   \mid  a</fr:tex> and <fr:tex>\mathfrak { b }   \mid  b</fr:tex> such that <fr:tex>a + b = 1</fr:tex>. But <fr:tex>\operatorname {lcm} ( \mathfrak { a } ,  \mathfrak { b } )  \mid  a b</fr:tex>, therefore <fr:tex>a b = 0</fr:tex>. This implies <fr:tex>a(1-a) = 0</fr:tex>, or <fr:tex>a^2 = a</fr:tex>. The same goes for <fr:tex>b</fr:tex>.
  </fr:p>

  <fr:p>
    Let <fr:tex>R_1</fr:tex> be the subset of <fr:tex>R</fr:tex> consisting of multiples of <fr:tex>a</fr:tex>. It contains an identity <fr:tex>a</fr:tex>, since <fr:tex>a  \cdot  a x = a x</fr:tex> by idempotence. Hence this subset forms a ring with the same addition and multiplication but a different identity. The same goes for <fr:tex>R_2</fr:tex>, the multiples of <fr:tex>b</fr:tex>. There is an obvious map <fr:tex>R_1  \times  R_2  \to  R</fr:tex>, given by <fr:tex>(ax, by)  \mapsto  ax + by</fr:tex>. This is an injection since <fr:tex>z  \mapsto  a z</fr:tex> recovers the first argument, and <fr:tex>z  \mapsto  b z</fr:tex> recovers the second. It is also a surjection because <fr:tex>z = a z + b z</fr:tex> is the image of <fr:tex>(az, bz)</fr:tex>. Hence we found an isomorphism.
  </fr:p>

  <fr:p>
    In the other direction, suppose <fr:tex>R  \cong  R_1  \times  R_2</fr:tex>, then <fr:tex>D((1,0))</fr:tex> and <fr:tex>D((0,1))</fr:tex> separates the spectrum into two disjoint parts.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1820</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000F</fr:addr><fr:route>algm-000F.xml</fr:route><fr:title>Hilbert basis theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If a commutative ring <fr:tex>R</fr:tex> is noetherian, then <fr:tex>R[x]</fr:tex> is also noetherian.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1003</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000F</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Being noetherian is equivalent to having all ideals finitely generated. Suppose we have an ideal <fr:tex>\mathfrak { a } R  \subseteq  R</fr:tex>. We recursively produce a list of generators. Suppose we have already selected <fr:tex>f_1,  \dots , f_n</fr:tex>. If this doesn’t generate <fr:tex>\mathfrak { a } R</fr:tex>, then we select another one of the lowest degree. We prove that this procedure terminates.
  </fr:p>

  <fr:p>
    Consider the initial coefficient <fr:tex>c_i</fr:tex> of <fr:tex>f_i</fr:tex>. The ideal <fr:tex>\mathfrak { c } _k</fr:tex> generated by the first <fr:tex>k</fr:tex> elements must eventually stabilize. Let’s say <fr:tex>c_{n+1} =  \sum _{i=1}^n b_i c_i</fr:tex>. Then we can subtract <fr:tex>f_{n+1}</fr:tex> by suitable multiples of <fr:tex>f_1,  \dots , f_n</fr:tex> to cancel the leading term. This must not belong to ideal generated by <fr:tex>f_1,  \dots , f_n</fr:tex>, which contradicts our choice of generators, being of the lowest degree.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1822</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000B</fr:addr><fr:route>algm-000B.xml</fr:route><fr:title>A <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">ring spectrum</fr:link> is quasi-compact</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The space <fr:tex>\operatorname {Spec} (R)</fr:tex> is always <fr:link
href="algm-000A.xml"
type="local"
addr="algm-000A">quasi-compact</fr:link>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>985</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since quasi-compectness can be tested on a basis, we just have to show that if <fr:tex>\bigcup _i D(f_i) =  \top</fr:tex>, then there is a finite union equal to <fr:tex>\top</fr:tex>. Algebraically this means <fr:tex>\sqrt { \gcd \{ f_i \} } = 1</fr:tex>, equivalently <fr:tex>\gcd \{ f_i \}  = 1</fr:tex>. So we have a linear combination <fr:tex>\sum _k a_k f_k = 1</fr:tex>. Crucially, this can only be a finite combination. Hence we can take the non-zero terms, whose corresponding opens already cover the whole space.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1824</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000D</fr:addr><fr:route>algm-000D.xml</fr:route><fr:title>A closed in a noetherian space is uniquely a finite union of irreducible closeds</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If <fr:tex>X</fr:tex> is a <fr:link
href="algm-000C.xml"
type="local"
addr="algm-000C">noetherian space</fr:link>, then a closed <fr:tex>Z  \subseteq  X</fr:tex> can be written uniquely as the union of finitely many irreducible closeds.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1017</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We first deal with existence. By noetherianness, we perform well-founded induction. Suppose all the closed subsets of <fr:tex>Z</fr:tex> can be written as a finite union. If <fr:tex>Z</fr:tex> is irreducible then we’re done. Otherwise <fr:tex>Z = Z_1  \cup  Z_2</fr:tex> is a non-trivial union of two closeds. By the induction hypothesis <fr:tex>Z_1</fr:tex> and <fr:tex>Z_2</fr:tex> can be written as a finite union of irreducible closeds, which we can combine to get the desired union.
  </fr:p>

  <fr:p>
    We then prove uniqueness. Suppose
    <fr:tex
display="block">Z_1  \cup   \cdots   \cup  Z_n = Z'_1  \cup   \cdots   \cup  Z'_m.</fr:tex>
    Consider the intersection with <fr:tex>Z_1</fr:tex>. The left hand side collapses to <fr:tex>Z_1</fr:tex>. The right hand side becomes <fr:tex>\bigcup _{i=1}^m (Z'_i  \cap  Z_1)</fr:tex>. Since <fr:tex>Z_1</fr:tex> is irreducible, <fr:tex>Z'_i  \cap  Z_1</fr:tex> must be either <fr:tex>Z_1</fr:tex> or empty. In the former case, since <fr:tex>Z'_i</fr:tex> is also irreducible, <fr:tex>Z'_i = Z_1</fr:tex>. Therefore each <fr:tex>Z_j</fr:tex> appears in the right hand side, and vice versa. Therefore the two sides are the same up to reordering and repetition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1826</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname {Spec} (R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens in <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the locale</fr:link> <fr:tex>\operatorname {Spec} (R)</fr:tex> bijectively corresponds to radical ideals of <fr:tex>R</fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We can first put the opens in disjunctive normal form
    <fr:tex
display="block">U =  \bigcup _{i  \in  I}  \bigcap _{j=1}^{n_i} D(f_{i, j}).</fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex>f_i =  \prod _j f_{i, j}</fr:tex>, we have <fr:tex>U =  \bigcup _i D(f_i)</fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex>U</fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex>D(f)</fr:tex> can be added, i.e. <fr:tex>D(f)  \nsubseteq  U</fr:tex>. This would uniquely determine <fr:tex>U</fr:tex>.
  </fr:p>

  <fr:p>
    Such a saturated set would have to be closed under addition since <fr:tex>D(f+g)  \subseteq  D(f)  \cup  D(g)</fr:tex>, and for the nullary case it must include <fr:tex>D(0) =  \bot</fr:tex>. It also has to absorb multiplication, because <fr:tex>D(f  \cdot  g)  \subseteq  D(f)</fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex>D( \mathfrak { a } )</fr:tex> for the union <fr:tex>\bigcup _{ \mathfrak { a }   \mid  f} D(f)</fr:tex>.
  </fr:p>

  <fr:p>
    There is one last requirement we haven’t dealt with, i.e. <fr:tex>D(f  \cdot  g)</fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex>D(f)</fr:tex> and <fr:tex>D(g)</fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex>D(f^n) = D(f)</fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex>f  \cdot  g</fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1828</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0004</fr:addr><fr:route>algm-0004.xml</fr:route><fr:title>Distinguished opens of <fr:tex>\operatorname {Spec} (R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We define a basis of opens on <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001"><fr:tex>\operatorname {Spec} (R)</fr:tex></fr:link> by <fr:tex>D(f)</fr:tex> for every element <fr:tex>f  \in  R</fr:tex>. These are called <fr:strong>distinguished opens</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>835</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0004</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex
display="block">D( \mathfrak { a } ) =  \bigcup _{ \mathfrak { a }   \mid  f} D(f).</fr:tex> Alternatively, <fr:tex>V( \mathfrak { a } ) =  \bigcap _{ \mathfrak { a }   \mid  f} V(f)</fr:tex>. Since <fr:tex>\mathfrak { a }   \mid  f</fr:tex> implies <fr:tex>V( \mathfrak { a } )  \subseteq  V(f)</fr:tex>, we have the forward inclusion. For the backwards inclusion, suppose <fr:tex>\left [ \mathfrak { p } \right ]   \notin  V( \mathfrak { a } )</fr:tex>, i.e. <fr:tex>\mathfrak { p }   \nmid   \mathfrak { a }</fr:tex>, then by definition there is an element <fr:tex>\mathfrak { a }   \mid  f</fr:tex> such that <fr:tex>\mathfrak { p }   \nmid  f</fr:tex>, meaning that <fr:tex>\left [ \mathfrak { p } \right ]   \notin  V(f)</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1830</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-000E</fr:addr><fr:route>algm-000E.xml</fr:route><fr:title>Ideals under quotient and localization</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, the ideals of <fr:tex>R/ \mathfrak { a }</fr:tex> bijectively corresponds to the ideals in <fr:tex>R</fr:tex> that divides <fr:tex>\mathfrak { a }</fr:tex>. The ideals of <fr:tex>R[S^{-1}]</fr:tex> are generated by images of ideals in <fr:tex>R</fr:tex> under the localization map, written as <fr:tex>\mathfrak { b } [S^{-1}]</fr:tex>, isomorphic to <fr:tex>\mathfrak { b }   \otimes _R R[S^{-1}]</fr:tex>.
</fr:p><fr:p>
  The prime ideals in <fr:tex>R</fr:tex> that doesn’t intersect <fr:tex>S</fr:tex> bijectively correspond to prime ideals in <fr:tex>R[S^{-1}]</fr:tex> via the localization map.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:addr>algm-0005</fr:addr><fr:route>algm-0005.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <fr:tex>f/g</fr:tex>, so the domain should be the non-vanishing part of <fr:tex>g</fr:tex>, which we denote as <fr:tex>D(g)</fr:tex>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1029</fr:anchor><fr:addr>algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title>Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</fr:p><fr:p>
  For example, on the space given by <fr:tex>xy = zw</fr:tex>, we can define a funtion given by <fr:tex>x/w</fr:tex>, which is equal to <fr:tex>z/y</fr:tex>. They are only jointly undefined on <fr:tex>w = z = 0</fr:tex>, but there is no single expression that achieves this.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Recognizing this, we can try to freely generate a locale using <fr:tex>D(g)</fr:tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1031</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a frame generated by the symbols <fr:tex>D(f)</fr:tex> for <fr:tex>f  \in  R</fr:tex>, subject to the following relations:
  <fr:tex
display="block">\begin {aligned}     D(0) &amp;=  \bot   \\      D(1) &amp;=  \top   \\      D(f  \cdot  g) &amp;= D(f)  \cap  D(g)  \\      D(f + g) &amp; \subseteq  D(f)  \cup  D(g)    \end {aligned}</fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex>\operatorname {Spec} (R)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1033</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0008</fr:addr><fr:route>algm-0008.xml</fr:route><fr:title>Characterization of the locale <fr:tex>\operatorname {Spec} (R)</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The opens in <fr:link
href="algm-0007.xml"
type="local"
addr="algm-0007">the locale</fr:link> <fr:tex>\operatorname {Spec} (R)</fr:tex> bijectively corresponds to radical ideals of <fr:tex>R</fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link> by <fr:ref
addr="algm-0002"
href="algm-0002.xml"
taxon="Theorem"></fr:ref>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0008</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We can first put the opens in disjunctive normal form
    <fr:tex
display="block">U =  \bigcup _{i  \in  I}  \bigcap _{j=1}^{n_i} D(f_{i, j}).</fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex>f_i =  \prod _j f_{i, j}</fr:tex>, we have <fr:tex>U =  \bigcup _i D(f_i)</fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex>U</fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex>D(f)</fr:tex> can be added, i.e. <fr:tex>D(f)  \nsubseteq  U</fr:tex>. This would uniquely determine <fr:tex>U</fr:tex>.
  </fr:p>

  <fr:p>
    Such a saturated set would have to be closed under addition since <fr:tex>D(f+g)  \subseteq  D(f)  \cup  D(g)</fr:tex>, and for the nullary case it must include <fr:tex>D(0) =  \bot</fr:tex>. It also has to absorb multiplication, because <fr:tex>D(f  \cdot  g)  \subseteq  D(f)</fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex>D( \mathfrak { a } )</fr:tex> for the union <fr:tex>\bigcup _{ \mathfrak { a }   \mid  f} D(f)</fr:tex>.
  </fr:p>

  <fr:p>
    There is one last requirement we haven’t dealt with, i.e. <fr:tex>D(f  \cdot  g)</fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex>D(f)</fr:tex> and <fr:tex>D(g)</fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex>D(f^n) = D(f)</fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex>f  \cdot  g</fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex>, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1834</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0007</fr:addr><fr:route>algm-0007.xml</fr:route><fr:title>Localic spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a commutative ring <fr:tex>R</fr:tex>, we define a frame generated by the symbols <fr:tex>D(f)</fr:tex> for <fr:tex>f  \in  R</fr:tex>, subject to the following relations:
  <fr:tex
display="block">\begin {aligned}     D(0) &amp;=  \bot   \\      D(1) &amp;=  \top   \\      D(f  \cdot  g) &amp;= D(f)  \cap  D(g)  \\      D(f + g) &amp; \subseteq  D(f)  \cup  D(g)    \end {aligned}</fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex>\operatorname {Spec} (R)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1836</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-000C</fr:addr><fr:route>algm-000C.xml</fr:route><fr:title>Noetherian space</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A space is <fr:strong>noetherian</fr:strong> if every descending chain of closeds, or equivalently every ascending chain of opens stabilizes. In other words, the partial order of closeds is well-founded.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1838</fr:anchor><fr:addr>algm-0006</fr:addr><fr:route>algm-0006.xml</fr:route><fr:title>Rational functions not definable via a single expression</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.
</fr:p><fr:p>
  For example, on the space given by <fr:tex>xy = zw</fr:tex>, we can define a funtion given by <fr:tex>x/w</fr:tex>, which is equal to <fr:tex>z/y</fr:tex>. They are only jointly undefined on <fr:tex>w = z = 0</fr:tex>, but there is no single expression that achieves this.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1840</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>algm-000A</fr:addr><fr:route>algm-000A.xml</fr:route><fr:title>Terminology of compactness in algebraic geometry</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1842</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title>The radical ideal is the lcm of prime ideal divisors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any ideal <fr:tex>\mathfrak { a }</fr:tex> of a commutative ring, the radical <fr:tex>\sqrt { \mathfrak { a } }</fr:tex> is the lowest common multiple of the prime ideals <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>959</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt { \mathfrak { a } }  \mid  f</fr:tex>, then <fr:tex>\mathfrak { a }   \mid  f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex>, we have <fr:tex>\mathfrak { p }   \mid  f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak { p }   \mid  f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak { a }   \nmid  f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak { a }</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak { d }</fr:tex> still in this set, since <fr:tex>\mathfrak { d }</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak { q }</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak { q }   \nmid  x, y</fr:tex> such that <fr:tex>\mathfrak { q }   \mid  x y</fr:tex>, then <fr:tex>\mathfrak { q } ' =  \gcd ( \mathfrak { q } , x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak { q }</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y  \mid  f^n</fr:tex>, so <fr:tex>\mathfrak { q }   \mid  x y  \mid  f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1844</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0002</fr:addr><fr:route>algm-0002.xml</fr:route><fr:title>Radical ideals bijectively correspond to open sets</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an arbitrary <fr:link
href="algm-0001.xml"
type="local"
addr="algm-0001">topological spectrum of a commutative ring</fr:link>, we have <fr:tex>D( \mathfrak { a } ) = D( \sqrt { \mathfrak { a } })</fr:tex>. There is a containment of opens <fr:tex>D( \mathfrak { a } )  \subseteq  D( \mathfrak { b } )</fr:tex> — equivalently <fr:tex>V( \mathfrak { b } )  \subseteq  V( \mathfrak { a } )</fr:tex> — iff <fr:tex>\sqrt { \mathfrak { b } }  \mid   \sqrt { \mathfrak { a } }</fr:tex>, and the points contained in an open set completely determines the radical ideal.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>963</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0002</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex> implies <fr:tex>\sqrt { \mathfrak { p } }  \mid   \sqrt { \mathfrak { a } }</fr:tex>, but <fr:tex>\mathfrak { p }  =  \sqrt { \mathfrak { p } }</fr:tex>, we see that <fr:tex>D( \mathfrak { a } ) = D( \sqrt { \mathfrak { a } })</fr:tex>. We just have to prove the forward implication of the last statement. Suppose for all prime ideals <fr:tex>\mathfrak { p }</fr:tex> we have <fr:tex>\mathfrak { p }   \mid   \mathfrak { b }   \implies   \mathfrak { p }   \mid   \mathfrak { a }</fr:tex>. We need to prove that <fr:tex>\sqrt { \mathfrak { a } }  \mid  f  \implies   \sqrt { \mathfrak { b } }  \mid  f</fr:tex>.
  </fr:p>

  <fr:p>
    Given <fr:tex>\sqrt { \mathfrak { a } }  \mid  f</fr:tex>, we have <fr:tex>\mathfrak { p }   \mid  f</fr:tex> for all prime ideals <fr:tex>\mathfrak { p }   \mid   \sqrt { \mathfrak { a } }</fr:tex> (which is equivalent to <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex>). So we know that for all <fr:tex>\mathfrak { p }   \mid   \mathfrak { b }</fr:tex>, <fr:tex>\mathfrak { p }   \mid  f</fr:tex>. This is now purely a condition on <fr:tex>\mathfrak { b }</fr:tex>. The next lemma finishes the proof.
  </fr:p>

  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>961</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>algm-0003</fr:addr><fr:route>algm-0003.xml</fr:route><fr:title>The radical ideal is the lcm of prime ideal divisors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For any ideal <fr:tex>\mathfrak { a }</fr:tex> of a commutative ring, the radical <fr:tex>\sqrt { \mathfrak { a } }</fr:tex> is the lowest common multiple of the prime ideals <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>959</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>algm-0003</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    On one hand, if <fr:tex>\sqrt { \mathfrak { a } }  \mid  f</fr:tex>, then <fr:tex>\mathfrak { a }   \mid  f^n</fr:tex> for some natural number <fr:tex>n</fr:tex>. This means for all <fr:tex>\mathfrak { p }   \mid   \mathfrak { a }</fr:tex>, we have <fr:tex>\mathfrak { p }   \mid  f^n</fr:tex>, which by being a prime ideal implies <fr:tex>\mathfrak { p }   \mid  f</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, suppose <fr:tex>\mathfrak { a }   \nmid  f^n</fr:tex> for any <fr:tex>n</fr:tex>, we construct a prime ideal divisor of <fr:tex>\mathfrak { a }</fr:tex> that is not a divisor of <fr:tex>f</fr:tex>. Consider the set of all ideals not a divisor of <fr:tex>f^n</fr:tex> for any <fr:tex>n</fr:tex>. This is partially ordered by divisibility and non-empty. Any chain of divisibility has its greatest common divisor <fr:tex>\mathfrak { d }</fr:tex> still in this set, since <fr:tex>\mathfrak { d }</fr:tex> divides exactly the elements divided by some ideal in the chain. By <fr:link
href="https://en.wikipedia.org/wiki/Zorn's_lemma"
type="external">Zorn’s lemma</fr:link>, the set contains some <fr:tex>\mathfrak { q }</fr:tex> not divided by any other ideal in the set. This ideal must be prime: take <fr:tex>\mathfrak { q }   \nmid  x, y</fr:tex> such that <fr:tex>\mathfrak { q }   \mid  x y</fr:tex>, then <fr:tex>\mathfrak { q } ' =  \gcd ( \mathfrak { q } , x y)</fr:tex> is a proper divisor of <fr:tex>\mathfrak { q }</fr:tex>, and by construction it cannot be in the previously constructed set. Hence there is some <fr:tex>n</fr:tex> such that <fr:tex>x y  \mid  f^n</fr:tex>, so <fr:tex>\mathfrak { q }   \mid  x y  \mid  f^n</fr:tex>, contradiction.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1846</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>algm-0001</fr:addr><fr:route>algm-0001.xml</fr:route><fr:title>Topological spectrum of a commutative ring</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The topological <fr:strong>spectrum</fr:strong> of a commutative ring <fr:tex>R</fr:tex>, denoted <fr:tex>\operatorname {Spec} (R)</fr:tex>, is a topological space whose points are given by prime ideals of <fr:tex>R</fr:tex>. We denote the point corresponding to <fr:tex>\mathfrak { p }</fr:tex> as <fr:tex>\left [ \mathfrak { p } \right ]</fr:tex>. We define an open <fr:tex>D( \mathfrak { a } )</fr:tex> for each ideal <fr:tex>\mathfrak { a }</fr:tex> which contains the point <fr:tex>\left [ \mathfrak { p } \right ]</fr:tex> when <fr:tex>\mathfrak { p }   \nmid   \mathfrak { a }</fr:tex>. The corresponding closed is written as <fr:tex>V( \mathfrak { a } )</fr:tex>.
</fr:p><fr:p>
  We abuse the notation and write <fr:tex>D(f)</fr:tex> for the case where <fr:tex>\mathfrak { a }</fr:tex> is generated by <fr:tex>f</fr:tex>. Similar notations apply to <fr:tex>V</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1848</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001J</fr:addr><fr:route>hmlg-001J.xml</fr:route><fr:title>Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a mathematical object <fr:tex>X</fr:tex> canonically associated with an <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective</fr:link> chain complex <fr:tex>C_ \bullet  (X)</fr:tex> (e.g. the <fr:link
href="todo.xml"
type="local"
addr="todo">normalized chain complex</fr:link> of a <fr:link
href="todo.xml"
type="local"
addr="todo">simplicial set</fr:link>), it is said to be equipped with the structure of <fr:strong>effective homology</fr:strong>, if we have a <fr:link
href="hmlg-001I.xml"
type="local"
addr="hmlg-001I">strong homology equivalence</fr:link> <fr:tex>C_ \bullet  (X)  \Leftarrow   \mkern {-13mu}  \Leftrightarrow   \mkern {-13mu}  \Rightarrow  E_ \bullet</fr:tex>, such that <fr:tex>E_ \bullet</fr:tex> is <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective of finite type</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1850</fr:anchor><fr:addr>hmlg-001K</fr:addr><fr:route>hmlg-001K.xml</fr:route><fr:title>Effective homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  This is a set of notes on effective homology and algebraic topology. Main references are <fr:link
href="constructive-homological-algebra.xml"
type="local"
addr="constructive-homological-algebra">Constructive Homological Algebra and Applications</fr:link> and ...
</fr:p><fr:p>
  TODO: composition of <fr:link
href="hmlg-001I.xml"
type="local"
addr="hmlg-001I">strong homology equivalence</fr:link>, tensor product, cone, bicomplex, (effective) simplicial set, simplicial group, Kan complex
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1852</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001I</fr:addr><fr:route>hmlg-001I.xml</fr:route><fr:title>Strong homology equivalence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>strong homology equivalence</fr:strong> between chain complexes <fr:tex>C</fr:tex> and <fr:tex>D</fr:tex> is a span of chain reductions, i.e. a third chain complex <fr:tex>X</fr:tex> with <fr:tex>X  \Rightarrow \mkern {-14mu} \Rightarrow  C</fr:tex> and <fr:tex>X  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex>. We denote a strong homology equivalence with <fr:tex>C  \Leftarrow   \mkern {-13mu}  \Leftrightarrow   \mkern {-13mu}  \Rightarrow  D</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1854</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001G</fr:addr><fr:route>hmlg-001G.xml</fr:route><fr:title><fr:link
href="hmlg-001G.xml"
type="local"
addr="hmlg-001G">Perturbation</fr:link> of the larger chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a reduction <fr:tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex> and a perturbation <fr:tex>\delta _C</fr:tex> for <fr:tex>C</fr:tex>, we assume that <fr:tex>h_{ \rho }   \circ   \delta _C</fr:tex> is pointwise nilpotent, i.e. <fr:tex
display="block">\forall  c  \in  C_k,  \exists  n  \in   \mathbb {N},  \;  ( h_{ \rho } \delta _C)^n (c) = 0.</fr:tex> We can construct a new chain reduction <fr:tex>\rho ' : C'  \Rightarrow \mkern {-14mu} \Rightarrow  D'</fr:tex>, where <fr:tex>C'</fr:tex> is <fr:tex>C</fr:tex> perturbed by <fr:tex>\delta _C</fr:tex>.
</fr:p><fr:p>
  Note that this situation is much harder compared to <fr:ref
addr="hmlg-001E"
href="hmlg-001E.xml"
taxon="Construction"></fr:ref>, as it is generally impossible without the added condition.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>358</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001G</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For this construction using the third equivalent definition of a chain reduction in <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>, i.e. a homotopy operator on <fr:tex>C</fr:tex> such that <fr:tex>h  \circ  h = 0</fr:tex> and <fr:tex>h  \circ  d_C  \circ  h = h</fr:tex>.
  </fr:p>

  <fr:p>
    We need to construct a new homotopy operator such that <fr:tex>h'  \circ  h' = 0</fr:tex> and <fr:tex>h'  \circ  (d_C +  \delta _C)  \circ  h' = h'</fr:tex>. We approach this through a “perturbative” mindset. Starting with <fr:tex>h_0 = h</fr:tex>, the second equation is off by a difference of <fr:tex>h_0  \delta _C h_0</fr:tex>. We simply add this as a correction term, <fr:tex>h_1 = h_0 +  \alpha  h_0  \delta _C h_0</fr:tex> where <fr:tex>\alpha</fr:tex> is some coefficient. (Note that essentially the only terms we can consider are of the form <fr:tex>h_0  \delta _C h_0  \delta _C  \cdots  h_0</fr:tex>, since nothing else has the same type.) We still have <fr:tex>h_1  \circ  h_1 = 0</fr:tex>, and for the second equation this creates a new error term
    <fr:tex
display="block">\begin {aligned}       &amp; \quad  h_1 (d_C +  \delta _C) h_1 - h_1  \\        &amp;= (1 +  \alpha ) h_0  \delta _C h_0 + 2 ( \alpha  +  \alpha ^2) h_0  \delta _C h_0  \delta _C h_0 +  \alpha ^2 h_0  \delta _C h_0  \delta _C h_0  \delta _C h_0      \end {aligned}</fr:tex>
    and we can eliminate the first and second order part by setting <fr:tex>\alpha  = -1</fr:tex>. The natural next step would be to add a further correction <fr:tex>h_2 = h_1 +  \beta  h_0  \delta _C h_0  \delta _C h_0</fr:tex>. This turns out to require <fr:tex>\beta  = +1</fr:tex>, and so on.
  </fr:p>

  <fr:p>
    From the informal discussion above, we can conjecture the formula
    <fr:tex
display="block">h' =  \sum _{k=0}^ \infty  (-1)^k (h  \delta _C)^k h.</fr:tex>
    This reveals the reason for our pointwise nilpotency condition. With a little bit of care manipulating the infinite sum, we can prove that <fr:tex>h'  \circ  h' = 0</fr:tex> from <fr:tex>h  \circ  h = 0</fr:tex>, and the second equation follows from a nice telescopic sum
    <fr:tex
display="block">\begin {aligned}       h'  \circ  (d_C +  \delta _C)  \circ  h'       &amp;=  \sum _{i, j} (-1)^{i + j} (h  \delta _C)^i h (d_C +  \delta _C) (h  \delta _C)^j h  \\        &amp;=  \sum _{i, j} (-1)^{i + j}  \left [(h  \delta _C)^{i + j + 1} h + (h  \delta _C)^{i + j} h \right ]  \\        &amp;=  \sum _{k} (k+1) (-1)^k  \left [(h  \delta _C)^{k + 1} h + (h  \delta _C)^k h \right ]  \\        &amp;=  \sum _k (-1)^k (h  \delta _C)^k h = h'.      \end {aligned}</fr:tex></fr:p>

  <fr:p>
    We can reconstruct the other two components of the reduction <fr:tex>\iota _{ \rho ' }</fr:tex> and <fr:tex>\pi _{ \rho ' }</fr:tex> through <fr:ref
addr="hmlg-001H"
href="hmlg-001H.xml"
taxon="Theorem"></fr:ref>. In particular, <fr:tex>D'</fr:tex> is given by a perturbation of <fr:tex>D</fr:tex>. We only write down the results below for easy reference.
    <fr:tex
display="block">\begin {aligned}      \pi _{ \rho ' }  &amp;=  \sum _{k=0}^ \infty  (-1)^k  \pi _{ \rho }  ( \delta _C  h_{ \rho } )^k  \\       \iota _{ \rho ' }  &amp;=  \sum _{k=0}^ \infty  (-1)^k ( h_{ \rho }   \delta _C)^k  \iota _{ \rho }   \\       \delta _D &amp;=  \sum _{k=0}^ \infty  (-1)^k  \pi _{ \rho }   \delta _C ( h_{ \rho }   \delta _C)^k  \iota _{ \rho } .      \end {aligned}</fr:tex></fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1856</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-001H</fr:addr><fr:route>hmlg-001H.xml</fr:route><fr:title>Characterization of <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The following data are equivalent:
  <fr:ul><fr:li>A <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> <fr:tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex>.</fr:li>
    <fr:li>A splitting <fr:tex>C  \cong  D  \oplus  E</fr:tex>, where <fr:tex>E</fr:tex> is a <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>.</fr:li>
    <fr:li>A <fr:link
href="hmlg-0016.xml"
type="local"
addr="hmlg-0016">chain homotopy</fr:link> <fr:tex>h : C  \to  C</fr:tex> satisfying <fr:tex>h  \circ  h = 0</fr:tex> and <fr:tex>h  \circ  d_C  \circ  h = h</fr:tex>.</fr:li></fr:ul></fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>362</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001H</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    A chain reduction consists of maps <fr:tex>C_k  \mathrel { \smash { \xtofrom [g_k]{f_k}}} D_k</fr:tex> such that <fr:tex>f_k  \circ  g_k =  \operatorname {id}</fr:tex>. Therefore <fr:tex>C_ \bullet</fr:tex> <fr:link
href="todo.xml"
type="local"
addr="todo">splits</fr:link> as <fr:tex>D_ \bullet   \oplus  E_ \bullet</fr:tex>, and the boundary maps are preserved since <fr:tex>f, g</fr:tex> are chain maps. We have a homotopy <fr:tex>h_k : D_k  \oplus  E_k  \to  D_{k+1}  \oplus  E_{k+1}</fr:tex>, which we may write as a <fr:tex>(2  \times  2)</fr:tex>-matrix. <fr:tex>f  \circ  h = 0</fr:tex> demands the first row to be zero, and <fr:tex>h  \circ  g = 0</fr:tex> requires the first column to vanish. This leaves us with
    <fr:tex
display="block">\begin {bmatrix}       0 &amp; 0  \\        0 &amp; r_k      \end {bmatrix}</fr:tex>
    such that <fr:tex>r_{k+1}  \circ  r_k = 0</fr:tex>, since <fr:tex>h  \circ  h = 0</fr:tex>.
  </fr:p>

  <fr:p>
    Substituting the requirement that <fr:tex>h</fr:tex> is a homotopy <fr:tex>\operatorname {id}   \to  g  \circ  f</fr:tex>, we get the equation <fr:tex
display="block">d_{k+1}  \circ  r_k + r_{k-1}  \circ  d_k =  \operatorname {id} ,</fr:tex> where <fr:tex>d</fr:tex> is the boundary operator on <fr:tex>E_ \bullet</fr:tex>. In other words, <fr:tex>r</fr:tex> is a null-homotopy of <fr:tex>E_ \bullet</fr:tex>, rendering it <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>. Conversely, given <fr:tex>C  \cong  D  \oplus  E</fr:tex>, we can reconstruct <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> as the projection and inclusion maps, with <fr:tex>h</fr:tex> obtained out of <fr:tex>r</fr:tex> in the manner depicted above.
  </fr:p>

  <fr:p>
    On the other hand, given only the homotopy operator, we expect to have <fr:tex>d  \circ  h + h  \circ  d =  \operatorname {id}  - g  \circ  f</fr:tex>. And since <fr:tex>g  \circ  f</fr:tex> should be the projector of <fr:tex>C</fr:tex> onto the subspace <fr:tex>D</fr:tex>, <fr:tex>\operatorname {id}  - g  \circ  f</fr:tex> should be the projector onto <fr:tex>E</fr:tex>. We are thus led to proving <fr:tex>p = d  \circ  h + h  \circ  d</fr:tex> is indeed a projector.
    <fr:tex
display="block">\begin {aligned}       p_k  \circ  p_k &amp;= (d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k)  \circ  (d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k)  \\        &amp;= d_{k+1}  \circ   \overbrace {h_k  \circ  d_{k+1}  \circ  h_k}^{h_k} + d_{k+1}  \circ   \overbrace {h_k  \circ  h_{k-1}}^{0}  \circ  d_k  \\        &amp; \qquad  + h_{k-1}  \circ   \underbrace {d_k  \circ  d_{k+1}}_{0}  \circ  h_k +  \underbrace {h_{k-1}  \circ  d_k  \circ  h_{k-1}}_{h_{k-1}}  \circ  d_k  \\        &amp;= d_{k+1}  \circ  h_k + h_{k-1}  \circ  d_k = p_k.      \end {aligned}</fr:tex>
    Therefore we conclude that <fr:tex>p_k</fr:tex> splits <fr:tex>C_k  \cong  D_k  \oplus  E_k</fr:tex>. More over, <fr:tex>p  \circ  d = d  \circ  h  \circ  d = d  \circ  p</fr:tex>, meaning <fr:tex>p</fr:tex> is a chain map, and therefore the splitting is compatible with the boundary operator. Since <fr:tex>h  \circ  p = p  \circ  h = h  \circ  d  \circ  h = h</fr:tex>, the homotopy is also compatible with the splitting, so we can restrict it onto <fr:tex>E_k</fr:tex> to get a homotopy from <fr:tex>\operatorname {id} _E</fr:tex> to <fr:tex>0</fr:tex>.
  </fr:p>

  <fr:p>
    Finally, restricting <fr:tex>h</fr:tex> onto <fr:tex>D_k</fr:tex> we see that it must be zero, since <fr:tex>h( \operatorname {id}  - p) = h - h  \circ  d  \circ  h = 0</fr:tex>. This means that all the information of <fr:tex>h</fr:tex> can be reconstructed from the splitting, and thus all three sets of data are equivalent.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1858</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-001E</fr:addr><fr:route>hmlg-001E.xml</fr:route><fr:title><fr:link
href="hmlg-001C.xml"
type="local"
addr="hmlg-001C">Perturbation</fr:link> of the smaller chain complex in a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a reduction <fr:tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex> and a perturbation <fr:tex>\delta _D</fr:tex> for <fr:tex>D</fr:tex>, we can construct a perturbation <fr:tex>\delta _C</fr:tex> for <fr:tex>C</fr:tex>, such that the same <fr:tex>\rho</fr:tex> can serve as a reduction of the perturbed chain complexes.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1138</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-001E</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Let the reduction <fr:tex>\rho</fr:tex> be made out of the three maps <fr:tex>\pi _{ \rho }  : C  \to  D</fr:tex>, <fr:tex>\iota _{ \rho }  : D  \to  C</fr:tex> and <fr:tex>h_{ \rho }  : C  \to  C</fr:tex>. Then since <fr:tex>C</fr:tex> splits as the direct sum of <fr:tex>D</fr:tex> and an <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">acyclic</fr:link> complex, we can simply copy over the perturbation, and leave the acyclic part untouched. This gives us the definition <fr:tex>\delta _C =  \iota _{ \rho }   \circ   \delta _D  \circ   \pi _{ \rho }</fr:tex>. A quick computation shows that <fr:tex>\rho</fr:tex> is still a reduction of the perturbed chain complexes.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1860</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-001B</fr:addr><fr:route>hmlg-001B.xml</fr:route><fr:title>Terminology of <fr:link
href="hmlg-001A.xml"
type="local"
addr="hmlg-001A">effective <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  The terminology chosen here differs from that in <fr:link
href="kenzo.xml"
type="local"
addr="kenzo">Kenzo</fr:link>. What we call effective is named <fr:em>locally effective</fr:em>; and what we call effective of finite type is named <fr:em>effective</fr:em> instead.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1862</fr:anchor><fr:addr>hmlg-001D</fr:addr><fr:route>hmlg-001D.xml</fr:route><fr:title>Geometric interpretation of <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An ACC can be viewed as the algebraic distillation of a <fr:link
href="hmlg-0002.xml"
type="local"
addr="hmlg-0002">chain complex</fr:link>. The generators in dimension <fr:tex>n</fr:tex> are regarded as <fr:tex>n</fr:tex>-cells. However, we only record a formal sum of the boundaries, and forget the exact configuration. Hence, ACC is a suitable middle ground for both geometric transformations and algebraic operations.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1864</fr:anchor><fr:addr>hmlg-001F</fr:addr><fr:route>hmlg-001F.xml</fr:route><fr:title>Geometric interpretation of <fr:link
href="hmlg-001C.xml"
type="local"
addr="hmlg-001C">perturbations</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">ACCs</fr:link>, the effect of a perturbation is to “reconnect” the cells. But it may not create or delete cells, since the abelian groups are unchanged.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1866</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001C</fr:addr><fr:route>hmlg-001C.xml</fr:route><fr:title>Perturbation of chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>perturbation</fr:strong> of a chain complex with boundary operator <fr:tex>d</fr:tex> is an operator <fr:tex>\delta</fr:tex> of degree <fr:tex>(-1)</fr:tex> such that <fr:tex>d +  \delta</fr:tex> also forms a boundary operator.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1868</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-001A</fr:addr><fr:route>hmlg-001A.xml</fr:route><fr:title>Effective <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>25</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-0013.xml"
type="local"
addr="hmlg-0013">algebraic cellular complex</fr:link>, suppose we can encode the basis sets <fr:tex>C_ \bullet</fr:tex> such that they have <fr:link
href="todo.xml"
type="local"
addr="todo">decidable equality</fr:link>, and the maps <fr:tex>C_k  \to   \mathbb {Z}[C_{k-1}]</fr:tex> are computable, then we say the ACC is <fr:strong>effective</fr:strong>. Suppose further that <fr:tex>C_ \bullet</fr:tex> are (computably) finite sets, then we say it is <fr:strong>effective of finite type</fr:strong>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1870</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0018</fr:addr><fr:route>hmlg-0018.xml</fr:route><fr:title>An additive functor is exact iff it preserves quasi-isomorphisms</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F :  \mathcal { A }   \to   \mathcal { B }</fr:tex> between <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian categories</fr:link>, it is <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link> iff it sends <fr:link
href="hmlg-000C.xml"
type="local"
addr="hmlg-000C">quasi-isomorphisms</fr:link> to quasi-isomorphisms.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1227</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-0018</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Suppose an additive functor preserves quasi-isomorphisms. Since a chain complex is exact iff it is quasi-isomorphic to the zero complex, the functor must preserve exactness.
  </fr:p>

  <fr:p>
    On the other hand, <fr:link
href="todo.xml"
type="local"
addr="todo">exact functors commute with homology functors</fr:link>. Therefore if <fr:tex>f : C_ \bullet   \to  D_ \bullet</fr:tex> is a quasi-isomorphism, <fr:tex>H_n (f)</fr:tex> are all isomorphisms. Therefore <fr:tex>H_n (F(f)) = F(H_n(f))</fr:tex> is the functorial action on an isomorphism, which must also produce an isomorphism.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1872</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0016</fr:addr><fr:route>hmlg-0016.xml</fr:route><fr:title>Chain homotopy</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_ \bullet</fr:tex> and <fr:tex>D_ \bullet</fr:tex> with two <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain maps</fr:link> <fr:tex>f, g : C  \to  D</fr:tex> between them, a <fr:strong>chain homotopy</fr:strong> from <fr:tex>f</fr:tex> to <fr:tex>g</fr:tex> is given by a family of maps <fr:tex>h_n : C_n  \to  D_{n+1}</fr:tex>, such that
  <fr:tex
display="block">d_{n+1}  \circ  h_n + h_{n-1}  \circ  d_n = f_n - g_n.</fr:tex>
  Note that the two <fr:tex>d</fr:tex>’s denote the boundary map of different chain complexes.
</fr:p><fr:p>
  The chain homotopy can be written as <fr:tex>h : f  \to  g</fr:tex> or as <fr:tex>h : C  \to  D</fr:tex>. This causes no confusion, and the latter is convenient in situations where the maps <fr:tex>f, g</fr:tex> matter less than their difference <fr:tex>f - g</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1874</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0017</fr:addr><fr:route>hmlg-0017.xml</fr:route><fr:title>Chain reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C, D</fr:tex>, a <fr:strong>chain reduction</fr:strong> consists of a chain map <fr:tex>\pi  : C  \to  D</fr:tex>, a chain map <fr:tex>\iota  : D  \to  C</fr:tex> and a <fr:link
href="hmlg-0016.xml"
type="local"
addr="hmlg-0016">chain homotopy</fr:link> <fr:tex>h :  \operatorname {id}   \to  g  \circ  f</fr:tex>, such that <fr:tex>\pi   \circ   \iota  =  \operatorname {id}</fr:tex>, and <fr:tex
display="block">\pi   \circ  h = h  \circ   \iota  = h  \circ  h = 0.</fr:tex> Here the compositions are understood to have the appropriate subscript so the degrees match.
</fr:p><fr:p>
  We write the reduction as <fr:tex>\rho  : C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex>. The three components are denoted <fr:tex>\pi _{ \rho }  : C  \to  D</fr:tex>, <fr:tex>\iota _{ \rho }  : D  \to  C</fr:tex> and <fr:tex>h_{ \rho }  : C  \to  C</fr:tex>, respectively.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1876</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0019</fr:addr><fr:route>hmlg-0019.xml</fr:route><fr:title>Chain reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  For a <fr:link
href="hmlg-0017.xml"
type="local"
addr="hmlg-0017">chain reduction</fr:link> <fr:tex>C  \Rightarrow \mkern {-14mu} \Rightarrow  D</fr:tex>, <fr:tex>D</fr:tex> is embedded as a subcomplex of <fr:tex>C</fr:tex>. It is cleanly separated, indicating that <fr:link
href="hmlg-001H.xml"
type="local"
addr="hmlg-001H">it is split</fr:link>. The other part of <fr:tex>C</fr:tex> is <fr:link
href="todo.xml"
type="local"
addr="todo">split exact</fr:link>, and so its homology component is drawn as empty, with the components separated.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="7e3bc1462d3f87570cd3d40576c205a8"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
  %tex
  \begin{scope}
    \clip (-1.9, -1.4) rectangle (5.9, 1.7);
    \tikzset{every path/.style={thick}}

    \draw (-3.6,0) -- (-0.4,0) arc (0:180:1.6);
    \draw (-1.6,0) -- (1.6,0) arc (0:180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4,0) -- (3.6,0) arc (0:180:1.6);
    \draw (2.4,0) -- (5.6,0) arc (0:180:1.6);
    \draw (4.4,0) -- (7.6,0) arc (0:180:1.6);

    % arccos(1/1.6) = 51.318deg
    \draw (-1.6, -0.1) -- (-0.4, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (0.4, -0.1) -- (1.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \filldraw[fill = blue!80!yellow, fill opacity=0.2]
      (2.4, -0.1) -- (3.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
    \draw (4.4, -0.1) -- (5.6, -0.1) arc (0:-51.318:1.6) arc ({51.318-180}:-180:1.6);
  \end{scope}
  \node at (2, -1.6) {\(C_n\)};
  \node at (2, 1.1) {\(H_n\)};
  \draw[thick, decoration={brace, mirror}, decorate] (-2.1, 1.6) -- node[left] {\(C_\bullet\)} (-2.1, -1.35);
  \draw[thick, decoration={brace}, decorate] (6.1, 1.6) -- node[right] {\(D_\bullet\)} (6.1, 0);
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1878</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0013</fr:addr><fr:route>hmlg-0013.xml</fr:route><fr:title>Algebraic cellular complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>algebraic cellular complex</fr:strong> (or ACC) is a <fr:link
href="hmlg-0002.xml"
type="local"
addr="hmlg-0002">chain complex</fr:link> of free abelian groups. The generators are called <fr:strong>cells</fr:strong>, and the boundary maps can be expressed using the generators as a basis, yielding the <fr:strong>incidence matrices</fr:strong>.
</fr:p><fr:p>
  More precisely, we may define an ACC as a sequence of sets <fr:tex>C_ \bullet</fr:tex>, with a sequence of functions <fr:tex>d : C_k  \to   \mathbb {Z}[C_{k-1}]</fr:tex>, such that <fr:tex>d^2 = 0</fr:tex> is satisfied. When a generator has non-zero coefficient in some <fr:tex>d \sigma</fr:tex>, the generator is called a <fr:strong>face</fr:strong> of <fr:tex>\sigma</fr:tex>.
</fr:p><fr:p>
  Note that the generators of these chain groups are <fr:link
href="ualg-0006.xml"
type="local"
addr="ualg-0006">canonically chosen</fr:link> as part of the data. So a more accurate definition is a chain complex in the <fr:link
href="ualg-0004.xml"
type="local"
addr="ualg-0004">Kleisli category</fr:link> of abelian groups.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1880</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0015</fr:addr><fr:route>hmlg-0015.xml</fr:route><fr:title>Filtered chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Combining <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization"></fr:ref> and <fr:ref
addr="hmlg-0014"
href="hmlg-0014.xml"
taxon="Visualization"></fr:ref>, we arrive at the following picture. Each family of colors corresponds to the filtration <fr:tex>F_ \bullet  C_n</fr:tex> in one dimension, and the different shades corresponds to the degree in the filtration.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="5edffb1224886d5cf123812f3dbf58f4"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
   \tikzset {every path/.style={thick, fill opacity = 0.2, line join = round}}
   \foreach   \depth  in {4,3,2,1} {
     \fill [blue!80!yellow] (-4,4) -- (0,0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
     \fill [green!80!purple] (0,0) -- (4,4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
     \fill [yellow!80!red] (4,4) -- (8,0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
  }

   \foreach   \depth  in {4,3,2,1} {
     \draw  ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
     \draw  ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
     \draw  ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
  }
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  Note that we arranged so that only the higher degree (i.e. the lighter color) components may touch the lower degree components in the next dimension. So the intersection is a triangle shape instead of a complete diamond grid. This corresponds to the requirement that the boundary map sends <fr:tex>F_i C_j</fr:tex> to <fr:tex>F_i C_{j+1}</fr:tex>.
</fr:p><fr:p>
  We can see the associated spectral sequences directly from the visualization. We start with the graded components, which form strands of chain complexes. Here the second degree is highlighted.
  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="edacd3ac0aa6b36988f534239518c954"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
     \tikzset {every path/.style={thick, fill opacity = 0.4, line join = round}}
     \foreach   \depth  in {2} {
       \fill [blue!80!yellow] ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
       \fill [green!80!purple] ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
       \fill [yellow!80!red] ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
    }

     \foreach   \depth  in {4,3,2,1} {
       \draw  ({ \depth  - 5},4) -- ({ \depth  - 1},0) -- ({ \depth }, 0) -- ({ \depth  - 4}, 4) -- cycle;
       \draw  ({ \depth  - 1},0) -- ({ \depth  + 3},4) -- ({ \depth  + 4}, 4) -- ({ \depth }, 0) -- cycle;
       \draw  ({ \depth  + 3},4) -- ({ \depth  + 7},0) -- ({ \depth  + 8}, 0) -- ({ \depth  + 4}, 4) -- cycle;
    }
   \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>

  The homology chops off the intersections, and so we enter the first page of the spectral sequence, consisting of strands with the top and bottom part cut off. Repeatedly taking homology, we are finally left with the rectangular part in the middle, which is the graded components of the desired homology group of the entire complex.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1882</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0014</fr:addr><fr:route>hmlg-0014.xml</fr:route><fr:title>Filtered object</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can visualize a filtered object <fr:tex>F_1 A  \subseteq  F_2 A  \subseteq  F_3 A  \subseteq  A</fr:tex> as nested rectangles.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="360b99de446e14c5d12fdd97287432e2"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
   \tikzset {every path/.style={thick, fill = blue!80!yellow, fill opacity = 0.1}}
   \filldraw  (0,-1) rectangle (4,1);
   \filldraw  (0,-1) rectangle (3,1);
   \filldraw  (0,-1) rectangle (2,1);
   \filldraw  (0,-1) rectangle (1,1);
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  The graded components of this filtration are the individual rectangular regions.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1884</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-0012</fr:addr><fr:route>hmlg-0012.xml</fr:route><fr:title>Long exact sequence of homologies</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a short exact sequence of chain complexes
  <fr:tex
display="block">0  \to  A_ \bullet   \to  B_ \bullet   \to  C_ \bullet   \to  0,</fr:tex>
  there is a long exact sequence of homology groups
  <fr:tex
display="block">\cdots   \to  H_{n+1}(C)  \xrightarrow { \partial } H_n(A)  \to  H_n (B)  \to  H_n (C)  \xrightarrow { \partial } H_{n-1} (A)  \to   \cdots</fr:tex>
  The map <fr:tex>\partial</fr:tex> here is, after unpacking some quotients, simply the boundary map <fr:tex>B_n  \to  B_{n-1}</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1886</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-0010</fr:addr><fr:route>hmlg-0010.xml</fr:route><fr:title>Snake lemma</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link>, given the middle two rows of the diagram
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="281e810eff5b89c40221b433b27ffeca"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  &amp; { \ker  f} &amp; { \ker  g} &amp; { \ker  h}  \\ 
  { \ker  i} &amp;  \bullet  &amp;  \bullet  &amp;  \bullet  &amp; 0  \\ 
  0 &amp;  \bullet  &amp;  \bullet  &amp;  \bullet  &amp; { \operatorname {coker}  j}  \\ 
  &amp; { \operatorname {coker}  f} &amp; { \operatorname {coker}  g} &amp; { \operatorname {coker}  h}
   \arrow ["f", from=2-2, to=3-2]
   \arrow ["g", from=2-3, to=3-3]
   \arrow ["h", from=2-4, to=3-4]
   \arrow [from=1-2, to=2-2]
   \arrow [from=1-3, to=2-3]
   \arrow [from=1-4, to=2-4]
   \arrow [blue, &gt;-&gt;, out=90, in=180, from=2-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow ["i", from=2-2, to=2-3]
   \arrow [from=2-3, to=2-4]
   \arrow [from=3-2, to=3-3]
   \arrow ["j", from=3-3, to=3-4]
   \arrow [from=3-4, to=3-5]
   \arrow [blue, -&gt;&gt;, out=0, in=-90, from=4-4, to=3-5]
   \arrow [from=3-2, to=4-2]
   \arrow [from=3-3, to=4-3]
   \arrow [from=3-4, to=4-4]
   \arrow [blue, from=1-2, to=1-3]
   \arrow [blue, from=1-3, to=1-4]
   \arrow [blue, from=4-2, to=4-3]
   \arrow [blue, from=4-3, to=4-4]
   \arrow [blue, dashed, out=0, in=180, from=1-4, to=4-2]
   \arrow [from=2-4, to=2-5]
   \arrow [from=3-1, to=3-2]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  such that the rows are exact, we can take the kernels and cokernels, which forms a long exact sequence of blue arrows, <fr:tex>0  \to   \ker  i  \to   \ker  f  \to   \ker  g  \to   \ker  h  \xrightarrow { \partial }  \operatorname {coker}  f  \to   \operatorname {coker}  g  \to   \operatorname {coker}  h  \to   \operatorname {coker}  j  \to  0</fr:tex>. In particular, if <fr:tex>i</fr:tex> is monic and <fr:tex>j</fr:tex> is epic, this leads to a six-term exact sequence.
</fr:p><fr:p>
  There are multiple ways to prove this claim. We can first <fr:link
href="todo.xml"
type="local"
addr="todo">prove it in categories of modules</fr:link>, and <fr:link
href="hmlg-0011.xml"
type="local"
addr="hmlg-0011">use the Freyd–Mitchell embedding</fr:link>. We can also use <fr:link
href="todo.xml"
type="local"
addr="todo">pseudo-elements</fr:link> to <fr:link
href="todo.xml"
type="local"
addr="todo">perform diagram chases</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1888</fr:anchor><fr:addr>hmlg-0011</fr:addr><fr:route>hmlg-0011.xml</fr:route><fr:title>Using the <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">Freyd–Mitchell embedding</fr:link> to prove theorems</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We use the <fr:link
href="hmlg-0010.xml"
type="local"
addr="hmlg-0010">snake lemma</fr:link> as an example to demonstrate how the embedding theorem works in practice. The main technique is to avoid dealing with large categories.
</fr:p><fr:p>
  Suppose we have already <fr:link
href="todo.xml"
type="local"
addr="todo">proved</fr:link> the theorem in module categories. Given a snake lemma diagram in an arbitrary (locally small) <fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">abelian category</fr:link> <fr:tex>\mathcal { C }</fr:tex>, we take the smallest full subcategory closed under finite limits and colimits. This results in a small category <fr:tex>\mathcal { D }</fr:tex>, which we can embed in a module category <fr:tex>R \text {-} \mathsf { Mod }</fr:tex>.
</fr:p><fr:p>
  Now, the snake lemma in module categories implies that we have the required maps that forms an exact sequence. Since <fr:tex>\mathcal { D }</fr:tex> is a full abelian subcategory of <fr:tex>R \text {-} \mathsf { Mod }</fr:tex>, these morphisms are contained in <fr:tex>\mathcal { D }</fr:tex>, and the sequence is still exact. And since <fr:tex>\mathcal { D }</fr:tex> is a full abelian subcategory of <fr:tex>\mathcal { C }</fr:tex>, the sequence is again exact in <fr:tex>\mathcal { C }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1890</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X  \to  Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X /  \ker  f</fr:tex>, and the cokernel <fr:tex>Y /  \operatorname {im}  f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1892</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1325</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>\mathsf { Ab }</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, an <fr:tex>\mathsf { Ab }</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1327</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i  \to  X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom (X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod _i X_i  \to   \prod _i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1331</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X  \to  0  \to  Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X  \to  Y</fr:tex>, the following composition
    <fr:tex
display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X  \oplus  X  \to  Y  \oplus  Y</fr:tex> is given by a <fr:tex>2  \times  2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f  \oplus  g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1333</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F :  \mathcal { C }   \to   \mathcal { D }</fr:tex> between them, the following are equivalent:
  <fr:ul><fr:li>The functor preserves finite products.</fr:li>
    <fr:li>The functor preserves finite coproducts.</fr:li>
    <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom _{ \mathcal { C } }(X, Y)</fr:tex>, i.e. it is an <fr:tex>\mathsf { Ab }</fr:tex>-enriched functor.</fr:li></fr:ul>
  In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1220</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X)  \times  F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1)  \to  1</fr:tex> and <fr:tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1337</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F  \dashv  G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1335</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1341</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>\mathsf { Ab }</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1339</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1343</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X  \to  Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X /  \ker  f</fr:tex>, and the cokernel <fr:tex>Y /  \operatorname {im}  f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1345</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds:
  <fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
    <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
    <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1348</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F :  \mathcal { A }   \to   \mathcal { B }</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.

  <fr:ul><fr:li>It preserves kernels.</fr:li>
    <fr:li>It preserves finite limits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0  \to  A  \to  B  \to  C.</fr:tex></fr:li></fr:ul></fr:p><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
  <fr:ul><fr:li>It preserves cokernels.</fr:li>
    <fr:li>It preserves finite colimits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A  \to  B  \to  C  \to  0.</fr:tex></fr:li></fr:ul>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A  \to  B  \to  C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1214</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general coequalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A  \rightarrowtail  B  \to  C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B  \to  C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1894</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>\mathsf { Ab }</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1339</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1896</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="842478f248bf487e86aa9d32eaa644a3"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [" \sim ", from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1898</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F :  \mathcal { A }   \to   \mathcal { B }</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.

  <fr:ul><fr:li>It preserves kernels.</fr:li>
    <fr:li>It preserves finite limits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0  \to  A  \to  B  \to  C.</fr:tex></fr:li></fr:ul></fr:p><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
  <fr:ul><fr:li>It preserves cokernels.</fr:li>
    <fr:li>It preserves finite colimits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A  \to  B  \to  C  \to  0.</fr:tex></fr:li></fr:ul>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A  \to  B  \to  C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1214</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general coequalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A  \rightarrowtail  B  \to  C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B  \to  C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1900</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Z</fr:addr><fr:route>hmlg-000Z.xml</fr:route><fr:title>Monomorphisms can be expressed using finite limits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a morphism <fr:tex>f : X  \to  Y</fr:tex> in an arbitrary category, we can express the condition of being monic using finite limits.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1401</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Z</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We claim that <fr:tex>f</fr:tex> being monic is equivalent to the following square being a pullback square:
  </fr:p>

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="8008d22f1883cef2d1bfcd422112257a"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
    X &amp; X  \\ 
    X &amp; Y
     \arrow ["f"', from=2-1, to=2-2]
     \arrow ["f", from=1-2, to=2-2]
     \arrow [" \operatorname {id} "', from=1-1, to=2-1]
     \arrow [" \operatorname {id} ", from=1-1, to=1-2]
     \arrow [" \lrcorner "{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
   \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  <fr:p>
    For the forward implication, we consider the diagram
  </fr:p>

  
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="bac489a29cd45027c9697eb624b68ec5"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
    Z  \\ 
    &amp; X &amp; X  \\ 
    &amp; X &amp; Y
     \arrow ["f"', from=3-2, to=3-3]
     \arrow ["f", from=2-3, to=3-3]
     \arrow [" \operatorname {id} "', from=2-2, to=3-2]
     \arrow [" \operatorname {id} ", from=2-2, to=2-3]
     \arrow [" \lrcorner "{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
     \arrow [dashed, from=1-1, to=2-2]
     \arrow ["g"', curve={height=6pt}, from=1-1, to=3-2]
     \arrow ["h", curve={height=-6pt}, from=1-1, to=2-3]
   \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>


  <fr:p>
    Since <fr:tex>f</fr:tex> is mono, this diagram commutes iff <fr:tex>g = h</fr:tex>, in which case there is a unique way to fill in the dashed arrow, which is <fr:tex>g</fr:tex>.
  </fr:p>

  <fr:p>
    On the other hand, if the diagram is a pullback, then for every pair of morphisms <fr:tex>g, h : Z  \rightrightarrows  X</fr:tex>, we can draw the diagram above, and obtain the dashed arrow <fr:tex>k : Z  \to  X</fr:tex>. The diagram commuting implies <fr:tex>g =  \operatorname {id}   \circ  k = h</fr:tex>.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1902</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>\mathsf { Ab }</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, an <fr:tex>\mathsf { Ab }</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1904</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000F</fr:addr><fr:route>hmlg-000F.xml</fr:route><fr:title>Freyd–Mitchell embedding theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Any small abelian category can be realized as a full abelian subcategory of a category of left <fr:tex>R</fr:tex>-modules for some ring <fr:tex>R</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000F</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  (TODO)
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1906</fr:anchor><fr:addr>hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1369</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{ \alpha ,  \bullet }</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y  \subseteq  X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1360</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n}  \to  A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta  : A_{m, n}  \to  A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 =  \delta ^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m,  \bullet }</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1362</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m,  \bullet }</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1365</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="842478f248bf487e86aa9d32eaa644a3"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [" \sim ", from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1371</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1325</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>\mathsf { Ab }</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, an <fr:tex>\mathsf { Ab }</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1327</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i  \to  X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom (X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod _i X_i  \to   \prod _i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1331</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X  \to  0  \to  Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X  \to  Y</fr:tex>, the following composition
    <fr:tex
display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X  \oplus  X  \to  Y  \oplus  Y</fr:tex> is given by a <fr:tex>2  \times  2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f  \oplus  g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1333</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F :  \mathcal { C }   \to   \mathcal { D }</fr:tex> between them, the following are equivalent:
  <fr:ul><fr:li>The functor preserves finite products.</fr:li>
    <fr:li>The functor preserves finite coproducts.</fr:li>
    <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom _{ \mathcal { C } }(X, Y)</fr:tex>, i.e. it is an <fr:tex>\mathsf { Ab }</fr:tex>-enriched functor.</fr:li></fr:ul>
  In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1220</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X)  \times  F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1)  \to  1</fr:tex> and <fr:tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1337</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F  \dashv  G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1335</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1341</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>\mathsf { Ab }</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1339</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1343</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X  \to  Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X /  \ker  f</fr:tex>, and the cokernel <fr:tex>Y /  \operatorname {im}  f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1345</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds:
  <fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
    <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
    <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1348</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F :  \mathcal { A }   \to   \mathcal { B }</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.

  <fr:ul><fr:li>It preserves kernels.</fr:li>
    <fr:li>It preserves finite limits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0  \to  A  \to  B  \to  C.</fr:tex></fr:li></fr:ul></fr:p><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
  <fr:ul><fr:li>It preserves cokernels.</fr:li>
    <fr:li>It preserves finite colimits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A  \to  B  \to  C  \to  0.</fr:tex></fr:li></fr:ul>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A  \to  B  \to  C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1214</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general coequalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A  \rightarrowtail  B  \to  C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B  \to  C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1908</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds:
  <fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
    <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
    <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1910</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i  \to  X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom (X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod _i X_i  \to   \prod _i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1912</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F :  \mathcal { C }   \to   \mathcal { D }</fr:tex> between them, the following are equivalent:
  <fr:ul><fr:li>The functor preserves finite products.</fr:li>
    <fr:li>The functor preserves finite coproducts.</fr:li>
    <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom _{ \mathcal { C } }(X, Y)</fr:tex>, i.e. it is an <fr:tex>\mathsf { Ab }</fr:tex>-enriched functor.</fr:li></fr:ul>
  In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1220</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X)  \times  F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1)  \to  1</fr:tex> and <fr:tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1914</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F  \dashv  G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1335</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1916</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X  \to  0  \to  Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X  \to  Y</fr:tex>, the following composition
    <fr:tex
display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X  \oplus  X  \to  Y  \oplus  Y</fr:tex> is given by a <fr:tex>2  \times  2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f  \oplus  g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1918</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n}  \to  A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta  : A_{m, n}  \to  A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 =  \delta ^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m,  \bullet }</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1920</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{ \alpha ,  \bullet }</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1922</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m,  \bullet }</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1924</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{ \alpha ,  \bullet }</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y  \subseteq  X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1360</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n}  \to  A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta  : A_{m, n}  \to  A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 =  \delta ^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m,  \bullet }</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1362</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m,  \bullet }</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1365</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="842478f248bf487e86aa9d32eaa644a3"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [" \sim ", from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1926</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0  \to  A  \to  B  \to  C  \to  0.</fr:tex> Short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1928</fr:anchor><fr:taxon>Remark</fr:taxon><fr:addr>hmlg-000N</fr:addr><fr:route>hmlg-000N.xml</fr:route><fr:title>Signs in bicomplexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Some sources require a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> to have anti-commuting squares. In this way, the <fr:link
href="hmlg-000M.xml"
type="local"
addr="hmlg-000M">total complex</fr:link> has the simpler differential <fr:tex>\partial  = d +  \delta</fr:tex>. These two definitions are convertible by flipping the signs of the horizontal boundary maps in every other row.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1930</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000M</fr:addr><fr:route>hmlg-000M.xml</fr:route><fr:title>Total complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> <fr:tex>C_{ \bullet ,  \bullet }</fr:tex>, we can collapse it into a chain complex in two ways. In either way, <fr:tex>C_{p, q}</fr:tex> is contained in the total complex at degree <fr:tex>(m+n)</fr:tex>. We can use the direct sum to combine them: <fr:tex
display="block">\operatorname {Tot} ^ \oplus (C)_n =  \bigoplus _{n = p+q} C_{p, q},</fr:tex> or the direct product: <fr:tex
display="block">\operatorname {Tot} ^ \Pi (C)_n =  \prod _{n=p+q} C_{p,q}.</fr:tex></fr:p><fr:p>
  The total differential acts on elements in <fr:tex>C_{p, q}</fr:tex> by <fr:tex
display="block">\partial (x) = d(x) + (-1)^q  \delta (x),</fr:tex> where <fr:tex>d</fr:tex> is the vertical map, and <fr:tex>\delta</fr:tex> the horizontal map. The <fr:link
href="hmlg-000N.xml"
type="local"
addr="hmlg-000N">sign</fr:link> here is to ensure that <fr:tex>\partial ^2 = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1932</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1934</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="0a3470a2b5e0555203bd72cc6278c23f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1936</fr:anchor><fr:addr>hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title>Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex>C_n</fr:tex> freely generated by cells of dimension <fr:tex>n</fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex>d_n : C_n  \to  C_{n-1}</fr:tex>. The critical feature of the operator is <fr:tex
display="block">d_{n-1}  \circ  d_n = 0,</fr:tex> simply written as <fr:tex>d^2 = 0</fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1420</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title>Chain complex of abelian groups</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex>G_ \bullet</fr:tex> together with homomorphisms <fr:tex>d_n : G_n  \to  G_{n-1}</fr:tex>, such that <fr:tex>d_{n-1}  \circ  d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1421</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title>Chain complex of <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of <fr:tex>R</fr:tex>-modules is given by a sequence of modules <fr:tex>M_ \bullet</fr:tex> together with <fr:tex>R</fr:tex>-linear maps <fr:tex>d_n : R_n  \to  R_{n-1}</fr:tex>, such that <fr:tex>d_{n-1}  \circ  d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n  \to  C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1}  \to  C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1424</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="0a3470a2b5e0555203bd72cc6278c23f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1426</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_ \bullet , D_ \bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n  \to  D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cd317d151ec3ec11b0ab2f2a4fe88848"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow ["d", from=1-3, to=1-4]
   \arrow ["{f_n}"', from=1-3, to=2-3]
   \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
   \arrow ["d"', from=2-3, to=2-4]
   \arrow ["d"', from=2-2, to=2-3]
   \arrow ["d", from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1429</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0009</fr:addr><fr:route>hmlg-0009.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Appropriately combing two copies of <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization"></fr:ref>, we get the following picture for a <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="ee86aec03370b98cc616ae639df13044"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1433</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C  \to  D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C)  \to  H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f  \circ  g</fr:tex> induces composition homomorphism <fr:tex>(f  \circ  g)_* = f_*  \circ  g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1431</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Referring to <fr:ref
addr="hmlg-0009"
href="hmlg-0009.xml"
taxon="Visualization"></fr:ref> makes all the moving parts clear here. Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1435</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1437</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1439</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0  \to  A  \to  B  \to  C  \to  0.</fr:tex> Short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1441</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1938</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_ \bullet , D_ \bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n  \to  D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cd317d151ec3ec11b0ab2f2a4fe88848"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow ["d", from=1-3, to=1-4]
   \arrow ["{f_n}"', from=1-3, to=2-3]
   \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
   \arrow ["d"', from=2-3, to=2-4]
   \arrow ["d"', from=2-2, to=2-3]
   \arrow ["d", from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1940</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0009</fr:addr><fr:route>hmlg-0009.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Appropriately combing two copies of <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization"></fr:ref>, we get the following picture for a <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="ee86aec03370b98cc616ae639df13044"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1942</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C  \to  D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C)  \to  H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f  \circ  g</fr:tex> induces composition homomorphism <fr:tex>(f  \circ  g)_* = f_*  \circ  g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1431</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Referring to <fr:ref
addr="hmlg-0009"
href="hmlg-0009.xml"
taxon="Visualization"></fr:ref> makes all the moving parts clear here. Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1944</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n  \to  C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1}  \to  C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1946</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1948</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1950</fr:anchor><fr:addr>hmlg-0001</fr:addr><fr:route>hmlg-0001.xml</fr:route><fr:title>Homological Algebra</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a set of notes primarily based on <fr:link
href="homological-algebra.xml"
type="local"
addr="homological-algebra">Weibel</fr:link> and <fr:link
href="wwli.xml"
type="local"
addr="wwli">Wen-Wei Li</fr:link>’s <fr:link
href="methods-of-algebra-2.xml"
type="local"
addr="methods-of-algebra-2">unpublished book</fr:link>.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1443</fr:anchor><fr:addr>hmlg-0006</fr:addr><fr:route>hmlg-0006.xml</fr:route><fr:title>Chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex>C_n</fr:tex> freely generated by cells of dimension <fr:tex>n</fr:tex> (i.e. encoding the formal sums of cells), and a <fr:em>boundary</fr:em> operator <fr:tex>d_n : C_n  \to  C_{n-1}</fr:tex>. The critical feature of the operator is <fr:tex
display="block">d_{n-1}  \circ  d_n = 0,</fr:tex> simply written as <fr:tex>d^2 = 0</fr:tex>, reflecting a deep geometric phenomenon that <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">the boundary of a shape doesn’t have any boundary itself</html:mark>.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1420</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0002</fr:addr><fr:route>hmlg-0002.xml</fr:route><fr:title>Chain complex of abelian groups</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex>G_ \bullet</fr:tex> together with homomorphisms <fr:tex>d_n : G_n  \to  G_{n-1}</fr:tex>, such that <fr:tex>d_{n-1}  \circ  d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>This is eligible to immediate generalization.</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1421</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0003</fr:addr><fr:route>hmlg-0003.xml</fr:route><fr:title>Chain complex of <fr:tex>R</fr:tex>-modules</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:meta
name="generalizes">hmlg-0002</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
  A chain complex of <fr:tex>R</fr:tex>-modules is given by a sequence of modules <fr:tex>M_ \bullet</fr:tex> together with <fr:tex>R</fr:tex>-linear maps <fr:tex>d_n : R_n  \to  R_{n-1}</fr:tex>, such that <fr:tex>d_{n-1}  \circ  d_n = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1422</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0007</fr:addr><fr:route>hmlg-0007.xml</fr:route><fr:title>Components of a chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a <fr:link
href="hmlg-0003.xml"
type="local"
addr="hmlg-0003">chain complex</fr:link>, the <fr:strong>cycles</fr:strong> <fr:tex>Z_n</fr:tex> of dimension <fr:tex>n</fr:tex> are given by the kernel of <fr:tex>d_n : C_n  \to  C_{n-1}</fr:tex>. The <fr:strong>boundaries</fr:strong> <fr:tex>B_n</fr:tex> are given by the image of <fr:tex>d_{n+1} : C_{n+1}  \to  C_n</fr:tex>. The equation <fr:tex>d^2 = 0</fr:tex> is equivalent to <fr:tex
display="block">0  \subseteq  B_n  \subseteq  Z_n  \subseteq  C_n.</fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link
href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms"
type="external">homomorphism theorem</fr:link>, the quotient <fr:tex>C_n / Z_n</fr:tex> is isomorphic to the image of <fr:tex>d_n</fr:tex>, which is the next boundary <fr:tex>B_{n-1}</fr:tex>. On the other hand, the <fr:strong>homology groups</fr:strong> <fr:tex>H_n(C)</fr:tex> are defined as the quotient <fr:tex>Z_n/B_n</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1424</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-000A</fr:addr><fr:route>hmlg-000A.xml</fr:route><fr:title>Chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link
href="https://www.3blue1brown.com/blog/exact-sequence-picturebook"
type="external">here</fr:link>.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="0a3470a2b5e0555203bd72cc6278c23f"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
<fr:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1426</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0008</fr:addr><fr:route>hmlg-0008.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two chain complexes <fr:tex>C_ \bullet , D_ \bullet</fr:tex>, the natural notion of morphisms between them is <fr:strong>chain maps</fr:strong>, i.e. a sequence of maps <fr:tex>f_n : C_n  \to  D_n</fr:tex> such that all the squares commute.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="cd317d151ec3ec11b0ab2f2a4fe88848"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
   \cdots  &amp; {C_{n+1}} &amp; {C_n} &amp; {C_{n-1}} &amp;  \cdots   \\ 
   \cdots  &amp; {D_{n+1}} &amp; {D_n} &amp; {D_{n-1}} &amp;  \cdots 
   \arrow ["d", from=1-3, to=1-4]
   \arrow ["{f_n}"', from=1-3, to=2-3]
   \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
   \arrow ["d"', from=2-3, to=2-4]
   \arrow ["d"', from=2-2, to=2-3]
   \arrow ["d", from=1-2, to=1-3]
   \arrow [from=1-1, to=1-2]
   \arrow [from=2-1, to=2-2]
   \arrow [from=1-4, to=1-5]
   \arrow [from=2-4, to=2-5]
   \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1429</fr:anchor><fr:taxon>Visualization</fr:taxon><fr:addr>hmlg-0009</fr:addr><fr:route>hmlg-0009.xml</fr:route><fr:title>Chain map</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Appropriately combing two copies of <fr:ref
addr="hmlg-000A"
href="hmlg-000A.xml"
taxon="Visualization"></fr:ref>, we get the following picture for a <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link>. The upper and lower rows form chain complexes, while each four adjacent blocks form a pattern representing commutative squares.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz">
    <fr:embedded-tex
hash="ee86aec03370b98cc616ae639df13044"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture} 
    [scale=2]
  \clip (-0.5, -1.1) rectangle (3, 1.1);

  \tikzset{every path/.style={very thick, transform shape}}
  \tikzset{chain/.pic = {
    \filldraw[fill opacity=0.1] (0, -0.5) -- (0, 1) -- (2.5, 1) -- (2.5, 0.5) arc (0:-90:1) -- cycle;
  }}

  \draw[blue!80!pink] (-1.5,0)++(-0.01,-0.01) pic {chain};
  \draw[blue!60!pink] (1,0)++(-0.01,-0.01) pic[scale=-1] {chain};

  \draw[green!80!red] (0,0) pic {chain};
  \draw[green!60!red] (2.5,0) pic[scale=-1] {chain};

  \draw[red!80!cyan] (1.5,0)++(0.01,0.01) pic {chain};
  \draw[red!60!cyan] (4,0)++(0.01,0.01) pic[scale=-1] {chain};
 \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1433</fr:anchor><fr:taxon>Construction</fr:taxon><fr:addr>hmlg-000B</fr:addr><fr:route>hmlg-000B.xml</fr:route><fr:title>Chain maps induce maps on homology</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A chain map <fr:tex>f : C  \to  D</fr:tex> induces a family of homomorphisms <fr:tex>f_* : H_n (C)  \to  H_n (D)</fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex>f  \circ  g</fr:tex> induces composition homomorphism <fr:tex>(f  \circ  g)_* = f_*  \circ  g_*</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1431</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
  Referring to <fr:ref
addr="hmlg-0009"
href="hmlg-0009.xml"
taxon="Visualization"></fr:ref> makes all the moving parts clear here. Since <fr:tex>f</fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex>C_n</fr:tex> to the boundaries in <fr:tex>D_n</fr:tex>. Therefore the map is well-defined after passing to the quotient.
</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1435</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000C</fr:addr><fr:route>hmlg-000C.xml</fr:route><fr:title>Quasi-isomorphism</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="hmlg-0008.xml"
type="local"
addr="hmlg-0008">chain map</fr:link> is a <fr:strong>quasi-isomorphism</fr:strong> if it induces isomorphisms on the <fr:link
href="hmlg-0007.xml"
type="local"
addr="hmlg-0007">homology groups</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1437</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000D</fr:addr><fr:route>hmlg-000D.xml</fr:route><fr:title>Acyclic chain complex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  If all the homology groups vanish, then the chain complex is said fo be <fr:strong>acyclic</fr:strong> or <fr:strong>exact</fr:strong>. Equivalently, every cycle is a boundary.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1439</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000H</fr:addr><fr:route>hmlg-000H.xml</fr:route><fr:title>Short exact sequence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>short exact sequence</fr:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex
display="block">0  \to  A  \to  B  \to  C  \to  0.</fr:tex> Short exact sequence describes how <fr:tex>B</fr:tex> is made up of a subobject <fr:tex>A</fr:tex> and a quotient <fr:tex>C</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1441</fr:anchor><fr:addr>hmlg-000E</fr:addr><fr:route>hmlg-000E.xml</fr:route><fr:title>Difference of exactness and acyclicity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link
href="https://ncatlab.org/nlab/show/concept+with+an+attitude"
type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1445</fr:anchor><fr:addr>hmlg-000G</fr:addr><fr:route>hmlg-000G.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1369</fr:anchor><fr:addr>hmlg-000L</fr:addr><fr:route>hmlg-000L.xml</fr:route><fr:title>Operations on chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1358</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000I</fr:addr><fr:route>hmlg-000I.xml</fr:route><fr:title>Direct sum and product of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a family of chain complexes <fr:tex>C_{ \alpha ,  \bullet }</fr:tex>, we can take the direct sum in each dimension, giving <fr:tex>D_ \bullet  =  \bigoplus _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex>\prod _ \alpha  C_{ \alpha ,  \bullet }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
  As another example, the consideration of quotienting out a subspace <fr:tex>Y  \subseteq  X</fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex
display="block">0  \to  C_ \bullet (Y)  \hookrightarrow  C_ \bullet (X)  \to  C_ \bullet (X, Y)  \to  0.</fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1360</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000K</fr:addr><fr:route>hmlg-000K.xml</fr:route><fr:title>Bicomplex</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:strong>bicomplex</fr:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex>A_{m, n}</fr:tex>, vertical maps <fr:tex>d : A_{m, n}  \to  A_{m, n-1}</fr:tex> and horizontal maps <fr:tex>\delta  : A_{m, n}  \to  A_{m-1, n}</fr:tex>. Every square in the grid commutes, and <fr:tex>d^2 =  \delta ^2 = 0</fr:tex>.
</fr:p><fr:p>
  Each column <fr:tex>A_{m,  \bullet }</fr:tex> in the bicomplex is a chain complex, and <fr:tex>\delta</fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex>d</fr:tex> are chain maps between the row complexes.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1362</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000J</fr:addr><fr:route>hmlg-000J.xml</fr:route><fr:title>Exact sequence of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:strong>exact sequence</fr:strong> of chain complexes <fr:tex>C_{m,  \bullet }</fr:tex> is a <fr:link
href="hmlg-000K.xml"
type="local"
addr="hmlg-000K">bicomplex</fr:link> such that the rows are <fr:link
href="hmlg-000D.xml"
type="local"
addr="hmlg-000D">exact</fr:link>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1365</fr:anchor><fr:addr>hmlg-000V</fr:addr><fr:route>hmlg-000V.xml</fr:route><fr:title>Kernel, image, cokernel and coimage of chain complexes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a chain map <fr:tex>f_ \bullet  : C_ \bullet   \to  D_ \bullet</fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</fr:p>
  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="tikz tikzcd">
    <fr:embedded-tex
hash="842478f248bf487e86aa9d32eaa644a3"><fr:embedded-tex-preamble>
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzcd} 
  &amp;&amp; { \operatorname {im}  f} &amp; { \operatorname {coim}  f}  \\ 
  &amp; C &amp;&amp;&amp; D  \\ 
  { \ker  f} &amp;&amp;&amp;&amp;&amp; { \operatorname {coker}  f}
   \arrow [" \sim ", from=1-3, to=1-4]
   \arrow [from=2-2, to=1-3]
   \arrow [from=1-4, to=2-5]
   \arrow [from=3-1, to=2-2]
   \arrow [from=2-5, to=3-6]
 \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex>
  </html:span>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1371</fr:anchor><fr:addr>hmlg-000U</fr:addr><fr:route>hmlg-000U.xml</fr:route><fr:title>Additive and abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Since many <fr:link
href="hmlg-000L.xml"
type="local"
addr="hmlg-000L">operations</fr:link> on abelian groups and <fr:tex>R</fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</fr:p><fr:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1325</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000O</fr:addr><fr:route>hmlg-000O.xml</fr:route><fr:title><fr:tex>\mathsf { Ab }</fr:tex>-enriched category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category <fr:tex>\mathcal { C }</fr:tex>, an <fr:tex>\mathsf { Ab }</fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex>\hom (Y, Z)  \otimes   \hom (X, Y)  \to   \hom (X, Z)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1327</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000P</fr:addr><fr:route>hmlg-000P.xml</fr:route><fr:title>Additive category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <fr:strong>additive category</fr:strong>. In particular, the nullary product and coproduct coincide, and we call the object <fr:strong>zero object</fr:strong>, denoted <fr:tex>0</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1321</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000P</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex>X_i</fr:tex> to their product is given by a matrix of morphisms <fr:tex>f_{ij} : X_i  \to  X_j</fr:tex>. We choose the identity matrix
    <fr:tex
display="block">f_{ij} =  \begin {cases}        \operatorname {id}  &amp; (i = j)  \\        0 &amp; (i  \ne  j)      \end {cases}</fr:tex>
    where <fr:tex>0</fr:tex> is the additive neutral element in the abelian group <fr:tex>\hom (X_i, X_j)</fr:tex>. This gives a canonical map <fr:tex>\coprod _i X_i  \to   \prod _i X_i</fr:tex>.
  </fr:p>

  <fr:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex
display="block">\prod _i X_i  \xrightarrow { \pi _j} X_j  \xrightarrow { \iota _j}  \coprod _i X_i.</fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Due to this coincidence creating gadgets with <fr:em>two universal properties</fr:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1331</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000R</fr:addr><fr:route>hmlg-000R.xml</fr:route><fr:title>Being an additive category is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given a category, if it can be endowed with an <fr:link
href="hmlg-000O.xml"
type="local"
addr="hmlg-000O"><fr:tex>\mathsf { Ab }</fr:tex>-enrichment</fr:link> that makes it an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1329</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000R</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Notice that having finite products and coproducts is a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link
href="todo.xml"
type="local"
addr="todo">property</fr:link>. These do not mention the enrichment structure.
  </fr:p>

  <fr:p>
    With these properties satisfied, the addition structure on the <fr:tex>\hom</fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex
display="block">X  \to  0  \to  Y,</fr:tex>
    and given two parallel morphisms <fr:tex>f, g : X  \to  Y</fr:tex>, the following composition
    <fr:tex
display="block">X  \xrightarrow { \Delta } X  \oplus  X  \xrightarrow {f  \oplus  g} Y  \oplus  Y  \xrightarrow { \nabla } Y.</fr:tex>
    is equal to the addition <fr:tex>f + g</fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex>0'</fr:tex> and <fr:tex>f +' g</fr:tex>. By interpreting <fr:tex>\oplus</fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex>0'</fr:tex> is indeed the neutral element for <fr:tex>+'</fr:tex>.
  </fr:p>

  <fr:p>
    Recall that arrows <fr:tex>X  \oplus  X  \to  Y  \oplus  Y</fr:tex> is given by a <fr:tex>2  \times  2</fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex>f  \oplus  g</fr:tex> comes from a diagonal matrix with <fr:tex>f, g</fr:tex> as entries, so this operation is linear, which entails <fr:tex>+'</fr:tex> is also linear. By the <fr:link
href="todo.xml"
type="local"
addr="todo">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1333</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000S</fr:addr><fr:route>hmlg-000S.xml</fr:route><fr:title>Additive functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given two <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link> and a functor <fr:tex>F :  \mathcal { C }   \to   \mathcal { D }</fr:tex> between them, the following are equivalent:
  <fr:ul><fr:li>The functor preserves finite products.</fr:li>
    <fr:li>The functor preserves finite coproducts.</fr:li>
    <fr:li>The functor is a homomorphism on the abelian groups <fr:tex>\hom _{ \mathcal { C } }(X, Y)</fr:tex>, i.e. it is an <fr:tex>\mathsf { Ab }</fr:tex>-enriched functor.</fr:li></fr:ul>
  In this case, we call the functor <fr:strong>additive</fr:strong>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1220</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000S</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y),</fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex>X + Y  \stackrel { \sim \, }{ \to }  F(X  \times  Y)</fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex>F</fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex>F(X) + F(Y)</fr:tex> to <fr:tex>F(X)  \times  F(Y)</fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </fr:p>

  <fr:p>
    Since the abelian group structure on morphisms is <fr:link
href="hmlg-000R.xml"
type="local"
addr="hmlg-000R">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex>F(1)  \to  1</fr:tex> and <fr:tex>F(X  \times  Y)  \to  F(X)  \times  F(Y)</fr:tex> are isomorphisms. For the first one, since <fr:tex>1</fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex
display="block">F(X) + F(Y)  \to  F(X + Y)  \stackrel { \sim \, }{ \to }  F(X  \times  Y)  \to  F(X)  \times  F(Y).</fr:tex>
    Using the bilinearity of composition and that <fr:tex>F</fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1337</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000T</fr:addr><fr:route>hmlg-000T.xml</fr:route><fr:title>Adjunctions are additive</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  In an adjunction <fr:tex>F  \dashv  G</fr:tex>, both functors are automatically additive.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1335</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000T</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:ref
addr="hmlg-000S"
href="hmlg-000S.xml"
taxon="Definition"></fr:ref> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</fr:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1341</fr:anchor><fr:taxon>Theorem</fr:taxon><fr:addr>hmlg-000Y</fr:addr><fr:route>hmlg-000Y.xml</fr:route><fr:title>Equalizers can be reduced to kernels in <fr:tex>\mathsf { Ab }</fr:tex>-enriched categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1339</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000Y</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    We simply need to note that an equalizer for <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> is equivalent to an equalizer for <fr:tex>(f-g)</fr:tex> and <fr:tex>0</fr:tex>, by bilinearity of composition.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1343</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-000W</fr:addr><fr:route>hmlg-000W.xml</fr:route><fr:title>Abelian categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-000Q.xml"
type="local"
addr="hmlg-000Q">Abelian categories</fr:link> are one step further from <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex>f : X  \to  Y</fr:tex> has four key components, the image, the kernel, the coimage <fr:tex>X /  \ker  f</fr:tex>, and the cokernel <fr:tex>Y /  \operatorname {im}  f</fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1345</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000Q</fr:addr><fr:route>hmlg-000Q.xml</fr:route><fr:title>Abelian category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  Given an <fr:link
href="hmlg-000P.xml"
type="local"
addr="hmlg-000P">additive category</fr:link>, it is an <fr:strong>abelian category</fr:strong> if the following condition holds:
  <fr:ul><fr:li>Every morphism has a kernel and a cokernel.</fr:li>
    <fr:li>Every monomorphism is the kernel of its cokernel.</fr:li>
    <fr:li>Every epimorphism is the cokernel of its kernel.</fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex>R</fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link
href="hmlg-000F.xml"
type="local"
addr="hmlg-000F">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</fr:p><fr:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link
href="hmlg-000X.xml"
type="local"
addr="hmlg-000X">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark
xmlns:html="http://www.w3.org/1999/xhtml">One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1348</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-000X</fr:addr><fr:route>hmlg-000X.xml</fr:route><fr:title>Left and right exact functor</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  An <fr:link
href="hmlg-000S.xml"
type="local"
addr="hmlg-000S">additive functor</fr:link> <fr:tex>F :  \mathcal { A }   \to   \mathcal { B }</fr:tex> between abelian categories is <fr:strong>left exact</fr:strong> if it satisfies the following equivalent conditions.

  <fr:ul><fr:li>It preserves kernels.</fr:li>
    <fr:li>It preserves finite limits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">0  \to  A  \to  B  \to  C.</fr:tex></fr:li></fr:ul></fr:p><fr:p>
  Dually, an additive functor is <fr:strong>right exact</fr:strong> if it satisfies the following equivalent conditions.
  <fr:ul><fr:li>It preserves cokernels.</fr:li>
    <fr:li>It preserves finite colimits.</fr:li>
    <fr:li>It preserves the exactness of sequences <fr:tex
display="block">A  \to  B  \to  C  \to  0.</fr:tex></fr:li></fr:ul>
  If a functor is both left exact and right exact, it is simply called an <fr:strong>exact functor</fr:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex>A  \to  B  \to  C</fr:tex>.
</fr:p>
  
    
    <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1214</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors><fr:parent>hmlg-000X</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    Since additive functors already preserves finite products, and <fr:link
href="hmlg-000Y.xml"
type="local"
addr="hmlg-000Y">kernels are equivalent to general coequalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </fr:p>

  <fr:p>
    The sequence <fr:tex>A  \rightarrowtail  B  \to  C</fr:tex> being exact is equivalent to <fr:tex>A</fr:tex> being a kernel of <fr:tex>B  \to  C</fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1447</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>hmlg-0004</fr:addr><fr:route>hmlg-0004.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>In an abelian category, an object <fr:tex>P</fr:tex> is <fr:strong>projective</fr:strong> iff for every morphism <fr:tex>P  \to  B</fr:tex> can be lifted through an epimorphism <fr:tex>A  \twoheadrightarrow  B</fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex>P  \to  A</fr:tex> making the triangle commute.</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>1448</fr:anchor><fr:taxon>Intuition</fr:taxon><fr:addr>hmlg-0005</fr:addr><fr:route>hmlg-0005.xml</fr:route><fr:title>Projective objects</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p><fr:link
href="hmlg-0004.xml"
type="local"
addr="hmlg-0004">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex>P</fr:tex>, lifting a map <fr:tex>P  \to  B</fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="true"><fr:frontmatter><fr:anchor>1952</fr:anchor><fr:addr>trebor-0001</fr:addr><fr:route>index.xml</fr:route><fr:title>Trebor’s forest</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  This is my forest, which is <fr:link
href="https://www.jonmsterling.com/jms-005P.xml"
type="external">a way of organizing notes</fr:link>. Here is <fr:link
href="https://www.jonmsterling.com/jms-009H.xml"
type="external">a list of other websites organized as forests</fr:link>. Some of the contents here:
  <fr:ul><fr:li><fr:link
href="hmlg-0001.xml"
type="local"
addr="hmlg-0001">Notes on homological algebra</fr:link></fr:li>
    <fr:li><fr:link
href="hmlg-001K.xml"
type="local"
addr="hmlg-001K">Effective homology</fr:link></fr:li>
    <fr:li>Algebraic geometry (Under namespace <fr:code>algm</fr:code>, not organized)</fr:li></fr:ul></fr:p><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>993</fr:anchor><fr:addr>trebor-0002</fr:addr><fr:route>trebor-0002.xml</fr:route><fr:title>Style of writing</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
href="trebor.xml"
type="local"
addr="trebor">Trebor</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
  I try to adhere to several principles when composing trees.
</fr:p><fr:ul><fr:li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </fr:li>
  <fr:li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex>\mathfrak { a }   \mid  x</fr:tex> instead of <fr:tex>x  \in   \mathfrak { a }</fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex>\operatorname {Spec} (A)</fr:tex>, we do not identify them.
  </fr:li>
  <fr:li>
    Apply <fr:link
href="https://ncatlab.org/nlab/show/biased+definition"
type="external">unbiased terminology</fr:link> and <fr:link
href="https://ncatlab.org/nlab/show/negative+thinking"
type="external">negative thinking</fr:link>.
  </fr:li></fr:ul></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:contributions><fr:context></fr:context><fr:related></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>