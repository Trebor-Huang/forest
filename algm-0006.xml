<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" root="false">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>3</fr:month>
      <fr:day>3</fr:day>
    </fr:date>
    <fr:anchor>2963</fr:anchor>
    <fr:addr type="user">algm-0006</fr:addr>
    <fr:route>algm-0006.xml</fr:route>
    <fr:title text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p>
    <fr:p>For example, on the space given by <fr:tex display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:anchor>2957</fr:anchor>
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:anchor>2959</fr:anchor>
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:source-path>/Users/trebor/Desktop/blog/forest/trees/algm-0005.tree</fr:source-path>
            <fr:anchor>2958</fr:anchor>
            <fr:addr type="user">algm-0005</fr:addr>
            <fr:route>algm-0005.xml</fr:route>
            <fr:title text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>To define functions on an “algebraic space”, we need to define the possible domains. The correct structure formed by the domains is a locale. Intuitively, the only algebraic way for a function to become partially defined is by having zero in the denominator <fr:tex display="inline"><![CDATA[f/g]]></fr:tex>, so the domain should be the non-vanishing part of <fr:tex display="inline"><![CDATA[g]]></fr:tex>, which we denote as <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex>.</fr:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:source-path>/Users/trebor/Desktop/blog/forest/trees/algm-0006.tree</fr:source-path>
                <fr:anchor>796</fr:anchor>
                <fr:addr type="user">algm-0006</fr:addr>
                <fr:route>algm-0006.xml</fr:route>
                <fr:title text="Rational functions not definable via a single expression">Rational functions not definable via a single expression</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>We can sometimes define two functions that agree on their common domain, which suggests we should be able to piece them together into a larger function. But this may not always be expressible with one single expression.</fr:p>
                <fr:p>For example, on the space given by <fr:tex display="inline"><![CDATA[xy = zw]]></fr:tex>, we can define a funtion given by <fr:tex display="inline"><![CDATA[x/w]]></fr:tex>, which is equal to <fr:tex display="inline"><![CDATA[z/y]]></fr:tex>. They are only jointly undefined on <fr:tex display="inline"><![CDATA[w = z = 0]]></fr:tex>, but there is no single expression that achieves this.</fr:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:p>Recognizing this, we can try to freely generate a locale using <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex> as generators. We would like some obvious relations corresponding to each algebraic operation in the ring.</fr:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:source-path>/Users/trebor/Desktop/blog/forest/trees/algm-0007.tree</fr:source-path>
                <fr:anchor>797</fr:anchor>
                <fr:addr type="user">algm-0007</fr:addr>
                <fr:route>algm-0007.xml</fr:route>
                <fr:title text="Localic spectrum of a commutative ring">Localic spectrum of a commutative ring</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Given a commutative ring <fr:tex display="inline"><![CDATA[R]]></fr:tex>, we define a frame generated by the symbols <fr:tex display="inline"><![CDATA[D(f)]]></fr:tex> for <fr:tex display="inline"><![CDATA[f \in  R]]></fr:tex>, subject to the following relations:
  <fr:tex display="block"><![CDATA[\begin {aligned}
    D(0) &= \bot  \\
    D(1) &= \top  \\
    D(f \cdot  g) &= D(f) \cap  D(g) \\
    D(f + g) &\subseteq  D(f) \cup  D(g)
  \end {aligned}]]></fr:tex>
  The resulting frame defines the <fr:strong>localic spectrum</fr:strong> <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex>.</fr:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:p>We can actually produce a characterization of these generated opens. The following theorem is best read by skipping the statement and jump right into the proof, allowing the correct statement to gradually reveal itself.</fr:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:source-path>/Users/trebor/Desktop/blog/forest/trees/algm-0008.tree</fr:source-path>
                <fr:anchor>798</fr:anchor>
                <fr:addr type="user">algm-0008</fr:addr>
                <fr:route>algm-0008.xml</fr:route>
                <fr:title text="Characterization of the locale \operatorname{Spec}(R)">Characterization of the locale <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex></fr:title>
                <fr:taxon>Theorem</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>The opens in <fr:link href="algm-0007.xml" title="Localic spectrum of a commutative ring" addr="algm-0007" type="local">the locale</fr:link> <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> bijectively corresponds to radical ideals of <fr:tex display="inline"><![CDATA[R]]></fr:tex>, whose divisibility relation agree with the inverse inclusion relation of opens. Intersections correspond to lowest common multiple, and unions correspond to the radical of the greatest common divisor. In other words, the locale is isomorphic to the locale corresponding to the <fr:link href="algm-0001.xml" title="Topological spectrum of a commutative ring" addr="algm-0001" type="local">topological spectrum of a commutative ring</fr:link> by <fr:link href="algm-0002.xml" title="Radical ideals bijectively correspond to open sets" addr="algm-0002" type="local">Theorem <fr:contextual-number addr="algm-0002" /></fr:link>.</fr:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="trebor.xml" title="Trebor" addr="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>3</fr:day></fr:date><fr:source-path>/Users/trebor/Desktop/blog/forest/trees/algm-0008.tree</fr:source-path><fr:anchor>515</fr:anchor><fr:addr type="machine">unstable/457</fr:addr><fr:route>unstable-457.xml</fr:route><fr:title text="" /><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <fr:p>We can first put the opens in disjunctive normal form
    <fr:tex display="block"><![CDATA[U = \bigcup _{i \in  I} \bigcap _{j=1}^{n_i} D(f_{i, j}).]]></fr:tex>
    By the definition we can reduce the intersections into products. Write <fr:tex display="inline"><![CDATA[f_i = \prod _j f_{i, j}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[U = \bigcup _i D(f_i)]]></fr:tex>. Given this form, we can try to <fr:em>saturate</fr:em> the union, by throwing in everything that doesn’t enlarge <fr:tex display="inline"><![CDATA[U]]></fr:tex>. In other words, we only consider the unions such that no other generator <fr:tex display="inline"><![CDATA[D(f)]]></fr:tex> can be added, i.e. <fr:tex display="inline"><![CDATA[D(f) \nsubseteq  U]]></fr:tex>. This would uniquely determine <fr:tex display="inline"><![CDATA[U]]></fr:tex>.</fr:p>

  <fr:p>Such a saturated set would have to be closed under addition since <fr:tex display="inline"><![CDATA[D(f+g) \subseteq  D(f) \cup  D(g)]]></fr:tex>, and for the nullary case it must include <fr:tex display="inline"><![CDATA[D(0) = \bot ]]></fr:tex>. It also has to absorb multiplication, because <fr:tex display="inline"><![CDATA[D(f \cdot  g) \subseteq  D(f)]]></fr:tex>. This means we are dealing with ideals. Henceforth, we write <fr:tex display="inline"><![CDATA[D(\mathfrak {a})]]></fr:tex> for the union <fr:tex display="inline"><![CDATA[\bigcup _{\mathfrak {a} \mid  f} D(f)]]></fr:tex>.</fr:p>

  <fr:p>There is one last requirement we haven’t dealt with, i.e. <fr:tex display="inline"><![CDATA[D(f \cdot  g)]]></fr:tex> is the <fr:em>greatest</fr:em> lower bound of <fr:tex display="inline"><![CDATA[D(f)]]></fr:tex> and <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex>, instead of simply a lower bound. For example, this gives the equality <fr:tex display="inline"><![CDATA[D(f^n) = D(f)]]></fr:tex>, so we need to restrict our attention to radical ideals. It then suffices to prove that the radical ideal generated by <fr:tex display="inline"><![CDATA[f \cdot  g]]></fr:tex> is equal to the lowest common multiple of the radical ideals generated by <fr:tex display="inline"><![CDATA[f]]></fr:tex> and <fr:tex display="inline"><![CDATA[g]]></fr:tex>, which is true.</fr:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:anchor>2960</fr:anchor>
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:anchor>2961</fr:anchor>
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:anchor>2962</fr:anchor>
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
