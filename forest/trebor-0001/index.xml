<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/forest/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="true" base-url="/forest/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>2</fr:month>
      <fr:day>16</fr:day>
    </fr:date>
    <fr:uri>https://trebor-huang.github.io/forest/trebor-0001/</fr:uri>
    <fr:display-uri>trebor-0001</fr:display-uri>
    <fr:route>/forest/trebor-0001/</fr:route>
    <fr:title text="Trebor’s forest">Trebor’s forest</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>
  This is my forest. Forests are <fr:link href="https://www.jonmsterling.com/jms-005P.xml" type="external">a way of organizing notes</fr:link>, and here is <fr:link href="https://www.jonmsterling.com/jms-009H.xml" type="external">a list of other websites organized as forests</fr:link>. Some of the contents here:
</html:p>
    <html:ul><html:li><fr:link href="/forest/tile-0001/" title="Generating aperiodic tilings with substitution systems" uri="https://trebor-huang.github.io/forest/tile-0001/" display-uri="tile-0001" type="local">Generating aperiodic tilings with substitution systems</fr:link></html:li>
  <html:li><fr:link href="/forest/hmlg-0001/" title="Homological Algebra" uri="https://trebor-huang.github.io/forest/hmlg-0001/" display-uri="hmlg-0001" type="local">Notes on homological algebra</fr:link></html:li>
  <html:li><fr:link href="/forest/hmlg-001K/" title="Effective homology" uri="https://trebor-huang.github.io/forest/hmlg-001K/" display-uri="hmlg-001K" type="local">Effective homology</fr:link></html:li>
  <html:li>Algebraic geometry (Under namespace <html:code>algm</html:code>, not organized)</html:li>
  <html:li><fr:link href="/forest/ualg-000H/" title="Beck monadicity theorem" uri="https://trebor-huang.github.io/forest/ualg-000H/" display-uri="ualg-000H" type="local">Beck monadicity theorem</fr:link></html:li>
  <html:li>On <fr:link href="/forest/hmlg-002Y/" title="Ghost and phantom maps" uri="https://trebor-huang.github.io/forest/hmlg-002Y/" display-uri="hmlg-002Y" type="local">Ghost and phantom maps</fr:link></html:li></html:ul>
    <html:p>
  On a computer, you can press Ctrl–K to search for trees.
</html:p>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>3</fr:month>
          <fr:day>4</fr:day>
        </fr:date>
        <fr:uri>https://trebor-huang.github.io/forest/trebor-0002/</fr:uri>
        <fr:display-uri>trebor-0002</fr:display-uri>
        <fr:route>/forest/trebor-0002/</fr:route>
        <fr:title text="Style of writing">Style of writing</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>
  I try to adhere to several principles when composing trees.
</html:p>
        <html:ul><html:li>
    If a definition or a lemma would present itself during a proof attempt, then do not introduce it until that part of the proof. The nature of forests makes this kind of organization more viable, as each definition is a tree by itself.
  </html:li>
  <html:li>
    If a part of a proof has an easy constructive phrasing, use it and avoid classical reasoning. But if it requires some complication, then the classical way is used.
  </html:li>
  <html:li>
    Avoid abstraction leaks. Even if A is defined as B, do not use them interchangeably. For instance, an ideal is defined as a subset of a ring satisfying certain conditions. But we will insist on writing ideals as numbers, for example saying <fr:tex display="inline"><![CDATA[\mathfrak {a} \mid  x]]></fr:tex> instead of <fr:tex display="inline"><![CDATA[x \in  \mathfrak {a}]]></fr:tex>. This is not too heretic, since algebraic number theory already uses this kind of notation. Similarly, although prime ideals correspond to points in <fr:tex display="inline"><![CDATA[\operatorname {Spec}(A)]]></fr:tex>, we do not identify them.
  </html:li>
  <html:li>
    Apply <fr:link href="https://ncatlab.org/nlab/show/biased+definition" type="external">unbiased terminology</fr:link> and <fr:link href="https://ncatlab.org/nlab/show/negative+thinking" type="external">negative thinking</fr:link>.
  </html:li></html:ul>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/tile-0001/</fr:uri>
            <fr:display-uri>tile-0001</fr:display-uri>
            <fr:route>/forest/tile-0001/</fr:route>
            <fr:title text="Generating aperiodic tilings with substitution systems">Generating aperiodic tilings with substitution systems</fr:title>
            <fr:meta name="external">https://github.com/Trebor-Huang/aperiodic</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:img src="/forest/bafkrmihheo33cibhfuj2qe5foewh4ayyvdh6xvjsmj3yq76cemv4ydt5zi.svg" />
            <html:p>
  I assume familiarity with <fr:link href="https://en.wikipedia.org/wiki/Aperiodic_tiling" type="external">aperiodic tilings</fr:link> and <fr:link href="https://en.wikipedia.org/wiki/Substitution_tiling" type="external">substitution systems</fr:link>. It is already possible, via naïve use of the substitution system, to construct algorithms that generate arbitrarily large patches of the tilings. However, the collection of algorithms persented here has several advantages.
</html:p>
            <html:ul><html:li>It can incrementally generate patches arbitrarily far away from the starting point, without needing to specify the size up front.</html:li>
  <html:li>It is very efficient, both in time and in space, as it only generates tiles on demand, as they enter the viewport.</html:li>
  <html:li>For each concrete tiling system, it requires minimal manual input, automatically constructing almost the entire algorithm.</html:li>
  <html:li>The generation itself does <html:em>not</html:em> depend on the geometric information! This avoids difficult calculations with arbitrary-precision numbers.</html:li>
  <html:li>The algorithm elegantly handles very problematic situations such as substitutions with disjoint tiles, or zero-width spurs.</html:li></html:ul>
            <html:img src="/forest/bafkrmih5oi6bszh4vzrfkmrow57mem4m3uxhwjvlg3whqlvs7a4uao72l4.svg" />
            <html:p>
  These materials essentially come from <fr:link href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/aperiodic-tilings/" type="external">a four part series</fr:link> in Tatham’s blog. I strongly recommend reading through them first. In my own writeup, I removed the intermediate algorithms that are later replaced with better ones, and gave some more precise definitions and proofs.
</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-0002/</fr:uri>
                <fr:display-uri>tile-0002</fr:display-uri>
                <fr:route>/forest/tile-0002/</fr:route>
                <fr:title text="Overview of the setup">Overview of the setup</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  To generate a tiling, we need to determine what kind of information the computer needs. This can be divided into two parts. The <html:em>geometric</html:em> information records the shape of each tile, and the <html:em>combinatorial</html:em> information records the matching rules and combinatorial data of the substitution rules. Given <fr:link href="/forest/tile-0008/" title="Combinatorial data" uri="https://trebor-huang.github.io/forest/tile-0008/" display-uri="tile-0008" type="local">some combinatorial data</fr:link>, we can algorithmically produce the neighbor structure of each tile, which can then be easily graphically displayed by suitably translating and rotating the tiles using the geometric information. Note that producing the neighbor is non-trivial, since naïvely attempting every possible tile under the matching rules require arbitrarily far backtracking.
</html:p>
                <html:p>
  We will first construct a <html:strong><fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link></html:strong>, which computes the neighbor tile when we specify a tile and one of its edges. This is already enough if you want to display random patches of the tiling, but there are cases with zero probability where the program will hang. However, these cases often contain interesting features, such as a high degree of symmetry, or fractal structures. So we will construct another <html:strong>transductive neighborhood algorithm</html:strong>, depending on the recursive one, that allows us to handle those inputs by producing partial outputs as soon as they can be determined.
</html:p>
                <html:p>
  There is still a smaller set of input that cannot be handled. The situation is not unlike attempting to calculate <fr:tex display="inline"><![CDATA[0.9999\cdots  + 0.0000\cdots ]]></fr:tex>, with the algorithm forever unable to determine if it should output <fr:tex display="inline"><![CDATA[1.00\cdots ]]></fr:tex> or <fr:tex display="inline"><![CDATA[0.99\cdots ]]></fr:tex>, because it is unsure whether it will encounter a digit less than <fr:tex display="inline"><![CDATA[9]]></fr:tex> in the first summand, or a non-zero digit in the second summand. This is obviously impossible to solve, unless we have more information. For example, if we know beforehand that the first summand is indeed <fr:tex display="inline"><![CDATA[0.9\overline {9}]]></fr:tex>, then we can safely output <fr:tex display="inline"><![CDATA[1.]]></fr:tex> as the first digit. This also applies to our tiling algorithm. We will be able to classify all the failure cases, and if we know beforehand the input falls in one of those cases, then we can bypass the problem in an ad hoc way.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-0008/</fr:uri>
                <fr:display-uri>tile-0008</fr:display-uri>
                <fr:route>/forest/tile-0008/</fr:route>
                <fr:title text="Combinatorial data">Combinatorial data</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  We specify the combinatorial data required to define a substitution tile system.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-0003/</fr:uri>
                    <fr:display-uri>tile-0003</fr:display-uri>
                    <fr:route>/forest/tile-0003/</fr:route>
                    <fr:title text="tile system">tile system</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  We define a (two-dimensional, simple) <html:strong>tile system</html:strong> as a collection of finitely many polygons, called tiles, with colored edges, such that the colors come in pairs written as <fr:tex display="inline"><![CDATA[+c, -c]]></fr:tex>. A <html:strong>tiling</html:strong> of the tile system is a tessellation of the plane by these tiles, such that tiles can only touch by sharing entire edges, such that the colors on those edges are in pairs. In principle, a tiling only allows translations of tiles, but in implementation it is convenient to have a finite set of rotations (and possibly reflections), as it reduces code duplication.
</html:p>
                    <html:p>
  Sometimes, to disambiguate between a type of tiles (of which there are only finitely many) and one instance of such a tile in a tiling (which can occur infinitely many times), we refer to the former as a <html:strong>prototile</html:strong>. Every edge of a tile is given a unique number, which we refer to as <html:strong>edge labels</html:strong>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-0004/</fr:uri>
                    <fr:display-uri>tile-0004</fr:display-uri>
                    <fr:route>/forest/tile-0004/</fr:route>
                    <fr:title text="substitution system">substitution system</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a <fr:link href="/forest/tile-0003/" title="tile system" uri="https://trebor-huang.github.io/forest/tile-0003/" display-uri="tile-0003" type="local">tile system</fr:link>, a <html:strong>substitution system</html:strong> is a map from each prototile to a patch of tiles, such that when we replace each tile in a tiling with the substitution, the resulting patches of tiles can fit together in the same way, forming another tiling. This process is called <html:strong>deflation</html:strong>, while the inverse process, if it exists, is called <html:strong>inflation</html:strong>. We usually only consider substitution systems where inflation exists and is unique.
</html:p>
                    <html:p>
  More precisely, given a prototile <fr:tex display="inline"><![CDATA[t]]></fr:tex>, we assign a list of deflated tiles <fr:tex display="inline"><![CDATA[t_i]]></fr:tex>. Each edge of <fr:tex display="inline"><![CDATA[t]]></fr:tex> will be subdivided into several subedges (with their own colors), such that the subdivision only depends on the color, and edges of opposite colors are divided in a way such that the resulting subedges match. For the data of how the deflated tiles glue together, we have a perfect pairing on the set
  <fr:tex display="block"><![CDATA[\{\text {subedges of $t$}\} \sqcup  \coprod _i \{\text {edges of $t_i$}\}]]></fr:tex> such that the paired edges are compatible. Specifically, if two edges of deflated tiles, or two subedges of <fr:tex display="inline"><![CDATA[t]]></fr:tex> are matched, they must be of opposite colors; if an edge of a deflated tile is matched with a subedge, they must share colors.
</html:p>
                    <html:p>
  In addition to this, the subdivision must also match geometrically, but we shall not give its full definition here, as it suffices to recognize this intuitively.
</html:p>
                    <html:p>
  For convenience, if two edges <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\epsilon ']]></fr:tex> have opposite colors, we use the <html:em>same label</html:em> for their subedges in a substitution. This simplifies the presentation since we avoid using a conversion look-up table, but requires us to be somewhat careful in assigning labels. In general, we can assign the subedge labels counterclockwise for edges with positive colors, and clockwise for negative colors.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  On a first read, the definition of a substitution system may seem to contain some surprising cases. Why is it possible to have subedges paired against each other? This is because there are <fr:link href="/forest/tile-0005/" title="Penrose rhombs" uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" type="local">examples</fr:link> where this occurs. Even though we can often transform our substitution systems to avoid this, it allows for very economic presentations, and thus more efficient algorithms. In addition, accounting for these cases reveals some symmetry in the recursive structure of our programs.
</html:p>
                <html:p>
  Now we have enough terminology to define the fundamental object in our algorithms, the Conway signature.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-0006/</fr:uri>
                    <fr:display-uri>tile-0006</fr:display-uri>
                    <fr:route>/forest/tile-0006/</fr:route>
                    <fr:title text="Conway signature">Conway signature</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Assume we have a <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link> with unique inflation. For a tile <fr:tex display="inline"><![CDATA[t]]></fr:tex> in a tiling, we can inflate the tiling to find <fr:tex display="inline"><![CDATA[t]]></fr:tex> as a subtile in an inflated tile <fr:tex display="inline"><![CDATA[t_1]]></fr:tex>. If we give a unique number to each subtile in a substitution system, we can write this as <fr:tex display="inline"><![CDATA[t \xrightarrow {n_1} t_1]]></fr:tex>, meaning <fr:tex display="inline"><![CDATA[t]]></fr:tex> is the <fr:tex display="inline"><![CDATA[n_1]]></fr:tex>-th subtile. This process can be repeated, generating an infinite path
  <fr:tex display="block"><![CDATA[\Sigma  = t \xrightarrow {n_1} t_1 \xrightarrow {n_2} t_2 \longrightarrow  \cdots ]]></fr:tex>
  where <fr:tex display="inline"><![CDATA[t, t_1, t_2, \dots ]]></fr:tex> are prototile labels, and <fr:tex display="inline"><![CDATA[n_i]]></fr:tex> are subtile labels.
  This path <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is called the <html:strong>Conway signature</html:strong> of the tile. We will also consider the case of a finite patch of tiling, in which case the Conway signature will be a finite path.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  Computationally, this can be regarded as an infinite stream of data. In lazy languages like Haskell, we can directly implement this as an infinite list. Notice that there will be a lot of sharing as the signature of different tiles will often share a tail. So if your language does not have lazy functional data structures, you need to make sure sharing has a low cost.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-0009/</fr:uri>
                <fr:display-uri>tile-0009</fr:display-uri>
                <fr:route>/forest/tile-0009/</fr:route>
                <fr:title text="The recursive algorithm">The recursive algorithm</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  It is straightforward to write down a recursive algorithm for calculating neighborhood Conway signatures. It has an elegantly symmetric structure.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-0007/</fr:uri>
                    <fr:display-uri>tile-0007</fr:display-uri>
                    <fr:route>/forest/tile-0007/</fr:route>
                    <fr:title text="recursive neighborhood algorithm">recursive neighborhood algorithm</fr:title>
                    <fr:taxon>Algorithm</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Suppose we have a <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>. Given the <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link> of a tile <fr:tex display="inline"><![CDATA[t]]></fr:tex> and an edge label <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> of that tile, we can calculate the signature of the neighboring tile <fr:tex display="inline"><![CDATA[t']]></fr:tex> and the edge label <fr:tex display="inline"><![CDATA[\epsilon ']]></fr:tex> of <fr:tex display="inline"><![CDATA[t']]></fr:tex> that coincides with <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>. This is implemented by mutual recursion with another auxiliary function. Given the signature of a tile and a subedge of that tile under deflation, it calculates the signature of the subtile <fr:tex display="inline"><![CDATA[t']]></fr:tex> we will arrive in if we cross the subedge inwards, and the edge label of <fr:tex display="inline"><![CDATA[t']]></fr:tex> corresponding to the input subedge.
</html:p>
                    <html:p>
  This second function is non-trivial, because for some substitution systems, crossing inwards through a subedge may lead us immediately out through another subedge, if they are pinched together. See <fr:link href="/forest/tile-0005/" title="Penrose rhombs" uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" type="local">Example <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" /></fr:link>.
</html:p>
                    <html:p>
  The neighborhood function is as follows. Suppose we have a <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link>
  <fr:tex display="block"><![CDATA[t_0 \xrightarrow {s_1} t_1 \xrightarrow {s_2} t_2 \longrightarrow  \cdots ]]></fr:tex>
  and an edge <fr:tex display="inline"><![CDATA[\epsilon _0]]></fr:tex> of the tile <fr:tex display="inline"><![CDATA[t_0]]></fr:tex>. We consult the pairing of edges as specified in the <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>. This has two cases.
</html:p>
                    <html:ul><html:li>Suppose the edge <fr:tex display="inline"><![CDATA[\epsilon _0]]></fr:tex> (of the subtile labelled <fr:tex display="inline"><![CDATA[s_1]]></fr:tex>) is paired with another edge <fr:tex display="inline"><![CDATA[\epsilon '_0]]></fr:tex> of the subtile numbered <fr:tex display="inline"><![CDATA[s'_1]]></fr:tex>. Then since these two subtiles are neighbors already, we can directly output the signature
  <fr:tex display="block"><![CDATA[t'_0 \xrightarrow {s'_1} t_1 \xrightarrow {s_2} t_2 \longrightarrow  \cdots ]]></fr:tex>
  and the edge label <fr:tex display="inline"><![CDATA[\epsilon '_0]]></fr:tex>, where <fr:tex display="inline"><![CDATA[t'_0]]></fr:tex> is the prototile type of the <fr:tex display="inline"><![CDATA[s'_1]]></fr:tex> subtile in <fr:tex display="inline"><![CDATA[t_1]]></fr:tex>.</html:li>
  <html:li>Suppose the edge is paired with a subedge <fr:tex display="inline"><![CDATA[\sigma _1]]></fr:tex> of an edge <fr:tex display="inline"><![CDATA[\epsilon _1]]></fr:tex> in the tile <fr:tex display="inline"><![CDATA[t_1]]></fr:tex>. Then we need to exit the tile <fr:tex display="inline"><![CDATA[t_1]]></fr:tex> through this edge. We recursively call this function on the Conway signature <fr:tex display="inline"><![CDATA[t_1 \xrightarrow {s_2} \cdots ]]></fr:tex> and the edge label <fr:tex display="inline"><![CDATA[\epsilon _1]]></fr:tex>. Suppose the algorithm determines that its neighbor has the Conway signature <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> and the edge label <fr:tex display="inline"><![CDATA[\epsilon '_1]]></fr:tex>. We then invoke the auxiliary function to calculate the subtile we would obtain if we enter <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> from the subedge <fr:tex display="inline"><![CDATA[\sigma _1]]></fr:tex> of its edge <fr:tex display="inline"><![CDATA[\epsilon '_1]]></fr:tex>, and we can return its output, tail-recursively.</html:li></html:ul>
                    <html:p>
  For the auxiliary function, suppose again we have a signature
  <fr:tex display="block"><![CDATA[\Sigma  = t_0 \xrightarrow {s_1} t_1 \xrightarrow {s_2} t_2 \longrightarrow  \cdots ]]></fr:tex>
  and we have specified an edge <fr:tex display="inline"><![CDATA[\epsilon _0]]></fr:tex> of the tile <fr:tex display="inline"><![CDATA[t_0]]></fr:tex>, together with one of its subedges <fr:tex display="inline"><![CDATA[\sigma _0]]></fr:tex>. Again, we look up what is paired, in the substitution of <fr:tex display="inline"><![CDATA[t_0]]></fr:tex>, with the subedge <fr:tex display="inline"><![CDATA[\sigma _0]]></fr:tex>.
</html:p>
                    <html:ul><html:li>
    Suppose the result is an edge <fr:tex display="inline"><![CDATA[\epsilon _{-1}]]></fr:tex> in the subtile <fr:tex display="inline"><![CDATA[s_0]]></fr:tex> of <fr:tex display="inline"><![CDATA[t_0]]></fr:tex>. Then we can output
    <fr:tex display="block"><![CDATA[t_{-1} \xrightarrow {s_{0}} t_0 \xrightarrow {s_1} t_1 \longrightarrow  \cdots ]]></fr:tex>
    and the edge label <fr:tex display="inline"><![CDATA[\epsilon _{-1}]]></fr:tex>, where <fr:tex display="inline"><![CDATA[t_{-1}]]></fr:tex> is the prototile label corresponding to the subtile <fr:tex display="inline"><![CDATA[s_0]]></fr:tex>.
  </html:li>
  <html:li>
    Suppose the result is another subedge <fr:tex display="inline"><![CDATA[\sigma '_0]]></fr:tex> of the edge <fr:tex display="inline"><![CDATA[\epsilon '_0]]></fr:tex>. Then we call the neighborhood function on the Conway signature <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> and the edge label <fr:tex display="inline"><![CDATA[\epsilon '_0]]></fr:tex>. Let the result be the signature <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> and the edge <fr:tex display="inline"><![CDATA[\epsilon ''_0]]></fr:tex>. Now we just need to call the auxiliary function on <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> with the subedge <fr:tex display="inline"><![CDATA[\sigma '_0]]></fr:tex> of <fr:tex display="inline"><![CDATA[\epsilon ''_0]]></fr:tex>, and return its result.
  </html:li></html:ul>
                    <html:p>
  If we are dealing with finite Conway signatures, then the algorithm should raise an exception if at any point the path is too short. This signals that it has reached the boundary of the finite patch of tiles. Otherwise, the neighborhood function should always output a Conway path of equal length.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  With this algorithm, we can generate any patch of tiling by repeatedly asking the program what the neighbor of each tile is, until the generated tiles fill the area, like growing a crystal. We just need a Conway signature to begin with. Some methods to create this initial seed are discussed in <fr:link href="/forest/tile-000I/" title="Seed generation" uri="https://trebor-huang.github.io/forest/tile-000I/" display-uri="tile-000I" type="local">Seed generation</fr:link>, each designed for a different purpose.
</html:p>
                <html:p>
  Unfortunately, this recursive algorithm actually doesn’t generate all the possible tilings in our substitution system. This is surprising, because it seems that Conway signatures uniquely determines the arrangement of tiles we are in, if we suppose inflation is always unique. However, the definition of substitution tilings has a secret catch.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000A/</fr:uri>
                    <fr:display-uri>tile-000A</fr:display-uri>
                    <fr:route>/forest/tile-000A/</fr:route>
                    <fr:title text="hull of set of tilings">hull of set of tilings</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a set <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex> of (possibly incomplete) tilings of the plane, its <html:strong>hull</html:strong> <fr:tex display="inline"><![CDATA[\overline {\mathscr {S}}]]></fr:tex> is the set of complete tilings <fr:tex display="inline"><![CDATA[T]]></fr:tex>, such that given an arbitrarily large disk <fr:tex display="inline"><![CDATA[D \subseteq  \mathbb {R}^2]]></fr:tex>, the patch of tiles in <fr:tex display="inline"><![CDATA[T]]></fr:tex> intersecting <fr:tex display="inline"><![CDATA[D]]></fr:tex> appears inside a tiling <fr:tex display="inline"><![CDATA[T' \in  \mathscr {S}]]></fr:tex>, up to translation.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  When we talk about the set of, say, <fr:link href="/forest/tile-0005/" title="Penrose rhombs" uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" type="local">Penrose tilings</fr:link>, we are actually referring to the <html:em>hull</html:em> of all the iterated deflations of a single tile. Each of those iterated deflations only cover a finite portion of the plane, and an <html:em>actual</html:em> tiling completely covers the plane in a way that any finite portion of it can be found in one of those deflations.
</html:p>
                <html:p>
  In our <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">Algorithm <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" /></fr:link>, we are assuming the entire tiling comes from a single iterated deflation, so when we attempt to calculate the neighbor of a tile, we first repeatedly inflate the tiles so that both of them are contained in one giant tile, and then deflate back down. However, an actual tiling may only look like an iterated deflation on each finite patch, so it may be the case that no amount of inflation brings the neighbor into the same supertile.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000B/</fr:uri>
                    <fr:display-uri>tile-000B</fr:display-uri>
                    <fr:route>/forest/tile-000B/</fr:route>
                    <fr:title text="infinite walls">infinite walls</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Consider the substitution system of <fr:link href="/forest/tile-0005/" title="Penrose rhombs" uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" type="local">Penrose rhombs</fr:link>. Take the cyclic <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link>
  <fr:tex display="block"><![CDATA[
    \Sigma _0 = \text {Thin} \xrightarrow {\text {left}} \text {Thin} \xrightarrow {\text {left}} \cdots 
  ]]></fr:tex>
  This repeatedly selects the thin <fr:tex display="inline"><![CDATA[36\degree ]]></fr:tex> subtile on the left. No matter how many times we use the substitution rules, the selected thin rhomb will not have a neighbor.
</html:p>
                    <html:img src="/forest/bafkrmiciww3eu7abwydfm6v5zzzkwnnezp4afjcxzo53mauxinonp7lpha.svg" />
                    <html:p>
  However, after any finite length of this Conway signature, we can replace the rest of the signature with
  <fr:tex display="block"><![CDATA[\cdots  \text {Thin} \xrightarrow {\text {top}} \text {Thick} \xrightarrow {\text {left}} \text {Thick}\xrightarrow {\text {left}} \text {Thick}\xrightarrow {\text {left}} \cdots ]]></fr:tex>
  and this will cover the whole neighborhood. Therefore, for any finite radius, there is a patch of tiling that looks like it can be described by <fr:tex display="inline"><![CDATA[\Sigma _0]]></fr:tex> in that radius. As the radius tends to infinity, these patches converge to a single complete tiling whose center tile has Conway signature <fr:tex display="inline"><![CDATA[\Sigma _0]]></fr:tex>, which is therefore in the <fr:link href="/forest/tile-000A/" title="hull of set of tilings" uri="https://trebor-huang.github.io/forest/tile-000A/" display-uri="tile-000A" type="local">hull</fr:link> of Penrose tilings.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  As an analogy, the neighborhood algorithm behaves like the algorithm adding <fr:tex display="inline"><![CDATA[1]]></fr:tex> to an integer in decimal notation. Suppose it encounters <fr:tex display="inline"><![CDATA[\cdots  999 + 1]]></fr:tex>, then it will scan forwards until it reads a digit <fr:tex display="inline"><![CDATA[d]]></fr:tex> that is not <fr:tex display="inline"><![CDATA[9]]></fr:tex>. Then it performs the carry and outputs <fr:tex display="inline"><![CDATA[[d+1]00\cdots  00]]></fr:tex>. However, the tilings are only required to locally look like iterated deflations. In this analogy, we have numbers that only locally look like an “actual” integer, so it is possible to have infinitely many digit <fr:tex display="inline"><![CDATA[9]]></fr:tex>s. On the other hand, we don’t actually need to read ahead: as soon as we see a <fr:tex display="inline"><![CDATA[9]]></fr:tex>, we can go ahead and output a <fr:tex display="inline"><![CDATA[0]]></fr:tex>, since that is the only possible result! In <fr:link href="/forest/tile-000C/" title="The structure of neighbor Conway signatures" uri="https://trebor-huang.github.io/forest/tile-000C/" display-uri="tile-000C" type="local">§ <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-000C/" display-uri="tile-000C" /></fr:link>, we shall make this precise, in the context of Conway signatures.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-000C/</fr:uri>
                <fr:display-uri>tile-000C</fr:display-uri>
                <fr:route>/forest/tile-000C/</fr:route>
                <fr:title text="The structure of neighbor Conway signatures">The structure of neighbor Conway signatures</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  The <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link> computes neighboring tiles in some iterated deflation of a supertile, and we wish to extend this function to work with the <fr:link href="/forest/tile-000A/" title="hull of set of tilings" uri="https://trebor-huang.github.io/forest/tile-000A/" display-uri="tile-000A" type="local">hull</fr:link> of these deflations, i.e. the full set of possible Penrose tilings. It is first useful to consider a <html:em>binary relation</html:em>, instead of a function, between Conway signatures.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000D/</fr:uri>
                    <fr:display-uri>tile-000D</fr:display-uri>
                    <fr:route>/forest/tile-000D/</fr:route>
                    <fr:title text="neighborhood relation on Conway signatures">neighborhood relation on Conway signatures</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>, two infinite <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signatures</fr:link> <fr:tex display="inline"><![CDATA[\Sigma _1, \Sigma _2]]></fr:tex>, and an edge label <fr:tex display="inline"><![CDATA[\epsilon _1, \epsilon _2]]></fr:tex> for each signature, we define a neighborhood relation, denoted as <fr:tex display="inline"><![CDATA[\Sigma _1 \xrightleftharpoons [\epsilon _2]{\epsilon _1} \Sigma _2]]></fr:tex>. It holds if and only if, for every natural number <fr:tex display="inline"><![CDATA[n]]></fr:tex>, there exists finite signatures <fr:tex display="inline"><![CDATA[\Sigma '_1]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Sigma '_2]]></fr:tex> that agree with <fr:tex display="inline"><![CDATA[\Sigma _1]]></fr:tex> and <fr:tex display="inline"><![CDATA[\Sigma _2]]></fr:tex> at the first <fr:tex display="inline"><![CDATA[n]]></fr:tex> places, and the <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link> sends <fr:tex display="inline"><![CDATA[(\Sigma '_1, \epsilon _1)]]></fr:tex> to <fr:tex display="inline"><![CDATA[(\Sigma '_2, \epsilon _2)]]></fr:tex>.
</html:p>
                    <html:p>
  Note that this relation is symmetric, but not necessarily total or functional.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  Essentially the definition says that, if you look at a finite patch of tiles, it is always plausible that this <html:em>can</html:em> (hence the <fr:tex display="inline"><![CDATA[\exists ]]></fr:tex> quantifier, not <fr:tex display="inline"><![CDATA[\forall ]]></fr:tex>) be extended to a larger patch where they are neighbors in an iterated deflation of one single tile. This also leaves open the possibility that there may be multiple different possible Conway signatures for a neighbor, which is why we opted to consider a binary relation, instead of a function.
</html:p>
                <html:p>
  Next, we need some general theory relating these infinite objects to finite ones. For this we make some definitions.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000E/</fr:uri>
                    <fr:display-uri>tile-000E</fr:display-uri>
                    <fr:route>/forest/tile-000E/</fr:route>
                    <fr:title text="language of neighborhood relation">language of neighborhood relation</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Consider the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> where each symbol is either of the form <fr:tex display="inline"><![CDATA[(\text {tile label }t, \text {edge label of }t)]]></fr:tex> or <fr:tex display="inline"><![CDATA[(\text {tile label }t, \text {subtile label of }t)]]></fr:tex>. We define a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> on <fr:tex display="inline"><![CDATA[\Delta  \times  \Delta ]]></fr:tex>, representing a binary relation on <fr:tex display="inline"><![CDATA[\Delta ^*]]></fr:tex> between words of the same length.
  Let <fr:tex display="block"><![CDATA[\Sigma  = t_0 \xrightarrow {s_1} t_1 \xrightarrow {s_2} \cdots  \xrightarrow {s_n} t_n]]></fr:tex> be a <html:em>finite</html:em> <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link> and <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> be an edge label of the corresponding tile. We regard this as a word <fr:tex display="inline"><![CDATA[(t_0, \epsilon )(t_1, s_1) \cdots  (t_n, s_n)]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex>. Suppose the <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link> sends <fr:tex display="inline"><![CDATA[(\Sigma _1, \epsilon _1)]]></fr:tex> to <fr:tex display="inline"><![CDATA[(\Sigma _2, \epsilon _2)]]></fr:tex>, then the two corresponding words can be zipped together to form a word over <fr:tex display="inline"><![CDATA[\Delta  \times  \Delta ]]></fr:tex>. We define the set of all such words as the <html:strong>language of neighborhood relation</html:strong> <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>.
</html:p>
                    <html:p>
  Furthermore, consider the set of tile labels <fr:tex display="inline"><![CDATA[\mathrm {T}]]></fr:tex>. We define another language <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex>, called the <html:em>augmented</html:em> language of neighborhood relation, over the alphabet <fr:tex display="inline"><![CDATA[(\Delta  \times  \Delta ) \sqcup  \mathrm {T}]]></fr:tex>. Notice that if the <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link> sends <fr:tex display="inline"><![CDATA[(\Sigma _1, \epsilon _1)]]></fr:tex> to <fr:tex display="inline"><![CDATA[(\Sigma _2, \epsilon _2)]]></fr:tex>, the two signatures always share the last prototile label <fr:tex display="inline"><![CDATA[t_n]]></fr:tex>. We append the symbol <fr:tex display="inline"><![CDATA[t_n]]></fr:tex> to the corresponding word in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, and define <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> to be all the words of this form.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  We define the augmented language in this way because it has a very important property, which will be useful later. With this definition in hand, we see that <fr:link href="/forest/tile-000D/" title="neighborhood relation on Conway signatures" uri="https://trebor-huang.github.io/forest/tile-000D/" display-uri="tile-000D" type="local">Definition <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-000D/" display-uri="tile-000D" /></fr:link> can be defined in terms of a well-known construction in <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-languages, i.e. languages with infinitely long words.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000H/</fr:uri>
                    <fr:display-uri>misc-000H</fr:display-uri>
                    <fr:route>/forest/misc-000H/</fr:route>
                    <fr:title text="limit of a language">limit of a language</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given an alphabet <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> and a language <fr:tex display="inline"><![CDATA[\mathcal {L} \subseteq  \Sigma ^*]]></fr:tex>, its <html:strong>limit</html:strong> is an <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-language <fr:tex display="inline"><![CDATA[\lim  \mathcal {L} \subseteq  \Sigma ^\omega ]]></fr:tex> containing the words <fr:tex display="inline"><![CDATA[w]]></fr:tex> such that there are infinitely many finite prefixes of <fr:tex display="inline"><![CDATA[w]]></fr:tex> belonging to <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  We see that the limit of prefixes <fr:tex display="inline"><![CDATA[\operatorname {prfx}\mathcal {L}]]></fr:tex>, or equivalently that of <fr:tex display="inline"><![CDATA[\operatorname {prfx}\mathcal {L}^+]]></fr:tex> is exactly the neighborhood relation on infinite Conway signatures. Limits are nice because they can be recognized by deterministic finite state machines (also known as deterministic Büchi machines, to emphasize they are for <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-languages).
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000I/</fr:uri>
                    <fr:display-uri>misc-000I</fr:display-uri>
                    <fr:route>/forest/misc-000I/</fr:route>
                    <fr:title text="limits of regular languages are deterministic Büchi recognizable">limits of regular languages are deterministic Büchi recognizable</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a regular language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, its <fr:link href="/forest/misc-000H/" title="limit of a language" uri="https://trebor-huang.github.io/forest/misc-000H/" display-uri="misc-000H" type="local">limit</fr:link> <fr:tex display="inline"><![CDATA[\lim  \mathcal {L}]]></fr:tex> can be recognized by a deterministic Büchi automaton, by simply regarding a DFA for <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> as a Büchi automaton. In fact, every deterministic Büchi recognizable <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-language is of this form.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  If <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> is recognized by an automata, then <fr:tex display="inline"><![CDATA[\operatorname {prfx}\mathcal {L}]]></fr:tex> is recognized by an automata with every state declared to be accepting. This paired with <fr:link href="/forest/misc-000I/" title="limits of regular languages are deterministic Büchi recognizable" uri="https://trebor-huang.github.io/forest/misc-000I/" display-uri="misc-000I" type="local">Theorem <fr:contextual-number uri="https://trebor-huang.github.io/forest/misc-000I/" display-uri="misc-000I" /></fr:link> gives a nice construction of a Büchi automata that recognizes neighborhood relations.
  Now, there is one single hypothesis that I am not able to get rid of. It doesn’t even need a constructive proof, as we will later give a construction that provably satisfies the hypothesis <html:em>given that it is true</html:em>.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000F/</fr:uri>
                    <fr:display-uri>tile-000F</fr:display-uri>
                    <fr:route>/forest/tile-000F/</fr:route>
                    <fr:title text="regularity of the neighborhood relation">regularity of the neighborhood relation</fr:title>
                    <fr:taxon>Conjecture</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  For any <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>, the <fr:link href="/forest/tile-000E/" title="language of neighborhood relation" uri="https://trebor-huang.github.io/forest/tile-000E/" display-uri="tile-000E" type="local">language of neighborhood relation</fr:link> is regular.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-000H/</fr:uri>
                <fr:display-uri>tile-000H</fr:display-uri>
                <fr:route>/forest/tile-000H/</fr:route>
                <fr:title text="The transductive algorithm">The transductive algorithm</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  The discussion in <fr:link href="/forest/tile-000C/" title="The structure of neighbor Conway signatures" uri="https://trebor-huang.github.io/forest/tile-000C/" display-uri="tile-000C" type="local">§ <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-000C/" display-uri="tile-000C" /></fr:link> suggests that we can take the following approach to generate neighbor Conway signatures:
</html:p>
                <html:ul><html:li>Construct a finite automaton that recognizes <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, the <fr:link href="/forest/tile-000E/" title="language of neighborhood relation" uri="https://trebor-huang.github.io/forest/tile-000E/" display-uri="tile-000E" type="local">language of neighborhood relation</fr:link>.</html:li>
  <html:li>Convert a recognizer for the binary relation into a <html:em>transducer</html:em>, i.e. a finite state machine with input and output.</html:li>
  <html:li>Simulate the transducer efficiently.</html:li></html:ul>
                <html:p>
  The second step is very easy. Suppose we are working over the alphabet <fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex>, and we have a finite state automata where the transition edges are labelled with pairs <fr:tex display="inline"><![CDATA[(x, y) \in  \Delta  \times  \Delta ]]></fr:tex>. So we can just relabel it by <fr:tex display="inline"><![CDATA[x/y]]></fr:tex>, i.e. a transition that consumes the symbol <fr:tex display="inline"><![CDATA[x]]></fr:tex> and outputs the symbol <fr:tex display="inline"><![CDATA[y]]></fr:tex>. Of course, this results in a non-deterministic transducer. But there is a lot of previous work on executing non-deterministic transducers, which we can use verbatim.
</html:p>
                <html:p>
  So, we have reduced our problem to the first step. But unless we can resolve <fr:link href="/forest/tile-000F/" title="regularity of the neighborhood relation" uri="https://trebor-huang.github.io/forest/tile-000F/" display-uri="tile-000F" type="local">Conjecture <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-000F/" display-uri="tile-000F" /></fr:link> constructively, how are we going to produce such an automaton? This is due to a special property that <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> enjoys, as promised.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000L/</fr:uri>
                    <fr:display-uri>misc-000L</fr:display-uri>
                    <fr:route>/forest/misc-000L/</fr:route>
                    <fr:title text="bideterministic automaton">bideterministic automaton</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A deterministic automaton is <html:strong>bideterministic</html:strong> if it has only one accepting state, and if reversing all transitions and swapping the starting and accepting state produces another deterministic automaton.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000M/</fr:uri>
                    <fr:display-uri>misc-000M</fr:display-uri>
                    <fr:route>/forest/misc-000M/</fr:route>
                    <fr:title text="reversible regular language">reversible regular language</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A regular language is <html:strong>reversible</html:strong> if it can be recognized by a <fr:link href="/forest/misc-000L/" title="bideterministic automaton" uri="https://trebor-huang.github.io/forest/misc-000L/" display-uri="misc-000L" type="local">bideterministic</fr:link> DFA, which is equivalent to requiring the <fr:link href="/forest/misc-000K/" title="Myhill–Nerode automaton" uri="https://trebor-huang.github.io/forest/misc-000K/" display-uri="misc-000K" type="local">Myhill–Nerode automaton</fr:link> to be bideterministic.
</html:p>
                    <html:p>
  Note that there are stronger and weaker notions of reversible regular languages in the literature, with inconsistent names.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000N/</fr:uri>
                    <fr:display-uri>misc-000N</fr:display-uri>
                    <fr:route>/forest/misc-000N/</fr:route>
                    <fr:title text="characterization of reversible languages">characterization of reversible languages</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Given a language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, it is a <fr:link href="/forest/misc-000M/" title="reversible regular language" uri="https://trebor-huang.github.io/forest/misc-000M/" display-uri="misc-000M" type="local">reversible regular language</fr:link> if and only if it is regular, and if <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}]]></fr:tex> for some strings <fr:tex display="inline"><![CDATA[x, y, z]]></fr:tex>, then for all strings <fr:tex display="inline"><![CDATA[w]]></fr:tex> we have <fr:tex display="inline"><![CDATA[xw \in  \mathcal {L} \iff  yw \in  \mathcal {L}]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    See Theorem 7 in <fr:link href="/forest/inference-of-reversible-languages/" title="Inference of Reversible Languages" uri="https://trebor-huang.github.io/forest/inference-of-reversible-languages/" display-uri="inference-of-reversible-languages" type="local">Inference of Reversible Languages</fr:link>.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                </fr:tree>
                <html:p>
  By the way, this suggests a definition for reversible languages in general, without restricting to regular languages. And indeed, Tatham had the <fr:link href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/aperiodic-followup/adjrec-dsf" type="external">important realization</fr:link> that <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> is reversible, although the result there is stated in terms of <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>. This is essentially the same, because in the automaton for <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, there are many accepting states, each corresponding to a tile type. And the automaton for <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> simply adds a “true” accepting state, and connects each of the original accepting states to it by a transition that expects an input character of the correct tile type. Since we know what the tile type is at all times, there is no fundamental difference between the two languages. But for <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex>, the start and end is completely symmetric, so it allows for a cleaner treatment.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000G/</fr:uri>
                    <fr:display-uri>tile-000G</fr:display-uri>
                    <fr:route>/forest/tile-000G/</fr:route>
                    <fr:title text="the augmented language of neighborhood relation is reversible">the augmented language of neighborhood relation is reversible</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Given any <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>, the augmented <fr:link href="/forest/tile-000E/" title="language of neighborhood relation" uri="https://trebor-huang.github.io/forest/tile-000E/" display-uri="tile-000E" type="local">language of neighborhood relation</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {L}^+]]></fr:tex> is <fr:link href="/forest/misc-000M/" title="reversible regular language" uri="https://trebor-huang.github.io/forest/misc-000M/" display-uri="misc-000M" type="local">reversible</fr:link>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    We use the <fr:link href="/forest/misc-000N/" title="characterization of reversible languages" uri="https://trebor-huang.github.io/forest/misc-000N/" display-uri="misc-000N" type="local">characterization of reversible languages</fr:link>. Any substring (ignoring the special starting and ending symbols) in this case describes a fixed geometric transformation between a tile and some supertile that it is contained in. So suppose <fr:tex display="inline"><![CDATA[xz, yz \in  \mathcal {L}^+]]></fr:tex>, then inverting the transformation given by <fr:tex display="inline"><![CDATA[z]]></fr:tex>, we know that <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> describe equivalent geometric configurations of a tile in some supertile. Therefore they must actually be <fr:link href="/forest/misc-000J/" title="Nerode congruence" uri="https://trebor-huang.github.io/forest/misc-000J/" display-uri="misc-000J" type="local">Nerode congruent</fr:link>.
  </html:p>

  <html:p>
    Since we have not rigorously defined the geometric aspects of tile systems, we will not attempt to articulate a completely formal proof. But it should be noted how geometry plays a crucial role here, meaning that substitution systems that are “non-rigid” may fail this property.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                </fr:tree>
                <html:p>
  We are finally ready to discuss the benefits of a reversible language: they admit a very efficient algorithm that learns the language from a series of examples. This problem, called <html:em>language induction</html:em>, is very difficult for general languages.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/misc-000O/</fr:uri>
                    <fr:display-uri>misc-000O</fr:display-uri>
                    <fr:route>/forest/misc-000O/</fr:route>
                    <fr:title text="induction of reversible languages">induction of reversible languages</fr:title>
                    <fr:taxon>Algorithm</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  This algorithm is described in <fr:link href="/forest/inference-of-reversible-languages/" title="Inference of Reversible Languages" uri="https://trebor-huang.github.io/forest/inference-of-reversible-languages/" display-uri="inference-of-reversible-languages" type="local">Inference of Reversible Languages</fr:link>. It inputs a set of example strings in a <fr:link href="/forest/misc-000M/" title="reversible regular language" uri="https://trebor-huang.github.io/forest/misc-000M/" display-uri="misc-000M" type="local">reversible regular language</fr:link>, and outputs a finite <fr:link href="/forest/misc-000L/" title="bideterministic automaton" uri="https://trebor-huang.github.io/forest/misc-000L/" display-uri="misc-000L" type="local">bideterministic automaton</fr:link>. The soundness proof is given as Theorem 26, and if the input enumerates all the strings in the language, then the output is guaranteed to converge to the correct minimal DFA at a finite stage by Theorem 27. Note that obviously we cannot algorithmically determine whether it has converged or not, without further information.
</html:p>
                    <html:p>
  The algorithm proceeds as follows. Start with a trivial automata with a start and accept state, but no transitions. When we read a new example string, add a new chain of states and transitions from the start to the accept state, solely accepting this new string. Then we perform a merging process. Whenever a state has two transitions on the same letter, we merge the destination states, and vice versa for transitions to that state. This process obviously terminates and produces a bideterministic automata. And we can read the next example string.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  It is easy to generate example strings in our use case: simply feed in valid finite Conway signatures in <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">Algorithm <fr:contextual-number uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" /></fr:link>. Now all we need is a way to know when to stop. A possible criterion is when the resulting transducer never rejects a valid Conway signature. To do this, erase the outputs to get an automaton, and determinize it to get a DFA <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Now consider another automaton <fr:tex display="inline"><![CDATA[B]]></fr:tex> that recognizes valid Conway signatures (paired with an edge label at the beginning and a terminating tile label). Take the product of these two automata, remove unreachable states, and check whether there are states where <fr:tex display="inline"><![CDATA[B]]></fr:tex> has a valid transition but <fr:tex display="inline"><![CDATA[A]]></fr:tex> doesn’t. This is essentially a special case of the standard algorithm deciding regular language containment.
</html:p>
                <html:p>
  Since the learned language only grows larger with each example, this condition is obviously sufficient because the original language came from a recursive function. Furthermore, we will prove that under some conditions, this can always be achieved in finite time, so the language inference algorithm terminates. Recall that for the transducer, we modified it so that every state is accepting, so this claim is reduced to the following theorem.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000J/</fr:uri>
                    <fr:display-uri>tile-000J</fr:display-uri>
                    <fr:route>/forest/tile-000J/</fr:route>
                    <fr:title text="totality of the neighborhood relation">totality of the neighborhood relation</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Suppose we have a <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link> that doesn’t involve a prototile that never appears in its <fr:link href="/forest/tile-000A/" title="hull of set of tilings" uri="https://trebor-huang.github.io/forest/tile-000A/" display-uri="tile-000A" type="local">hull</fr:link>, then for every finite <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> with a valid edge label <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>, it is always possible to extend <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> so that the <fr:link href="/forest/tile-0007/" title="recursive neighborhood algorithm" uri="https://trebor-huang.github.io/forest/tile-0007/" display-uri="tile-0007" type="local">recursive neighborhood algorithm</fr:link> accepts it.
</html:p><html:p>
  There are contrived substitution systems that violate the condition of this theorem. For example, consider a one-dimensional system with two kinds of tiles <fr:tex display="inline"><![CDATA[a, b]]></fr:tex>. Let the substitution rules be <fr:tex display="inline"><![CDATA[a \mapsto  aa]]></fr:tex>, <fr:tex display="inline"><![CDATA[b \mapsto  ba]]></fr:tex>. Iterated deflations produce the patches <fr:tex display="inline"><![CDATA[baa\dots  a]]></fr:tex>, and taking the hull results in the periodic tiling <fr:tex display="inline"><![CDATA[\dots  aaa \dots ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[b]]></fr:tex> doesn’t occur. These are probably<fr:tex display="inline"><![CDATA[^?]]></fr:tex> never interesting.
</html:p><html:p>
  Another caveat is when the substitution system contains a final stage of deflation. This technically makes most of the results invalid since deflation rules are no longer unique. But it should be apparent that this can be fixed by suitably changing our definitions and proofs.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    If a prototile <fr:tex display="inline"><![CDATA[t]]></fr:tex> can appear in the hull of <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex>, this means for any radius, there is a patch of tiling in <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex> covering that radius, with this tile in the center. In this case, <fr:tex display="inline"><![CDATA[\mathscr {S}]]></fr:tex> consists of iterated deflations of a single tile. So there exists <fr:tex display="inline"><![CDATA[t']]></fr:tex> such that its <fr:tex display="inline"><![CDATA[n]]></fr:tex>-th deflation contains <fr:tex display="inline"><![CDATA[t]]></fr:tex>, such that all the edges of <fr:tex display="inline"><![CDATA[t]]></fr:tex> have neighbors in the deflation. So <fr:tex display="inline"><![CDATA[t]]></fr:tex> has a Conway signature <fr:tex display="inline"><![CDATA[\Sigma ' = t \rightarrow  \cdots  \rightarrow  t']]></fr:tex>. Now take <fr:tex display="inline"><![CDATA[t]]></fr:tex> to be the last prototile label in <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, and let the extension be the concatenation <fr:tex display="inline"><![CDATA[\Sigma  \frown  \Sigma ']]></fr:tex>.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                </fr:tree>
                <html:p>
  We finish with some discussion on methods to execute the resulting non-deterministic transducer efficiently. One obvious way is to attempt to determinize the transducer. This is not always possible, since the transducer also has a “potential output” state, which means the powerset construction may produce infinitely many states. However, this frequently works, and produces a deterministic finite state transducer.
</html:p>
                <html:p>
  Another, more convenient method is via programs like <fr:link href="https://kleenexlang.org/" type="external">Kleenex</fr:link> to compile the transducers. We can either directly extract the resulting deterministic streaming transducer and simulate it, or compile it into a binary and use FFI.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/tile-000I/</fr:uri>
                <fr:display-uri>tile-000I</fr:display-uri>
                <fr:route>/forest/tile-000I/</fr:route>
                <fr:title text="Seed generation">Seed generation</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  There are multiple ways to generate an initial <fr:link href="/forest/tile-0006/" title="Conway signature" uri="https://trebor-huang.github.io/forest/tile-0006/" display-uri="tile-0006" type="local">Conway signature</fr:link>. If we want to randomly generate a typical tiling according to some natural probability distribution, we can try to calculate the corresponding probability distribution on the signatures. We will also discuss some special eventually periodic signatures, whose tiling exhibit interesting features, such as rotational (or almost rotational) symmetry, fractal structures, and Conway worms, i.e. two similar tilings differing only on a narrow stripe of tiles. In addition, if we see a picture of some tiling in the wild, we may want to calculate Conway signatures that lead to this tiling, even when it is originally generated using a different or unknown technique.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>24</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/tile-000K/</fr:uri>
                    <fr:display-uri>tile-000K</fr:display-uri>
                    <fr:route>/forest/tile-000K/</fr:route>
                    <fr:title text="Distribution of Conway signatures">Distribution of Conway signatures</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a <fr:link href="/forest/tile-0004/" title="substitution system" uri="https://trebor-huang.github.io/forest/tile-0004/" display-uri="tile-0004" type="local">substitution system</fr:link>, there is a canonical probability distribution on the set of tilings with a vertex at the origin. Consider the <html:strong>substitution matrix</html:strong> <fr:tex display="inline"><![CDATA[(a_{ij})]]></fr:tex>, where <fr:tex display="inline"><![CDATA[i, j]]></fr:tex> are labels of prototiles, and <fr:tex display="inline"><![CDATA[a_{ij}]]></fr:tex> is the number of times the tile <fr:tex display="inline"><![CDATA[i]]></fr:tex> appears in <fr:tex display="inline"><![CDATA[j]]></fr:tex>. When, for example, <fr:tex display="inline"><![CDATA[a_{ij} > 0]]></fr:tex> for all entries, there is a unique positive eigenvector <fr:tex display="inline"><![CDATA[v]]></fr:tex>. We can then use <fr:tex display="inline"><![CDATA[v_i]]></fr:tex> as the weight for selecting a tile of type <fr:tex display="inline"><![CDATA[i]]></fr:tex> in each step.
</html:p>
                    <html:p>
  Taking the example of <fr:link href="/forest/tile-0005/" title="Penrose rhombs" uri="https://trebor-huang.github.io/forest/tile-0005/" display-uri="tile-0005" type="local">Penrose rhombs</fr:link>, the substitution matrix is <fr:tex display="block"><![CDATA[\begin {pmatrix}
    2 & 1 \\
    1 & 1
  \end {pmatrix}]]></fr:tex>
  with the unique positive eigenvector <fr:tex display="inline"><![CDATA[v_1 = \frac {1+\sqrt {5}}{2} = \varphi ]]></fr:tex>, <fr:tex display="inline"><![CDATA[v_2 = 1]]></fr:tex>. So given a thick rhomb, we have probability <fr:tex display="inline"><![CDATA[\varphi  /(2\varphi  + 1) = 1/\varphi ^2]]></fr:tex> to select a thick rhomb in its deflated subtiles, and <fr:tex display="inline"><![CDATA[1/(2\varphi +1) = 1/\varphi ^3]]></fr:tex> probability to select the thin rhomb. This defines a Markov process, with steady state distribution also given by <fr:tex display="inline"><![CDATA[v]]></fr:tex> (normalized so the entries sum to <fr:tex display="inline"><![CDATA[1]]></fr:tex>).
</html:p>
                    <html:p>
  However, we usually need to generate the signature in the backwards direction, i.e. from small to big. For this, we just invert the Markov process. Given a prototile <fr:tex display="inline"><![CDATA[i]]></fr:tex>, the probability of it being the <fr:tex display="inline"><![CDATA[s]]></fr:tex>-th subtile of <fr:tex display="inline"><![CDATA[j]]></fr:tex> is given by <fr:tex display="inline"><![CDATA[v_j / v_i]]></fr:tex> times the corresponding probability in the forwards direction.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  (...) discussion of cyclic signatures and their fractal structure
</html:p>
                <html:p>
  (...) signature finder
</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>12</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/hmlg-002Y/</fr:uri>
            <fr:display-uri>hmlg-002Y</fr:display-uri>
            <fr:route>/forest/hmlg-002Y/</fr:route>
            <fr:title text="Ghost and phantom maps">Ghost and phantom maps</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  There are a few different concepts of ghosts and phantoms in homotopy theory.
  <html:ul><html:li>In the unstable world, a <html:strong>ghost map</html:strong> <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex> between CW-complexes is a non-zero map that cannot be detected via homotopy groups (or more generally finite CW-complexes), i.e. all compositions <fr:tex display="inline"><![CDATA[Z \to  X \to  Y]]></fr:tex> with <fr:tex display="inline"><![CDATA[Z]]></fr:tex> finite are null-homotopic.</html:li>
    <html:li>In the stable case, a map between spectra is a (co)homology <html:strong>phantom</html:strong> if all the induced maps on the (co)homology of finite CW-complexes is zero.</html:li>
    <html:li>A stronger condition is given by requiring the induced maps on the (co)homology of <html:em>all spaces</html:em> (equivalently, all suspension spectra, possibly with some desuspensions) are zero. This is called a <html:strong>superphantom map</html:strong>.</html:li>
    <html:li>We can have an even stronger condition, requiring triviality on all spectra. Let’s temporarily call this a (co)homology <html:em>ultraphantom map</html:em>.</html:li></html:ul></html:p>
            <html:p>
  Obviously, when we pass to the stable world, ghost maps becomes cohomology phantom maps. By Spanier–Whitehead duality, we can replace finite CW-complexes with their duals, thus establishing that the cohomology and homology phantom maps are identical. On the other hand, it is impossible to have a cohomology ultraphantom map <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex>, since the identity cohomology class <fr:tex display="inline"><![CDATA[\iota  : X \to  X]]></fr:tex> will be sent to zero, meaning <fr:tex display="inline"><![CDATA[f]]></fr:tex> itself is null-homotopic. Similarly, a ghost map cannot give a cohomology superphantom map.
</html:p>
            <html:p>
  Since homology preserves filtered colimits, every homology superphantom map comes from a phantom map, and vice versa. Similarly, we can extend this to ultraphantom maps. Therefore these three concepts collapse into one, and the phrases <html:em>phantom maps</html:em> and <html:em>superphantom maps</html:em> suffices to unambiguously refer to all of these concepts.
</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>12</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/hmlg-0030/</fr:uri>
                <fr:display-uri>hmlg-0030</fr:display-uri>
                <fr:route>/forest/hmlg-0030/</fr:route>
                <fr:title text="phantom maps K(\mathbb {Q}, n) \to  K(\mathbb {Z}, n+1)">phantom maps <fr:tex display="inline"><![CDATA[K(\mathbb {Q}, n) \to  K(\mathbb {Z}, n+1)]]></fr:tex></fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  By construction, the homotopy classes of maps <fr:tex display="inline"><![CDATA[f : K(\mathbb {Q}, n) \to  K(\mathbb {Z}, n+1)]]></fr:tex> corresponds to elements <fr:tex display="inline"><![CDATA[\operatorname {Ext}(\mathbb {Q}, \mathbb {Z})]]></fr:tex>. However, any map from a finite CW-complex into <fr:tex display="inline"><![CDATA[K(\mathbb {Q}, n)]]></fr:tex> lifts to <fr:tex display="inline"><![CDATA[K(A, n)]]></fr:tex> where <fr:tex display="inline"><![CDATA[A \subseteq  \mathbb {Q}]]></fr:tex> is finitely generated. But <fr:tex display="inline"><![CDATA[\operatorname {Ext}(A, \mathbb {Z}) = 0]]></fr:tex>. This means <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a <fr:link href="/forest/hmlg-002Y/" title="Ghost and phantom maps" uri="https://trebor-huang.github.io/forest/hmlg-002Y/" display-uri="hmlg-002Y" type="local">ghost</fr:link>, and consequently a <fr:link href="/forest/hmlg-002Y/" title="Ghost and phantom maps" uri="https://trebor-huang.github.io/forest/hmlg-002Y/" display-uri="hmlg-002Y" type="local">phantom</fr:link> <fr:tex display="inline"><![CDATA[H \mathbb {Q} \to  \Sigma  H \mathbb {Z}]]></fr:tex>.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>12</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/hmlg-002Z/</fr:uri>
                <fr:display-uri>hmlg-002Z</fr:display-uri>
                <fr:route>/forest/hmlg-002Z/</fr:route>
                <fr:title text="a superphantom map KU \to  \Sigma  H \mathbb  Z">a superphantom map <fr:tex display="inline"><![CDATA[KU \to  \Sigma  H \mathbb  Z]]></fr:tex></fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>
  For the complex <fr:tex display="inline"><![CDATA[K]]></fr:tex>-theory spectrum <fr:tex display="inline"><![CDATA[KU]]></fr:tex>, the integral homology is given by <fr:tex display="inline"><![CDATA[H_{2n} (K U) = \mathbb {Q}]]></fr:tex>, and the odd degrees are zero. Therefore <fr:tex display="inline"><![CDATA[H^1 (KU) = \operatorname {Ext}(\mathbb {Q}, \mathbb {Z})]]></fr:tex> by the universal coefficient theorem. Pick a non-zero map <fr:tex display="inline"><![CDATA[\theta  : KU \to  \Sigma  H \mathbb {Z}]]></fr:tex>. We claim it is a <fr:link href="/forest/hmlg-002Y/" title="Ghost and phantom maps" uri="https://trebor-huang.github.io/forest/hmlg-002Y/" display-uri="hmlg-002Y" type="local">cohomology superphantom map</fr:link>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>12</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    Consider any space <fr:tex display="inline"><![CDATA[X]]></fr:tex>. Cohomology classes <fr:tex display="inline"><![CDATA[\omega  \in  KU(X)]]></fr:tex> correspond to (formal sums of) vector bundles on <fr:tex display="inline"><![CDATA[X]]></fr:tex>, and the image in <fr:tex display="inline"><![CDATA[H^1 (X; \mathbb {Z})]]></fr:tex> assigns a characteristic class <fr:tex display="inline"><![CDATA[\theta (\omega )]]></fr:tex> for each vector bundle. Consider the universal example, the tautological bundle <fr:tex display="inline"><![CDATA[\tau ]]></fr:tex> on <fr:tex display="inline"><![CDATA[BU(n)]]></fr:tex>. All vector bundles come from the pullback of a map <fr:tex display="inline"><![CDATA[f : X \to  BU(n)]]></fr:tex>, and the characteristic class will also come from the pullback <fr:tex display="inline"><![CDATA[f^* \theta (\tau )]]></fr:tex> of the universal characteristic class. However, <fr:tex display="inline"><![CDATA[H^1 (BU(n)) = 0]]></fr:tex>, so this cohomology operation vanishes on all spaces.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/ualg-000H/</fr:uri>
            <fr:display-uri>ualg-000H</fr:display-uri>
            <fr:route>/forest/ualg-000H/</fr:route>
            <fr:title text="Beck monadicity theorem">Beck monadicity theorem</fr:title>
            <fr:taxon>Theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>
  Let <fr:tex display="inline"><![CDATA[G : \mathcal {D} \to  \mathcal {C}]]></fr:tex> be a functor with a left adjoint <fr:tex display="inline"><![CDATA[F]]></fr:tex>. <fr:tex display="inline"><![CDATA[G]]></fr:tex> is <fr:link href="/forest/ualg-000A/" title="monadic functor" uri="https://trebor-huang.github.io/forest/ualg-000A/" display-uri="ualg-000A" type="local">monadic</fr:link> iff <fr:tex display="inline"><![CDATA[G]]></fr:tex> <fr:link href="/forest/ualg-000G/" title="preservation, lifting, reflection and creation of limits" uri="https://trebor-huang.github.io/forest/ualg-000G/" display-uri="ualg-000G" type="local">creates</fr:link> coequalizers whose image under <fr:tex display="inline"><![CDATA[G]]></fr:tex> is <fr:link href="/forest/ualg-000B/" title="split coequalizer" uri="https://trebor-huang.github.io/forest/ualg-000B/" display-uri="ualg-000B" type="local">split</fr:link>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>21</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    For necessity, using <fr:link href="/forest/ualg-000I/" title="limits and colimits created by a monadic functor" uri="https://trebor-huang.github.io/forest/ualg-000I/" display-uri="ualg-000I" type="local">Theorem <fr:contextual-number uri="https://trebor-huang.github.io/forest/ualg-000I/" display-uri="ualg-000I" /></fr:link>, we only need to verify that a monad <fr:tex display="inline"><![CDATA[M]]></fr:tex> preserves the relevant coequalizers, which is true since <fr:link href="/forest/ualg-000D/" title="characterization of absolute coequalizers" uri="https://trebor-huang.github.io/forest/ualg-000D/" display-uri="ualg-000D" type="local">they are absolute</fr:link>.
  </html:p>

  <html:p>
    For sufficiency, we observe the proof of <fr:link href="/forest/ualg-000E/" title="crude monadicity theorem" uri="https://trebor-huang.github.io/forest/ualg-000E/" display-uri="ualg-000E" type="local">Theorem <fr:contextual-number uri="https://trebor-huang.github.io/forest/ualg-000E/" display-uri="ualg-000E" /></fr:link>. Notice that the coequalizers involved are of the form <fr:tex display="inline"><![CDATA[F\alpha , \epsilon  : FGFA \rightrightarrows  FA]]></fr:tex>. The images of these under <fr:tex display="inline"><![CDATA[G]]></fr:tex> are indeed split by <fr:tex display="inline"><![CDATA[\eta  : GFA \to  GFGFA]]></fr:tex> and <fr:tex display="inline"><![CDATA[\eta  : A \to  GFA]]></fr:tex>. Therefore we just have to show <fr:tex display="inline"><![CDATA[G]]></fr:tex> reflects isomorphisms. Given an isomorphism <fr:tex display="inline"><![CDATA[Gf : GA \cong  GB]]></fr:tex>, we have a split coequalizer <fr:tex display="inline"><![CDATA[GA \rightrightarrows  GB \to  GA]]></fr:tex> where the two maps on the left are <fr:tex display="inline"><![CDATA[Gf]]></fr:tex>, and the map on the right is its inverse. This creates a map <fr:tex display="inline"><![CDATA[g : B \to  A]]></fr:tex> which is the coequalizer of <fr:tex display="inline"><![CDATA[f]]></fr:tex> with itself. So this map must be an isomorphism. We then consider the coequalizer <fr:tex display="inline"><![CDATA[GB \rightrightarrows  GA \to  GB]]></fr:tex>, where the two maps on the left are <fr:tex display="inline"><![CDATA[Gg]]></fr:tex> and the map on the right is <fr:tex display="inline"><![CDATA[Gf]]></fr:tex>. Since <fr:tex display="inline"><![CDATA[G]]></fr:tex> reflects this limit, <fr:tex display="inline"><![CDATA[f]]></fr:tex> must also be an isomorphism.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/hmlg-001K/</fr:uri>
            <fr:display-uri>hmlg-001K</fr:display-uri>
            <fr:route>/forest/hmlg-001K/</fr:route>
            <fr:title text="Effective homology">Effective homology</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  This is a set of notes on effective homology and algebraic topology. Main references are <fr:link href="/forest/constructive-homological-algebra/" title="Constructive Homological Algebra and Applications" uri="https://trebor-huang.github.io/forest/constructive-homological-algebra/" display-uri="constructive-homological-algebra" type="local">Constructive Homological Algebra and Applications</fr:link> and <fr:link href="/forest/discrete-vector-fields/" title="Discrete Vector Fields and Fundamental Algebraic Topology" uri="https://trebor-huang.github.io/forest/discrete-vector-fields/" display-uri="discrete-vector-fields" type="local">Discrete Vector Fields and Fundamental Algebraic Topology</fr:link>. We assume basic familiarity with the classical aspects of the theory, although there will also be links within this forest to the relevant concepts.
</html:p>
            <html:ul><html:li><fr:link href="/forest/hmlg-0021/" title="W-bar construction" uri="https://trebor-huang.github.io/forest/hmlg-0021/" display-uri="hmlg-0021" type="local">W-bar construction</fr:link>, simplicial principal bundles, twisted products by <fr:link href="/forest/simplicial-objects/" title="Simplicial objects in algebraic topology" uri="https://trebor-huang.github.io/forest/simplicial-objects/" display-uri="simplicial-objects" type="local">Simplicial objects in algebraic topology</fr:link></html:li>
  <html:li>classifying space, loop space</html:li>
  <html:li>composition of <fr:link href="/forest/hmlg-001I/" title="strong homology equivalence" uri="https://trebor-huang.github.io/forest/hmlg-001I/" display-uri="hmlg-001I" type="local">strong homology equivalence</fr:link>, tensor product, cone, bicomplex</html:li>
  <html:li>simplicial group, Kan complex</html:li>
  <html:li>organize into notes</html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>2</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/hmlg-0001/</fr:uri>
            <fr:display-uri>hmlg-0001</fr:display-uri>
            <fr:route>/forest/hmlg-0001/</fr:route>
            <fr:title text="Homological Algebra">Homological Algebra</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This is a set of notes primarily based on <fr:link href="/forest/homological-algebra/" title="An Introduction to Homological Algebra" uri="https://trebor-huang.github.io/forest/homological-algebra/" display-uri="homological-algebra" type="local">Weibel</fr:link> and <fr:link href="/forest/wwli/" title="Wen-Wei Li" uri="https://trebor-huang.github.io/forest/wwli/" display-uri="wwli" type="local">Wen-Wei Li</fr:link>’s <fr:link href="/forest/methods-of-algebra-2/" title="代数学方法 卷二: 线性代数" uri="https://trebor-huang.github.io/forest/methods-of-algebra-2/" display-uri="methods-of-algebra-2" type="local">unpublished book</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/hmlg-0006/</fr:uri>
                <fr:display-uri>hmlg-0006</fr:display-uri>
                <fr:route>/forest/hmlg-0006/</fr:route>
                <fr:title text="Chain complexes">Chain complexes</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  Chain complexes arose from combinatorial topology, in the form of a sequence of abelian groups <fr:tex display="inline"><![CDATA[C_n]]></fr:tex> freely generated by cells of dimension <fr:tex display="inline"><![CDATA[n]]></fr:tex> (i.e. encoding the formal sums of cells), and a <html:em>boundary</html:em> operator <fr:tex display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The critical feature of the operator is <fr:tex display="block"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0,]]></fr:tex> simply written as <fr:tex display="inline"><![CDATA[d^2 = 0]]></fr:tex>, reflecting a deep geometric phenomenon that <html:mark>the boundary of a shape doesn’t have any boundary itself</html:mark>.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-0002/</fr:uri>
                    <fr:display-uri>hmlg-0002</fr:display-uri>
                    <fr:route>/forest/hmlg-0002/</fr:route>
                    <fr:title text="chain complex of abelian groups">chain complex of abelian groups</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A chain complex of abelian groups is given by a sequence of abelian groups <fr:tex display="inline"><![CDATA[G_\bullet ]]></fr:tex> together with homomorphisms <fr:tex display="inline"><![CDATA[d_n : G_n \to  G_{n-1}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>This is eligible to immediate generalization.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-0003/</fr:uri>
                    <fr:display-uri>hmlg-0003</fr:display-uri>
                    <fr:route>/forest/hmlg-0003/</fr:route>
                    <fr:title text="chain complex of R-modules">chain complex of <fr:tex display="inline"><![CDATA[R]]></fr:tex>-modules</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:meta name="generalizes">hmlg-0002</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A chain complex of <fr:tex display="inline"><![CDATA[R]]></fr:tex>-modules is given by a sequence of modules <fr:tex display="inline"><![CDATA[M_\bullet ]]></fr:tex> together with <fr:tex display="inline"><![CDATA[R]]></fr:tex>-linear maps <fr:tex display="inline"><![CDATA[d_n : R_n \to  R_{n-1}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[d_{n-1} \mathbin {\circ } d_n = 0]]></fr:tex>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>
  Homology can be defined using this algebraic information, without any further reference to topology. Homological algebra is then the algebraic part of reasoning utilized in algebraic topology, repackaged as a stand-alone branch of mathematics. We recall some basics of what we’ve got from algebraic topology.
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-0007/</fr:uri>
                    <fr:display-uri>hmlg-0007</fr:display-uri>
                    <fr:route>/forest/hmlg-0007/</fr:route>
                    <fr:title text="components of a chain complex">components of a chain complex</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Given a <fr:link href="/forest/hmlg-0003/" title="chain complex of R-modules" uri="https://trebor-huang.github.io/forest/hmlg-0003/" display-uri="hmlg-0003" type="local">chain complex</fr:link>, the <html:strong>cycles</html:strong> <fr:tex display="inline"><![CDATA[Z_n]]></fr:tex> of dimension <fr:tex display="inline"><![CDATA[n]]></fr:tex> are given by the kernel of <fr:tex display="inline"><![CDATA[d_n : C_n \to  C_{n-1}]]></fr:tex>. The <html:strong>boundaries</html:strong> <fr:tex display="inline"><![CDATA[B_n]]></fr:tex> are given by the image of <fr:tex display="inline"><![CDATA[d_{n+1} : C_{n+1} \to  C_n]]></fr:tex>. The equation <fr:tex display="inline"><![CDATA[d^2 = 0]]></fr:tex> is equivalent to <fr:tex display="block"><![CDATA[0 \subseteq  B_n \subseteq  Z_n \subseteq  C_n.]]></fr:tex> We can define quotient groups to measure the gaps in the inclusion chain. By the <fr:link href="https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms" type="external">homomorphism theorem</fr:link>, the quotient <fr:tex display="inline"><![CDATA[C_n / Z_n]]></fr:tex> is isomorphic to the image of <fr:tex display="inline"><![CDATA[d_n]]></fr:tex>, which is the next boundary <fr:tex display="inline"><![CDATA[B_{n-1}]]></fr:tex>. On the other hand, the <html:strong>homology groups</html:strong> <fr:tex display="inline"><![CDATA[H_n(C)]]></fr:tex> are defined as the quotient <fr:tex display="inline"><![CDATA[Z_n/B_n]]></fr:tex>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000A/</fr:uri>
                    <fr:display-uri>hmlg-000A</fr:display-uri>
                    <fr:route>/forest/hmlg-000A/</fr:route>
                    <fr:title text="chain complex">chain complex</fr:title>
                    <fr:taxon>Visualization</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Since the boundary subgroup in one dimension can also be considered as a quotient in a lower dimension, it may be beneficial to identify the two in a visualization. This leads to the following picture. Regions appearing to the right are to be considered as quotients, and those to the left as subobjects. Further development of this visualization scheme can be seen <fr:link href="https://www.3blue1brown.com/blog/exact-sequence-picturebook" type="external">here</fr:link>.
</html:p>
  <html:span class="tikz">
    <fr:resource hash="e6f840e52babb21ae173e2964ca5c1be"><fr:resource-content><html:img src="/forest/e6f840e52babb21ae173e2964ca5c1be.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, mathtools, amssymb, stmaryrd, mathrsfs}
      \usetikzlibrary{decorations.pathreplacing}
    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}
    \clip (-1.9, -2.4) rectangle (5.9, 2);
  \tikzset{every path/.style={thick}}

  % The circles
  \draw (-2,0) circle (1.6);

  \draw (0,0) circle (1.6);
  \node at (0, -2) {\(C_{n+1}\)};
  \node at (0,1) {\(H_{n+1}\)};

  \node at (1,0) {\(B_n\)};
  \draw (2,0) circle (1.6);
  \node at (2, -2) {\(C_{n}\)};
  \node at (2,1) {\(H_n\)};

  \node at (3,0) {\(B_{n-1}\)};
  \draw (4,0) circle (1.6);
  \node at (4, -2) {\(C_{n-1}\)};
  \node at (4,1) {\(H_{n-1}\)};

  \draw (6,0) circle (1.6);
\end {tikzpicture}
    ]]></fr:resource-source></fr:resource>
  </html:span>
<html:p>
  We chose to draw circles to emphasize the individual chain groups. In more complicated situations, it is more convenient to draw a chain of rectangles, with each chain group spanning three rectangular regions. We would then need other means to convey the confines of each object.
</html:p></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-0008/</fr:uri>
                    <fr:display-uri>hmlg-0008</fr:display-uri>
                    <fr:route>/forest/hmlg-0008/</fr:route>
                    <fr:title text="chain map">chain map</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Given two chain complexes <fr:tex display="inline"><![CDATA[C_\bullet , D_\bullet ]]></fr:tex>, the natural notion of morphisms between them is <html:strong>chain maps</html:strong>, i.e. a sequence of maps <fr:tex display="inline"><![CDATA[f_n : C_n \to  D_n]]></fr:tex> such that all the squares commute.
</html:p>
  <html:span class="tikz tikzcd">
    <fr:resource hash="d6ebd3fbb0653a3742fcca15309441e6"><fr:resource-content><html:img src="/forest/d6ebd3fbb0653a3742fcca15309441e6.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzcd}
  \cdots  & {C_{n+1}} & {C_n} & {C_{n-1}} & \cdots  \\
  \cdots  & {D_{n+1}} & {D_n} & {D_{n-1}} & \cdots 
  \arrow ["d", from=1-3, to=1-4]
  \arrow ["{f_n}"', from=1-3, to=2-3]
  \arrow ["{f_{n-1}}"', from=1-4, to=2-4]
  \arrow ["d"', from=2-3, to=2-4]
  \arrow ["d"', from=2-2, to=2-3]
  \arrow ["d", from=1-2, to=1-3]
  \arrow [from=1-1, to=1-2]
  \arrow [from=2-1, to=2-2]
  \arrow [from=1-4, to=1-5]
  \arrow [from=2-4, to=2-5]
  \arrow ["{f_{n+1}}"', from=1-2, to=2-2]
\end {tikzcd}
    ]]></fr:resource-source></fr:resource>
  </html:span>
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000B/</fr:uri>
                    <fr:display-uri>hmlg-000B</fr:display-uri>
                    <fr:route>/forest/hmlg-000B/</fr:route>
                    <fr:title text="chain maps induce maps on homology">chain maps induce maps on homology</fr:title>
                    <fr:taxon>Construction</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  A chain map <fr:tex display="inline"><![CDATA[f : C \to  D]]></fr:tex> induces a family of homomorphisms <fr:tex display="inline"><![CDATA[f_* : H_n (C) \to  H_n (D)]]></fr:tex> on the homology groups. The identity map induces the identity morphism, and a composition of maps <fr:tex display="inline"><![CDATA[f \mathbin {\circ } g]]></fr:tex> induces composition homomorphism <fr:tex display="inline"><![CDATA[(f \mathbin {\circ } g)_* = f_* \mathbin {\circ } g_*]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  Since <fr:tex display="inline"><![CDATA[f]]></fr:tex> commutes with the boundary maps, it maps the boundaries in <fr:tex display="inline"><![CDATA[C_n]]></fr:tex> to the boundaries in <fr:tex display="inline"><![CDATA[D_n]]></fr:tex>. Therefore the map is well-defined after passing to the quotient.
</html:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000C/</fr:uri>
                    <fr:display-uri>hmlg-000C</fr:display-uri>
                    <fr:route>/forest/hmlg-000C/</fr:route>
                    <fr:title text="quasi-isomorphism">quasi-isomorphism</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A <fr:link href="/forest/hmlg-0008/" title="chain map" uri="https://trebor-huang.github.io/forest/hmlg-0008/" display-uri="hmlg-0008" type="local">chain map</fr:link> is a <html:strong>quasi-isomorphism</html:strong> if it induces isomorphisms on the <fr:link href="/forest/hmlg-0007/" title="components of a chain complex" uri="https://trebor-huang.github.io/forest/hmlg-0007/" display-uri="hmlg-0007" type="local">homology groups</fr:link>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000D/</fr:uri>
                    <fr:display-uri>hmlg-000D</fr:display-uri>
                    <fr:route>/forest/hmlg-000D/</fr:route>
                    <fr:title text="acyclic chain complex">acyclic chain complex</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  If all the homology groups vanish, then the chain complex is said fo be <html:strong>acyclic</html:strong> or <html:strong>exact</html:strong>. Equivalently, every cycle is a boundary.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>18</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000H/</fr:uri>
                    <fr:display-uri>hmlg-000H</fr:display-uri>
                    <fr:route>/forest/hmlg-000H/</fr:route>
                    <fr:title text="short exact sequence">short exact sequence</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A <html:strong>short exact sequence</html:strong> is an exact sequence with all but three consecutive terms being zero. It is often written as <fr:tex display="block"><![CDATA[0 \to  A \to  B \to  C \to  0.]]></fr:tex> The short exact sequence describes how <fr:tex display="inline"><![CDATA[B]]></fr:tex> is made up of a subobject <fr:tex display="inline"><![CDATA[A]]></fr:tex> and a quotient <fr:tex display="inline"><![CDATA[C]]></fr:tex>.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000E/</fr:uri>
                    <fr:display-uri>hmlg-000E</fr:display-uri>
                    <fr:route>/forest/hmlg-000E/</fr:route>
                    <fr:title text="difference of exactness and acyclicity">difference of exactness and acyclicity</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Although the definition of exactness and acyclicity are the same, they have different <fr:link href="https://ncatlab.org/nlab/show/concept+with+an+attitude" type="external">attitudes</fr:link>. Acyclicity reguards the chain complex as a geometric object, concerning cycles and boundaries. On the other hand, exactness takes a purely algebraic perspective, describing how the algebraic pieces fit together.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>18</fr:day>
                </fr:date>
                <fr:uri>https://trebor-huang.github.io/forest/hmlg-000G/</fr:uri>
                <fr:display-uri>hmlg-000G</fr:display-uri>
                <fr:route>/forest/hmlg-000G/</fr:route>
                <fr:title text="Abelian categories">Abelian categories</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>18</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000L/</fr:uri>
                    <fr:display-uri>hmlg-000L</fr:display-uri>
                    <fr:route>/forest/hmlg-000L/</fr:route>
                    <fr:title text="Operations on chain complexes">Operations on chain complexes</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  It is fruitful to manipulate chain complexes as a whole. This allows us to neatly package some common algebraic operations.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000I/</fr:uri>
                        <fr:display-uri>hmlg-000I</fr:display-uri>
                        <fr:route>/forest/hmlg-000I/</fr:route>
                        <fr:title text="direct sum and product of chain complexes">direct sum and product of chain complexes</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Given a family of chain complexes <fr:tex display="inline"><![CDATA[C_{\alpha , \bullet }]]></fr:tex>, we can take the direct sum in each dimension, giving <fr:tex display="inline"><![CDATA[D_\bullet  = \bigoplus _\alpha  C_{\alpha , \bullet }]]></fr:tex>, which is another chain complex. Dually, we can take the direct product <fr:tex display="inline"><![CDATA[\prod _\alpha  C_{\alpha , \bullet }]]></fr:tex>.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>
  As another example, the consideration of quotienting out a subspace <fr:tex display="inline"><![CDATA[Y \subseteq  X]]></fr:tex> naturally leads us to relative homology. We construct a chain complex by taking a quotient in each dimension: <fr:tex display="block"><![CDATA[0 \to  C_\bullet (Y) \hookrightarrow  C_\bullet (X) \to  C_\bullet (X, Y) \to  0.]]></fr:tex> These maps commute with the boundary maps, so it can be regarded as an exact sequence of chain complexes. Thus we are led to the following definitions.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000K/</fr:uri>
                        <fr:display-uri>hmlg-000K</fr:display-uri>
                        <fr:route>/forest/hmlg-000K/</fr:route>
                        <fr:title text="bicomplex">bicomplex</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  A <html:strong>bicomplex</html:strong> is a chain complex of chain complexes. More specifically, we have a grid of objects <fr:tex display="inline"><![CDATA[A_{m, n}]]></fr:tex>, vertical maps <fr:tex display="inline"><![CDATA[d : A_{m, n} \to  A_{m, n-1}]]></fr:tex> and horizontal maps <fr:tex display="inline"><![CDATA[\delta  : A_{m, n} \to  A_{m-1, n}]]></fr:tex>. Every square in the grid commutes, and <fr:tex display="inline"><![CDATA[d^2 = \delta ^2 = 0]]></fr:tex>.
</html:p>
                        <html:p>
  Each column <fr:tex display="inline"><![CDATA[A_{m, \bullet }]]></fr:tex> in the bicomplex is a chain complex, and <fr:tex display="inline"><![CDATA[\delta ]]></fr:tex> are chain maps between the column complexes. Similarly, each row forms a chain complex, and <fr:tex display="inline"><![CDATA[d]]></fr:tex> are chain maps between the row complexes.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000J/</fr:uri>
                        <fr:display-uri>hmlg-000J</fr:display-uri>
                        <fr:route>/forest/hmlg-000J/</fr:route>
                        <fr:title text="exact sequence of chain complexes">exact sequence of chain complexes</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  An <html:strong>exact sequence</html:strong> of chain complexes <fr:tex display="inline"><![CDATA[C_{m, \bullet }]]></fr:tex> is a <fr:link href="/forest/hmlg-000K/" title="bicomplex" uri="https://trebor-huang.github.io/forest/hmlg-000K/" display-uri="hmlg-000K" type="local">bicomplex</fr:link> such that the rows are <fr:link href="/forest/hmlg-000D/" title="acyclic chain complex" uri="https://trebor-huang.github.io/forest/hmlg-000D/" display-uri="hmlg-000D" type="local">exact</fr:link>.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000V/</fr:uri>
                        <fr:display-uri>hmlg-000V</fr:display-uri>
                        <fr:route>/forest/hmlg-000V/</fr:route>
                        <fr:title text="Kernel, image, cokernel and coimage of chain complexes">Kernel, image, cokernel and coimage of chain complexes</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Given a chain map <fr:tex display="inline"><![CDATA[f_\bullet  : C_\bullet  \to  D_\bullet ]]></fr:tex>, we can take the kernel, image, cokernel and coimage in each dimension, to obtain new chain complexes. It is a matter of unpacking and repacking quotients to verify that the relevant squares commute, rendering the following diagram of chain complexes.
</html:p>
  <html:span class="tikz tikzcd">
    <fr:resource hash="0bc1ee6bda6f8c4f95778bed17501fc5"><fr:resource-content><html:img src="/forest/0bc1ee6bda6f8c4f95778bed17501fc5.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
            \usepackage{mlmodern, tikz, tikz-cd, quiver, mathtools, amssymb, stmaryrd, mathrsfs}
    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzcd}
  && {\operatorname {im} f} & {\operatorname {coim} f} \\
  & C &&& D \\
  {\ker  f} &&&&& {\operatorname {coker} f}
  \arrow ["\sim ", from=1-3, to=1-4]
  \arrow [from=2-2, to=1-3]
  \arrow [from=1-4, to=2-5]
  \arrow [from=3-1, to=2-2]
  \arrow [from=2-5, to=3-6]
\end {tikzcd}
    ]]></fr:resource-source></fr:resource>
  </html:span>
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-000U/</fr:uri>
                    <fr:display-uri>hmlg-000U</fr:display-uri>
                    <fr:route>/forest/hmlg-000U/</fr:route>
                    <fr:title text="Additive and abelian categories">Additive and abelian categories</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Since many <fr:link href="/forest/hmlg-000L/" title="Operations on chain complexes" uri="https://trebor-huang.github.io/forest/hmlg-000L/" display-uri="hmlg-000L" type="local">operations</fr:link> on abelian groups and <fr:tex display="inline"><![CDATA[R]]></fr:tex>-modules can be performed on chain complexes, we wish to axiomatize an abstract notion to encapsulate them all. This motivates the definition of additive and abelian categories. We can use the three examples mentioned above as the source for intuitions for abelian categories.
</html:p>
                    <html:p>
  First, we wish to let the morphisms form abelian groups. This turns out to have a surprising impact on the structure of categories, the most important of which is the coincidence of finite products and coproducts.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000O/</fr:uri>
                        <fr:display-uri>hmlg-000O</fr:display-uri>
                        <fr:route>/forest/hmlg-000O/</fr:route>
                        <fr:title text="\mathsf {Ab}-enriched category"><fr:tex display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Given a category <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, an <fr:tex display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment is given by abelian group structures on every hom-set, such that composition is linear in each argument. In other words, we have a homomorphism <fr:tex display="inline"><![CDATA[\hom (Y, Z) \otimes  \hom (X, Y) \to  \hom (X, Z)]]></fr:tex>.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000P/</fr:uri>
                        <fr:display-uri>hmlg-000P</fr:display-uri>
                        <fr:route>/forest/hmlg-000P/</fr:route>
                        <fr:title text="additive category">additive category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Let <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be <fr:link href="/forest/hmlg-000O/" title="\mathsf {Ab}-enriched category" uri="https://trebor-huang.github.io/forest/hmlg-000O/" display-uri="hmlg-000O" type="local"><fr:tex display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched</fr:link>. The finite products and coproducts, if they exist, are isomorphic via a canonical map. If they all exist, then this category is called an <html:strong>additive category</html:strong>. In particular, the nullary product and coproduct coincide, and we call the object <html:strong>zero object</html:strong>, denoted <fr:tex display="inline"><![CDATA[0]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    By the universal property of products and coproducts, a map from the coproduct of some objects <fr:tex display="inline"><![CDATA[X_i]]></fr:tex> to their product is given by a matrix of morphisms <fr:tex display="inline"><![CDATA[f_{ij} : X_i \to  X_j]]></fr:tex>. We choose the identity matrix
    <fr:tex display="block"><![CDATA[f_{ij} = \begin {cases}
      \textrm {id} & (i = j) \\
      0 & (i \ne  j)
    \end {cases}]]></fr:tex>
    where <fr:tex display="inline"><![CDATA[0]]></fr:tex> is the additive neutral element in the abelian group <fr:tex display="inline"><![CDATA[\hom (X_i, X_j)]]></fr:tex>. This gives a canonical map <fr:tex display="inline"><![CDATA[\coprod _i X_i \to  \prod _i X_i]]></fr:tex>.
  </html:p>

  <html:p>
    When there are finitely many objects involved, we can construct an inverse. Consider the morphisms <fr:tex display="block"><![CDATA[\prod _i X_i \xrightarrow {\pi _j} X_j \xrightarrow {\iota _j} \coprod _i X_i.]]></fr:tex> We claim the sum of these morphisms is the desired inverse. To verify this, we compose them. Using bilinearity, we are reduced to showing that the coproduct and product of the identity map is the identity, which is true.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <html:p>
  Due to this coincidence creating gadgets with <html:em>two universal properties</html:em>, the structure of additive categories are uniquely determined. This also means that we only need very mild conditions on functors to preserve the structures of an additive category.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000R/</fr:uri>
                        <fr:display-uri>hmlg-000R</fr:display-uri>
                        <fr:route>/forest/hmlg-000R/</fr:route>
                        <fr:title text="being an additive category is a property">being an additive category is a <fr:link href="/forest/todo/" title="Unfinished trees" uri="https://trebor-huang.github.io/forest/todo/" display-uri="todo" type="local">property</fr:link></fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Given a category, if it can be endowed with an <fr:link href="/forest/hmlg-000O/" title="\mathsf {Ab}-enriched category" uri="https://trebor-huang.github.io/forest/hmlg-000O/" display-uri="hmlg-000O" type="local"><fr:tex display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enrichment</fr:link> that makes it an <fr:link href="/forest/hmlg-000P/" title="additive category" uri="https://trebor-huang.github.io/forest/hmlg-000P/" display-uri="hmlg-000P" type="local">additive category</fr:link>, then it only has one possible enrichment. In particular, there is at most one way to turn a category into an additive category.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    Notice that having finite products and coproducts is a <fr:link href="/forest/todo/" title="Unfinished trees" uri="https://trebor-huang.github.io/forest/todo/" display-uri="todo" type="local">property</fr:link>, and the canonical morphism between them being an isomorphism is also a <fr:link href="/forest/todo/" title="Unfinished trees" uri="https://trebor-huang.github.io/forest/todo/" display-uri="todo" type="local">property</fr:link>. These do not mention the enrichment structure.
  </html:p>

  <html:p>
    With these properties satisfied, the addition structure on the <fr:tex display="inline"><![CDATA[\hom ]]></fr:tex>-sets are fixed. We claim that the additive neutral element is given by the composition
    <fr:tex display="block"><![CDATA[X \to  0 \to  Y,]]></fr:tex>
    and given two parallel morphisms <fr:tex display="inline"><![CDATA[f, g : X \to  Y]]></fr:tex>, the following composition
    <fr:tex display="block"><![CDATA[X \xrightarrow {\Delta } X \oplus  X \xrightarrow {f \oplus  g} Y \oplus  Y \xrightarrow {\nabla } Y.]]></fr:tex>
    is equal to the addition <fr:tex display="inline"><![CDATA[f + g]]></fr:tex>. For disambiguation, we temporarily denote these constructions as <fr:tex display="inline"><![CDATA[0']]></fr:tex> and <fr:tex display="inline"><![CDATA[f +' g]]></fr:tex>. By interpreting <fr:tex display="inline"><![CDATA[\oplus ]]></fr:tex> as a product or a coproduct at appropriate times, it is easy to see that <fr:tex display="inline"><![CDATA[0']]></fr:tex> is indeed the neutral element for <fr:tex display="inline"><![CDATA[+']]></fr:tex>.
  </html:p>

  <html:p>
    Recall that arrows <fr:tex display="inline"><![CDATA[X \oplus  X \to  Y \oplus  Y]]></fr:tex> is given by a <fr:tex display="inline"><![CDATA[2 \times  2]]></fr:tex> matrix, and this correspondence is an abelian group isomorphism by general enriched category theory. <fr:tex display="inline"><![CDATA[f \oplus  g]]></fr:tex> comes from a diagonal matrix with <fr:tex display="inline"><![CDATA[f, g]]></fr:tex> as entries, so this operation is linear, which entails <fr:tex display="inline"><![CDATA[+']]></fr:tex> is also linear. By the <fr:link href="/forest/todo/" title="Unfinished trees" uri="https://trebor-huang.github.io/forest/todo/" display-uri="todo" type="local">Eckmann–Hilton argument</fr:link>, the two addition operations must coincide.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000S/</fr:uri>
                        <fr:display-uri>hmlg-000S</fr:display-uri>
                        <fr:route>/forest/hmlg-000S/</fr:route>
                        <fr:title text="additive functor">additive functor</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Given two <fr:link href="/forest/hmlg-000P/" title="additive category" uri="https://trebor-huang.github.io/forest/hmlg-000P/" display-uri="hmlg-000P" type="local">additive categories</fr:link> and a functor <fr:tex display="inline"><![CDATA[F : \mathcal {C} \to  \mathcal {D}]]></fr:tex> between them, the following are equivalent. In this case, we call the functor <html:strong>additive</html:strong>.
</html:p><html:ul><html:li>The functor preserves finite products.</html:li>
  <html:li>The functor preserves finite coproducts.</html:li>
  <html:li>The functor is a homomorphism on the abelian groups <fr:tex display="inline"><![CDATA[\hom _{\mathcal {C}}(X, Y)]]></fr:tex>, i.e. it is an <fr:tex display="inline"><![CDATA[\mathsf {Ab}]]></fr:tex>-enriched functor.</html:li></html:ul>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    For the equivalence of the first two claims, we have a composition
    <fr:tex display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y),]]></fr:tex>
    where the middle morphism comes from the canonical isomorphism <fr:tex display="inline"><![CDATA[X + Y \stackrel {\sim \,}{\to } F(X \times  Y)]]></fr:tex>. The first two claim is equivalent to the right and left arrows being iso, respectively. Recall that a morphism from a coproduct to a product is determined by a matrix of morphisms. With this fact and the functoriality of <fr:tex display="inline"><![CDATA[F]]></fr:tex>, we can compute that the composition is the canonical isomorphism from <fr:tex display="inline"><![CDATA[F(X) + F(Y)]]></fr:tex> to <fr:tex display="inline"><![CDATA[F(X) \times  F(Y)]]></fr:tex>. Therefore the leftmost arrow being iso is equivalent to the rightmost arrow being iso.
  </html:p>

  <html:p>
    Since the abelian group structure on morphisms is <fr:link href="/forest/hmlg-000R/" title="being an additive category is a property" uri="https://trebor-huang.github.io/forest/hmlg-000R/" display-uri="hmlg-000R" type="local">uniquely determined</fr:link> from the finite products and coproducts in an additive category, a functor satisfying the first two conditions automatically satisfies the third. Conversely, we need to prove the canonical maps <fr:tex display="inline"><![CDATA[F(1) \to  1]]></fr:tex> and <fr:tex display="inline"><![CDATA[F(X \times  Y) \to  F(X) \times  F(Y)]]></fr:tex> are isomorphisms. For the first one, since <fr:tex display="inline"><![CDATA[1]]></fr:tex> is also the initial object, any morphism into it is automatically iso. For the second one, we again look at the diagram which composes to an isomorphism:
    <fr:tex display="block"><![CDATA[F(X) + F(Y) \to  F(X + Y) \stackrel {\sim \,}{\to } F(X \times  Y) \to  F(X) \times  F(Y).]]></fr:tex>
    Using the bilinearity of composition and that <fr:tex display="inline"><![CDATA[F]]></fr:tex> preserves addition on morphisms, we can verify that this provides a two-sided inverse.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000T/</fr:uri>
                        <fr:display-uri>hmlg-000T</fr:display-uri>
                        <fr:route>/forest/hmlg-000T/</fr:route>
                        <fr:title text="adjunctions are additive">adjunctions are additive</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  In an adjunction <fr:tex display="inline"><![CDATA[F \dashv  G]]></fr:tex>, both functors are automatically additive.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Since the left adjoint preserves colimits, it preserves finite coproducts. Therefore by <fr:link href="/forest/hmlg-000S/" title="additive functor" uri="https://trebor-huang.github.io/forest/hmlg-000S/" display-uri="hmlg-000S" type="local">Definition <fr:contextual-number uri="https://trebor-huang.github.io/forest/hmlg-000S/" display-uri="hmlg-000S" /></fr:link> it is an additive functor. Dually, the right adjoint preserves limits, and is also additive.</html:p></fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <html:p>
  Kernels and cokernels are also greatly simplified in additive categories.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000Y/</fr:uri>
                        <fr:display-uri>hmlg-000Y</fr:display-uri>
                        <fr:route>/forest/hmlg-000Y/</fr:route>
                        <fr:title text="equalizers can be reduced to kernels in \Cat {Ab}-enriched categories">equalizers can be reduced to kernels in <fr:tex display="inline"><![CDATA[\Cat {Ab}]]></fr:tex>-enriched categories</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  We can express equalizers with kernels (which are equalizers with the zero morphism).
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    We simply need to note that an equalizer for <fr:tex display="inline"><![CDATA[f]]></fr:tex> and <fr:tex display="inline"><![CDATA[g]]></fr:tex> is equivalent to an equalizer for <fr:tex display="inline"><![CDATA[(f-g)]]></fr:tex> and <fr:tex display="inline"><![CDATA[0]]></fr:tex>, by bilinearity of composition.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000W/</fr:uri>
                        <fr:display-uri>hmlg-000W</fr:display-uri>
                        <fr:route>/forest/hmlg-000W/</fr:route>
                        <fr:title text="abelian categories">abelian categories</fr:title>
                        <fr:taxon>Intuition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p><fr:link href="/forest/hmlg-000Q/" title="abelian category" uri="https://trebor-huang.github.io/forest/hmlg-000Q/" display-uri="hmlg-000Q" type="local">Abelian categories</fr:link> are one step further from <fr:link href="/forest/hmlg-000P/" title="additive category" uri="https://trebor-huang.github.io/forest/hmlg-000P/" display-uri="hmlg-000P" type="local">additive categories</fr:link>. Similar to the situation of abelian groups or modules, every morphism <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex> has four key components, the image, the kernel, the coimage <fr:tex display="inline"><![CDATA[X / \ker  f]]></fr:tex>, and the cokernel <fr:tex display="inline"><![CDATA[Y / \operatorname {im} f]]></fr:tex>. The image is always identical with the coimage, representing the core part of the homomorphism. The kernel perfectly measures the failure of injectivity, and the cokernel perfectly measures the failure of surjectivity. This is in stark constrast with general maps, where the failure of injectivity may be heterogeneous, and thus cannot be simply characterized.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>18</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000Q/</fr:uri>
                        <fr:display-uri>hmlg-000Q</fr:display-uri>
                        <fr:route>/forest/hmlg-000Q/</fr:route>
                        <fr:title text="abelian category">abelian category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Given an <fr:link href="/forest/hmlg-000P/" title="additive category" uri="https://trebor-huang.github.io/forest/hmlg-000P/" display-uri="hmlg-000P" type="local">additive category</fr:link>, it is an <html:strong>abelian category</html:strong> if the following condition holds.
</html:p>
                        <html:ul><html:li>Every morphism has a kernel and a cokernel.</html:li>
  <html:li>Every monomorphism is the kernel of its cokernel.</html:li>
  <html:li>Every epimorphism is the cokernel of its kernel.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>
  The definition of abelian categories may look intimidating, but thinking of it as <fr:tex display="inline"><![CDATA[R]]></fr:tex>-modules is a very effective way to reduce mental load. In fact, <fr:link href="/forest/hmlg-000F/" title="Freyd–Mitchell embedding theorem" uri="https://trebor-huang.github.io/forest/hmlg-000F/" display-uri="hmlg-000F" type="local">the Freyd–Mitchell embedding theorem</fr:link> justifies this to some extent, allowing us to use familiar language such as taking and manipulating elements.
</html:p>
                    <html:p>
  Although practically every important functor between additive categories is additive, the same cannot be said for abelian categories. Functors preserving the structure of abelian categories are called <fr:link href="/forest/hmlg-000X/" title="left and right exact functor" uri="https://trebor-huang.github.io/forest/hmlg-000X/" display-uri="hmlg-000X" type="local">exact</fr:link>, but many functors fail to satisfy this for various reasons. <html:mark>One of the main endeavours of homological algebra is to characterize the failures of exactness, and study their consequences.</html:mark> This leads to intricate and beautiful structures emerging.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-000X/</fr:uri>
                        <fr:display-uri>hmlg-000X</fr:display-uri>
                        <fr:route>/forest/hmlg-000X/</fr:route>
                        <fr:title text="left and right exact functor">left and right exact functor</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  An <fr:link href="/forest/hmlg-000S/" title="additive functor" uri="https://trebor-huang.github.io/forest/hmlg-000S/" display-uri="hmlg-000S" type="local">additive functor</fr:link> <fr:tex display="inline"><![CDATA[F : \mathcal {A} \to  \mathcal {B}]]></fr:tex> between abelian categories is <html:strong>left exact</html:strong> if it satisfies the following equivalent conditions.
</html:p><html:ul><html:li>It preserves kernels.</html:li>
  <html:li>It preserves finite limits.</html:li>
  <html:li>It preserves the exactness of sequences <fr:tex display="block"><![CDATA[0 \to  A \to  B \to  C.]]></fr:tex></html:li></html:ul><html:p>
  Dually, an additive functor is <html:strong>right exact</html:strong> if it satisfies the following equivalent conditions.
</html:p><html:ul><html:li>It preserves cokernels.</html:li>
  <html:li>It preserves finite colimits.</html:li>
  <html:li>It preserves the exactness of sequences <fr:tex display="block"><![CDATA[A \to  B \to  C \to  0.]]></fr:tex></html:li></html:ul><html:p>
  If a functor is both left exact and right exact, it is simply called an <html:strong>exact functor</html:strong>, which is equivalent to it preserving the exactness of sequences <fr:tex display="inline"><![CDATA[A \to  B \to  C]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    Since additive functors already preserves finite products, and <fr:link href="/forest/hmlg-000Y/" title="equalizers can be reduced to kernels in \Cat {Ab}-enriched categories" uri="https://trebor-huang.github.io/forest/hmlg-000Y/" display-uri="hmlg-000Y" type="local">kernels are equivalent to general equalizers</fr:link> using the additive structure, the first two conditions are equivalent.
  </html:p>

  <html:p>
    The sequence <fr:tex display="inline"><![CDATA[A \rightarrowtail  B \to  C]]></fr:tex> being exact is equivalent to <fr:tex display="inline"><![CDATA[A]]></fr:tex> being a kernel of <fr:tex display="inline"><![CDATA[B \to  C]]></fr:tex>. So the third condition is equivalent to the first. This completes the equivalence proof.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://trebor-huang.github.io/forest/hmlg-002H/</fr:uri>
                    <fr:display-uri>hmlg-002H</fr:display-uri>
                    <fr:route>/forest/hmlg-002H/</fr:route>
                    <fr:title text="Exactness of \hom ">Exactness of <fr:tex display="inline"><![CDATA[\hom ]]></fr:tex></fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Since <fr:tex display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves limits, by <fr:link href="/forest/hmlg-000X/" title="left and right exact functor" uri="https://trebor-huang.github.io/forest/hmlg-000X/" display-uri="hmlg-000X" type="local">Definition <fr:contextual-number uri="https://trebor-huang.github.io/forest/hmlg-000X/" display-uri="hmlg-000X" /></fr:link> it is left exact. Similarly <fr:tex display="inline"><![CDATA[\hom (-, I)]]></fr:tex> is right exact. Therefore we naturally want to find out when <fr:tex display="inline"><![CDATA[\hom (P, -)]]></fr:tex> is <html:em>right</html:em> exact. We only need to guarantee that <fr:tex display="inline"><![CDATA[\hom (P, -)]]></fr:tex> preserves epimorphisms. This can be unpackaged to the following definition.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>16</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-0004/</fr:uri>
                        <fr:display-uri>hmlg-0004</fr:display-uri>
                        <fr:route>/forest/hmlg-0004/</fr:route>
                        <fr:title text="projective object">projective object</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In an abelian category, an object <fr:tex display="inline"><![CDATA[P]]></fr:tex> is <html:strong>projective</html:strong> iff for every morphism <fr:tex display="inline"><![CDATA[P \to  B]]></fr:tex> can be lifted through an epimorphism <fr:tex display="inline"><![CDATA[A \twoheadrightarrow  B]]></fr:tex>, i.e. there exists a (non-unique) morphism <fr:tex display="inline"><![CDATA[P \to  A]]></fr:tex> making the triangle commute.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>16</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-0005/</fr:uri>
                        <fr:display-uri>hmlg-0005</fr:display-uri>
                        <fr:route>/forest/hmlg-0005/</fr:route>
                        <fr:title text="projective objects">projective objects</fr:title>
                        <fr:taxon>Intuition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p><fr:link href="/forest/hmlg-0004/" title="projective object" uri="https://trebor-huang.github.io/forest/hmlg-0004/" display-uri="hmlg-0004" type="local">Projective objects</fr:link> are defined to capture a key property of free objects. For an arbitrary abelian group <fr:tex display="inline"><![CDATA[P]]></fr:tex>, lifting a map <fr:tex display="inline"><![CDATA[P \to  B]]></fr:tex> through an epimorphism requires us to pick a lifting for every generator, such that the relations between the generators still hold after lifting. If such a thing can always be done, then we may say that the relations, or tangling between generators are practically non-existent. A projective object can thus be reguarded as generated by some elements with zero or undetectable “tangling”.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>
  As an example, consider the projective objects in the category of modules. We can give a nice characterization of projective modules.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>6</fr:month>
                          <fr:day>8</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-002I/</fr:uri>
                        <fr:display-uri>hmlg-002I</fr:display-uri>
                        <fr:route>/forest/hmlg-002I/</fr:route>
                        <fr:title text="projective modules are direct summands of free modules">projective modules are direct summands of free modules</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  In the <fr:link href="/forest/hmlg-000Q/" title="abelian category" uri="https://trebor-huang.github.io/forest/hmlg-000Q/" display-uri="hmlg-000Q" type="local">abelian category</fr:link> of modules over a ring <fr:tex display="inline"><![CDATA[R]]></fr:tex>, the <fr:link href="/forest/hmlg-0004/" title="projective object" uri="https://trebor-huang.github.io/forest/hmlg-0004/" display-uri="hmlg-0004" type="local">projective object</fr:link> modules are exactly the modules that appear as a direct summand of some free module <fr:tex display="inline"><![CDATA[P \oplus  Q = R^{\oplus  n}]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    A free module evidently projective. If <fr:tex display="inline"><![CDATA[P]]></fr:tex> is a direct summand of a projective module <fr:tex display="inline"><![CDATA[Q]]></fr:tex>, then we can extend any map <fr:tex display="inline"><![CDATA[P \to  B]]></fr:tex> to <fr:tex display="inline"><![CDATA[Q]]></fr:tex> by zero. Then the projectivity of <fr:tex display="inline"><![CDATA[Q]]></fr:tex> implies that of <fr:tex display="inline"><![CDATA[P]]></fr:tex>.
  </html:p>

  <html:p>
    On the other hand, suppose <fr:tex display="inline"><![CDATA[P]]></fr:tex> is projective, then we have an epimorphism <fr:tex display="inline"><![CDATA[R^{\oplus  |P|} \twoheadrightarrow  P]]></fr:tex>. The identity map <fr:tex display="inline"><![CDATA[P \to  P]]></fr:tex> lifts against this epimorphism to a splitting of it, hence <fr:tex display="inline"><![CDATA[P]]></fr:tex> is its direct summand.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                    <html:p>
  Dually, we have the definition of injective objects, which make <fr:tex display="inline"><![CDATA[\hom (-, I)]]></fr:tex> exact.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>6</fr:month>
                          <fr:day>12</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-002J/</fr:uri>
                        <fr:display-uri>hmlg-002J</fr:display-uri>
                        <fr:route>/forest/hmlg-002J/</fr:route>
                        <fr:title text="injective object">injective object</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  In an <fr:link href="/forest/hmlg-000Q/" title="abelian category" uri="https://trebor-huang.github.io/forest/hmlg-000Q/" display-uri="hmlg-000Q" type="local">abelian category</fr:link>, an object <fr:tex display="inline"><![CDATA[I]]></fr:tex> is <html:strong>injective</html:strong> iff every morphism <fr:tex display="inline"><![CDATA[B \to  I]]></fr:tex> can be extended along monomorphisms <fr:tex display="inline"><![CDATA[B \rightarrowtail  A]]></fr:tex>. Equivalently, it is a <fr:link href="/forest/hmlg-0004/" title="projective object" uri="https://trebor-huang.github.io/forest/hmlg-0004/" display-uri="hmlg-0004" type="local">projective object</fr:link> in the dual category.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>
  As an example, we characterize injective abelian groups. Similar characterizations can be done for modules over principal ideal domains.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>6</fr:month>
                          <fr:day>17</fr:day>
                        </fr:date>
                        <fr:uri>https://trebor-huang.github.io/forest/hmlg-002O/</fr:uri>
                        <fr:display-uri>hmlg-002O</fr:display-uri>
                        <fr:route>/forest/hmlg-002O/</fr:route>
                        <fr:title text="abelian groups are injective iff divisible">abelian groups are injective iff divisible</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  An abelian group <fr:tex display="inline"><![CDATA[G]]></fr:tex> is <fr:link href="/forest/hmlg-002J/" title="injective object" uri="https://trebor-huang.github.io/forest/hmlg-002J/" display-uri="hmlg-002J" type="local">injective</fr:link> iff it is <html:strong>divisible</html:strong>, i.e. for element <fr:tex display="inline"><![CDATA[g \in  G]]></fr:tex> and positive integer <fr:tex display="inline"><![CDATA[n]]></fr:tex>, there exists a (non-unique) solution of <fr:tex display="inline"><![CDATA[nx = g]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    In one direction, suppose the group is injective, then the map <fr:tex display="inline"><![CDATA[\mathbb {Z} \to  G]]></fr:tex> defined by <fr:tex display="inline"><![CDATA[k \mapsto  k g]]></fr:tex> can be extended along the monomorphism <fr:tex display="inline"><![CDATA[(n \times  -) : \mathbb {Z} \to  \mathbb {Z}]]></fr:tex>. This provides the division.
  </html:p>

  <html:p>
    On the other hand, suppose divisibility holds. Given a morphism <fr:tex display="inline"><![CDATA[f : A \to  G]]></fr:tex> and an injection <fr:tex display="inline"><![CDATA[A \hookrightarrow  B]]></fr:tex>, we extend <fr:tex display="inline"><![CDATA[f]]></fr:tex> to <fr:tex display="inline"><![CDATA[B]]></fr:tex> by Zorn’s lemma. Consider the poset of homomorphisms extending <fr:tex display="inline"><![CDATA[f]]></fr:tex> to some subgroup of <fr:tex display="inline"><![CDATA[B]]></fr:tex>. Given a chain in this poset, we can take the union to create an upper bound. And it is non-empty since <fr:tex display="inline"><![CDATA[f]]></fr:tex> is an element. Hence it has a maximal element <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. Suppose it is defined on <fr:tex display="inline"><![CDATA[B' \subsetneq  B]]></fr:tex>, then there is an element <fr:tex display="inline"><![CDATA[b \in  B]]></fr:tex> not in <fr:tex display="inline"><![CDATA[B']]></fr:tex>. Suppose <fr:tex display="inline"><![CDATA[n b \notin  B']]></fr:tex> for all non-zero integers <fr:tex display="inline"><![CDATA[n]]></fr:tex>, then we can define a larger homomorphism on <fr:tex display="inline"><![CDATA[B + \mathbb {Z} b]]></fr:tex>, contradicting the maximality. Suppose there is some <fr:tex display="inline"><![CDATA[n b \in  B']]></fr:tex>, then by divisibility we can assign <fr:tex display="inline"><![CDATA[\phi (b)]]></fr:tex> a division of <fr:tex display="inline"><![CDATA[\phi (n b)]]></fr:tex> by <fr:tex display="inline"><![CDATA[n]]></fr:tex>. This too contradicts maximality.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
