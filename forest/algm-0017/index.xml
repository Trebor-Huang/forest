<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/forest/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/forest/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>3</fr:month>
      <fr:day>15</fr:day>
    </fr:date>
    <fr:uri>https://trebor-huang.github.io/forest/algm-0017/</fr:uri>
    <fr:display-uri>algm-0017</fr:display-uri>
    <fr:route>/forest/algm-0017/</fr:route>
    <fr:title text="affine local properties">affine local properties</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter><html:p>
  Suppose a property on affine subschemes <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex> is closed under taking distinguished subsets <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_f) \hookrightarrow  X]]></fr:tex>, and for <fr:tex display="inline"><![CDATA[\gcd \{f_i\} = 1]]></fr:tex>, the property being true on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_{f_i}) \hookrightarrow  X]]></fr:tex> implies it being true on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R) \hookrightarrow  X]]></fr:tex>. Then such a property is called <html:strong>affine local</html:strong>. We then say that <fr:tex display="inline"><![CDATA[X]]></fr:tex> has such a property if some affine cover has such a property: the result doesn’t depend on the chosen cover.
</html:p><html:p>
  If the property <fr:tex display="inline"><![CDATA[P]]></fr:tex> only depends on <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R)]]></fr:tex> and not <fr:tex display="inline"><![CDATA[X]]></fr:tex> (or the inclusion map), it can be simplified as a property on affine schemes. In this case, the above definition extends it to a property <fr:tex display="inline"><![CDATA[P']]></fr:tex> on schemes, which we will usually refer to as <html:strong>locally</html:strong> <fr:tex display="inline"><![CDATA[P]]></fr:tex>. Suppose the scheme is furthermore <fr:link href="/forest/algm-000A/" title="terminology of compactness in algebraic geometry" uri="https://trebor-huang.github.io/forest/algm-000A/" display-uri="algm-000A" type="local">quasi-compact</fr:link>, we say the scheme satisfies <fr:tex display="inline"><![CDATA[P]]></fr:tex>.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    We prove that if some affine cover <fr:tex display="inline"><![CDATA[\{\operatorname {Spec}(R_i) \hookrightarrow  X\}]]></fr:tex> has such a property, then all the affine subschemes has it, hence we can check on any affine cover. Given an affine subscheme <fr:tex display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex>, using <fr:link href="/forest/algm-0016/" title="Nike’s trick" uri="https://trebor-huang.github.io/forest/algm-0016/" display-uri="algm-0016" type="local">Nike’s trick</fr:link>, we see that the intersection with <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_i)]]></fr:tex> is covered by affine subschemes, which will all have the said property. Hence we get a cover of <fr:tex display="inline"><![CDATA[\operatorname {Spec}(S) \hookrightarrow  X]]></fr:tex> with the said property, and therefore itself also.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/algm-0016/</fr:uri>
            <fr:display-uri>algm-0016</fr:display-uri>
            <fr:route>/forest/algm-0016/</fr:route>
            <fr:title text="Nike’s trick">Nike’s trick</fr:title>
            <fr:taxon>Theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>
  The intersections of two <fr:link href="/forest/algm-000Q/" title="affine scheme" uri="https://trebor-huang.github.io/forest/algm-000Q/" display-uri="algm-000Q" type="local">affine</fr:link> subschemes <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_1), \operatorname {Spec}(R_2) \hookrightarrow  X]]></fr:tex> can be covered by affine schemes distinguished in both of them.
</html:p>
  
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>15</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    We just need to cover each point of the intersection. Suppose a point in the intersection is given by a prime ideal <fr:tex display="inline"><![CDATA[\mathfrak {p}]]></fr:tex> of <fr:tex display="inline"><![CDATA[R_1]]></fr:tex>. We can pick a distinguished open <fr:tex display="inline"><![CDATA[D(f)]]></fr:tex> of <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex> contained in the intersection and containing <fr:tex display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>, and a distinguished open <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex> of <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_1)]]></fr:tex> contained in <fr:tex display="inline"><![CDATA[D(f)]]></fr:tex> and containing <fr:tex display="inline"><![CDATA[\mathfrak {p}]]></fr:tex>. Now we prove that <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>.
  </html:p>

  <html:p>
    It suffices to prove that <fr:tex display="inline"><![CDATA[D(g)]]></fr:tex> is a distinguished open in <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>, since this would imply the existence of an element <fr:tex display="inline"><![CDATA[g'/f^{n} \in  R_2[f^{-1}]]]></fr:tex>, and we can take <fr:tex display="inline"><![CDATA[D(g') \cap  D(f) = D(g' f)]]></fr:tex> in <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2)]]></fr:tex>. Now there is an inclusion map <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2[f^{-1}]) \to  \operatorname {Spec}(R_1)]]></fr:tex>, which amounts to a ring homomorphism <fr:tex display="inline"><![CDATA[\varphi ]]></fr:tex> by <fr:link href="/forest/algm-000X/" title="morphisms of affine schemes" uri="https://trebor-huang.github.io/forest/algm-000X/" display-uri="algm-000X" type="local">Theorem <fr:contextual-number uri="https://trebor-huang.github.io/forest/algm-000X/" display-uri="algm-000X" /></fr:link>. In this case, <fr:tex display="inline"><![CDATA[D(\varphi (g))]]></fr:tex> is the required distinguished open, since <fr:tex display="inline"><![CDATA[\varphi ^{-1}D(u)]]></fr:tex> is equal to <fr:tex display="inline"><![CDATA[D(\varphi (u))]]></fr:tex> in <fr:tex display="inline"><![CDATA[\operatorname {Spec}(R_2 [f^{-1}])]]></fr:tex>.
  </html:p>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/trebor/" title="Trebor" uri="https://trebor-huang.github.io/forest/trebor/" display-uri="trebor" type="local">Trebor</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:uri>https://trebor-huang.github.io/forest/algm-000A/</fr:uri>
            <fr:display-uri>algm-000A</fr:display-uri>
            <fr:route>/forest/algm-000A/</fr:route>
            <fr:title text="terminology of compactness in algebraic geometry">terminology of compactness in algebraic geometry</fr:title>
            <fr:taxon>Remark</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  The word compactness historically required the space to be Hausdorff. And the modern meaning of compactness was called quasi-compact. In algebraic geometry, most spaces are never Hausdorff, and the topological compactness condition does not lead to similar behavior. There is another notion more suitable as an analog of topological compactness. Therefore, we choose to always use the word “quasi-compact”.
</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
